begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|elasticsearch
operator|.
name|query
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|AbstractIterator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Queues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PerfLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|elasticsearch
operator|.
name|ElasticsearchIndexCoordinateFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|elasticsearch
operator|.
name|ElasticsearchIndexDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|search
operator|.
name|FieldNames
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|search
operator|.
name|IndexDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|search
operator|.
name|PropertyDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|search
operator|.
name|spi
operator|.
name|query
operator|.
name|FulltextIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|search
operator|.
name|spi
operator|.
name|query
operator|.
name|FulltextIndexPlanner
operator|.
name|PlanResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|query
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|query
operator|.
name|QueryConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|query
operator|.
name|QueryIndex
operator|.
name|IndexPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|query
operator|.
name|fulltext
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|search
operator|.
name|SearchResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|BoolQueryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|QueryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|QueryBuilders
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|SearchHit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|NotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|PropertyType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|JcrConstants
operator|.
name|JCR_MIXINTYPES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|JcrConstants
operator|.
name|JCR_PRIMARYTYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Type
operator|.
name|STRING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
operator|.
name|denotesRoot
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
operator|.
name|getParentPath
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|TermQueryBuilderFactory
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|search
operator|.
name|spi
operator|.
name|query
operator|.
name|FulltextIndex
operator|.
name|isNodePath
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|query
operator|.
name|QueryConstants
operator|.
name|JCR_PATH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|util
operator|.
name|ISO8601
operator|.
name|parse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|QueryBuilders
operator|.
name|*
import|;
end_import

begin_class
specifier|public
class|class
name|ElasticsearchResultRowIterator
extends|extends
name|AbstractIterator
argument_list|<
name|FulltextIndex
operator|.
name|FulltextResultRow
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ElasticsearchResultRowIterator
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|PerfLogger
name|PERF_LOGGER
init|=
operator|new
name|PerfLogger
argument_list|(
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ElasticsearchResultRowIterator
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".perf"
argument_list|)
argument_list|)
decl_stmt|;
comment|// TODO: oak-lucene gets this via WildcardQuery class. See if ES also exposes these consts
specifier|private
specifier|static
specifier|final
name|char
name|WILDCARD_STRING
init|=
literal|'*'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|WILDCARD_CHAR
init|=
literal|'?'
decl_stmt|;
comment|/**      * Batch size for fetching results from queries.      */
specifier|private
specifier|static
specifier|final
name|int
name|ELASTICSEARCH_QUERY_BATCH_SIZE
init|=
literal|1000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ELASTICSEARCH_QUERY_MAX_BATCH_SIZE
init|=
literal|10000
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|FulltextIndex
operator|.
name|FulltextResultRow
argument_list|>
name|queue
init|=
name|Queues
operator|.
name|newArrayDeque
argument_list|()
decl_stmt|;
comment|// TODO : find if ES can return dup docs - if so how to avoid
comment|//    private final Set<String> seenPaths = Sets.newHashSet();
specifier|private
name|SearchHit
name|lastDoc
decl_stmt|;
specifier|private
name|int
name|nextBatchSize
init|=
name|ELASTICSEARCH_QUERY_BATCH_SIZE
decl_stmt|;
specifier|private
name|boolean
name|noDocs
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|ElasticsearchIndexCoordinateFactory
name|esIndexCoordFactory
decl_stmt|;
specifier|private
specifier|final
name|Filter
name|filter
decl_stmt|;
specifier|private
specifier|final
name|PlanResult
name|pr
decl_stmt|;
specifier|private
specifier|final
name|IndexPlan
name|plan
decl_stmt|;
specifier|private
specifier|final
name|ElasticsearchIndexNode
name|indexNode
decl_stmt|;
specifier|private
specifier|final
name|RowInclusionPredicate
name|rowInclusionPredicate
decl_stmt|;
name|ElasticsearchResultRowIterator
parameter_list|(
annotation|@
name|NotNull
name|ElasticsearchIndexCoordinateFactory
name|esIndexCoordFactory
parameter_list|,
annotation|@
name|NotNull
name|Filter
name|filter
parameter_list|,
annotation|@
name|NotNull
name|PlanResult
name|pr
parameter_list|,
annotation|@
name|NotNull
name|IndexPlan
name|plan
parameter_list|,
name|ElasticsearchIndexNode
name|indexNode
parameter_list|,
name|RowInclusionPredicate
name|rowInclusionPredicate
parameter_list|)
block|{
name|this
operator|.
name|esIndexCoordFactory
operator|=
name|esIndexCoordFactory
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|this
operator|.
name|pr
operator|=
name|pr
expr_stmt|;
name|this
operator|.
name|plan
operator|=
name|plan
expr_stmt|;
name|this
operator|.
name|indexNode
operator|=
name|indexNode
expr_stmt|;
name|this
operator|.
name|rowInclusionPredicate
operator|=
name|rowInclusionPredicate
operator|!=
literal|null
condition|?
name|rowInclusionPredicate
else|:
name|RowInclusionPredicate
operator|.
name|NOOP
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|FulltextIndex
operator|.
name|FulltextResultRow
name|computeNext
parameter_list|()
block|{
if|if
condition|(
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
operator|||
name|loadDocs
argument_list|()
condition|)
block|{
return|return
name|queue
operator|.
name|remove
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|endOfData
argument_list|()
return|;
block|}
block|}
comment|/**      * Loads the lucene documents in batches      * @return true if any document is loaded      */
specifier|private
name|boolean
name|loadDocs
parameter_list|()
block|{
if|if
condition|(
name|noDocs
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SearchHit
name|lastDocToRecord
init|=
literal|null
decl_stmt|;
name|checkState
argument_list|(
name|indexNode
operator|!=
literal|null
argument_list|)
expr_stmt|;
try|try
block|{
name|ElasticsearchSearcher
name|searcher
init|=
name|getCurrentSearcher
argument_list|(
name|indexNode
argument_list|)
decl_stmt|;
name|QueryBuilder
name|query
init|=
name|getESRequest
argument_list|(
name|plan
argument_list|,
name|pr
argument_list|)
decl_stmt|;
comment|// TODO: custom scoring
name|SearchResponse
name|docs
decl_stmt|;
name|long
name|start
init|=
name|PERF_LOGGER
operator|.
name|start
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"loading {} entries for query {}"
argument_list|,
name|nextBatchSize
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|docs
operator|=
name|searcher
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|nextBatchSize
argument_list|)
expr_stmt|;
name|SearchHit
index|[]
name|searchHits
init|=
name|docs
operator|.
name|getHits
argument_list|()
operator|.
name|getHits
argument_list|()
decl_stmt|;
name|PERF_LOGGER
operator|.
name|end
argument_list|(
name|start
argument_list|,
operator|-
literal|1
argument_list|,
literal|"{} ..."
argument_list|,
name|searchHits
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchHits
operator|.
name|length
operator|<
name|nextBatchSize
condition|)
block|{
name|noDocs
operator|=
literal|true
expr_stmt|;
block|}
name|nextBatchSize
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|nextBatchSize
operator|*
literal|2L
argument_list|,
name|ELASTICSEARCH_QUERY_MAX_BATCH_SIZE
argument_list|)
expr_stmt|;
comment|// TODO: faceting
comment|// TODO: excerpt
comment|// TODO: explanation
comment|// TODO: sim search
for|for
control|(
name|SearchHit
name|doc
range|:
name|searchHits
control|)
block|{
comment|// TODO : excerpts
name|FulltextIndex
operator|.
name|FulltextResultRow
name|row
init|=
name|convertToRow
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|!=
literal|null
condition|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
name|lastDocToRecord
operator|=
name|doc
expr_stmt|;
block|}
if|if
condition|(
name|queue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|searchHits
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|//queue is still empty but more results can be fetched
comment|//from Lucene so still continue
name|lastDoc
operator|=
name|lastDocToRecord
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// TODO: spellcheck else if (luceneRequestFacade.getLuceneRequest() instanceof SpellcheckHelper.SpellcheckQuery) {
comment|// TODO: suggest } else if (luceneRequestFacade.getLuceneRequest() instanceof SuggestHelper.SuggestQuery) {
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"query via {} failed."
argument_list|,
name|this
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|indexNode
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lastDocToRecord
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|lastDoc
operator|=
name|lastDocToRecord
expr_stmt|;
block|}
return|return
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|private
name|ElasticsearchSearcher
name|getCurrentSearcher
parameter_list|(
name|ElasticsearchIndexNode
name|indexNode
parameter_list|)
block|{
return|return
operator|new
name|ElasticsearchSearcher
argument_list|(
name|esIndexCoordFactory
argument_list|,
name|indexNode
argument_list|)
return|;
block|}
specifier|private
name|FulltextIndex
operator|.
name|FulltextResultRow
name|convertToRow
parameter_list|(
name|SearchHit
name|hit
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|id
init|=
name|hit
operator|.
name|getId
argument_list|()
decl_stmt|;
name|String
name|path
init|=
name|idToPath
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|path
operator|=
literal|"/"
expr_stmt|;
block|}
if|if
condition|(
name|pr
operator|.
name|isPathTransformed
argument_list|()
condition|)
block|{
name|String
name|originalPath
init|=
name|path
decl_stmt|;
name|path
operator|=
name|pr
operator|.
name|transformPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Ignoring path {} : Transformation returned null"
argument_list|,
name|originalPath
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
name|boolean
name|shouldIncludeForHierarchy
init|=
name|rowInclusionPredicate
operator|.
name|shouldInclude
argument_list|(
name|path
argument_list|,
name|plan
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Matched path {}; shouldIncludeForHierarchy: {}"
argument_list|,
name|path
argument_list|,
name|shouldIncludeForHierarchy
argument_list|)
expr_stmt|;
return|return
name|shouldIncludeForHierarchy
condition|?
operator|new
name|FulltextIndex
operator|.
name|FulltextResultRow
argument_list|(
name|path
argument_list|,
name|hit
operator|.
name|getScore
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
else|:
literal|null
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
interface|interface
name|RowInclusionPredicate
block|{
name|boolean
name|shouldInclude
parameter_list|(
annotation|@
name|NotNull
name|String
name|path
parameter_list|,
annotation|@
name|NotNull
name|IndexPlan
name|plan
parameter_list|)
function_decl|;
name|RowInclusionPredicate
name|NOOP
init|=
parameter_list|(
annotation|@
name|NotNull
name|String
name|path
parameter_list|,
annotation|@
name|NotNull
name|IndexPlan
name|plan
parameter_list|)
lambda|->
literal|true
decl_stmt|;
block|}
comment|/**      * Get the Elasticsearch query for the given filter.      *      * @param plan index plan containing filter details      * @param planResult      * @return the Lucene query      */
specifier|static
name|QueryBuilder
name|getESRequest
parameter_list|(
name|IndexPlan
name|plan
parameter_list|,
name|PlanResult
name|planResult
parameter_list|)
block|{
name|List
argument_list|<
name|QueryBuilder
argument_list|>
name|qs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Filter
name|filter
init|=
name|plan
operator|.
name|getFilter
argument_list|()
decl_stmt|;
name|FullTextExpression
name|ft
init|=
name|filter
operator|.
name|getFullTextConstraint
argument_list|()
decl_stmt|;
name|ElasticsearchIndexDefinition
name|defn
init|=
operator|(
name|ElasticsearchIndexDefinition
operator|)
name|planResult
operator|.
name|indexDefinition
decl_stmt|;
if|if
condition|(
name|ft
operator|!=
literal|null
condition|)
block|{
name|qs
operator|.
name|add
argument_list|(
name|getFullTextQuery
argument_list|(
name|ft
argument_list|,
name|planResult
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// there might be no full-text constraint
comment|// when using the LowCostLuceneIndexProvider
comment|// which is used for testing
block|}
comment|//Check if native function is supported
name|Filter
operator|.
name|PropertyRestriction
name|pr
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|defn
operator|.
name|hasFunctionDefined
argument_list|()
condition|)
block|{
name|pr
operator|=
name|filter
operator|.
name|getPropertyRestriction
argument_list|(
name|defn
operator|.
name|getFunctionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pr
operator|!=
literal|null
condition|)
block|{
name|String
name|query
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|pr
operator|.
name|first
operator|.
name|getValue
argument_list|(
name|pr
operator|.
name|first
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// TODO: more like this
comment|// TODO: spellcheck
comment|// TODO: suggest
name|qs
operator|.
name|add
argument_list|(
name|QueryBuilders
operator|.
name|queryStringQuery
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|planResult
operator|.
name|evaluateNonFullTextConstraints
argument_list|()
condition|)
block|{
name|addNonFullTextConstraints
argument_list|(
name|qs
argument_list|,
name|plan
argument_list|,
name|planResult
argument_list|)
expr_stmt|;
block|}
comment|// TODO: sort with no other restriction
if|if
condition|(
name|qs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// TODO: what happens here in planning mode (specially, apparently for things like rep:similar)
comment|//For purely nodeType based queries all the documents would have to
comment|//be returned (if the index definition has a single rule)
if|if
condition|(
name|planResult
operator|.
name|evaluateNodeTypeRestriction
argument_list|()
condition|)
block|{
return|return
name|matchAllQuery
argument_list|()
return|;
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No query created for filter "
operator|+
name|filter
argument_list|)
throw|;
block|}
return|return
name|performAdditionalWraps
argument_list|(
name|qs
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|QueryBuilder
name|getFullTextQuery
parameter_list|(
name|FullTextExpression
name|ft
parameter_list|,
specifier|final
name|PlanResult
name|pr
parameter_list|)
block|{
comment|// a reference to the query, so it can be set in the visitor
comment|// (a "non-local return")
specifier|final
name|AtomicReference
argument_list|<
name|QueryBuilder
argument_list|>
name|result
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
name|ft
operator|.
name|accept
argument_list|(
operator|new
name|FullTextVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|visit
parameter_list|(
name|FullTextContains
name|contains
parameter_list|)
block|{
name|visitTerm
argument_list|(
name|contains
operator|.
name|getPropertyName
argument_list|()
argument_list|,
name|contains
operator|.
name|getRawText
argument_list|()
argument_list|,
literal|null
argument_list|,
name|contains
operator|.
name|isNot
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|visit
parameter_list|(
name|FullTextOr
name|or
parameter_list|)
block|{
name|BoolQueryBuilder
name|q
init|=
name|boolQuery
argument_list|()
decl_stmt|;
for|for
control|(
name|FullTextExpression
name|e
range|:
name|or
operator|.
name|list
control|)
block|{
name|QueryBuilder
name|x
init|=
name|getFullTextQuery
argument_list|(
name|e
argument_list|,
name|pr
argument_list|)
decl_stmt|;
name|q
operator|.
name|should
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|set
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|visit
parameter_list|(
name|FullTextAnd
name|and
parameter_list|)
block|{
name|BoolQueryBuilder
name|q
init|=
name|boolQuery
argument_list|()
decl_stmt|;
for|for
control|(
name|FullTextExpression
name|e
range|:
name|and
operator|.
name|list
control|)
block|{
name|QueryBuilder
name|x
init|=
name|getFullTextQuery
argument_list|(
name|e
argument_list|,
name|pr
argument_list|)
decl_stmt|;
comment|// TODO: see OAK-2434 and see if ES also can't work without unwrapping
comment|/* Only unwrap the clause if MUST_NOT(x) */
name|boolean
name|hasMustNot
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|x
operator|instanceof
name|BoolQueryBuilder
condition|)
block|{
name|BoolQueryBuilder
name|bq
init|=
operator|(
name|BoolQueryBuilder
operator|)
name|x
decl_stmt|;
if|if
condition|(
name|bq
operator|.
name|mustNot
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
comment|// no other clauses
operator|&&
name|bq
operator|.
name|should
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|bq
operator|.
name|must
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|bq
operator|.
name|filter
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|hasMustNot
operator|=
literal|true
expr_stmt|;
name|q
operator|.
name|mustNot
argument_list|(
name|bq
operator|.
name|mustNot
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hasMustNot
condition|)
block|{
name|q
operator|.
name|must
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|.
name|set
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|visit
parameter_list|(
name|FullTextTerm
name|term
parameter_list|)
block|{
return|return
name|visitTerm
argument_list|(
name|term
operator|.
name|getPropertyName
argument_list|()
argument_list|,
name|term
operator|.
name|getText
argument_list|()
argument_list|,
name|term
operator|.
name|getBoost
argument_list|()
argument_list|,
name|term
operator|.
name|isNot
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|visitTerm
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|text
parameter_list|,
name|String
name|boost
parameter_list|,
name|boolean
name|not
parameter_list|)
block|{
name|String
name|p
init|=
name|getLuceneFieldName
argument_list|(
name|propertyName
argument_list|,
name|pr
argument_list|)
decl_stmt|;
name|QueryBuilder
name|q
init|=
name|tokenToQuery
argument_list|(
name|text
argument_list|,
name|p
argument_list|,
name|pr
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|boost
operator|!=
literal|null
condition|)
block|{
name|q
operator|.
name|boost
argument_list|(
name|Float
operator|.
name|parseFloat
argument_list|(
name|boost
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|not
condition|)
block|{
name|BoolQueryBuilder
name|bq
init|=
name|boolQuery
argument_list|()
decl_stmt|;
name|bq
operator|.
name|mustNot
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|result
operator|.
name|set
argument_list|(
name|bq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|set
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|QueryBuilder
name|tokenToQuery
parameter_list|(
name|String
name|text
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|PlanResult
name|pr
parameter_list|)
block|{
name|QueryBuilder
name|ret
decl_stmt|;
name|IndexDefinition
operator|.
name|IndexingRule
name|indexingRule
init|=
name|pr
operator|.
name|indexingRule
decl_stmt|;
comment|//Expand the query on fulltext field
if|if
condition|(
name|FieldNames
operator|.
name|FULLTEXT
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
operator|&&
operator|!
name|indexingRule
operator|.
name|getNodeScopeAnalyzedProps
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|BoolQueryBuilder
name|in
init|=
name|boolQuery
argument_list|()
decl_stmt|;
for|for
control|(
name|PropertyDefinition
name|pd
range|:
name|indexingRule
operator|.
name|getNodeScopeAnalyzedProps
argument_list|()
control|)
block|{
name|QueryBuilder
name|q
init|=
name|matchQuery
argument_list|(
name|FieldNames
operator|.
name|createAnalyzedFieldName
argument_list|(
name|pd
operator|.
name|name
argument_list|)
argument_list|,
name|text
argument_list|)
decl_stmt|;
name|q
operator|.
name|boost
argument_list|(
name|pd
operator|.
name|boost
argument_list|)
expr_stmt|;
name|in
operator|.
name|should
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|//Add the query for actual fulltext field also. That query would
comment|//not be boosted
name|in
operator|.
name|should
argument_list|(
name|matchQuery
argument_list|(
name|fieldName
argument_list|,
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|in
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|matchQuery
argument_list|(
name|fieldName
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|private
specifier|static
name|String
name|getLuceneFieldName
parameter_list|(
annotation|@
name|Nullable
name|String
name|p
parameter_list|,
name|PlanResult
name|pr
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
literal|null
condition|)
block|{
return|return
name|FieldNames
operator|.
name|FULLTEXT
return|;
block|}
if|if
condition|(
name|isNodePath
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|pr
operator|.
name|isPathTransformed
argument_list|()
condition|)
block|{
name|p
operator|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//Get rid of /* as aggregated fulltext field name is the
comment|//node relative path
name|p
operator|=
name|FieldNames
operator|.
name|createFulltextFieldName
argument_list|(
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pr
operator|.
name|isPathTransformed
argument_list|()
condition|)
block|{
name|p
operator|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|FieldNames
operator|.
name|createAnalyzedFieldName
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"*"
operator|.
name|equals
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|p
operator|=
name|FieldNames
operator|.
name|FULLTEXT
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
comment|/**      * Perform additional wraps on the list of queries to allow, for example, the NOT CONTAINS to      * play properly when sent to lucene.      *      * @param qs the list of queries. Cannot be null.      * @return the request facade      */
annotation|@
name|NotNull
specifier|private
specifier|static
name|QueryBuilder
name|performAdditionalWraps
parameter_list|(
annotation|@
name|NotNull
name|List
argument_list|<
name|QueryBuilder
argument_list|>
name|qs
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|qs
argument_list|)
expr_stmt|;
if|if
condition|(
name|qs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// we don't need to worry about all-negatives in a bool query as
comment|// BoolQueryBuilder.adjustPureNegative is on by default anyway
return|return
name|qs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|BoolQueryBuilder
name|bq
init|=
operator|new
name|BoolQueryBuilder
argument_list|()
decl_stmt|;
comment|// TODO: while I've attempted to translate oak-lucene code to corresponding ES one but I am
comment|// unable to make sense of this code
for|for
control|(
name|QueryBuilder
name|q
range|:
name|qs
control|)
block|{
name|boolean
name|unwrapped
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|q
operator|instanceof
name|BoolQueryBuilder
condition|)
block|{
name|unwrapped
operator|=
name|unwrapMustNot
argument_list|(
operator|(
name|BoolQueryBuilder
operator|)
name|q
argument_list|,
name|bq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|unwrapped
condition|)
block|{
name|bq
operator|.
name|must
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|bq
return|;
block|}
comment|/**      * unwraps any NOT clauses from the provided boolean query into another boolean query.      *      * @param input the query to be analysed for the existence of NOT clauses. Cannot be null.      * @param output the query where the unwrapped NOTs will be saved into. Cannot be null.      * @return true if there where at least one unwrapped NOT. false otherwise.      */
specifier|private
specifier|static
name|boolean
name|unwrapMustNot
parameter_list|(
annotation|@
name|NotNull
name|BoolQueryBuilder
name|input
parameter_list|,
annotation|@
name|NotNull
name|BoolQueryBuilder
name|output
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|boolean
name|unwrapped
init|=
literal|false
decl_stmt|;
for|for
control|(
name|QueryBuilder
name|mustNot
range|:
name|input
operator|.
name|mustNot
argument_list|()
control|)
block|{
name|output
operator|.
name|mustNot
argument_list|(
name|mustNot
argument_list|)
expr_stmt|;
name|unwrapped
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|unwrapped
condition|)
block|{
comment|// if we have unwrapped "must not" conditions,
comment|// then we need to unwrap "must" conditions as well
for|for
control|(
name|QueryBuilder
name|must
range|:
name|input
operator|.
name|must
argument_list|()
control|)
block|{
name|output
operator|.
name|must
argument_list|(
name|must
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|unwrapped
return|;
block|}
specifier|private
specifier|static
name|void
name|addNonFullTextConstraints
parameter_list|(
name|List
argument_list|<
name|QueryBuilder
argument_list|>
name|qs
parameter_list|,
name|IndexPlan
name|plan
parameter_list|,
name|PlanResult
name|planResult
parameter_list|)
block|{
name|Filter
name|filter
init|=
name|plan
operator|.
name|getFilter
argument_list|()
decl_stmt|;
name|IndexDefinition
name|defn
init|=
name|planResult
operator|.
name|indexDefinition
decl_stmt|;
if|if
condition|(
operator|!
name|filter
operator|.
name|matchesAllTypes
argument_list|()
condition|)
block|{
name|addNodeTypeConstraints
argument_list|(
name|planResult
operator|.
name|indexingRule
argument_list|,
name|qs
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
name|String
name|path
init|=
name|getPathRestriction
argument_list|(
name|plan
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|filter
operator|.
name|getPathRestriction
argument_list|()
condition|)
block|{
case|case
name|ALL_CHILDREN
case|:
if|if
condition|(
name|defn
operator|.
name|evaluatePathRestrictions
argument_list|()
condition|)
block|{
if|if
condition|(
literal|"/"
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
break|break;
block|}
name|qs
operator|.
name|add
argument_list|(
name|newAncestorQuery
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIRECT_CHILDREN
case|:
if|if
condition|(
name|defn
operator|.
name|evaluatePathRestrictions
argument_list|()
condition|)
block|{
name|BoolQueryBuilder
name|bq
init|=
name|boolQuery
argument_list|()
decl_stmt|;
name|bq
operator|.
name|must
argument_list|(
name|newAncestorQuery
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|bq
operator|.
name|must
argument_list|(
name|newDepthQuery
argument_list|(
name|path
argument_list|,
name|planResult
argument_list|)
argument_list|)
expr_stmt|;
name|qs
operator|.
name|add
argument_list|(
name|bq
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXACT
case|:
comment|// For transformed paths, we can only add path restriction if absolute path to property can be
comment|// deduced
if|if
condition|(
name|planResult
operator|.
name|isPathTransformed
argument_list|()
condition|)
block|{
name|String
name|parentPathSegment
init|=
name|planResult
operator|.
name|getParentPathSegment
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Iterables
operator|.
name|any
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|parentPathSegment
argument_list|)
argument_list|,
literal|"*"
operator|::
name|equals
argument_list|)
condition|)
block|{
name|qs
operator|.
name|add
argument_list|(
name|newPathQuery
argument_list|(
name|path
operator|+
name|parentPathSegment
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|qs
operator|.
name|add
argument_list|(
name|newPathQuery
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARENT
case|:
if|if
condition|(
name|denotesRoot
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|// there's no parent of the root node
comment|// we add a path that can not possibly occur because there
comment|// is no way to say "match no documents" in Lucene
name|qs
operator|.
name|add
argument_list|(
name|newPathQuery
argument_list|(
literal|"///"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// For transformed paths, we can only add path restriction if absolute path to property can be
comment|// deduced
if|if
condition|(
name|planResult
operator|.
name|isPathTransformed
argument_list|()
condition|)
block|{
name|String
name|parentPathSegment
init|=
name|planResult
operator|.
name|getParentPathSegment
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Iterables
operator|.
name|any
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|parentPathSegment
argument_list|)
argument_list|,
literal|"*"
operator|::
name|equals
argument_list|)
condition|)
block|{
name|qs
operator|.
name|add
argument_list|(
name|newPathQuery
argument_list|(
name|getParentPath
argument_list|(
name|path
argument_list|)
operator|+
name|parentPathSegment
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|qs
operator|.
name|add
argument_list|(
name|newPathQuery
argument_list|(
name|getParentPath
argument_list|(
name|path
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|NO_RESTRICTION
case|:
break|break;
block|}
for|for
control|(
name|Filter
operator|.
name|PropertyRestriction
name|pr
range|:
name|filter
operator|.
name|getPropertyRestrictions
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|pr
operator|.
name|propertyName
decl_stmt|;
if|if
condition|(
name|QueryConstants
operator|.
name|REP_EXCERPT
operator|.
name|equals
argument_list|(
name|name
argument_list|)
operator|||
name|QueryConstants
operator|.
name|OAK_SCORE_EXPLANATION
operator|.
name|equals
argument_list|(
name|name
argument_list|)
operator|||
name|QueryConstants
operator|.
name|REP_FACET
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|QueryConstants
operator|.
name|RESTRICTION_LOCAL_NAME
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|planResult
operator|.
name|evaluateNodeNameRestriction
argument_list|()
condition|)
block|{
name|QueryBuilder
name|q
init|=
name|createNodeNameQuery
argument_list|(
name|pr
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
name|qs
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
if|if
condition|(
name|pr
operator|.
name|first
operator|!=
literal|null
operator|&&
name|pr
operator|.
name|first
operator|.
name|equals
argument_list|(
name|pr
operator|.
name|last
argument_list|)
operator|&&
name|pr
operator|.
name|firstIncluding
operator|&&
name|pr
operator|.
name|lastIncluding
condition|)
block|{
name|String
name|first
init|=
name|pr
operator|.
name|first
operator|.
name|getValue
argument_list|(
name|STRING
argument_list|)
decl_stmt|;
name|first
operator|=
name|first
operator|.
name|replace
argument_list|(
literal|"\\"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|JCR_PATH
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|qs
operator|.
name|add
argument_list|(
name|newPathQuery
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|"*"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|//TODO Revisit reference constraint. For performant impl
comment|//references need to be indexed in a different manner
name|addReferenceConstraint
argument_list|(
name|first
argument_list|,
name|qs
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|PropertyDefinition
name|pd
init|=
name|planResult
operator|.
name|getPropDefn
argument_list|(
name|pr
argument_list|)
decl_stmt|;
if|if
condition|(
name|pd
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|QueryBuilder
name|q
init|=
name|createQuery
argument_list|(
name|planResult
operator|.
name|getPropertyName
argument_list|(
name|pr
argument_list|)
argument_list|,
name|pr
argument_list|,
name|pd
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
name|qs
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|addNodeTypeConstraints
parameter_list|(
name|IndexDefinition
operator|.
name|IndexingRule
name|defn
parameter_list|,
name|List
argument_list|<
name|QueryBuilder
argument_list|>
name|qs
parameter_list|,
name|Filter
name|filter
parameter_list|)
block|{
name|BoolQueryBuilder
name|bq
init|=
name|boolQuery
argument_list|()
decl_stmt|;
name|PropertyDefinition
name|primaryType
init|=
name|defn
operator|.
name|getConfig
argument_list|(
name|JCR_PRIMARYTYPE
argument_list|)
decl_stmt|;
comment|//TODO OAK-2198 Add proper nodeType query support
if|if
condition|(
name|primaryType
operator|!=
literal|null
operator|&&
name|primaryType
operator|.
name|propertyIndex
condition|)
block|{
for|for
control|(
name|String
name|type
range|:
name|filter
operator|.
name|getPrimaryTypes
argument_list|()
control|)
block|{
name|bq
operator|.
name|should
argument_list|(
name|newNodeTypeQuery
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|PropertyDefinition
name|mixinType
init|=
name|defn
operator|.
name|getConfig
argument_list|(
name|JCR_MIXINTYPES
argument_list|)
decl_stmt|;
if|if
condition|(
name|mixinType
operator|!=
literal|null
operator|&&
name|mixinType
operator|.
name|propertyIndex
condition|)
block|{
for|for
control|(
name|String
name|type
range|:
name|filter
operator|.
name|getMixinTypes
argument_list|()
control|)
block|{
name|bq
operator|.
name|should
argument_list|(
name|newMixinTypeQuery
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bq
operator|.
name|hasClauses
argument_list|()
condition|)
block|{
name|qs
operator|.
name|add
argument_list|(
name|bq
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: utilize FulltextIndex#getPathRestriction instead of copying it here
specifier|private
specifier|static
name|String
name|getPathRestriction
parameter_list|(
name|IndexPlan
name|plan
parameter_list|)
block|{
name|Filter
name|f
init|=
name|plan
operator|.
name|getFilter
argument_list|()
decl_stmt|;
name|String
name|pathPrefix
init|=
name|plan
operator|.
name|getPathPrefix
argument_list|()
decl_stmt|;
if|if
condition|(
name|pathPrefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|f
operator|.
name|getPath
argument_list|()
return|;
block|}
name|String
name|relativePath
init|=
name|PathUtils
operator|.
name|relativize
argument_list|(
name|pathPrefix
argument_list|,
name|f
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
return|return
literal|"/"
operator|+
name|relativePath
return|;
block|}
specifier|private
specifier|static
name|QueryBuilder
name|createNodeNameQuery
parameter_list|(
name|Filter
operator|.
name|PropertyRestriction
name|pr
parameter_list|)
block|{
name|String
name|first
init|=
name|pr
operator|.
name|first
operator|!=
literal|null
condition|?
name|pr
operator|.
name|first
operator|.
name|getValue
argument_list|(
name|STRING
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|pr
operator|.
name|first
operator|!=
literal|null
operator|&&
name|pr
operator|.
name|first
operator|.
name|equals
argument_list|(
name|pr
operator|.
name|last
argument_list|)
operator|&&
name|pr
operator|.
name|firstIncluding
operator|&&
name|pr
operator|.
name|lastIncluding
condition|)
block|{
comment|// [property]=[value]
return|return
name|termQuery
argument_list|(
name|FieldNames
operator|.
name|NODE_NAME
argument_list|,
name|first
argument_list|)
return|;
block|}
if|if
condition|(
name|pr
operator|.
name|isLike
condition|)
block|{
return|return
name|createLikeQuery
argument_list|(
name|FieldNames
operator|.
name|NODE_NAME
argument_list|,
name|first
argument_list|)
return|;
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"For nodeName queries only EQUALS and LIKE are supported "
operator|+
name|pr
argument_list|)
throw|;
block|}
specifier|private
specifier|static
name|QueryBuilder
name|createLikeQuery
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|first
parameter_list|)
block|{
name|first
operator|=
name|first
operator|.
name|replace
argument_list|(
literal|'%'
argument_list|,
name|WILDCARD_STRING
argument_list|)
expr_stmt|;
name|first
operator|=
name|first
operator|.
name|replace
argument_list|(
literal|'_'
argument_list|,
name|WILDCARD_CHAR
argument_list|)
expr_stmt|;
name|QueryBuilders
operator|.
name|wildcardQuery
argument_list|(
name|name
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|int
name|indexOfWS
init|=
name|first
operator|.
name|indexOf
argument_list|(
name|WILDCARD_STRING
argument_list|)
decl_stmt|;
name|int
name|indexOfWC
init|=
name|first
operator|.
name|indexOf
argument_list|(
name|WILDCARD_CHAR
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|first
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexOfWS
operator|==
name|len
operator|||
name|indexOfWC
operator|==
name|len
condition|)
block|{
comment|// remove trailing "*" for prefixquery
name|first
operator|=
name|first
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|first
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|JCR_PATH
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|newPrefixPathQuery
argument_list|(
name|first
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|newPrefixQuery
argument_list|(
name|name
argument_list|,
name|first
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|JCR_PATH
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|newWildcardPathQuery
argument_list|(
name|first
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|newWildcardQuery
argument_list|(
name|name
argument_list|,
name|first
argument_list|)
return|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|addReferenceConstraint
parameter_list|(
name|String
name|uuid
parameter_list|,
name|List
argument_list|<
name|QueryBuilder
argument_list|>
name|qs
parameter_list|)
block|{
comment|// TODO: this seems very bad as a query - do we really want to support it. In fact, is it even used?
comment|// reference query
name|qs
operator|.
name|add
argument_list|(
name|QueryBuilders
operator|.
name|multiMatchQuery
argument_list|(
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Nullable
specifier|private
specifier|static
name|QueryBuilder
name|createQuery
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|Filter
operator|.
name|PropertyRestriction
name|pr
parameter_list|,
name|PropertyDefinition
name|defn
parameter_list|)
block|{
name|int
name|propType
init|=
name|determinePropertyType
argument_list|(
name|defn
argument_list|,
name|pr
argument_list|)
decl_stmt|;
if|if
condition|(
name|pr
operator|.
name|isNullRestriction
argument_list|()
condition|)
block|{
return|return
name|newNullPropQuery
argument_list|(
name|defn
operator|.
name|name
argument_list|)
return|;
block|}
comment|//If notNullCheckEnabled explicitly enabled use the simple TermQuery
comment|//otherwise later fallback to range query
if|if
condition|(
name|pr
operator|.
name|isNotNullRestriction
argument_list|()
operator|&&
name|defn
operator|.
name|notNullCheckEnabled
condition|)
block|{
return|return
name|newNotNullPropQuery
argument_list|(
name|defn
operator|.
name|name
argument_list|)
return|;
block|}
name|QueryBuilder
name|in
decl_stmt|;
switch|switch
condition|(
name|propType
condition|)
block|{
case|case
name|PropertyType
operator|.
name|DATE
case|:
block|{
name|in
operator|=
name|newPropertyRestrictionQuery
argument_list|(
name|propertyName
argument_list|,
literal|false
argument_list|,
name|pr
argument_list|,
name|value
lambda|->
name|parse
argument_list|(
name|value
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|DATE
argument_list|)
argument_list|)
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PropertyType
operator|.
name|DOUBLE
case|:
block|{
name|in
operator|=
name|newPropertyRestrictionQuery
argument_list|(
name|propertyName
argument_list|,
literal|false
argument_list|,
name|pr
argument_list|,
name|value
lambda|->
name|value
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|DOUBLE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PropertyType
operator|.
name|LONG
case|:
block|{
name|in
operator|=
name|newPropertyRestrictionQuery
argument_list|(
name|propertyName
argument_list|,
literal|false
argument_list|,
name|pr
argument_list|,
name|value
lambda|->
name|value
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|LONG
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
if|if
condition|(
name|pr
operator|.
name|isLike
condition|)
block|{
return|return
name|createLikeQuery
argument_list|(
name|propertyName
argument_list|,
name|pr
operator|.
name|first
operator|.
name|getValue
argument_list|(
name|STRING
argument_list|)
argument_list|)
return|;
block|}
comment|//TODO Confirm that all other types can be treated as string
name|in
operator|=
name|newPropertyRestrictionQuery
argument_list|(
name|propertyName
argument_list|,
literal|true
argument_list|,
name|pr
argument_list|,
name|value
lambda|->
name|value
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|STRING
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
return|return
name|in
return|;
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"PropertyRestriction not handled "
operator|+
name|pr
operator|+
literal|" for index "
operator|+
name|defn
argument_list|)
throw|;
block|}
specifier|private
specifier|static
name|String
name|idToPath
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
return|return
name|URLDecoder
operator|.
name|decode
argument_list|(
name|id
argument_list|,
literal|"UTF-8"
argument_list|)
return|;
block|}
block|}
end_class

end_unit

