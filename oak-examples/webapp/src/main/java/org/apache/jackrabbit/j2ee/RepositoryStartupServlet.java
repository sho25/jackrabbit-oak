begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|j2ee
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|api
operator|.
name|JackrabbitRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|commons
operator|.
name|repository
operator|.
name|RepositoryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|run
operator|.
name|osgi
operator|.
name|OakOSGiRepositoryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|rmi
operator|.
name|server
operator|.
name|RemoteAdapterFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|rmi
operator|.
name|server
operator|.
name|ServerAdapterFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|servlet
operator|.
name|AbstractRepositoryServlet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|BundleActivator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|BundleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ServerSocket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|AlreadyBoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|Naming
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|NoSuchObjectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|Remote
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|registry
operator|.
name|LocateRegistry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|registry
operator|.
name|Registry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|server
operator|.
name|RMIServerSocketFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|server
operator|.
name|UnicastRemoteObject
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|Repository
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|RepositoryException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|InitialContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|NamingException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletRequest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletResponse
import|;
end_import

begin_comment
comment|/**  * The RepositoryStartupServlet starts a jackrabbit repository and registers it  * to the JNDI environment and optional to the RMI registry.  *<p id="registerAlgo">  *<b>Registration with RMI</b>  *<p>  * Upon successfull creation of the repository in the {@link #init()} method,  * the repository is registered with an RMI registry if the web application is  * so configured. To register with RMI, the following web application  *<code>init-params</code> are considered:<code>rmi-port</code> designating  * the port on which the RMI registry is listening,<code>rmi-host</code>  * designating the interface on the local host on which the RMI registry is  * active,<code>repository-name</code> designating the name to which the  * repository is to be bound in the registry, and<code>rmi-uri</code>  * designating an RMI URI complete with host, optional port and name to which  * the object is bound.  *<p>  * If the<code>rmi-uri</code> parameter is configured with a non-empty value,  * the<code>rmi-port</code> and<code>rmi-host</code> parameters are ignored.  * The<code>repository-name</code> parameter is only considered if a non-empty  *<code>rmi-uri</code> parameter is configured if the latter does not contain  * a name to which to bind the repository.  *<p>  * This is the algorithm used to find out the host, port and name for RMI  * registration:  *<ol>  *<li>If neither a<code>rmi-uri</code> nor a<code>rmi-host</code> nor a  *<code>rmi-port</code> parameter is configured, the repository is not  * registered with any RMI registry.  *<li>If a non-empty<code>rmi-uri</code> parameter is configured extract the  * host name (or IP address), port number and name to bind to from the  * URI. If the URI is not valid, host defaults to<code>0.0.0.0</code>  * meaning all interfaces on the local host, port defaults to the RMI  * default port (<code>1099</code>) and the name defaults to the value  * of the<code>repository-name</code> parameter.  *<li>If a non-empty<code>rmi-uri</code> is not configured, the host is taken  * from the<code>rmi-host</code> parameter, the port from the  *<code>rmi-port</code> parameter and the name to bind the repository to  * from the<code>repository-name</code> parameter. If the  *<code>rmi-host</code> parameter is empty or not configured, the host  * defaults to<code>0.0.0.0</code> meaning all interfaces on the local  * host. If the<code>rmi-port</code> parameter is empty, not configured,  * zero or a negative value, the default port for the RMI registry  * (<code>1099</code>) is used.  *</ol>  *<p>  * After finding the host and port of the registry, the RMI registry itself  * is acquired. It is assumed, that host and port primarily designate an RMI  * registry, which should be active on the local host but has not been started  * yet. In this case, the<code>LocateRegistry.createRegistry</code> method is  * called to create a registry on the local host listening on the host and port  * configured. If creation fails, the<code>LocateRegistry.getRegistry</code>  * method is called to get a remote instance of the registry. Note, that  *<code>getRegistry</code> does not create an actual registry on the given  * host/port nor does it check, whether an RMI registry is active.  *<p>  * When the registry has been retrieved, either by creation or by just creating  * a remote instance, the repository is bound to the configured name in the  * registry.  *<p>  * Possible causes for registration failures include:  *<ul>  *<li>The web application is not configured to register with an RMI registry at  * all.  *<li>The registry is expected to be running on a remote host but does not.  *<li>The registry is expected to be running on the local host but cannot be  * accessed. Reasons include another application which does not act as an  * RMI registry is running on the configured port and thus blocks creation  * of a new RMI registry.  *<li>An object may already be bound to the same name as is configured to be  * used for the repository.  *</ul>  *<p>  *<b>Note:</b> if a<code>bootstrap-config</code> init parameter is specified the  * servlet tries to read the respective resource, either as context resource or  * as file. The properties specified in this file override the init params  * specified in the<code>web.xml</code>.  *<p>  *<p>  *<b>Setup Wizard Functionality</b><br>  * When using the first time, the configuraition can miss the relevant  * repository parameters in the web.xml. if so, it must contain a  *<code>bootstrap-config</code> parameter that referrs to a propertiy file.  * This file must exsit for proper working. If not, the repository is not  * started.<br>  * If the servlet is not configured correctly and accessed via http, it will  * provide a simple wizard for the first time configuration. It propmpts for  * a new (or existing) repository home and will copy the templates of the  * repository.xml and bootstrap.properties to the respective location.  */
end_comment

begin_class
specifier|public
class|class
name|RepositoryStartupServlet
extends|extends
name|AbstractRepositoryServlet
block|{
comment|/**      * the default logger      */
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RepositoryStartupServlet
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * the context attribute name foe 'this' instance.      */
specifier|private
specifier|final
specifier|static
name|String
name|CTX_PARAM_THIS
init|=
literal|"repository.startup.servet"
decl_stmt|;
comment|/**      * initial param name for the bootstrap config location      */
specifier|public
specifier|final
specifier|static
name|String
name|INIT_PARAM_BOOTSTRAP_CONFIG
init|=
literal|"bootstrap-config"
decl_stmt|;
comment|/**      * Ugly hack to override the bootstrap file location in the test cases      */
specifier|static
name|String
name|bootstrapOverride
init|=
literal|null
decl_stmt|;
comment|/**      * the registered repository      */
specifier|private
name|Repository
name|repository
decl_stmt|;
comment|/**      * the jndi context; created based on configuration      */
specifier|private
name|InitialContext
name|jndiContext
decl_stmt|;
specifier|private
name|Registry
name|rmiRegistry
init|=
literal|null
decl_stmt|;
comment|/**      * Keeps a strong reference to the server side RMI repository instance to      * prevent the RMI distributed Garbage Collector from collecting the      * instance making the repository unaccessible though it should still be.      * This field is only set to a non-<code>null</code> value, if registration      * of the repository to an RMI registry succeeded in the      * {@link #registerRMI()} method.      *      * @see #registerRMI()      * @see #unregisterRMI()      */
specifier|private
name|Remote
name|rmiRepository
decl_stmt|;
comment|/**      * the file to the bootstrap config      */
specifier|private
name|File
name|bootstrapConfigFile
decl_stmt|;
comment|/**      * The bootstrap configuration      */
specifier|private
name|BootstrapConfig
name|config
decl_stmt|;
comment|/**      * Initializes the servlet.<br>      * Please note that only one repository startup servlet may exist per      * webapp. it registers itself as context attribute and acts as singleton.      *      * @throws ServletException if a same servlet is already registered or of      * another initialization error occurs.      */
specifier|public
name|void
name|init
parameter_list|()
throws|throws
name|ServletException
block|{
comment|// check if servlet is defined twice
if|if
condition|(
name|getServletContext
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|CTX_PARAM_THIS
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ServletException
argument_list|(
literal|"Only one repository startup servlet allowed per web-app."
argument_list|)
throw|;
block|}
name|getServletContext
argument_list|()
operator|.
name|setAttribute
argument_list|(
name|CTX_PARAM_THIS
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|startup
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns an instance of this servlet. Please note, that only 1      * repository startup servlet can exist per webapp.      *      * @param context the servlet context      * @return this servlet      */
specifier|public
specifier|static
name|RepositoryStartupServlet
name|getInstance
parameter_list|(
name|ServletContext
name|context
parameter_list|)
block|{
return|return
operator|(
name|RepositoryStartupServlet
operator|)
name|context
operator|.
name|getAttribute
argument_list|(
name|CTX_PARAM_THIS
argument_list|)
return|;
block|}
comment|/**      * Configures and starts the repository. It registers it then to the      * RMI registry and bind is to the JNDI context if so configured.      * @throws ServletException if an error occurs.      */
specifier|public
name|void
name|startup
parameter_list|()
throws|throws
name|ServletException
block|{
if|if
condition|(
name|repository
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Startup: Repository already running."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ServletException
argument_list|(
literal|"Repository already running."
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"RepositoryStartupServlet initializing..."
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|configure
argument_list|()
condition|)
block|{
name|initRepository
argument_list|()
expr_stmt|;
name|registerRMI
argument_list|()
expr_stmt|;
name|registerJNDI
argument_list|()
expr_stmt|;
block|}
comment|//Once repository is initialized get its instances bounded to ServletContext
comment|//via super class init
if|if
condition|(
name|repository
operator|!=
literal|null
condition|)
block|{
name|super
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"RepositoryStartupServlet initialized."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServletException
name|e
parameter_list|)
block|{
comment|// shutdown repository
name|shutdownRepository
argument_list|()
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"RepositoryStartupServlet initializing failed: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Does a shutdown of the repository and deregisters it from the RMI      * registry and unbinds if from the JNDI context if so configured.      */
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|repository
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Shutdown: Repository already stopped."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"RepositoryStartupServlet shutting down..."
argument_list|)
expr_stmt|;
name|unregisterOSGi
argument_list|()
expr_stmt|;
name|shutdownRepository
argument_list|()
expr_stmt|;
name|unregisterRMI
argument_list|()
expr_stmt|;
name|unregisterJNDI
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"RepositoryStartupServlet shut down."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Restarts the repository.      * @throws ServletException if an error occurs.      * @see #shutdown()      * @see #startup()      */
specifier|public
name|void
name|restart
parameter_list|()
throws|throws
name|ServletException
block|{
if|if
condition|(
name|repository
operator|!=
literal|null
condition|)
block|{
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|startup
argument_list|()
expr_stmt|;
block|}
comment|/**      * destroy the servlet      */
specifier|public
name|void
name|destroy
parameter_list|()
block|{
name|super
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns the started repository or<code>null</code> if not started      * yet.      * @return the JCR repository      */
specifier|public
name|Repository
name|getRepository
parameter_list|()
block|{
return|return
name|repository
return|;
block|}
comment|/**      * Returns a repository factory that returns the repository if available      * or throws an exception if not.      *      * @return repository factory      */
specifier|public
name|RepositoryFactory
name|getRepositoryFactory
parameter_list|()
block|{
return|return
operator|new
name|RepositoryFactory
argument_list|()
block|{
specifier|public
name|Repository
name|getRepository
parameter_list|()
throws|throws
name|RepositoryException
block|{
name|Repository
name|r
init|=
name|repository
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
return|return
name|repository
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RepositoryException
argument_list|(
literal|"Repository not available"
argument_list|)
throw|;
block|}
block|}
block|}
return|;
block|}
comment|/**      * Reads the configuration and initializes the {@link #config} field if      * successful.      * @throws ServletException if an error occurs.      */
specifier|private
name|boolean
name|configure
parameter_list|()
throws|throws
name|ServletException
block|{
comment|// check if there is a loadable bootstrap config
name|Properties
name|bootstrapProps
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|String
name|bstrp
init|=
name|bootstrapOverride
decl_stmt|;
if|if
condition|(
name|bstrp
operator|==
literal|null
condition|)
block|{
name|bstrp
operator|=
name|getServletConfig
argument_list|()
operator|.
name|getInitParameter
argument_list|(
name|INIT_PARAM_BOOTSTRAP_CONFIG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bstrp
operator|!=
literal|null
condition|)
block|{
comment|// check if it's a web-resource
name|InputStream
name|in
init|=
name|getServletContext
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|bstrp
argument_list|)
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
comment|// check if it's a file
name|bootstrapConfigFile
operator|=
operator|new
name|File
argument_list|(
name|bstrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootstrapConfigFile
operator|.
name|canRead
argument_list|()
condition|)
block|{
try|try
block|{
name|in
operator|=
operator|new
name|FileInputStream
argument_list|(
name|bootstrapConfigFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ServletExceptionWithCause
argument_list|(
literal|"Bootstrap configuration not found: "
operator|+
name|bstrp
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|bootstrapProps
operator|.
name|load
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ServletException
argument_list|(
literal|"Bootstrap configuration failure: "
operator|+
name|bstrp
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
try|try
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
block|}
comment|// read bootstrap config
name|config
operator|=
operator|new
name|BootstrapConfig
argument_list|()
expr_stmt|;
name|config
operator|.
name|init
argument_list|(
name|getServletConfig
argument_list|()
argument_list|)
expr_stmt|;
name|config
operator|.
name|init
argument_list|(
name|bootstrapProps
argument_list|)
expr_stmt|;
name|config
operator|.
name|validate
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|.
name|isValid
argument_list|()
operator|||
name|config
operator|.
name|getRepositoryHome
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|bstrp
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Repository startup configuration is not valid."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Repository startup configuration is not valid but a bootstrap config is specified."
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"Either create the {} file or"
argument_list|,
name|bstrp
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"use the '/config/index.jsp' for easy configuration."
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
name|config
operator|.
name|logInfos
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**      * Creates a new Repository based on the configuration and initializes the      * {@link #repository} field if successful.      *      * @throws ServletException if an error occurs      */
specifier|private
name|void
name|initRepository
parameter_list|()
throws|throws
name|ServletException
block|{
comment|// get repository config
name|File
name|repHome
decl_stmt|;
try|try
block|{
name|repHome
operator|=
operator|new
name|File
argument_list|(
name|config
operator|.
name|getRepositoryHome
argument_list|()
argument_list|)
operator|.
name|getCanonicalFile
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ServletExceptionWithCause
argument_list|(
literal|"Repository configuration failure: "
operator|+
name|config
operator|.
name|getRepositoryHome
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|String
name|repConfig
init|=
name|config
operator|.
name|getRepositoryConfig
argument_list|()
decl_stmt|;
if|if
condition|(
name|repConfig
operator|!=
literal|null
condition|)
block|{
name|File
name|configJson
init|=
operator|new
name|File
argument_list|(
name|repHome
argument_list|,
name|repConfig
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|configJson
operator|.
name|exists
argument_list|()
condition|)
block|{
name|InputStream
name|in
init|=
name|getServletContext
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|repConfig
argument_list|)
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ServletException
argument_list|(
literal|"No config file found in classpath "
operator|+
name|repConfig
argument_list|)
throw|;
block|}
name|OutputStream
name|os
init|=
literal|null
decl_stmt|;
try|try
block|{
name|os
operator|=
name|FileUtils
operator|.
name|openOutputStream
argument_list|(
name|configJson
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|in
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e1
parameter_list|)
block|{
throw|throw
operator|new
name|ServletExceptionWithCause
argument_list|(
literal|"Error copying the repository config json"
argument_list|,
name|e1
argument_list|)
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|repository
operator|=
name|createRepository
argument_list|(
name|configJson
argument_list|,
name|repHome
argument_list|)
expr_stmt|;
if|if
condition|(
name|getBootstrapConfig
argument_list|()
operator|.
name|isRepositoryCreateDefaultIndexes
argument_list|()
condition|)
block|{
operator|new
name|IndexInitializer
argument_list|(
name|repository
argument_list|)
operator|.
name|initialize
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RepositoryException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ServletExceptionWithCause
argument_list|(
literal|"Error while creating repository"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Shuts down the repository. If the repository is an instanceof      * {@link JackrabbitRepository} it's {@link JackrabbitRepository#shutdown()}      * method is called. in any case, the {@link #repository} field is      *<code>nulled</code>.      */
specifier|private
name|void
name|shutdownRepository
parameter_list|()
block|{
if|if
condition|(
name|repository
operator|instanceof
name|JackrabbitRepository
condition|)
block|{
operator|(
operator|(
name|JackrabbitRepository
operator|)
name|repository
operator|)
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|repository
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * Creates the repository instance for the given config and homedir.      * Subclasses may override this method of providing own implementations of      * a {@link Repository}.      *      * @param is input source of the repository config      * @param homedir the repository home directory      * @return a new jcr repository.      * @throws RepositoryException if an error during creation occurs.      */
specifier|protected
name|Repository
name|createRepository
parameter_list|(
name|File
name|configJson
parameter_list|,
name|File
name|homedir
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|config
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|config
operator|.
name|put
argument_list|(
name|OakOSGiRepositoryFactory
operator|.
name|REPOSITORY_HOME
argument_list|,
name|homedir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|config
operator|.
name|put
argument_list|(
name|OakOSGiRepositoryFactory
operator|.
name|REPOSITORY_CONFIG_FILE
argument_list|,
name|configJson
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|config
operator|.
name|put
argument_list|(
name|OakOSGiRepositoryFactory
operator|.
name|REPOSITORY_BUNDLE_FILTER
argument_list|,
name|getBootstrapConfig
argument_list|()
operator|.
name|getBundleFilter
argument_list|()
argument_list|)
expr_stmt|;
name|config
operator|.
name|put
argument_list|(
name|OakOSGiRepositoryFactory
operator|.
name|REPOSITORY_SHUTDOWN_ON_TIMEOUT
argument_list|,
name|getBootstrapConfig
argument_list|()
operator|.
name|isShutdownOnTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|config
operator|.
name|put
argument_list|(
name|OakOSGiRepositoryFactory
operator|.
name|REPOSITORY_TIMEOUT_IN_SECS
argument_list|,
name|getBootstrapConfig
argument_list|()
operator|.
name|getStartupTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|configureActivator
argument_list|(
name|config
argument_list|)
expr_stmt|;
comment|//TODO oak-jcr also provides a dummy RepositoryFactory. Hence this
comment|//cannot be used
comment|//return JcrUtils.getRepository(config);
return|return
operator|new
name|OakOSGiRepositoryFactory
argument_list|()
operator|.
name|getRepository
argument_list|(
name|config
argument_list|)
return|;
block|}
specifier|private
name|void
name|configureActivator
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|config
parameter_list|)
block|{
try|try
block|{
name|config
operator|.
name|put
argument_list|(
name|BundleActivator
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|BundleActivator
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|start
parameter_list|(
name|BundleContext
name|bundleContext
parameter_list|)
throws|throws
name|Exception
block|{
name|registerOSGi
argument_list|(
name|bundleContext
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
name|BundleContext
name|bundleContext
parameter_list|)
throws|throws
name|Exception
block|{
name|unregisterOSGi
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"OSGi support not present"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Binds the repository to the JNDI context      * @throws ServletException if an error occurs.      */
specifier|private
name|void
name|registerJNDI
parameter_list|()
throws|throws
name|ServletException
block|{
name|JNDIConfig
name|jc
init|=
name|config
operator|.
name|getJndiConfig
argument_list|()
decl_stmt|;
if|if
condition|(
name|jc
operator|.
name|isValid
argument_list|()
operator|&&
name|jc
operator|.
name|enabled
argument_list|()
condition|)
block|{
try|try
block|{
name|jndiContext
operator|=
operator|new
name|InitialContext
argument_list|(
name|jc
operator|.
name|getJndiEnv
argument_list|()
argument_list|)
expr_stmt|;
name|jndiContext
operator|.
name|bind
argument_list|(
name|jc
operator|.
name|getJndiName
argument_list|()
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Repository bound to JNDI with name: "
operator|+
name|jc
operator|.
name|getJndiName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NamingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ServletExceptionWithCause
argument_list|(
literal|"Unable to bind repository using JNDI: "
operator|+
name|jc
operator|.
name|getJndiName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Unbinds the repository from the JNDI context.      */
specifier|private
name|void
name|unregisterJNDI
parameter_list|()
block|{
if|if
condition|(
name|jndiContext
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|jndiContext
operator|.
name|unbind
argument_list|(
name|config
operator|.
name|getJndiConfig
argument_list|()
operator|.
name|getJndiName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NamingException
name|e
parameter_list|)
block|{
name|log
argument_list|(
literal|"Error while unbinding repository from JNDI: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Registers the repository to an RMI registry configured in the web      * application. See<a href="#registerAlgo">Registration with RMI</a> in the      * class documentation for a description of the algorithms used to register      * the repository with an RMI registry.      * @throws ServletException if an error occurs.      */
specifier|private
name|void
name|registerRMI
parameter_list|()
block|{
name|RMIConfig
name|rc
init|=
name|config
operator|.
name|getRmiConfig
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|rc
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|rc
operator|.
name|enabled
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// try to create remote repository
name|Remote
name|remote
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|Class
operator|.
name|forName
argument_list|(
name|getRemoteFactoryDelegaterClass
argument_list|()
argument_list|)
decl_stmt|;
name|RemoteFactoryDelegater
name|rmf
init|=
operator|(
name|RemoteFactoryDelegater
operator|)
name|clazz
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|remote
operator|=
name|rmf
operator|.
name|createRemoteRepository
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to create RMI repository."
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to create RMI repository."
operator|+
literal|" The jcr-rmi jar might be missing."
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|System
operator|.
name|setProperty
argument_list|(
literal|"java.rmi.server.useCodebaseOnly"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|Registry
name|reg
init|=
literal|null
decl_stmt|;
comment|// first try to create the registry, which will fail if another
comment|// application is already running on the configured host/port
comment|// or if the rmiHost is not local
try|try
block|{
comment|// find the server socket factory: use the default if the
comment|// rmiHost is not configured
name|RMIServerSocketFactory
name|sf
decl_stmt|;
if|if
condition|(
name|rc
operator|.
name|getRmiHost
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Creating RMIServerSocketFactory for host "
operator|+
name|rc
operator|.
name|getRmiHost
argument_list|()
argument_list|)
expr_stmt|;
name|InetAddress
name|hostAddress
init|=
name|InetAddress
operator|.
name|getByName
argument_list|(
name|rc
operator|.
name|getRmiHost
argument_list|()
argument_list|)
decl_stmt|;
name|sf
operator|=
name|getRMIServerSocketFactory
argument_list|(
name|hostAddress
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// have the RMI implementation decide which factory is the
comment|// default actually
name|log
operator|.
name|debug
argument_list|(
literal|"Using default RMIServerSocketFactory"
argument_list|)
expr_stmt|;
name|sf
operator|=
literal|null
expr_stmt|;
block|}
comment|// create a registry using the default client socket factory
comment|// and the server socket factory retrieved above. This also
comment|// binds to the server socket to the rmiHost:rmiPort.
name|reg
operator|=
name|LocateRegistry
operator|.
name|createRegistry
argument_list|(
name|rc
operator|.
name|rmiPort
argument_list|()
argument_list|,
literal|null
argument_list|,
name|sf
argument_list|)
expr_stmt|;
name|rmiRegistry
operator|=
name|reg
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|uhe
parameter_list|)
block|{
comment|// thrown if the rmiHost cannot be resolved into an IP-Address
comment|// by getRMIServerSocketFactory
name|log
operator|.
name|info
argument_list|(
literal|"Cannot create Registry"
argument_list|,
name|uhe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
comment|// thrown by createRegistry if binding to the rmiHost:rmiPort
comment|// fails, for example due to rmiHost being remote or another
comment|// application already being bound to the port
name|log
operator|.
name|info
argument_list|(
literal|"Cannot create Registry"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// if creation of the registry failed, we try to access an
comment|// potentially active registry. We do not check yet, whether the
comment|// registry is actually accessible.
if|if
condition|(
name|reg
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Trying to access existing registry at "
operator|+
name|rc
operator|.
name|getRmiHost
argument_list|()
operator|+
literal|":"
operator|+
name|rc
operator|.
name|getRmiPort
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|reg
operator|=
name|LocateRegistry
operator|.
name|getRegistry
argument_list|(
name|rc
operator|.
name|getRmiHost
argument_list|()
argument_list|,
name|rc
operator|.
name|rmiPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Cannot create the reference to the registry at "
operator|+
name|rc
operator|.
name|getRmiHost
argument_list|()
operator|+
literal|":"
operator|+
name|rc
operator|.
name|getRmiPort
argument_list|()
argument_list|,
name|re
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if we finally have a registry, register the repository with the
comment|// rmiName
if|if
condition|(
name|reg
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Registering repository as "
operator|+
name|rc
operator|.
name|getRmiName
argument_list|()
operator|+
literal|" to registry "
operator|+
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|.
name|bind
argument_list|(
name|rc
operator|.
name|getRmiName
argument_list|()
argument_list|,
name|remote
argument_list|)
expr_stmt|;
comment|// when successfull, keep references
name|this
operator|.
name|rmiRepository
operator|=
name|remote
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Repository bound via RMI with name: "
operator|+
name|rc
operator|.
name|getRmiUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"RMI registry missing, cannot bind repository via RMI"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to bind repository via RMI: "
operator|+
name|rc
operator|.
name|getRmiUri
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AlreadyBoundException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to bind repository via RMI: "
operator|+
name|rc
operator|.
name|getRmiUri
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Unregisters the repository from the RMI registry, if it has previously      * been registered.      */
specifier|private
name|void
name|unregisterRMI
parameter_list|()
block|{
if|if
condition|(
name|rmiRepository
operator|!=
literal|null
condition|)
block|{
comment|// Forcibly unexport the repository;
try|try
block|{
name|UnicastRemoteObject
operator|.
name|unexportObject
argument_list|(
name|rmiRepository
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchObjectException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Odd, the RMI repository was not exported"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// drop strong reference to remote repository
name|rmiRepository
operator|=
literal|null
expr_stmt|;
comment|// unregister repository
try|try
block|{
name|Naming
operator|.
name|unbind
argument_list|(
name|config
operator|.
name|getRmiConfig
argument_list|()
operator|.
name|getRmiUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
argument_list|(
literal|"Error while unbinding repository from JNDI: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rmiRegistry
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|UnicastRemoteObject
operator|.
name|unexportObject
argument_list|(
name|rmiRegistry
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchObjectException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Odd, the RMI registry was not exported"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|rmiRegistry
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**      * Set the BundleContext reference with ServletContext. This is then used by      * Felix Proxy Servlet. Kept the type as object to allow logic to work in      * absence of OSGi classes also.      * @param bundleContext      */
specifier|private
name|void
name|registerOSGi
parameter_list|(
name|Object
name|bundleContext
parameter_list|)
block|{
name|getServletContext
argument_list|()
operator|.
name|setAttribute
argument_list|(
literal|"org.osgi.framework.BundleContext"
argument_list|,
name|bundleContext
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|unregisterOSGi
parameter_list|()
block|{
name|getServletContext
argument_list|()
operator|.
name|removeAttribute
argument_list|(
literal|"org.osgi.framework.BundleContext"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the config that was used to bootstrap this servlet.      * @return the bootstrap config or<code>null</code>.      */
specifier|public
name|BootstrapConfig
name|getBootstrapConfig
parameter_list|()
block|{
return|return
name|config
return|;
block|}
comment|/**      * Return the fully qualified name of the class providing the remote      * repository. The class whose name is returned must implement the      * {@link RemoteFactoryDelegater} interface.      *<p>      * Subclasses may override this method for providing a name of a own      * implementation.      *      * @return getClass().getName() + "$RMIRemoteFactoryDelegater"      */
specifier|protected
name|String
name|getRemoteFactoryDelegaterClass
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"$RMIRemoteFactoryDelegater"
return|;
block|}
comment|/**      * Returns an<code>RMIServerSocketFactory</code> used to create the server      * socket for a locally created RMI registry.      *<p>      * This implementation returns a new instance of a simple      *<code>RMIServerSocketFactory</code> which just creates instances of      * the<code>java.net.ServerSocket</code> class bound to the given      *<code>hostAddress</code>. Implementations may overwrite this method to      * provide factory instances, which provide more elaborate server socket      * creation, such as SSL server sockets.      *      * @param hostAddress The<code>InetAddress</code> instance representing the      *                    the interface on the local host to which the server sockets are      *                    bound.      * @return A new instance of a simple<code>RMIServerSocketFactory</code>      *         creating<code>java.net.ServerSocket</code> instances bound to      *         the<code>rmiHost</code>.      */
specifier|protected
name|RMIServerSocketFactory
name|getRMIServerSocketFactory
parameter_list|(
specifier|final
name|InetAddress
name|hostAddress
parameter_list|)
block|{
return|return
operator|new
name|RMIServerSocketFactory
argument_list|()
block|{
specifier|public
name|ServerSocket
name|createServerSocket
parameter_list|(
name|int
name|port
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|ServerSocket
argument_list|(
name|port
argument_list|,
operator|-
literal|1
argument_list|,
name|hostAddress
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**      * optional class for RMI, will only be used, if RMI server is present      */
specifier|protected
specifier|static
specifier|abstract
class|class
name|RemoteFactoryDelegater
block|{
specifier|public
specifier|abstract
name|Remote
name|createRemoteRepository
parameter_list|(
name|Repository
name|repository
parameter_list|)
throws|throws
name|RemoteException
function_decl|;
block|}
comment|/**      * optional class for RMI, will only be used, if RMI server is present      */
specifier|protected
specifier|static
class|class
name|RMIRemoteFactoryDelegater
extends|extends
name|RemoteFactoryDelegater
block|{
specifier|private
specifier|static
specifier|final
name|RemoteAdapterFactory
name|FACTORY
init|=
operator|new
name|ServerAdapterFactory
argument_list|()
decl_stmt|;
specifier|public
name|Remote
name|createRemoteRepository
parameter_list|(
name|Repository
name|repository
parameter_list|)
throws|throws
name|RemoteException
block|{
return|return
name|FACTORY
operator|.
name|getRemoteRepository
argument_list|(
name|repository
argument_list|)
return|;
block|}
block|}
comment|//-------------------------------------------------< Installer Routines>---
comment|/**      * {@inheritDoc}      */
specifier|protected
name|void
name|doGet
parameter_list|(
name|HttpServletRequest
name|req
parameter_list|,
name|HttpServletResponse
name|resp
parameter_list|)
throws|throws
name|ServletException
throws|,
name|IOException
block|{
if|if
condition|(
name|repository
operator|==
literal|null
condition|)
block|{
name|redirect
argument_list|(
name|req
argument_list|,
name|resp
argument_list|,
literal|"/bootstrap/missing.jsp"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|redirect
argument_list|(
name|req
argument_list|,
name|resp
argument_list|,
literal|"/bootstrap/running.jsp"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * {@inheritDoc}      */
specifier|protected
name|void
name|doPost
parameter_list|(
name|HttpServletRequest
name|req
parameter_list|,
name|HttpServletResponse
name|resp
parameter_list|)
throws|throws
name|ServletException
throws|,
name|IOException
block|{
if|if
condition|(
name|repository
operator|!=
literal|null
condition|)
block|{
name|redirect
argument_list|(
name|req
argument_list|,
name|resp
argument_list|,
literal|"/bootstrap/reconfigure.jsp"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|rc
init|=
operator|new
name|Installer
argument_list|(
name|bootstrapConfigFile
argument_list|,
name|getServletContext
argument_list|()
argument_list|)
operator|.
name|installRepository
argument_list|(
name|req
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|Installer
operator|.
name|C_INSTALL_OK
case|:
comment|// restart rep
name|restart
argument_list|()
expr_stmt|;
if|if
condition|(
name|repository
operator|==
literal|null
condition|)
block|{
name|redirect
argument_list|(
name|req
argument_list|,
name|resp
argument_list|,
literal|"/bootstrap/error.jsp"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|redirect
argument_list|(
name|req
argument_list|,
name|resp
argument_list|,
literal|"/bootstrap/success.jsp"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Installer
operator|.
name|C_INVALID_INPUT
case|:
name|redirect
argument_list|(
name|req
argument_list|,
name|resp
argument_list|,
literal|"/bootstrap/missing.jsp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Installer
operator|.
name|C_CONFIG_EXISTS
case|:
case|case
name|Installer
operator|.
name|C_BOOTSTRAP_EXISTS
case|:
case|case
name|Installer
operator|.
name|C_HOME_EXISTS
case|:
name|redirect
argument_list|(
name|req
argument_list|,
name|resp
argument_list|,
literal|"/bootstrap/exists.jsp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Installer
operator|.
name|C_HOME_MISSING
case|:
case|case
name|Installer
operator|.
name|C_CONFIG_MISSING
case|:
name|redirect
argument_list|(
name|req
argument_list|,
name|resp
argument_list|,
literal|"/bootstrap/notexists.jsp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Installer
operator|.
name|C_INSTALL_ERROR
case|:
name|redirect
argument_list|(
name|req
argument_list|,
name|resp
argument_list|,
literal|"/bootstrap/error.jsp"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/**      * Helper function to send a redirect response respecting the context path.      *      * @param req the request      * @param resp the response      * @param loc the location for the redirect      * @throws ServletException if an servlet error occurs.      * @throws IOException if an I/O error occurs.      */
specifier|private
name|void
name|redirect
parameter_list|(
name|HttpServletRequest
name|req
parameter_list|,
name|HttpServletResponse
name|resp
parameter_list|,
name|String
name|loc
parameter_list|)
throws|throws
name|ServletException
throws|,
name|IOException
block|{
name|String
name|cp
init|=
name|req
operator|.
name|getContextPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|null
operator|||
name|cp
operator|.
name|equals
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|cp
operator|=
literal|""
expr_stmt|;
block|}
name|resp
operator|.
name|sendRedirect
argument_list|(
name|cp
operator|+
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

