begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|jcr
operator|.
name|xml
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|NamespaceRegistry
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|PropertyType
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|RepositoryException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|nodetype
operator|.
name|ConstraintViolationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|jcr
operator|.
name|session
operator|.
name|SessionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|namepath
operator|.
name|JcrNameParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|name
operator|.
name|NamespaceConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|xml
operator|.
name|Importer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|xml
operator|.
name|NodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|xml
operator|.
name|PropInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|xml
operator|.
name|TextValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|util
operator|.
name|ISO9075
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|Attributes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * {@code DocViewImportHandler} processes Document View XML SAX events  * and 'translates' them into {@code {@link Importer}} method calls.  */
end_comment

begin_class
class|class
name|DocViewImportHandler
extends|extends
name|TargetImportHandler
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DocViewImportHandler
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * stack of NodeInfo instances; an instance is pushed onto the stack      * in the startElement method and is popped from the stack in the      * endElement method.      */
specifier|private
specifier|final
name|Stack
argument_list|<
name|NodeInfo
argument_list|>
name|stack
init|=
operator|new
name|Stack
argument_list|<
name|NodeInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// buffer used to merge adjacent character data
specifier|private
name|BufferedStringValue
name|textHandler
decl_stmt|;
comment|/**      * Constructs a new {@code DocViewImportHandler}.      *      * @param importer     the importer      * @param sessionContext the session context      */
name|DocViewImportHandler
parameter_list|(
name|Importer
name|importer
parameter_list|,
name|SessionContext
name|sessionContext
parameter_list|)
block|{
name|super
argument_list|(
name|importer
argument_list|,
name|sessionContext
argument_list|)
expr_stmt|;
block|}
comment|/**      * Parses the given string as a list of JCR names. Any whitespace sequence      * is supported as a names separator instead of just a single space to      * be more liberal in what we accept. The current namespace context is      * used to convert the prefixed name strings to QNames.      *      * @param value string value      * @return the parsed names      * @throws SAXException if an invalid name was encountered      */
specifier|private
name|Iterable
argument_list|<
name|String
argument_list|>
name|parseNames
parameter_list|(
name|String
name|value
parameter_list|)
throws|throws
name|SAXException
block|{
name|String
index|[]
name|names
init|=
name|value
operator|.
name|split
argument_list|(
literal|"\\p{Space}+"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|qnames
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|names
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
try|try
block|{
name|qnames
operator|.
name|add
argument_list|(
operator|new
name|NameInfo
argument_list|(
name|name
argument_list|)
operator|.
name|getRepoQualifiedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RepositoryException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SAXException
argument_list|(
literal|"Invalid name: "
operator|+
name|name
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|qnames
return|;
block|}
comment|/**      * Appends the given character data to the internal buffer.      *      * @param ch     the characters to be appended      * @param start  the index of the first character to append      * @param length the number of characters to append      * @throws SAXException if an error occurs      * @see #characters(char[], int, int)      * @see #ignorableWhitespace(char[], int, int)      * @see #processCharacters()      */
specifier|private
name|void
name|appendCharacters
parameter_list|(
name|char
index|[]
name|ch
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|SAXException
block|{
if|if
condition|(
name|textHandler
operator|==
literal|null
condition|)
block|{
name|textHandler
operator|=
operator|new
name|BufferedStringValue
argument_list|(
name|sessionContext
operator|.
name|getValueFactory
argument_list|()
argument_list|,
name|currentNamePathMapper
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|textHandler
operator|.
name|append
argument_list|(
name|ch
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"internal error while processing internal buffer data"
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SAXException
argument_list|(
name|msg
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
comment|/**      * Translates character data reported by the      * {@code {@link #characters(char[], int, int)}}&      * {@code {@link #ignorableWhitespace(char[], int, int)}} SAX events      * into a  {@code jcr:xmltext} child node with one      * {@code jcr:xmlcharacters} property.      *      * @throws SAXException if an error occurs      * @see #appendCharacters(char[], int, int)      */
specifier|private
name|void
name|processCharacters
parameter_list|()
throws|throws
name|SAXException
block|{
try|try
block|{
if|if
condition|(
name|textHandler
operator|!=
literal|null
operator|&&
name|textHandler
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// there is character data that needs to be added to
comment|// the current node
comment|// check for pure whitespace character data
name|Reader
name|reader
init|=
name|textHandler
operator|.
name|reader
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|reader
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ch
operator|>
literal|0x20
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
block|{
comment|// the character data consists of pure whitespace, ignore
name|log
operator|.
name|debug
argument_list|(
literal|"ignoring pure whitespace character data..."
argument_list|)
expr_stmt|;
comment|// reset handler
name|textHandler
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|textHandler
operator|=
literal|null
expr_stmt|;
return|return;
block|}
block|}
finally|finally
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|NodeInfo
name|node
init|=
operator|new
name|NodeInfo
argument_list|(
name|getJcrName
argument_list|(
name|NamespaceRegistry
operator|.
name|NAMESPACE_JCR
argument_list|,
literal|"xmltext"
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|PropInfo
argument_list|>
name|props
init|=
operator|new
name|ArrayList
argument_list|<
name|PropInfo
argument_list|>
argument_list|()
decl_stmt|;
name|props
operator|.
name|add
argument_list|(
operator|new
name|PropInfo
argument_list|(
name|getJcrName
argument_list|(
name|NamespaceRegistry
operator|.
name|NAMESPACE_JCR
argument_list|,
literal|"xmlcharacters"
argument_list|)
argument_list|,
name|PropertyType
operator|.
name|STRING
argument_list|,
name|textHandler
argument_list|)
argument_list|)
expr_stmt|;
comment|// call Importer
name|importer
operator|.
name|startNode
argument_list|(
name|node
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|importer
operator|.
name|endNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// reset handler
name|textHandler
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|textHandler
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"internal error while processing internal buffer data"
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SAXException
argument_list|(
name|msg
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|RepositoryException
name|re
parameter_list|)
block|{
throw|throw
operator|new
name|SAXException
argument_list|(
name|re
argument_list|)
throw|;
block|}
block|}
specifier|private
name|String
name|getJcrName
parameter_list|(
name|String
name|uri
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|RepositoryException
block|{
return|return
name|sessionContext
operator|.
name|getSession
argument_list|()
operator|.
name|getNamespacePrefix
argument_list|(
name|uri
argument_list|)
operator|+
literal|':'
operator|+
name|name
return|;
block|}
comment|/**      * Processes the given {@code name}, i.e. decodes it and checks      * the format of the decoded name.      *      * @param nameInfo name to process      * @return the decoded and valid jcr name or the original name if it is      *         not encoded or if the resulting decoded name would be illegal.      * @throws javax.jcr.RepositoryException      */
specifier|private
name|NameInfo
name|processName
parameter_list|(
name|NameInfo
name|nameInfo
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|String
name|decodedLocalName
init|=
name|ISO9075
operator|.
name|decode
argument_list|(
name|nameInfo
operator|.
name|getLocalName
argument_list|()
argument_list|)
decl_stmt|;
name|NameInfo
name|decodedNameInfo
init|=
operator|new
name|NameInfo
argument_list|(
name|nameInfo
operator|.
name|getDocPrefix
argument_list|()
argument_list|,
name|decodedLocalName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|decodedLocalName
operator|.
name|equals
argument_list|(
name|nameInfo
operator|.
name|getLocalName
argument_list|()
argument_list|)
condition|)
block|{
try|try
block|{
name|JcrNameParser
operator|.
name|checkName
argument_list|(
name|decodedNameInfo
operator|.
name|getRepoQualifiedName
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ConstraintViolationException
name|e
parameter_list|)
block|{
comment|// decoded name would be illegal according to jsr 170,
comment|// use encoded name as a fallback
name|log
operator|.
name|warn
argument_list|(
literal|"encountered illegal decoded name '"
operator|+
name|decodedLocalName
operator|+
literal|'\''
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|nameInfo
return|;
block|}
block|}
return|return
name|decodedNameInfo
return|;
block|}
comment|//-------------------------------------------------------< ContentHandler>
comment|/**      * {@inheritDoc}      *<p>      * See also {@link org.apache.jackrabbit.commons.xml.Exporter#exportProperties(Node)}      * regarding special handling of multi-valued properties on export.      */
annotation|@
name|Override
specifier|public
name|void
name|startElement
parameter_list|(
name|String
name|namespaceURI
parameter_list|,
name|String
name|localName
parameter_list|,
name|String
name|qName
parameter_list|,
name|Attributes
name|atts
parameter_list|)
throws|throws
name|SAXException
block|{
comment|// process buffered character data
name|processCharacters
argument_list|()
expr_stmt|;
try|try
block|{
name|NameInfo
name|nameInfo
init|=
operator|new
name|NameInfo
argument_list|(
name|qName
argument_list|)
decl_stmt|;
name|nameInfo
operator|=
name|processName
argument_list|(
name|nameInfo
argument_list|)
expr_stmt|;
comment|// properties
name|String
name|id
init|=
literal|null
decl_stmt|;
name|String
name|nodeTypeName
init|=
literal|null
decl_stmt|;
name|Iterable
argument_list|<
name|String
argument_list|>
name|mixinTypes
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|PropInfo
argument_list|>
name|props
init|=
operator|new
name|ArrayList
argument_list|<
name|PropInfo
argument_list|>
argument_list|(
name|atts
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|atts
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|atts
operator|.
name|getURI
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|NamespaceConstants
operator|.
name|NAMESPACE_XMLNS
argument_list|)
condition|)
block|{
comment|// skip namespace declarations reported as attributes
comment|// see http://issues.apache.org/jira/browse/JCR-620#action_12448164
continue|continue;
block|}
name|NameInfo
name|propNameInfo
init|=
name|processName
argument_list|(
operator|new
name|NameInfo
argument_list|(
name|atts
operator|.
name|getQName
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|attrValue
init|=
name|atts
operator|.
name|getValue
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|NamespaceRegistry
operator|.
name|NAMESPACE_JCR
operator|.
name|equals
argument_list|(
name|propNameInfo
operator|.
name|getNamespaceUri
argument_list|()
argument_list|)
operator|&&
literal|"primaryType"
operator|.
name|equals
argument_list|(
name|propNameInfo
operator|.
name|getLocalName
argument_list|()
argument_list|)
condition|)
block|{
comment|// jcr:primaryType
if|if
condition|(
operator|!
name|attrValue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//TODO
name|nodeTypeName
operator|=
name|attrValue
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|NamespaceRegistry
operator|.
name|NAMESPACE_JCR
operator|.
name|equals
argument_list|(
name|propNameInfo
operator|.
name|getNamespaceUri
argument_list|()
argument_list|)
operator|&&
literal|"mixinTypes"
operator|.
name|equals
argument_list|(
name|propNameInfo
operator|.
name|getLocalName
argument_list|()
argument_list|)
condition|)
block|{
comment|// jcr:mixinTypes
name|mixinTypes
operator|=
name|parseNames
argument_list|(
name|attrValue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NamespaceRegistry
operator|.
name|NAMESPACE_JCR
operator|.
name|equals
argument_list|(
name|propNameInfo
operator|.
name|getNamespaceUri
argument_list|()
argument_list|)
operator|&&
literal|"uuid"
operator|.
name|equals
argument_list|(
name|propNameInfo
operator|.
name|getLocalName
argument_list|()
argument_list|)
condition|)
block|{
comment|// jcr:uuid
if|if
condition|(
operator|!
name|attrValue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|id
operator|=
name|attrValue
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// always assume single-valued property for the time being
comment|// until a way of properly serializing/detecting multi-valued
comment|// properties on re-import is found (see JCR-325);
comment|// see also DocViewSAXEventGenerator#leavingProperties(Node, int)
comment|// TODO proper multi-value serialization support
name|TextValue
name|tv
init|=
operator|new
name|StringValue
argument_list|(
name|attrValue
argument_list|,
name|sessionContext
operator|.
name|getValueFactory
argument_list|()
argument_list|,
name|currentNamePathMapper
argument_list|()
argument_list|)
decl_stmt|;
name|props
operator|.
name|add
argument_list|(
operator|new
name|PropInfo
argument_list|(
name|propNameInfo
operator|.
name|getRepoQualifiedName
argument_list|()
argument_list|,
name|PropertyType
operator|.
name|UNDEFINED
argument_list|,
name|tv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|NodeInfo
name|node
init|=
operator|new
name|NodeInfo
argument_list|(
name|nameInfo
operator|.
name|getRepoQualifiedName
argument_list|()
argument_list|,
name|nodeTypeName
argument_list|,
name|mixinTypes
argument_list|,
name|id
argument_list|)
decl_stmt|;
comment|// all information has been collected, now delegate to importer
name|importer
operator|.
name|startNode
argument_list|(
name|node
argument_list|,
name|props
argument_list|)
expr_stmt|;
comment|// push current node data onto stack
name|stack
operator|.
name|push
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RepositoryException
name|re
parameter_list|)
block|{
throw|throw
operator|new
name|SAXException
argument_list|(
name|re
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|characters
parameter_list|(
name|char
index|[]
name|ch
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|SAXException
block|{
comment|/**          * buffer data reported by the characters event;          * will be processed on the next endElement or startElement event.          */
name|appendCharacters
argument_list|(
name|ch
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|ignorableWhitespace
parameter_list|(
name|char
index|[]
name|ch
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|SAXException
block|{
comment|/**          * buffer data reported by the ignorableWhitespace event;          * will be processed on the next endElement or startElement event.          */
name|appendCharacters
argument_list|(
name|ch
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|endElement
parameter_list|(
name|String
name|namespaceURI
parameter_list|,
name|String
name|localName
parameter_list|,
name|String
name|qName
parameter_list|)
throws|throws
name|SAXException
block|{
comment|// process buffered character data
name|processCharacters
argument_list|()
expr_stmt|;
name|NodeInfo
name|node
init|=
name|stack
operator|.
name|peek
argument_list|()
decl_stmt|;
try|try
block|{
comment|// call Importer
name|importer
operator|.
name|endNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RepositoryException
name|re
parameter_list|)
block|{
throw|throw
operator|new
name|SAXException
argument_list|(
name|re
argument_list|)
throw|;
block|}
comment|// we're done with this node, pop it from stack
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

