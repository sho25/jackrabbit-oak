begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|ClusterNodeInfo
operator|.
name|ClusterNodeState
operator|.
name|ACTIVE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|ClusterNodeInfo
operator|.
name|ClusterNodeState
operator|.
name|NONE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|ClusterNodeInfo
operator|.
name|RecoverLockState
operator|.
name|ACQUIRED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|Utils
operator|.
name|getModuleVersion
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|NetworkInterface
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Stopwatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|stats
operator|.
name|Clock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|NotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Information about a cluster node.  */
end_comment

begin_class
specifier|public
class|class
name|ClusterNodeInfo
block|{
specifier|private
specifier|static
specifier|final
name|String
name|LEASE_CHECK_FAILED_MSG
init|=
literal|"This oak instance failed to update "
operator|+
literal|"the lease in time and can therefore no longer access this DocumentNodeStore."
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ClusterNodeInfo
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The prefix for random (non-reusable) keys.      */
specifier|private
specifier|static
specifier|final
name|String
name|RANDOM_PREFIX
init|=
literal|"random:"
decl_stmt|;
comment|/**      * The machine id.      */
specifier|private
specifier|static
specifier|final
name|String
name|MACHINE_ID_KEY
init|=
literal|"machine"
decl_stmt|;
comment|/**      * The Oak version.      */
specifier|static
specifier|final
name|String
name|OAK_VERSION_KEY
init|=
literal|"oakVersion"
decl_stmt|;
comment|/**      * The unique instance id within this machine (the current working directory      * if not set).      */
specifier|private
specifier|static
specifier|final
name|String
name|INSTANCE_ID_KEY
init|=
literal|"instance"
decl_stmt|;
comment|/**      * The end of the lease.      */
specifier|public
specifier|static
specifier|final
name|String
name|LEASE_END_KEY
init|=
literal|"leaseEnd"
decl_stmt|;
comment|/**      * The start time.      */
specifier|public
specifier|static
specifier|final
name|String
name|START_TIME_KEY
init|=
literal|"startTime"
decl_stmt|;
comment|/**      * The key for the root-revision of the last background write (of unsaved      * modifications) - that is: the last root-revision written by the instance      * in case of a clear shutdown or via recovery of another instance in case      * of a crash      */
specifier|public
specifier|static
specifier|final
name|String
name|LAST_WRITTEN_ROOT_REV_KEY
init|=
literal|"lastWrittenRootRev"
decl_stmt|;
comment|/**      * The state of the cluster. On proper shutdown the state should be cleared.      *      * @see org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState      */
specifier|public
specifier|static
specifier|final
name|String
name|STATE
init|=
literal|"state"
decl_stmt|;
comment|/**      * The broadcast id. If the broadcasting cache is used, a new id is set after startup.      */
specifier|public
specifier|static
specifier|final
name|String
name|BROADCAST_ID
init|=
literal|"broadcastId"
decl_stmt|;
comment|/**      * The broadcast listener (host:port). If the broadcasting cache is used, this is set after startup.      */
specifier|public
specifier|static
specifier|final
name|String
name|BROADCAST_LISTENER
init|=
literal|"broadcastListener"
decl_stmt|;
specifier|public
specifier|static
enum|enum
name|ClusterNodeState
block|{
name|NONE
block|,
comment|/**          * Indicates that cluster node is currently active          */
name|ACTIVE
block|;
specifier|static
name|ClusterNodeState
name|fromString
parameter_list|(
name|String
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
return|return
name|NONE
return|;
block|}
return|return
name|valueOf
argument_list|(
name|state
argument_list|)
return|;
block|}
block|}
comment|/**      * Flag to indicate whether the _lastRev recovery is in progress.      *      * @see RecoverLockState      */
specifier|public
specifier|static
specifier|final
name|String
name|REV_RECOVERY_LOCK
init|=
literal|"recoveryLock"
decl_stmt|;
specifier|public
specifier|static
enum|enum
name|RecoverLockState
block|{
name|NONE
block|,
comment|/**          * _lastRev recovery in progress          */
name|ACQUIRED
block|;
specifier|static
name|RecoverLockState
name|fromString
parameter_list|(
name|String
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
return|return
name|NONE
return|;
block|}
return|return
name|valueOf
argument_list|(
name|state
argument_list|)
return|;
block|}
block|}
comment|/**      * Flag indicating which cluster node is running the recovery.      */
specifier|public
specifier|static
specifier|final
name|String
name|REV_RECOVERY_BY
init|=
literal|"recoveryBy"
decl_stmt|;
comment|/**      * Additional info, such as the process id, for support.      */
specifier|private
specifier|static
specifier|final
name|String
name|INFO_KEY
init|=
literal|"info"
decl_stmt|;
comment|/**      * The read/write mode key. Specifies the read/write preference to be used with      * DocumentStore      */
specifier|private
specifier|static
specifier|final
name|String
name|READ_WRITE_MODE_KEY
init|=
literal|"readWriteMode"
decl_stmt|;
comment|/**      * The unique machine id (the MAC address if available).      */
specifier|private
specifier|static
specifier|final
name|String
name|MACHINE_ID
init|=
name|getHardwareMachineId
argument_list|()
decl_stmt|;
comment|/**      * The process id (if available).      */
specifier|private
specifier|static
specifier|final
name|long
name|PROCESS_ID
init|=
name|getProcessId
argument_list|()
decl_stmt|;
comment|/**      * The current working directory.      * Note: marked protected non-final for testing purpose only.      */
specifier|protected
specifier|static
name|String
name|WORKING_DIR
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.dir"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|/**      *<b>Only Used For Testing</b>      */
specifier|private
specifier|static
name|Clock
name|clock
init|=
name|Clock
operator|.
name|SIMPLE
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_LEASE_DURATION_MILLIS
decl_stmt|;
static|static
block|{
name|String
name|leaseDurationProp
init|=
literal|"oak.documentMK.leaseDurationSeconds"
decl_stmt|;
name|Integer
name|leaseProp
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
name|leaseDurationProp
argument_list|)
decl_stmt|;
if|if
condition|(
name|leaseProp
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Lease duration set to: "
operator|+
name|leaseProp
operator|+
literal|"s (using system property "
operator|+
name|leaseDurationProp
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/** OAK-3398 : default lease duration 120sec **/
name|DEFAULT_LEASE_DURATION_MILLIS
operator|=
literal|1000
operator|*
operator|(
name|leaseProp
operator|!=
literal|null
condition|?
name|leaseProp
else|:
literal|120
operator|)
expr_stmt|;
block|}
comment|/** OAK-3398 : default update interval 10sec **/
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_LEASE_UPDATE_INTERVAL_MILLIS
init|=
literal|1000
operator|*
literal|10
decl_stmt|;
comment|/** OAK-3398 : default failure margin 20sec before actual lease timeout      * (note that OAK-3399 / MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE eats      * off another few seconds from this margin, by default 5sec,      * so the actual default failure-margin is down to 15sec - and that is high-noon!)      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_LEASE_FAILURE_MARGIN_MILLIS
init|=
literal|1000
operator|*
literal|20
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_LEASE_CHECK_DISABLED
init|=
name|Boolean
operator|.
name|valueOf
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"oak.documentMK.disableLeaseCheck"
argument_list|,
literal|"false"
argument_list|)
argument_list|)
decl_stmt|;
comment|/**      * Default lease check mode is strict, unless disabled via system property.      */
specifier|static
specifier|final
name|LeaseCheckMode
name|DEFAULT_LEASE_CHECK_MODE
init|=
name|DEFAULT_LEASE_CHECK_DISABLED
condition|?
name|LeaseCheckMode
operator|.
name|DISABLED
else|:
name|LeaseCheckMode
operator|.
name|STRICT
decl_stmt|;
comment|/** OAK-3399 : max number of times we're doing a 1sec retry loop just before declaring lease failure **/
specifier|private
specifier|static
specifier|final
name|int
name|MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE
init|=
literal|5
decl_stmt|;
comment|/**      * The Oak version.      */
specifier|private
specifier|static
specifier|final
name|String
name|OAK_VERSION
init|=
name|getModuleVersion
argument_list|()
decl_stmt|;
comment|/**      * The number of milliseconds for a lease (2 minute by default, and      * initially).      */
specifier|private
name|long
name|leaseTime
init|=
name|DEFAULT_LEASE_DURATION_MILLIS
decl_stmt|;
comment|/**      * The number of milliseconds after which a lease will be updated      * (should not be every second as that would increase number of      * writes towards DocumentStore considerably - but it should also      * not be too low as that would eat into the lease duration on average.      */
specifier|private
name|long
name|leaseUpdateInterval
init|=
name|DEFAULT_LEASE_UPDATE_INTERVAL_MILLIS
decl_stmt|;
comment|/**      * The number of milliseconds that a lease must still be valid      * before prematurely declaring it as failed. The default is 20sec.      * The idea of declaring a lease as failed before it actually failed      * is to avoid a race condition where the local instance assumes      * things are all fine but another instance in the cluster will      * 'in the same moment' declare it as failed. The lease should be      * checked every second and updated after 10sec, so it should always      * have a validity of at least 110sec - if that's down to this margin      * of 20sec then things are not good and we have to give up.      */
specifier|private
name|long
name|leaseFailureMargin
init|=
name|DEFAULT_LEASE_FAILURE_MARGIN_MILLIS
decl_stmt|;
comment|/**      * The assigned cluster id.      */
specifier|private
specifier|final
name|int
name|id
decl_stmt|;
comment|/**      * The machine id.      */
specifier|private
specifier|final
name|String
name|machineId
decl_stmt|;
comment|/**      * The instance id.      */
specifier|private
specifier|final
name|String
name|instanceId
decl_stmt|;
comment|/**      * The document store that is used to renew the lease.      */
specifier|private
specifier|final
name|DocumentStore
name|store
decl_stmt|;
comment|/**      * The time (in milliseconds UTC) where this instance was started.      */
specifier|private
specifier|final
name|long
name|startTime
decl_stmt|;
comment|/**      * A unique id.      */
specifier|private
specifier|final
name|String
name|uuid
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|/**      * The time (in milliseconds UTC) where the lease of this instance ends.      */
specifier|private
specifier|volatile
name|long
name|leaseEndTime
decl_stmt|;
comment|/**      * The value of leaseEnd last updated towards DocumentStore -      * this one is used to compare against (for OAK-3398) when checking      * if any other instance updated the lease or if the lease is unchanged.      * (This is kind of a duplication of the leaseEndTime field, yes - but the semantics      * are that previousLeaseEndTime exactly only serves the purpose of      * keeping the value of what was stored in the previous lease update.      * leaseEndTime on the other hand serves the purpose of *defining the lease end*,      * these are two different concerns, thus justify two different fields.      * the leaseEndTime for example can be manipulated during tests therefore,      * without interfering with previousLeaseEndTime)      */
specifier|private
name|long
name|previousLeaseEndTime
decl_stmt|;
comment|/**      * The read/write mode.      */
specifier|private
name|String
name|readWriteMode
decl_stmt|;
comment|/**      * The state of the cluster node.      */
specifier|private
name|ClusterNodeState
name|state
init|=
name|ACTIVE
decl_stmt|;
comment|/**      * OAK-2739 / OAK-3397 : once a lease check turns out negative, this flag      * is set to prevent any further checks to succeed. Also, only the first      * one to change this flag will take the appropriate action that results      * from a failed leaseCheck (which is currently to stop oak-store-document bundle)      */
specifier|private
name|boolean
name|leaseCheckFailed
init|=
literal|false
decl_stmt|;
comment|/**      * Default lease check mode is strict, unless disabled by      */
specifier|private
name|LeaseCheckMode
name|leaseCheckMode
init|=
name|DEFAULT_LEASE_CHECK_MODE
decl_stmt|;
comment|/**      * In memory flag indicating that this ClusterNode is entry is new and is being added to      * DocumentStore for the first time      *      * If false then it indicates that a previous entry for current node existed and that is being      * reused      */
specifier|private
name|boolean
name|newEntry
decl_stmt|;
comment|/**      * OAK-3397 / OAK-3400 : the LeaseFailureHandler is the one that actually      * stops the oak-store-document bundle (or does something else if necessary)      */
specifier|private
name|LeaseFailureHandler
name|leaseFailureHandler
decl_stmt|;
specifier|private
name|ClusterNodeInfo
parameter_list|(
name|int
name|id
parameter_list|,
name|DocumentStore
name|store
parameter_list|,
name|String
name|machineId
parameter_list|,
name|String
name|instanceId
parameter_list|,
name|boolean
name|newEntry
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|startTime
operator|=
name|getCurrentTime
argument_list|()
expr_stmt|;
name|this
operator|.
name|leaseEndTime
operator|=
name|this
operator|.
name|startTime
operator|+
name|leaseTime
expr_stmt|;
name|this
operator|.
name|previousLeaseEndTime
operator|=
name|this
operator|.
name|leaseEndTime
expr_stmt|;
name|this
operator|.
name|store
operator|=
name|store
expr_stmt|;
name|this
operator|.
name|machineId
operator|=
name|machineId
expr_stmt|;
name|this
operator|.
name|instanceId
operator|=
name|instanceId
expr_stmt|;
name|this
operator|.
name|newEntry
operator|=
name|newEntry
expr_stmt|;
block|}
name|void
name|setLeaseCheckMode
parameter_list|(
annotation|@
name|NotNull
name|LeaseCheckMode
name|mode
parameter_list|)
block|{
name|this
operator|.
name|leaseCheckMode
operator|=
name|checkNotNull
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
name|LeaseCheckMode
name|getLeaseCheckMode
parameter_list|()
block|{
return|return
name|leaseCheckMode
return|;
block|}
specifier|public
name|int
name|getId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
name|String
name|getMachineId
parameter_list|()
block|{
return|return
name|machineId
return|;
block|}
name|String
name|getInstanceId
parameter_list|()
block|{
return|return
name|instanceId
return|;
block|}
comment|/**      * Create a cluster node info instance to be utilized for read only access      * to underlying store.      *      * @param store the document store.      * @return the cluster node info      */
specifier|public
specifier|static
name|ClusterNodeInfo
name|getReadOnlyInstance
parameter_list|(
name|DocumentStore
name|store
parameter_list|)
block|{
return|return
operator|new
name|ClusterNodeInfo
argument_list|(
literal|0
argument_list|,
name|store
argument_list|,
name|MACHINE_ID
argument_list|,
name|WORKING_DIR
argument_list|,
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|dispose
parameter_list|()
block|{             }
annotation|@
name|Override
specifier|public
name|long
name|getLeaseEndTime
parameter_list|()
block|{
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|performLeaseCheck
parameter_list|()
block|{             }
annotation|@
name|Override
specifier|public
name|boolean
name|renewLease
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setInfo
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|info
parameter_list|)
block|{}
annotation|@
name|Override
specifier|public
name|void
name|setLeaseFailureHandler
parameter_list|(
name|LeaseFailureHandler
name|leaseFailureHandler
parameter_list|)
block|{}
block|}
return|;
block|}
comment|/**      * Get or create a cluster node info instance for the store.      *      * @param store the document store (for the lease)      * @param recoveryHandler the recovery handler to call for a clusterId with      *                        an expired lease.      * @param machineId the machine id (null for MAC address)      * @param instanceId the instance id (null for current working directory)      * @param configuredClusterId the configured cluster id (or 0 for dynamic assignment)      * @return the cluster node info      */
specifier|public
specifier|static
name|ClusterNodeInfo
name|getInstance
parameter_list|(
name|DocumentStore
name|store
parameter_list|,
name|RecoveryHandler
name|recoveryHandler
parameter_list|,
name|String
name|machineId
parameter_list|,
name|String
name|instanceId
parameter_list|,
name|int
name|configuredClusterId
parameter_list|)
block|{
comment|// defaults for machineId and instanceID
if|if
condition|(
name|machineId
operator|==
literal|null
condition|)
block|{
name|machineId
operator|=
name|MACHINE_ID
expr_stmt|;
block|}
if|if
condition|(
name|instanceId
operator|==
literal|null
condition|)
block|{
name|instanceId
operator|=
name|WORKING_DIR
expr_stmt|;
block|}
name|int
name|retries
init|=
literal|10
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|retries
condition|;
name|i
operator|++
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|ClusterNodeInfo
argument_list|,
name|Long
argument_list|>
name|suggestedClusterNode
init|=
name|createInstance
argument_list|(
name|store
argument_list|,
name|recoveryHandler
argument_list|,
name|machineId
argument_list|,
name|instanceId
argument_list|,
name|configuredClusterId
argument_list|,
name|i
operator|==
literal|0
argument_list|)
decl_stmt|;
name|ClusterNodeInfo
name|clusterNode
init|=
name|suggestedClusterNode
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Long
name|currentStartTime
init|=
name|suggestedClusterNode
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|clusterNode
operator|.
name|id
argument_list|)
decl_stmt|;
name|UpdateOp
name|update
init|=
operator|new
name|UpdateOp
argument_list|(
name|key
argument_list|,
name|clusterNode
operator|.
name|newEntry
argument_list|)
decl_stmt|;
name|update
operator|.
name|set
argument_list|(
name|MACHINE_ID_KEY
argument_list|,
name|clusterNode
operator|.
name|machineId
argument_list|)
expr_stmt|;
name|update
operator|.
name|set
argument_list|(
name|INSTANCE_ID_KEY
argument_list|,
name|clusterNode
operator|.
name|instanceId
argument_list|)
expr_stmt|;
name|update
operator|.
name|set
argument_list|(
name|LEASE_END_KEY
argument_list|,
name|clusterNode
operator|.
name|leaseEndTime
argument_list|)
expr_stmt|;
name|update
operator|.
name|set
argument_list|(
name|START_TIME_KEY
argument_list|,
name|clusterNode
operator|.
name|startTime
argument_list|)
expr_stmt|;
name|update
operator|.
name|set
argument_list|(
name|INFO_KEY
argument_list|,
name|clusterNode
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|update
operator|.
name|set
argument_list|(
name|STATE
argument_list|,
name|ACTIVE
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|update
operator|.
name|set
argument_list|(
name|OAK_VERSION_KEY
argument_list|,
name|OAK_VERSION
argument_list|)
expr_stmt|;
name|ClusterNodeInfoDocument
name|before
init|=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|success
decl_stmt|;
if|if
condition|(
name|clusterNode
operator|.
name|newEntry
condition|)
block|{
comment|// For new entry do a create. This ensures that if two nodes
comment|// create entry with same id then only one would succeed
name|success
operator|=
name|store
operator|.
name|create
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|update
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// remember how the entry looked before the update
name|before
operator|=
name|store
operator|.
name|find
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|// perform a conditional update with a check on the startTime
comment|// field. If there are competing cluster nodes trying to acquire
comment|// the same inactive clusterId, only one of them will succeed.
name|update
operator|.
name|equals
argument_list|(
name|START_TIME_KEY
argument_list|,
name|currentStartTime
argument_list|)
expr_stmt|;
comment|// ensure some other conditions
comment|// 1) must not be active
name|update
operator|.
name|notEquals
argument_list|(
name|STATE
argument_list|,
name|ACTIVE
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2) must not have a recovery lock
name|update
operator|.
name|notEquals
argument_list|(
name|REV_RECOVERY_LOCK
argument_list|,
name|ACQUIRED
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|success
operator|=
name|store
operator|.
name|findAndUpdate
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
name|update
argument_list|)
operator|!=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|logClusterIdAcquired
argument_list|(
name|clusterNode
argument_list|,
name|before
argument_list|)
expr_stmt|;
return|return
name|clusterNode
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Collision while acquiring clusterId {}. Retrying..."
argument_list|,
name|clusterNode
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"Could not get cluster node info (tried "
operator|+
name|retries
operator|+
literal|" times)"
argument_list|)
throw|;
block|}
specifier|private
specifier|static
name|Map
operator|.
name|Entry
argument_list|<
name|ClusterNodeInfo
argument_list|,
name|Long
argument_list|>
name|createInstance
parameter_list|(
name|DocumentStore
name|store
parameter_list|,
name|RecoveryHandler
name|recoveryHandler
parameter_list|,
name|String
name|machineId
parameter_list|,
name|String
name|instanceId
parameter_list|,
name|int
name|configuredClusterId
parameter_list|,
name|boolean
name|waitForLease
parameter_list|)
block|{
name|long
name|now
init|=
name|getCurrentTime
argument_list|()
decl_stmt|;
name|int
name|maxId
init|=
literal|0
decl_stmt|;
name|ClusterNodeInfoDocument
name|alreadyExistingConfigured
init|=
literal|null
decl_stmt|;
name|String
name|reuseFailureReason
init|=
literal|""
decl_stmt|;
name|List
argument_list|<
name|ClusterNodeInfoDocument
argument_list|>
name|list
init|=
name|ClusterNodeInfoDocument
operator|.
name|all
argument_list|(
name|store
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Long
argument_list|>
name|startTimes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|SortedSet
argument_list|<
name|ClusterNodeInfo
argument_list|>
name|candidates
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
operator|new
name|ClusterNodeInfoComparator
argument_list|(
name|machineId
argument_list|,
name|instanceId
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|ClusterNodeInfoDocument
name|doc
range|:
name|list
control|)
block|{
name|String
name|key
init|=
name|doc
operator|.
name|getId
argument_list|()
decl_stmt|;
name|int
name|id
decl_stmt|;
try|try
block|{
name|id
operator|=
name|doc
operator|.
name|getClusterId
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping cluster node info document {} because ID is invalid"
argument_list|,
name|key
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|maxId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxId
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|// cannot use an entry without start time
if|if
condition|(
name|doc
operator|.
name|getStartTime
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|reuseFailureReason
operator|=
name|reject
argument_list|(
name|id
argument_list|,
literal|"Cluster node entry does not have a startTime. "
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// if a cluster id was configured: check that and abort if it does
comment|// not match
if|if
condition|(
name|configuredClusterId
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|configuredClusterId
operator|!=
name|id
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|alreadyExistingConfigured
operator|=
name|doc
expr_stmt|;
block|}
block|}
name|Long
name|leaseEnd
init|=
operator|(
name|Long
operator|)
name|doc
operator|.
name|get
argument_list|(
name|LEASE_END_KEY
argument_list|)
decl_stmt|;
name|String
name|mId
init|=
literal|""
operator|+
name|doc
operator|.
name|get
argument_list|(
name|MACHINE_ID_KEY
argument_list|)
decl_stmt|;
name|String
name|iId
init|=
literal|""
operator|+
name|doc
operator|.
name|get
argument_list|(
name|INSTANCE_ID_KEY
argument_list|)
decl_stmt|;
comment|// handle active clusterId with valid lease and no recovery lock
comment|// -> potentially wait for lease if machine and instance id match
if|if
condition|(
name|leaseEnd
operator|!=
literal|null
operator|&&
name|leaseEnd
operator|>
name|now
operator|&&
operator|!
name|doc
operator|.
name|isRecoveryNeeded
argument_list|(
name|now
argument_list|)
condition|)
block|{
comment|// wait if (a) instructed to, and (b) also the remaining time
comment|// time is not much bigger than the lease interval (in which
comment|// case something is very very wrong anyway)
if|if
condition|(
name|waitForLease
operator|&&
operator|(
name|leaseEnd
operator|-
name|now
operator|)
operator|<
operator|(
name|DEFAULT_LEASE_DURATION_MILLIS
operator|+
literal|5000
operator|)
operator|&&
name|mId
operator|.
name|equals
argument_list|(
name|machineId
argument_list|)
operator|&&
name|iId
operator|.
name|equals
argument_list|(
name|instanceId
argument_list|)
condition|)
block|{
name|boolean
name|worthRetrying
init|=
name|waitForLeaseExpiry
argument_list|(
name|store
argument_list|,
name|doc
argument_list|,
name|leaseEnd
argument_list|,
name|machineId
argument_list|,
name|instanceId
argument_list|)
decl_stmt|;
if|if
condition|(
name|worthRetrying
condition|)
block|{
return|return
name|createInstance
argument_list|(
name|store
argument_list|,
name|recoveryHandler
argument_list|,
name|machineId
argument_list|,
name|instanceId
argument_list|,
name|configuredClusterId
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
name|reuseFailureReason
operator|=
name|reject
argument_list|(
name|id
argument_list|,
literal|"leaseEnd "
operator|+
name|leaseEnd
operator|+
literal|"> "
operator|+
name|now
operator|+
literal|" - "
operator|+
operator|(
name|leaseEnd
operator|-
name|now
operator|)
operator|+
literal|"ms in the future"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// if we get here the clusterId either:
comment|// 1) is inactive
comment|// 2) needs recovery
if|if
condition|(
name|doc
operator|.
name|isRecoveryNeeded
argument_list|(
name|now
argument_list|)
condition|)
block|{
if|if
condition|(
name|mId
operator|.
name|equals
argument_list|(
name|machineId
argument_list|)
operator|&&
name|iId
operator|.
name|equals
argument_list|(
name|instanceId
argument_list|)
condition|)
block|{
comment|// this id matches our environment and has an expired lease
comment|// use it after a successful recovery
if|if
condition|(
operator|!
name|recoveryHandler
operator|.
name|recover
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|reuseFailureReason
operator|=
name|reject
argument_list|(
name|id
argument_list|,
literal|"needs recovery and was unable to perform it myself"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|// a different machine or instance
name|reuseFailureReason
operator|=
name|reject
argument_list|(
name|id
argument_list|,
literal|"needs recovery and machineId/instanceId do not match: "
operator|+
name|mId
operator|+
literal|"/"
operator|+
name|iId
operator|+
literal|" != "
operator|+
name|machineId
operator|+
literal|"/"
operator|+
name|instanceId
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|// if we get here the cluster node entry is inactive. if recovery
comment|// was needed, then it was successful
comment|// create a candidate. those with matching machine and instance id
comment|// are preferred, then the one with the lowest clusterId.
name|candidates
operator|.
name|add
argument_list|(
operator|new
name|ClusterNodeInfo
argument_list|(
name|id
argument_list|,
name|store
argument_list|,
name|mId
argument_list|,
name|iId
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|startTimes
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|doc
operator|.
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|candidates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No usable existing entry found
name|int
name|clusterNodeId
decl_stmt|;
if|if
condition|(
name|configuredClusterId
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|alreadyExistingConfigured
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"Configured cluster node id "
operator|+
name|configuredClusterId
operator|+
literal|" already in use: "
operator|+
name|reuseFailureReason
argument_list|)
throw|;
block|}
name|clusterNodeId
operator|=
name|configuredClusterId
expr_stmt|;
block|}
else|else
block|{
name|clusterNodeId
operator|=
name|maxId
operator|+
literal|1
expr_stmt|;
block|}
comment|// No usable existing entry found so create a new entry
name|candidates
operator|.
name|add
argument_list|(
operator|new
name|ClusterNodeInfo
argument_list|(
name|clusterNodeId
argument_list|,
name|store
argument_list|,
name|machineId
argument_list|,
name|instanceId
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// use the best candidate
name|ClusterNodeInfo
name|info
init|=
name|candidates
operator|.
name|first
argument_list|()
decl_stmt|;
comment|// and replace with an info matching the current machine and instance id
name|info
operator|=
operator|new
name|ClusterNodeInfo
argument_list|(
name|info
operator|.
name|id
argument_list|,
name|store
argument_list|,
name|machineId
argument_list|,
name|instanceId
argument_list|,
name|info
operator|.
name|newEntry
argument_list|)
expr_stmt|;
return|return
operator|new
name|AbstractMap
operator|.
name|SimpleImmutableEntry
argument_list|<>
argument_list|(
name|info
argument_list|,
name|startTimes
operator|.
name|get
argument_list|(
name|info
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|logClusterIdAcquired
parameter_list|(
name|ClusterNodeInfo
name|clusterNode
parameter_list|,
name|ClusterNodeInfoDocument
name|before
parameter_list|)
block|{
name|String
name|type
init|=
name|clusterNode
operator|.
name|newEntry
condition|?
literal|"new"
else|:
literal|"existing"
decl_stmt|;
name|String
name|machineInfo
init|=
name|clusterNode
operator|.
name|machineId
decl_stmt|;
name|String
name|instanceInfo
init|=
name|clusterNode
operator|.
name|instanceId
decl_stmt|;
if|if
condition|(
name|before
operator|!=
literal|null
condition|)
block|{
comment|// machineId or instanceId may have changed
name|String
name|beforeMachineId
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|before
operator|.
name|get
argument_list|(
name|MACHINE_ID_KEY
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|beforeInstanceId
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|before
operator|.
name|get
argument_list|(
name|INSTANCE_ID_KEY
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|clusterNode
operator|.
name|machineId
operator|.
name|equals
argument_list|(
name|beforeMachineId
argument_list|)
condition|)
block|{
name|machineInfo
operator|=
literal|"(changed) "
operator|+
name|beforeMachineId
operator|+
literal|" -> "
operator|+
name|machineInfo
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|clusterNode
operator|.
name|instanceId
operator|.
name|equals
argument_list|(
name|beforeInstanceId
argument_list|)
condition|)
block|{
name|instanceInfo
operator|=
literal|"(changed) "
operator|+
name|beforeInstanceId
operator|+
literal|" -> "
operator|+
name|instanceInfo
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Acquired ({}) clusterId {}. MachineId {}, InstanceId {}"
argument_list|,
name|type
argument_list|,
name|clusterNode
operator|.
name|getId
argument_list|()
argument_list|,
name|machineInfo
argument_list|,
name|instanceInfo
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|String
name|reject
parameter_list|(
name|int
name|id
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cannot acquire {}: {}"
argument_list|,
name|id
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
name|reason
return|;
block|}
specifier|private
specifier|static
name|boolean
name|waitForLeaseExpiry
parameter_list|(
name|DocumentStore
name|store
parameter_list|,
name|ClusterNodeInfoDocument
name|cdoc
parameter_list|,
name|long
name|leaseEnd
parameter_list|,
name|String
name|machineId
parameter_list|,
name|String
name|instanceId
parameter_list|)
block|{
name|String
name|key
init|=
name|cdoc
operator|.
name|getId
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Found an existing possibly active cluster node info ("
operator|+
name|key
operator|+
literal|") for this instance: "
operator|+
name|machineId
operator|+
literal|"/"
operator|+
name|instanceId
operator|+
literal|", will try use it."
argument_list|)
expr_stmt|;
comment|// wait until lease expiry plus 2s
name|long
name|waitUntil
init|=
name|leaseEnd
operator|+
literal|2000
decl_stmt|;
while|while
condition|(
name|getCurrentTime
argument_list|()
operator|<
name|waitUntil
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for cluster node "
operator|+
name|key
operator|+
literal|"'s lease to expire: "
operator|+
operator|(
name|waitUntil
operator|-
name|getCurrentTime
argument_list|()
operator|)
operator|/
literal|1000
operator|+
literal|"s left"
argument_list|)
expr_stmt|;
try|try
block|{
name|clock
operator|.
name|waitUntil
argument_list|(
name|getCurrentTime
argument_list|()
operator|+
literal|5000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignored
block|}
try|try
block|{
comment|// check state of cluster node info
name|ClusterNodeInfoDocument
name|reread
init|=
name|store
operator|.
name|find
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|reread
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cluster node info "
operator|+
name|key
operator|+
literal|": gone; continueing."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|Long
name|newLeaseEnd
init|=
operator|(
name|Long
operator|)
name|reread
operator|.
name|get
argument_list|(
name|LEASE_END_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|newLeaseEnd
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cluster node "
operator|+
name|key
operator|+
literal|": lease end information missing, aborting."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|newLeaseEnd
operator|!=
name|leaseEnd
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cluster node "
operator|+
name|key
operator|+
literal|" seems to be still active (lease end changed from "
operator|+
name|leaseEnd
operator|+
literal|" to "
operator|+
name|newLeaseEnd
operator|+
literal|", will not try to use it."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Error reading cluster node info for key "
operator|+
name|key
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Checks if the lease for this cluster node is still valid, otherwise      * throws a {@link DocumentStoreException}. Depending on the      * {@link LeaseCheckMode} this method will not throw the      * exception immediately when the lease expires. If the mode is set to      * {@link LeaseCheckMode#LENIENT}, then this method will give the lease      * update thread a last chance of 5 seconds to renew it. This allows the      * DocumentNodeStore to recover from an expired lease caused by a system      * put to sleep or a JVM in debug mode.      *      * @throws DocumentStoreException if the lease expired.      */
specifier|public
name|void
name|performLeaseCheck
parameter_list|()
throws|throws
name|DocumentStoreException
block|{
if|if
condition|(
name|leaseCheckMode
operator|==
name|LeaseCheckMode
operator|.
name|DISABLED
condition|)
block|{
comment|// if leaseCheckDisabled is set we never do the check, so return fast
return|return;
block|}
if|if
condition|(
name|leaseCheckFailed
condition|)
block|{
comment|// unsynchronized access to leaseCheckFailed is fine
comment|// since it only ever changes from false to true once
comment|// and should the current thread read it erroneously
comment|// as false here, it would further down find out that
comment|// the lease has indeed still expired and then
comment|// go into the synchronized.
comment|// (note that once a lease check failed it would not
comment|// be updated again, ever, as guaranteed by checking
comment|// for leaseCheckFailed in renewLease() )
throw|throw
name|leaseExpired
argument_list|(
name|LEASE_CHECK_FAILED_MSG
argument_list|,
literal|true
argument_list|)
throw|;
block|}
name|long
name|now
init|=
name|getCurrentTime
argument_list|()
decl_stmt|;
comment|// OAK-3238 put the barrier 1/3 of 60sec=20sec before the end
comment|// OAK-3398 keeps this the same but uses an explicit leaseFailureMargin for this
if|if
condition|(
operator|!
name|isLeaseExpired
argument_list|(
name|now
argument_list|)
condition|)
block|{
comment|// then all is good
return|return;
block|}
comment|// synchronized: we need to guard leaseCheckFailed in order to ensure
comment|//               that it is only set by 1 thread - thus handleLeaseFailure
comment|//               is guaranteed to be only called once
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|leaseCheckFailed
condition|)
block|{
comment|// someone else won and marked leaseCheckFailed - so we only log/throw
throw|throw
name|leaseExpired
argument_list|(
name|LEASE_CHECK_FAILED_MSG
argument_list|,
literal|true
argument_list|)
throw|;
block|}
comment|// only retry in lenient mode, fail immediately in strict mode
specifier|final
name|int
name|maxRetries
init|=
name|leaseCheckMode
operator|==
name|LeaseCheckMode
operator|.
name|STRICT
condition|?
literal|0
else|:
name|MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxRetries
condition|;
name|i
operator|++
control|)
block|{
name|now
operator|=
name|getCurrentTime
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isLeaseExpired
argument_list|(
name|now
argument_list|)
condition|)
block|{
comment|// if lease is OK here, then there was a race
comment|// between performLeaseCheck and renewLease()
comment|// where the winner was: renewLease().
comment|// so: luckily we can continue here
return|return;
block|}
comment|// OAK-3399 : in case of running into the leaseFailureMargin
comment|// (shortly, 20sec, before the lease times out), we're now doing
comment|// a short retry loop of 1sec sleeps (default 5x1sec=5sec),
comment|// to give this instance 'one last chance' before we have to
comment|// declare the lease as failed.
comment|// This sort of retry loop would allow situations such as
comment|// when running a single-node cluster and interrupting/pausing
comment|// the process temporarily: in this case when waking up, the
comment|// lease might momentarily be timed out, but the lease would
comment|// still be 'updateable' and that would happen pretty soon
comment|// after waking up. So in that case, doing these retry-sleeps
comment|// would help.
comment|// in most other cases where the local instance is not doing
comment|// lease updates due to 'GC-death' or 'lease-thread-crashed'
comment|// or the like, it would not help. But it would also not hurt
comment|// as the margin is 20sec and we're just reducing it by 5sec
comment|// (in the un-paused case)
try|try
block|{
name|long
name|difference
init|=
name|leaseEndTime
operator|-
name|now
decl_stmt|;
name|long
name|waitForMs
init|=
literal|1000
decl_stmt|;
name|String
name|detail
init|=
name|difference
operator|>=
literal|0
condition|?
name|String
operator|.
name|format
argument_list|(
literal|"lease within %dms of failing (%dms precisely)"
argument_list|,
name|leaseFailureMargin
argument_list|,
name|difference
argument_list|)
else|:
name|String
operator|.
name|format
argument_list|(
literal|"already past lease end (%dms precisely)"
argument_list|,
operator|-
literal|1
operator|*
name|difference
argument_list|)
decl_stmt|;
name|String
name|retries
init|=
name|String
operator|.
name|format
argument_list|(
literal|"waiting %dms to retry (up to another %d times...)"
argument_list|,
name|waitForMs
argument_list|,
name|maxRetries
operator|-
literal|1
operator|-
name|i
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"performLeaseCheck: "
operator|+
name|detail
operator|+
literal|" - "
operator|+
name|retries
argument_list|)
expr_stmt|;
comment|// directly use this to sleep on - to allow renewLease() to work
name|wait
argument_list|(
name|waitForMs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"performLeaseCheck: got interrupted - giving up: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|leaseCheckFailed
condition|)
block|{
comment|// someone else won and marked leaseCheckFailed - so we only log/throw
throw|throw
name|leaseExpired
argument_list|(
name|LEASE_CHECK_FAILED_MSG
argument_list|,
literal|true
argument_list|)
throw|;
block|}
name|leaseCheckFailed
operator|=
literal|true
expr_stmt|;
comment|// make sure only one thread 'wins', ie goes any further
block|}
specifier|final
name|String
name|errorMsg
init|=
name|LEASE_CHECK_FAILED_MSG
operator|+
literal|" (leaseEndTime: "
operator|+
name|leaseEndTime
operator|+
literal|", leaseTime: "
operator|+
name|leaseTime
operator|+
literal|", leaseFailureMargin: "
operator|+
name|leaseFailureMargin
operator|+
literal|", lease check end time (leaseEndTime-leaseFailureMargin): "
operator|+
operator|(
name|leaseEndTime
operator|-
name|leaseFailureMargin
operator|)
operator|+
literal|", now: "
operator|+
name|now
operator|+
literal|", remaining: "
operator|+
operator|(
operator|(
name|leaseEndTime
operator|-
name|leaseFailureMargin
operator|)
operator|-
name|now
operator|)
operator|+
literal|") Need to stop oak-store-document/DocumentNodeStoreService."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
name|handleLeaseFailure
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns {@code true} if the lease for this cluster node info should be      * considered expired given the current {@code time}. This method takes      * {@link #leaseFailureMargin} into account and will return {@code true}      * even before the passed {@code time} is beyond the {@link #leaseEndTime}.      *      * @param time the current time to check against the lease end.      * @return {@code true} if the lease is considered expired, {@code false}      *         otherwise.      */
specifier|private
name|boolean
name|isLeaseExpired
parameter_list|(
name|long
name|time
parameter_list|)
block|{
return|return
name|time
operator|>=
operator|(
name|leaseEndTime
operator|-
name|leaseFailureMargin
operator|)
return|;
block|}
specifier|private
name|void
name|handleLeaseFailure
parameter_list|(
specifier|final
name|String
name|errorMsg
parameter_list|)
block|{
comment|// OAK-3397 : unlike previously, when the lease check fails we should not
comment|// do a hard System exit here but rather stop the oak-store-document bundle
comment|// (or if that fails just deactivate DocumentNodeStore) - with the
comment|// goals to prevent this instance to continue to operate
comment|// give that a lease failure is a strong indicator of a faulty
comment|// instance - and to stop the background threads of DocumentNodeStore,
comment|// specifically the BackgroundLeaseUpdate and the BackgroundOperation.
comment|// actual stopping should be done in a separate thread, so:
if|if
condition|(
name|leaseFailureHandler
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Runnable
name|r
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|leaseFailureHandler
operator|!=
literal|null
condition|)
block|{
name|leaseFailureHandler
operator|.
name|handleLeaseFailure
argument_list|()
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
specifier|final
name|Thread
name|th
init|=
operator|new
name|Thread
argument_list|(
name|r
argument_list|,
literal|"LeaseFailureHandler-Thread"
argument_list|)
decl_stmt|;
name|th
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|th
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
throw|throw
name|leaseExpired
argument_list|(
name|errorMsg
argument_list|,
literal|false
argument_list|)
throw|;
block|}
comment|/**      * Renew the cluster id lease. This method needs to be called once in a while,      * to ensure the same cluster id is not re-used by a different instance.      * The lease is only renewed after 'leaseUpdateInterval' millis      * since last lease update - default being every 10 sec (this used to be 30sec).      *<p>      * This method will not fail immediately with a DocumentStoreException if      * the lease expired. It will still try to renew the lease and only fail if      * {@link #performLeaseCheck()} decided the lease expired or another cluster      * node initiated recover for this node.      *      * @return {@code true} if the lease was renewed; {@code false} otherwise.      * @throws DocumentStoreException if the operation failed or the lease      *          expired.      */
specifier|public
name|boolean
name|renewLease
parameter_list|()
throws|throws
name|DocumentStoreException
block|{
name|long
name|now
init|=
name|getCurrentTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"renewLease - leaseEndTime: "
operator|+
name|leaseEndTime
operator|+
literal|", leaseTime: "
operator|+
name|leaseTime
operator|+
literal|", leaseUpdateInterval: "
operator|+
name|leaseUpdateInterval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|now
operator|<
name|leaseEndTime
operator|-
name|leaseTime
operator|+
name|leaseUpdateInterval
condition|)
block|{
comment|// no need to renew the lease - it is still within 'leaseUpdateInterval'
return|return
literal|false
return|;
block|}
comment|// lease requires renewal
name|long
name|updatedLeaseEndTime
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// this is synchronized since access to leaseCheckFailed and leaseEndTime
comment|// are both normally synchronized to propagate values between renewLease()
comment|// and performLeaseCheck().
comment|// (there are unsynchronized accesses to both of these as well - however
comment|// they are both double-checked - and with both reading a stale value is thus OK)
if|if
condition|(
name|leaseCheckFailed
condition|)
block|{
comment|// prevent lease renewal after it failed
throw|throw
name|leaseExpired
argument_list|(
name|LEASE_CHECK_FAILED_MSG
argument_list|,
literal|true
argument_list|)
throw|;
block|}
comment|// synchronized could have delayed the 'now', so
comment|// set it again..
name|now
operator|=
name|getCurrentTime
argument_list|()
expr_stmt|;
name|updatedLeaseEndTime
operator|=
name|now
operator|+
name|leaseTime
expr_stmt|;
block|}
if|if
condition|(
name|leaseCheckMode
operator|==
name|LeaseCheckMode
operator|.
name|STRICT
condition|)
block|{
comment|// check whether the lease is still valid and can be renewed
if|if
condition|(
name|isLeaseExpired
argument_list|(
name|now
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|leaseCheckFailed
condition|)
block|{
comment|// some other thread already noticed and calls failure handler
throw|throw
name|leaseExpired
argument_list|(
name|LEASE_CHECK_FAILED_MSG
argument_list|,
literal|true
argument_list|)
throw|;
block|}
comment|// current thread calls failure handler
comment|// outside synchronized block
name|leaseCheckFailed
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|String
name|errorMsg
init|=
name|LEASE_CHECK_FAILED_MSG
operator|+
literal|" (mode: "
operator|+
name|leaseCheckMode
operator|.
name|name
argument_list|()
operator|+
literal|",leaseEndTime: "
operator|+
name|leaseEndTime
operator|+
literal|", leaseTime: "
operator|+
name|leaseTime
operator|+
literal|", leaseFailureMargin: "
operator|+
name|leaseFailureMargin
operator|+
literal|", lease check end time (leaseEndTime-leaseFailureMargin): "
operator|+
operator|(
name|leaseEndTime
operator|-
name|leaseFailureMargin
operator|)
operator|+
literal|", now: "
operator|+
name|now
operator|+
literal|", remaining: "
operator|+
operator|(
operator|(
name|leaseEndTime
operator|-
name|leaseFailureMargin
operator|)
operator|-
name|now
operator|)
operator|+
literal|") Need to stop oak-store-document/DocumentNodeStoreService."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
name|handleLeaseFailure
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
comment|// should never be reached: handleLeaseFailure throws a DocumentStoreException
return|return
literal|false
return|;
block|}
block|}
name|UpdateOp
name|update
init|=
operator|new
name|UpdateOp
argument_list|(
literal|""
operator|+
name|id
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|update
operator|.
name|set
argument_list|(
name|LEASE_END_KEY
argument_list|,
name|updatedLeaseEndTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|leaseCheckMode
operator|!=
name|LeaseCheckMode
operator|.
name|DISABLED
condition|)
block|{
comment|// if leaseCheckDisabled, then we just update the lease without
comment|// checking
comment|// OAK-3398:
comment|// if we renewed the lease ever with this instance/ClusterNodeInfo
comment|// (which is the normal case.. except for startup),
comment|// then we can now make an assertion that the lease is unchanged
comment|// and the incremental update must only succeed if no-one else
comment|// did a recover/inactivation in the meantime
comment|// make three assertions: the leaseEnd must match ..
name|update
operator|.
name|equals
argument_list|(
name|LEASE_END_KEY
argument_list|,
literal|null
argument_list|,
name|previousLeaseEndTime
argument_list|)
expr_stmt|;
comment|// plus it must still be active ..
name|update
operator|.
name|equals
argument_list|(
name|STATE
argument_list|,
literal|null
argument_list|,
name|ACTIVE
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
comment|// plus it must not have a recovery lock on it
name|update
operator|.
name|notEquals
argument_list|(
name|REV_RECOVERY_LOCK
argument_list|,
name|ACQUIRED
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
comment|// @TODO: to make it 100% failure proof we could introduce
comment|// yet another field to clusterNodes: a runtimeId that we
comment|// create (UUID) at startup each time - and against that
comment|// we could also check here - but that goes a bit far IMO
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renewing lease for cluster id "
operator|+
name|id
operator|+
literal|" with UpdateOp "
operator|+
name|update
argument_list|)
expr_stmt|;
block|}
name|Stopwatch
name|sw
init|=
name|Stopwatch
operator|.
name|createStarted
argument_list|()
decl_stmt|;
name|DocumentStoreException
name|dse
decl_stmt|;
name|Object
name|result
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ClusterNodeInfoDocument
name|doc
init|=
name|store
operator|.
name|findAndUpdate
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
name|update
argument_list|)
decl_stmt|;
name|result
operator|=
name|doc
expr_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
comment|// should not occur when leaseCheckDisabled
comment|// OAK-3398 : someone else either started recovering or is already through with that.
comment|// in both cases the local instance lost the lease-update-game - and hence
comment|// should behave and must consider itself as 'lease failed'
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|leaseCheckFailed
condition|)
block|{
comment|// somehow the instance figured out otherwise that the
comment|// lease check failed - so we don't have to too - so we just log/throw
throw|throw
name|leaseExpired
argument_list|(
name|LEASE_CHECK_FAILED_MSG
argument_list|,
literal|true
argument_list|)
throw|;
block|}
name|leaseCheckFailed
operator|=
literal|true
expr_stmt|;
comment|// make sure only one thread 'wins', ie goes any further
block|}
name|String
name|errorMsg
init|=
name|LEASE_CHECK_FAILED_MSG
operator|+
literal|" (Could not update lease anymore, someone else in the cluster "
operator|+
literal|"must have noticed this instance' slowness already. "
operator|+
literal|"Going to invoke leaseFailureHandler!)"
decl_stmt|;
comment|// try to add more diagnostics
try|try
block|{
name|ClusterNodeInfoDocument
name|current
init|=
name|store
operator|.
name|find
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
literal|""
operator|+
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|!=
literal|null
condition|)
block|{
name|Object
name|leaseEnd
init|=
name|current
operator|.
name|get
argument_list|(
name|LEASE_END_KEY
argument_list|)
decl_stmt|;
name|Object
name|recoveryLock
init|=
name|current
operator|.
name|get
argument_list|(
name|REV_RECOVERY_LOCK
argument_list|)
decl_stmt|;
name|Object
name|recoveryBy
init|=
name|current
operator|.
name|get
argument_list|(
name|REV_RECOVERY_BY
argument_list|)
decl_stmt|;
name|Object
name|cnState
init|=
name|current
operator|.
name|get
argument_list|(
name|STATE
argument_list|)
decl_stmt|;
name|errorMsg
operator|+=
literal|" (leaseEnd: "
operator|+
name|leaseEnd
operator|+
literal|" (expected: "
operator|+
name|leaseEndTime
operator|+
literal|")"
operator|+
literal|", (state: "
operator|+
name|cnState
operator|+
literal|" (expected: "
operator|+
name|ACTIVE
operator|.
name|name
argument_list|()
operator|+
literal|")"
operator|+
literal|", recoveryLock: "
operator|+
name|recoveryLock
operator|+
literal|", recoveryBy: "
operator|+
name|recoveryBy
operator|+
literal|")"
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"trying to read ClusterNodeInfo for cluster id "
operator|+
name|id
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
name|handleLeaseFailure
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
comment|// should never be reached: handleLeaseFailure throws a DocumentStoreException
return|return
literal|false
return|;
block|}
name|leaseEndTime
operator|=
name|updatedLeaseEndTime
expr_stmt|;
name|previousLeaseEndTime
operator|=
name|leaseEndTime
expr_stmt|;
comment|// store previousLeaseEndTime for reference for next time
name|String
name|mode
init|=
operator|(
name|String
operator|)
name|doc
operator|.
name|get
argument_list|(
name|READ_WRITE_MODE_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|null
operator|&&
operator|!
name|mode
operator|.
name|equals
argument_list|(
name|readWriteMode
argument_list|)
condition|)
block|{
name|readWriteMode
operator|=
name|mode
expr_stmt|;
name|store
operator|.
name|setReadWriteMode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|e
parameter_list|)
block|{
name|dse
operator|=
name|e
expr_stmt|;
name|result
operator|=
name|e
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|sw
operator|.
name|stop
argument_list|()
expr_stmt|;
name|String
name|msg
init|=
literal|"Lease renewal for cluster id {} took {}, resulted in: {}"
decl_stmt|;
if|if
condition|(
name|sw
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
operator|>
literal|10
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|,
name|id
argument_list|,
name|sw
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sw
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
operator|>
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|msg
argument_list|,
name|id
argument_list|,
name|sw
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|,
name|id
argument_list|,
name|sw
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if we get here, the update failed with an exception, try to read the
comment|// current cluster node info document and update leaseEndTime&
comment|// previousLeaseEndTime accordingly until leaseEndTime is reached
while|while
condition|(
name|getCurrentTime
argument_list|()
operator|<
name|updatedLeaseEndTime
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|leaseCheckFailed
condition|)
block|{
comment|// no need to read from store, lease check already failed
break|break;
block|}
block|}
name|long
name|t1
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|ClusterNodeInfoDocument
name|doc
decl_stmt|;
try|try
block|{
name|doc
operator|=
name|store
operator|.
name|find
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Reading ClusterNodeInfoDocument for id "
operator|+
name|id
operator|+
literal|" failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// do not retry more than once a second
try|try
block|{
name|clock
operator|.
name|waitUntil
argument_list|(
name|t1
operator|+
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// ignore
block|}
continue|continue;
block|}
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|doc
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ClusterNodeInfoDocument for id {} is not active "
operator|+
literal|"anymore. {}"
argument_list|,
name|id
argument_list|,
name|doc
argument_list|)
expr_stmt|;
comment|// break here and let the next lease update attempt fail
break|break;
block|}
elseif|else
if|if
condition|(
name|doc
operator|.
name|getLeaseEndTime
argument_list|()
operator|==
name|previousLeaseEndTime
operator|||
name|doc
operator|.
name|getLeaseEndTime
argument_list|()
operator|==
name|updatedLeaseEndTime
condition|)
block|{
comment|// set lease end times to current values
name|previousLeaseEndTime
operator|=
name|doc
operator|.
name|getLeaseEndTime
argument_list|()
expr_stmt|;
name|leaseEndTime
operator|=
name|doc
operator|.
name|getLeaseEndTime
argument_list|()
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// leaseEndTime is neither the previous nor the new value
comment|// another cluster node must have updated the leaseEndTime
comment|// break here and let the next lease update attempt fail
break|break;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ClusterNodeInfoDocument for id {} does not exist anymore"
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
throw|throw
name|dse
throw|;
block|}
comment|/**      * Update the cluster node info.      *       * @param info the map of changes      */
specifier|public
name|void
name|setInfo
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|info
parameter_list|)
block|{
comment|// synchronized, because renewLease is also synchronized
synchronized|synchronized
init|(
name|this
init|)
block|{
name|UpdateOp
name|update
init|=
operator|new
name|UpdateOp
argument_list|(
literal|""
operator|+
name|id
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|info
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|update
operator|.
name|set
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|store
operator|.
name|findAndUpdate
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
name|update
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** for testing purpose only, not to be changed at runtime! */
name|void
name|setLeaseTime
parameter_list|(
name|long
name|leaseTime
parameter_list|)
block|{
name|this
operator|.
name|leaseTime
operator|=
name|leaseTime
expr_stmt|;
block|}
comment|/** for testing purpose only, not to be changed at runtime! */
name|void
name|setLeaseUpdateInterval
parameter_list|(
name|long
name|leaseUpdateInterval
parameter_list|)
block|{
name|this
operator|.
name|leaseUpdateInterval
operator|=
name|leaseUpdateInterval
expr_stmt|;
block|}
specifier|public
name|long
name|getLeaseTime
parameter_list|()
block|{
return|return
name|leaseTime
return|;
block|}
specifier|public
name|long
name|getLeaseEndTime
parameter_list|()
block|{
return|return
name|leaseEndTime
return|;
block|}
specifier|public
name|void
name|setLeaseFailureHandler
parameter_list|(
name|LeaseFailureHandler
name|leaseFailureHandler
parameter_list|)
block|{
name|this
operator|.
name|leaseFailureHandler
operator|=
name|leaseFailureHandler
expr_stmt|;
block|}
specifier|public
name|void
name|dispose
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|leaseCheckFailed
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"dispose: lease check failed, thus not marking instance as cleanly shut down."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|UpdateOp
name|update
init|=
operator|new
name|UpdateOp
argument_list|(
literal|""
operator|+
name|id
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|update
operator|.
name|set
argument_list|(
name|LEASE_END_KEY
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|update
operator|.
name|set
argument_list|(
name|STATE
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|store
operator|.
name|createOrUpdate
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
name|update
argument_list|)
expr_stmt|;
name|state
operator|=
name|NONE
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"id: "
operator|+
name|id
operator|+
literal|",\n"
operator|+
literal|"startTime: "
operator|+
name|startTime
operator|+
literal|",\n"
operator|+
literal|"machineId: "
operator|+
name|machineId
operator|+
literal|",\n"
operator|+
literal|"instanceId: "
operator|+
name|instanceId
operator|+
literal|",\n"
operator|+
literal|"pid: "
operator|+
name|PROCESS_ID
operator|+
literal|",\n"
operator|+
literal|"uuid: "
operator|+
name|uuid
operator|+
literal|",\n"
operator|+
literal|"readWriteMode: "
operator|+
name|readWriteMode
operator|+
literal|",\n"
operator|+
literal|"leaseCheckMode: "
operator|+
name|leaseCheckMode
operator|.
name|name
argument_list|()
operator|+
literal|",\n"
operator|+
literal|"state: "
operator|+
name|state
operator|+
literal|",\n"
operator|+
literal|"oakVersion: "
operator|+
name|OAK_VERSION
operator|+
literal|",\n"
operator|+
literal|"formatVersion: "
operator|+
name|DocumentNodeStore
operator|.
name|VERSION
return|;
block|}
comment|/**      * Specify a custom clock to be used for determining current time.      *      *<b>Only Used For Testing</b>      */
specifier|static
name|void
name|setClock
parameter_list|(
name|Clock
name|c
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|clock
operator|=
name|c
expr_stmt|;
block|}
comment|/**      * Resets the clock to the default      */
specifier|static
name|void
name|resetClockToDefault
parameter_list|()
block|{
name|clock
operator|=
name|Clock
operator|.
name|SIMPLE
expr_stmt|;
block|}
specifier|private
specifier|static
name|long
name|getProcessId
parameter_list|()
block|{
try|try
block|{
name|String
name|name
init|=
name|ManagementFactory
operator|.
name|getRuntimeMXBean
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|indexOf
argument_list|(
literal|'@'
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not get process id"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/*      * Allow external override of hardware address. The special value "(none)"      * indicates that a situation where no hardware address is available is to      * be simulated.      */
specifier|private
specifier|static
name|String
name|getHWAFromSystemProperty
parameter_list|()
block|{
name|String
name|pname
init|=
name|ClusterNodeInfo
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".HWADDRESS"
decl_stmt|;
name|String
name|hwa
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|pname
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
literal|""
operator|.
name|equals
argument_list|(
name|hwa
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"obtaining hardware address from system variable "
operator|+
name|pname
operator|+
literal|": "
operator|+
name|hwa
argument_list|)
expr_stmt|;
block|}
return|return
name|hwa
return|;
block|}
comment|/**      * Calculate the unique machine id. This usually is the lowest MAC address      * if available. As an alternative, a randomly generated UUID is used.      *      * @return the unique id      */
specifier|private
specifier|static
name|String
name|getHardwareMachineId
parameter_list|()
block|{
name|Exception
name|exception
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|macAddresses
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|likelyVirtualMacAddresses
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|otherAddresses
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|hwaFromSysProp
init|=
name|getHWAFromSystemProperty
argument_list|()
decl_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|hwaFromSysProp
argument_list|)
condition|)
block|{
name|Enumeration
argument_list|<
name|NetworkInterface
argument_list|>
name|e
init|=
name|NetworkInterface
operator|.
name|getNetworkInterfaces
argument_list|()
decl_stmt|;
while|while
condition|(
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|NetworkInterface
name|ni
init|=
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|hwa
init|=
name|ni
operator|.
name|getHardwareAddress
argument_list|()
decl_stmt|;
comment|// empty addresses have been seen on loopback devices
if|if
condition|(
name|hwa
operator|!=
literal|null
operator|&&
name|hwa
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|String
name|str
init|=
name|StringUtils
operator|.
name|convertBytesToHex
argument_list|(
name|hwa
argument_list|)
decl_stmt|;
if|if
condition|(
name|hwa
operator|.
name|length
operator|==
literal|6
condition|)
block|{
comment|// likely a MAC address
name|String
name|displayName
init|=
name|ni
operator|.
name|getDisplayName
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
decl_stmt|;
comment|// de-prioritize addresses that are likely to be virtual (see OAK-3885)
name|boolean
name|looksVirtual
init|=
name|displayName
operator|.
name|indexOf
argument_list|(
literal|"virtual"
argument_list|)
operator|>=
literal|0
operator|||
name|displayName
operator|.
name|indexOf
argument_list|(
literal|"vpn"
argument_list|)
operator|>=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|looksVirtual
condition|)
block|{
name|macAddresses
operator|.
name|add
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|likelyVirtualMacAddresses
operator|.
name|add
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|otherAddresses
operator|.
name|add
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e2
parameter_list|)
block|{
name|exception
operator|=
name|e2
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
literal|"(none)"
operator|.
name|equals
argument_list|(
name|hwaFromSysProp
argument_list|)
condition|)
block|{
if|if
condition|(
name|hwaFromSysProp
operator|.
name|length
argument_list|()
operator|==
literal|12
condition|)
block|{
comment|// assume 12 hex digits are a mac address
name|macAddresses
operator|.
name|add
argument_list|(
name|hwaFromSysProp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|otherAddresses
operator|.
name|add
argument_list|(
name|hwaFromSysProp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getMachineId(): discovered addresses: {} {} {}"
argument_list|,
name|macAddresses
argument_list|,
name|likelyVirtualMacAddresses
argument_list|,
name|otherAddresses
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|macAddresses
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// use the lowest MAC value, such that if the order changes,
comment|// the same one is used
name|Collections
operator|.
name|sort
argument_list|(
name|macAddresses
argument_list|)
expr_stmt|;
return|return
literal|"mac:"
operator|+
name|macAddresses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|likelyVirtualMacAddresses
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|likelyVirtualMacAddresses
argument_list|)
expr_stmt|;
return|return
literal|"mac:"
operator|+
name|likelyVirtualMacAddresses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|otherAddresses
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// try the lowest "other" address
name|Collections
operator|.
name|sort
argument_list|(
name|otherAddresses
argument_list|)
expr_stmt|;
return|return
literal|"hwa:"
operator|+
name|otherAddresses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|exception
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|exception
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error getting the machine id; using a UUID"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
return|return
name|RANDOM_PREFIX
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|long
name|getCurrentTime
parameter_list|()
block|{
return|return
name|clock
operator|.
name|getTime
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|DocumentStoreException
name|leaseExpired
parameter_list|(
name|String
name|msg
parameter_list|,
name|boolean
name|log
parameter_list|)
block|{
if|if
condition|(
name|log
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|DocumentStoreException
argument_list|(
name|msg
argument_list|)
return|;
block|}
block|}
end_class

end_unit

