begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|cache
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheLoader
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheStats
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LoadingCache
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|RemovalCause
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|Weigher
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListenableFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|UncheckedExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A scan resistant cache. It is meant to cache objects that are relatively  * costly to acquire, for example file content.  *<p>  * This implementation is multi-threading safe and supports concurrent access.  * Null keys or null values are not allowed. The map fill factor is at most 75%.  *<p>  * Each entry is assigned a distinct memory size, and the cache will try to use  * at most the specified amount of memory. The memory unit is not relevant,  * however it is suggested to use bytes as the unit.  *<p>  * This class implements an approximation of the the LIRS replacement algorithm  * invented by Xiaodong Zhang and Song Jiang as described in  * http://www.cse.ohio-state.edu/~zhang/lirs-sigmetrics-02.html with a few  * smaller changes: An additional queue for non-resident entries is used, to  * prevent unbound memory usage. The maximum size of this queue is at most the  * size of the rest of the stack. About 6.25% of the mapped entries are cold.  *<p>  * Internally, the cache is split into a number of segments, and each segment is  * an individual LIRS cache.  *<p>  * Accessed entries are only moved to the top of the stack if at least a number  * of other entries have been moved to the front (1% by default). Write access  * and moving entries to the top of the stack is synchronized per segment.  *  * @author Thomas Mueller  * @param<K> the key type  * @param<V> the value type  */
end_comment

begin_class
specifier|public
class|class
name|CacheLIRS
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|LoadingCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CacheLIRS
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
name|CURRENTLY_LOADING
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|AtomicInteger
name|NEXT_CACHE_ID
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|PUT_HOT
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"oak.cacheLIRS.putHot"
argument_list|,
literal|"true"
argument_list|)
argument_list|)
decl_stmt|;
comment|/**      * Listener for items that are evicted from the cache. The listener      * is called for both, resident and non-resident items. In the      * latter case the passed value is {@code null}.      * @param<K>  type of the key      * @param<V>  type of the value      */
specifier|public
interface|interface
name|EvictionCallback
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**          * Indicates eviction of an item.          *<p>          *<em>Note:</em> It is not safe to call any of {@code CacheLIRS}'s          * method from withing this callback. Any such call might result in          * undefined behaviour and Java level deadlocks.          *<p>          * The method may be called twice for the same key (first if the entry          * is resident, and later if the entry is non-resident).          *           * @param key the evicted item's key          * @param value the evicted item's value or {@code null} if non-resident          * @param cause the cause of the eviction          */
name|void
name|evicted
parameter_list|(
annotation|@
name|Nonnull
name|K
name|key
parameter_list|,
annotation|@
name|Nullable
name|V
name|value
parameter_list|,
annotation|@
name|Nonnull
name|RemovalCause
name|cause
parameter_list|)
function_decl|;
block|}
specifier|final
name|int
name|cacheId
init|=
name|NEXT_CACHE_ID
operator|.
name|getAndIncrement
argument_list|()
decl_stmt|;
comment|/**      * The maximum memory this cache should use.      */
specifier|private
name|long
name|maxMemory
decl_stmt|;
comment|/**      * The average memory used by one entry.      */
specifier|private
name|int
name|averageMemory
decl_stmt|;
specifier|private
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
decl_stmt|;
specifier|private
specifier|final
name|int
name|segmentCount
decl_stmt|;
specifier|private
specifier|final
name|int
name|segmentShift
decl_stmt|;
specifier|private
specifier|final
name|int
name|segmentMask
decl_stmt|;
specifier|private
specifier|final
name|int
name|stackMoveDistance
decl_stmt|;
specifier|private
specifier|final
name|Weigher
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
decl_stmt|;
specifier|private
specifier|final
name|CacheLoader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loader
decl_stmt|;
comment|/**      * The eviction listener of this cache or {@code null} if none.      */
specifier|private
specifier|final
name|EvictionCallback
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|evicted
decl_stmt|;
comment|/**      * A concurrent hash map of keys where loading is in progress. Key: the      * cache key. Value: a synchronization object. The threads that wait for the      * value to be loaded need to wait on the synchronization object. The      * loading thread will notify all waiting threads once loading is done.      */
specifier|final
name|ConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|AtomicBoolean
argument_list|>
name|loadingInProgress
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|AtomicBoolean
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Create a new cache with the given number of entries, and the default      * settings (an average size of 1 per entry, 16 segments, and stack move      * distance equals to the maximum number of entries divided by 100).      *      * @param maxEntries the maximum number of entries      */
specifier|public
name|CacheLIRS
parameter_list|(
name|int
name|maxEntries
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|maxEntries
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|maxEntries
operator|/
literal|100
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new cache with the given memory size.      *      * @param maxMemory the maximum memory to use (1 or larger)      * @param averageMemory the average memory (1 or larger)      * @param segmentCount the number of cache segments (must be a power of 2)      * @param stackMoveDistance how many other item are to be moved to the top      *        of the stack before the current item is moved      * @param  evicted the eviction listener of this segment or {@code null} if none.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|CacheLIRS
parameter_list|(
name|Weigher
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
parameter_list|,
name|long
name|maxMemory
parameter_list|,
name|int
name|averageMemory
parameter_list|,
name|int
name|segmentCount
parameter_list|,
name|int
name|stackMoveDistance
parameter_list|,
specifier|final
name|CacheLoader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|,
name|EvictionCallback
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|evicted
parameter_list|,
name|String
name|module
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Init #{}, module={}, maxMemory={}, segmentCount={}, stackMoveDistance={}"
argument_list|,
name|cacheId
argument_list|,
name|module
argument_list|,
name|maxMemory
argument_list|,
name|segmentCount
argument_list|,
name|segmentCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|weigher
operator|=
name|weigher
expr_stmt|;
name|setMaxMemory
argument_list|(
name|maxMemory
argument_list|)
expr_stmt|;
name|setAverageMemory
argument_list|(
name|averageMemory
argument_list|)
expr_stmt|;
if|if
condition|(
name|Integer
operator|.
name|bitCount
argument_list|(
name|segmentCount
argument_list|)
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The segment count must be a power of 2, is "
operator|+
name|segmentCount
argument_list|)
throw|;
block|}
name|this
operator|.
name|segmentCount
operator|=
name|segmentCount
expr_stmt|;
name|this
operator|.
name|segmentMask
operator|=
name|segmentCount
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|stackMoveDistance
operator|=
name|stackMoveDistance
expr_stmt|;
name|segments
operator|=
operator|new
name|Segment
index|[
name|segmentCount
index|]
expr_stmt|;
name|this
operator|.
name|evicted
operator|=
name|evicted
expr_stmt|;
name|invalidateAll
argument_list|()
expr_stmt|;
name|this
operator|.
name|segmentShift
operator|=
name|Integer
operator|.
name|numberOfTrailingZeros
argument_list|(
name|segments
index|[
literal|0
index|]
operator|.
name|entries
operator|.
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|loader
operator|=
name|loader
expr_stmt|;
block|}
comment|/**      * Remove all entries.      */
annotation|@
name|Override
specifier|public
name|void
name|invalidateAll
parameter_list|()
block|{
name|long
name|max
init|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|maxMemory
operator|/
name|segmentCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segmentCount
condition|;
name|i
operator|++
control|)
block|{
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|old
init|=
name|segments
index|[
name|i
index|]
decl_stmt|;
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
init|=
operator|new
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|max
argument_list|,
name|averageMemory
argument_list|,
name|stackMoveDistance
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|hitCount
operator|=
name|old
operator|.
name|hitCount
expr_stmt|;
name|s
operator|.
name|missCount
operator|=
name|old
operator|.
name|missCount
expr_stmt|;
name|s
operator|.
name|loadSuccessCount
operator|=
name|old
operator|.
name|loadSuccessCount
expr_stmt|;
name|s
operator|.
name|loadExceptionCount
operator|=
name|old
operator|.
name|loadExceptionCount
expr_stmt|;
name|s
operator|.
name|totalLoadTime
operator|=
name|old
operator|.
name|totalLoadTime
expr_stmt|;
name|s
operator|.
name|evictionCount
operator|=
name|old
operator|.
name|evictionCount
expr_stmt|;
block|}
name|setSegment
argument_list|(
name|i
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setSegment
parameter_list|(
name|int
name|index
parameter_list|,
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
parameter_list|)
block|{
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|old
init|=
name|segments
index|[
name|index
index|]
decl_stmt|;
name|segments
index|[
name|index
index|]
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|evicted
operator|!=
literal|null
operator|&&
name|old
operator|!=
literal|null
operator|&&
name|old
operator|!=
name|s
condition|)
block|{
name|old
operator|.
name|evictedAll
argument_list|(
name|RemovalCause
operator|.
name|EXPLICIT
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|evicted
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|RemovalCause
name|cause
parameter_list|)
block|{
if|if
condition|(
name|evicted
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|K
name|key
init|=
name|entry
operator|.
name|key
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|evicted
operator|.
name|evicted
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|value
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Check whether there is a resident entry for the given key. This      * method does not adjust the internal state of the cache.      *      * @param key the key (may not be null)      * @return true if there is a resident entry      */
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|containsKey
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**      * Get the value for the given key if the entry is cached. This method does      * not modify the internal state.      *      * @param key the key (may not be null)      * @return the value, or null if there is no resident entry      */
specifier|public
name|V
name|peek
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|find
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
return|return
name|e
operator|==
literal|null
condition|?
literal|null
else|:
name|e
operator|.
name|value
return|;
block|}
comment|/**      * Add an entry to the cache. This method is an explicit memory size      * (weight), and not using the weigher even if configured. The entry may or      * may not exist in the cache yet. This method will usually mark unknown      * entries as cold and known entries as hot.      *       * @param key the key (may not be null)      * @param value the value (may not be null)      * @param memory the memory used for the given entry      * @return the old value, or null if there was no resident entry      */
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|memory
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|memory
argument_list|)
return|;
block|}
comment|/**      * Add an entry to the cache. If a weigher is specified, it is used,      * otherwise the average memory size is used.      *       * @param key the key (may not be null)      * @param value the value (may not be null)      */
annotation|@
name|Override
specifier|public
name|void
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|sizeOf
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|,
name|Callable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|valueLoader
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|valueLoader
argument_list|)
return|;
block|}
comment|/**      * Get the value, loading it if needed.      *<p>      * If there is an exception loading, an UncheckedExecutionException is      * thrown.      *      * @param key the key      * @return the value      * @throws UncheckedExecutionException      */
annotation|@
name|Override
specifier|public
name|V
name|getUnchecked
parameter_list|(
name|K
name|key
parameter_list|)
block|{
try|try
block|{
return|return
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UncheckedExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Get the value, loading it if needed.      *      * @param key the key      * @return the value      * @throws ExecutionException      */
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|loader
argument_list|)
return|;
block|}
comment|/**      * Re-load the value for the given key.      *<p>      * If there is an exception while loading, it is logged and ignored. This      * method calls CacheLoader.reload, but synchronously replaces the old      * value.      *      * @param key the key      */
annotation|@
name|Override
specifier|public
name|void
name|refresh
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
try|try
block|{
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|refresh
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|loader
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not refresh value for key "
operator|+
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|sizeOf
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|,
name|sizeOf
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|)
argument_list|)
return|;
block|}
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
specifier|protected
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|sizeOf
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Get the value for the given key if the entry is cached. This method      * adjusts the internal state of the cache sometimes, to ensure commonly      * used entries stay in the cache.      *      * @param key the key (may not be null)      * @return the value, or null if there is no resident entry      */
annotation|@
name|Override
annotation|@
name|Nullable
specifier|public
name|V
name|getIfPresent
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**      * Get the size of the given value. The default implementation returns the      * average memory as configured for this cache.      *      * @param key the key      * @param value the value      * @return the size      */
specifier|protected
name|int
name|sizeOf
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|weigher
operator|==
literal|null
condition|)
block|{
return|return
name|averageMemory
return|;
block|}
return|return
name|weigher
operator|.
name|weigh
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**      * Remove an entry. Both resident and non-resident entries can be      * removed.      *      * @param key the key (may not be null)      */
annotation|@
name|Override
specifier|public
name|void
name|invalidate
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|invalidate
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|RemovalCause
operator|.
name|EXPLICIT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove an entry. Both resident and non-resident entries can be      * removed.      *      * @param key the key (may not be null)      * @return the old value or null      */
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|void
name|invalidateAll
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|keys
parameter_list|)
block|{
for|for
control|(
name|K
name|k
range|:
operator|(
name|Iterable
argument_list|<
name|K
argument_list|>
operator|)
name|keys
control|)
block|{
name|invalidate
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get the memory used for the given key.      *      * @param key the key (may not be null)      * @return the memory, or 0 if there is no resident entry      */
specifier|public
name|int
name|getMemory
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|getMemory
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
specifier|private
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getSegment
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
name|int
name|segmentIndex
init|=
operator|(
name|hash
operator|>>>
name|segmentShift
operator|)
operator|&
name|segmentMask
decl_stmt|;
return|return
name|segments
index|[
name|segmentIndex
index|]
return|;
block|}
comment|/**      * Get the hash code for the given key. The hash code is      * further enhanced to spread the values more evenly.      *      * @param key the key      * @return the hash code      */
specifier|static
name|int
name|getHash
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|key
operator|.
name|hashCode
argument_list|()
decl_stmt|;
comment|// a supplemental secondary hash function
comment|// to protect against hash codes that don't differ much
name|hash
operator|=
operator|(
operator|(
name|hash
operator|>>>
literal|16
operator|)
operator|^
name|hash
operator|)
operator|*
literal|0x45d9f3b
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
name|hash
operator|>>>
literal|16
operator|)
operator|^
name|hash
operator|)
operator|*
literal|0x45d9f3b
expr_stmt|;
name|hash
operator|=
operator|(
name|hash
operator|>>>
literal|16
operator|)
operator|^
name|hash
expr_stmt|;
return|return
name|hash
return|;
block|}
comment|/**      * Get the currently used memory.      *      * @return the used memory      */
specifier|public
name|long
name|getUsedMemory
parameter_list|()
block|{
name|long
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|x
operator|+=
name|s
operator|.
name|usedMemory
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/**      * Set the maximum memory this cache should use. This will not      * immediately cause entries to get removed however; it will only change      * the limit. To resize the internal array, call the clear method.      *      * @param maxMemory the maximum size (1 or larger)      */
specifier|public
name|void
name|setMaxMemory
parameter_list|(
name|long
name|maxMemory
parameter_list|)
block|{
if|if
condition|(
name|maxMemory
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Max memory must not be negative"
argument_list|)
throw|;
block|}
name|this
operator|.
name|maxMemory
operator|=
name|maxMemory
expr_stmt|;
if|if
condition|(
name|segments
operator|!=
literal|null
condition|)
block|{
name|long
name|max
init|=
literal|1
operator|+
name|maxMemory
operator|/
name|segments
operator|.
name|length
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|s
operator|.
name|setMaxMemory
argument_list|(
name|max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Set the average memory used per entry. It is used to calculate the      * length of the internal array.      *      * @param averageMemory the average memory used (1 or larger)      */
specifier|public
name|void
name|setAverageMemory
parameter_list|(
name|int
name|averageMemory
parameter_list|)
block|{
if|if
condition|(
name|averageMemory
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Average memory must be larger than 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|averageMemory
operator|=
name|averageMemory
expr_stmt|;
if|if
condition|(
name|segments
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|s
operator|.
name|setAverageMemory
argument_list|(
name|averageMemory
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Get the average memory used per entry.      *      * @return the average memory      */
specifier|public
name|int
name|getAverageMemory
parameter_list|()
block|{
return|return
name|averageMemory
return|;
block|}
comment|/**      * Get the maximum memory to use.      *      * @return the maximum memory      */
specifier|public
name|long
name|getMaxMemory
parameter_list|()
block|{
return|return
name|maxMemory
return|;
block|}
comment|/**      * Get the entry set for all resident entries.      *      * @return the entry set      */
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|K
name|k
range|:
name|keySet
argument_list|()
control|)
block|{
name|V
name|v
init|=
name|peek
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
operator|.
name|entrySet
argument_list|()
return|;
block|}
specifier|protected
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|V
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|V
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|K
name|k
range|:
name|keySet
argument_list|()
control|)
block|{
name|V
name|v
init|=
name|peek
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
for|for
control|(
name|K
name|k
range|:
name|s
operator|.
name|keySet
argument_list|()
control|)
block|{
name|V
name|v
init|=
name|peek
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|null
operator|&&
name|v
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Get the set of keys for resident entries.      *      * @return the set of keys      */
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|HashSet
argument_list|<
name|K
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|K
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|s
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
comment|/**      * Get the number of non-resident entries in the cache.      *      * @return the number of non-resident entries      */
specifier|public
name|int
name|sizeNonResident
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|x
operator|+=
name|s
operator|.
name|queue2Size
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/**      * Get the length of the internal map array.      *      * @return the size of the array      */
specifier|public
name|int
name|sizeMapArray
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|x
operator|+=
name|s
operator|.
name|entries
operator|.
name|length
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/**      * Get the number of hot entries in the cache.      *      * @return the number of hot entries      */
specifier|public
name|int
name|sizeHot
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|x
operator|+=
name|s
operator|.
name|mapSize
operator|-
name|s
operator|.
name|queueSize
operator|-
name|s
operator|.
name|queue2Size
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/**      * Get the number of resident entries.      *      * @return the number of entries      */
annotation|@
name|Override
specifier|public
name|long
name|size
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|x
operator|+=
name|s
operator|.
name|mapSize
operator|-
name|s
operator|.
name|queue2Size
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
synchronized|synchronized
init|(
name|s
init|)
block|{
if|if
condition|(
name|evicted
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|evictedAll
argument_list|(
name|RemovalCause
operator|.
name|EXPLICIT
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Get the list of keys. This method allows to read the internal state of      * the cache.      *      * @param cold if true, only keys for the cold entries are returned      * @param nonResident true for non-resident entries      * @return the key list      */
specifier|public
specifier|synchronized
name|List
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|(
name|boolean
name|cold
parameter_list|,
name|boolean
name|nonResident
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|K
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<
name|K
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|keys
operator|.
name|addAll
argument_list|(
name|s
operator|.
name|keys
argument_list|(
name|cold
argument_list|,
name|nonResident
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|keys
return|;
block|}
annotation|@
name|Override
specifier|public
name|CacheStats
name|stats
parameter_list|()
block|{
name|long
name|hitCount
init|=
literal|0
decl_stmt|;
name|long
name|missCount
init|=
literal|0
decl_stmt|;
name|long
name|loadSuccessCount
init|=
literal|0
decl_stmt|;
name|long
name|loadExceptionCount
init|=
literal|0
decl_stmt|;
name|long
name|totalLoadTime
init|=
literal|0
decl_stmt|;
name|long
name|evictionCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|hitCount
operator|+=
name|s
operator|.
name|hitCount
expr_stmt|;
name|missCount
operator|+=
name|s
operator|.
name|missCount
expr_stmt|;
name|loadSuccessCount
operator|+=
name|s
operator|.
name|loadSuccessCount
expr_stmt|;
name|loadExceptionCount
operator|+=
name|s
operator|.
name|loadExceptionCount
expr_stmt|;
name|totalLoadTime
operator|+=
name|s
operator|.
name|totalLoadTime
expr_stmt|;
name|evictionCount
operator|+=
name|s
operator|.
name|evictionCount
expr_stmt|;
block|}
name|CacheStats
name|stats
init|=
operator|new
name|CacheStats
argument_list|(
name|hitCount
argument_list|,
name|missCount
argument_list|,
name|loadSuccessCount
argument_list|,
name|loadExceptionCount
argument_list|,
name|totalLoadTime
argument_list|,
name|evictionCount
argument_list|)
decl_stmt|;
return|return
name|stats
return|;
block|}
comment|/**      * A cache segment      *      * @param<K> the key type      * @param<V> the value type      */
specifier|static
class|class
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**          * The number of (hot, cold, and non-resident) entries in the map.          */
name|int
name|mapSize
decl_stmt|;
comment|/**          * The size of the LIRS queue for resident cold entries.          */
name|int
name|queueSize
decl_stmt|;
comment|/**          * The size of the LIRS queue for non-resident cold entries.          */
name|int
name|queue2Size
decl_stmt|;
comment|/**          * The map array. The size is always a power of 2. The bit mask that is          * applied to the key hash code to get the index in the map array. The          * mask is the length of the array minus one.          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|entries
decl_stmt|;
comment|/**          * The currently used memory.          */
name|long
name|usedMemory
decl_stmt|;
name|long
name|hitCount
decl_stmt|;
name|long
name|missCount
decl_stmt|;
name|long
name|loadSuccessCount
decl_stmt|;
name|long
name|loadExceptionCount
decl_stmt|;
name|long
name|totalLoadTime
decl_stmt|;
name|long
name|evictionCount
decl_stmt|;
comment|/**          * The cache.          */
specifier|private
specifier|final
name|CacheLIRS
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cache
decl_stmt|;
comment|/**          * How many other item are to be moved to the top of the stack before          * the current item is moved.          */
specifier|private
specifier|final
name|int
name|stackMoveDistance
decl_stmt|;
comment|/**          * The maximum memory this cache should use.          */
specifier|private
name|long
name|maxMemory
decl_stmt|;
comment|/**          * The average memory used by one entry.          */
specifier|private
name|int
name|averageMemory
decl_stmt|;
comment|/**          * The LIRS stack size.          */
specifier|private
name|int
name|stackSize
decl_stmt|;
comment|/**          * The stack of recently referenced elements. This includes all hot          * entries, and the recently referenced cold entries. Resident cold          * entries that were not recently referenced, as well as non-resident          * cold entries, are not in the stack.          *<p>          * There is always at least one entry: the head entry.          */
specifier|private
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|stack
decl_stmt|;
comment|/**          * The queue of resident cold entries.          *<p>          * There is always at least one entry: the head entry.          */
specifier|private
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|queue
decl_stmt|;
comment|/**          * The queue of non-resident cold entries.          *<p>          * There is always at least one entry: the head entry.          */
specifier|private
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|queue2
decl_stmt|;
comment|/**          * The number of times any item was moved to the top of the stack.          */
specifier|private
name|int
name|stackMoveCounter
decl_stmt|;
comment|/**          * Create a new cache.          *  @param maxMemory the maximum memory to use          * @param averageMemory the average memory usage of an object          * @param stackMoveDistance the number of other entries to be moved to          *        the top of the stack before moving an entry to the top          * @param evicted  the eviction listener of this segment or {@code null} if none.          */
name|Segment
parameter_list|(
name|CacheLIRS
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cache
parameter_list|,
name|long
name|maxMemory
parameter_list|,
name|int
name|averageMemory
parameter_list|,
name|int
name|stackMoveDistance
parameter_list|)
block|{
name|this
operator|.
name|cache
operator|=
name|cache
expr_stmt|;
name|setMaxMemory
argument_list|(
name|maxMemory
argument_list|)
expr_stmt|;
name|setAverageMemory
argument_list|(
name|averageMemory
argument_list|)
expr_stmt|;
name|this
operator|.
name|stackMoveDistance
operator|=
name|stackMoveDistance
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|evictedAll
parameter_list|(
name|RemovalCause
name|cause
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|stack
operator|.
name|stackNext
init|;
name|e
operator|!=
name|stack
condition|;
name|e
operator|=
name|e
operator|.
name|stackNext
control|)
block|{
if|if
condition|(
name|e
operator|.
name|value
operator|!=
literal|null
condition|)
block|{
name|cache
operator|.
name|evicted
argument_list|(
name|e
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|queue
operator|.
name|queueNext
init|;
name|e
operator|!=
name|queue
condition|;
name|e
operator|=
name|e
operator|.
name|queueNext
control|)
block|{
if|if
condition|(
name|e
operator|.
name|stackNext
operator|==
literal|null
condition|)
block|{
name|cache
operator|.
name|evicted
argument_list|(
name|e
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|queue2
operator|.
name|queueNext
init|;
name|e
operator|!=
name|queue2
condition|;
name|e
operator|=
name|e
operator|.
name|queueNext
control|)
block|{
name|cache
operator|.
name|evicted
argument_list|(
name|e
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
comment|// calculate the size of the map array
comment|// assume a fill factor of at most 80%
name|long
name|maxLen
init|=
call|(
name|long
call|)
argument_list|(
name|maxMemory
operator|/
name|averageMemory
operator|/
literal|0.75
argument_list|)
decl_stmt|;
comment|// the size needs to be a power of 2
name|long
name|l
init|=
literal|8
decl_stmt|;
while|while
condition|(
name|l
operator|<
name|maxLen
condition|)
block|{
name|l
operator|+=
name|l
expr_stmt|;
block|}
comment|// the array size is at most 2^31 elements
name|int
name|len
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
literal|1L
operator|<<
literal|31
argument_list|,
name|l
argument_list|)
decl_stmt|;
comment|// initialize the stack and queue heads
name|stack
operator|=
operator|new
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
expr_stmt|;
name|stack
operator|.
name|stackPrev
operator|=
name|stack
operator|.
name|stackNext
operator|=
name|stack
expr_stmt|;
name|queue
operator|=
operator|new
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
expr_stmt|;
name|queue
operator|.
name|queuePrev
operator|=
name|queue
operator|.
name|queueNext
operator|=
name|queue
expr_stmt|;
name|queue2
operator|=
operator|new
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
expr_stmt|;
name|queue2
operator|.
name|queuePrev
operator|=
name|queue2
operator|.
name|queueNext
operator|=
name|queue2
expr_stmt|;
comment|// first set to a small array, to avoiding out of memory
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|small
init|=
operator|new
name|Entry
index|[
literal|1
index|]
decl_stmt|;
name|entries
operator|=
name|small
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|e
init|=
operator|new
name|Entry
index|[
name|len
index|]
decl_stmt|;
name|entries
operator|=
name|e
expr_stmt|;
name|mapSize
operator|=
literal|0
expr_stmt|;
name|usedMemory
operator|=
literal|0
expr_stmt|;
name|stackSize
operator|=
name|queueSize
operator|=
name|queue2Size
operator|=
literal|0
expr_stmt|;
block|}
comment|/**          * Get the memory used for the given key.          *          * @param key the key (may not be null)          * @param hash the hash          * @return the memory, or 0 if there is no resident entry          */
name|int
name|getMemory
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|find
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
return|return
name|e
operator|==
literal|null
condition|?
literal|0
else|:
name|e
operator|.
name|memory
return|;
block|}
comment|/**          * Get the value for the given key if the entry is cached. This method          * adjusts the internal state of the cache sometimes, to ensure commonly          * used entries stay in the cache.          *          * @param key the key (may not be null)          * @param hash the hash          * @return the value, or null if there is no resident entry          */
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"#{} get hash {} key {}"
argument_list|,
name|cache
operator|.
name|cacheId
argument_list|,
name|hash
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|find
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
comment|// the entry was not found
name|missCount
operator|++
expr_stmt|;
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|e
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// it was a non-resident entry
name|missCount
operator|++
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|e
operator|.
name|isHot
argument_list|()
condition|)
block|{
if|if
condition|(
name|e
operator|!=
name|stack
operator|.
name|stackNext
condition|)
block|{
if|if
condition|(
name|stackMoveDistance
operator|==
literal|0
operator|||
name|stackMoveCounter
operator|-
name|e
operator|.
name|topMove
operator|>
name|stackMoveDistance
condition|)
block|{
name|access
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|access
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
name|hitCount
operator|++
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/**          * Access an item, moving the entry to the top of the stack or front of the          * queue if found.          *          * @param key the key          */
specifier|private
specifier|synchronized
name|void
name|access
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|find
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|e
operator|.
name|value
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|e
operator|.
name|isHot
argument_list|()
condition|)
block|{
if|if
condition|(
name|e
operator|!=
name|stack
operator|.
name|stackNext
condition|)
block|{
if|if
condition|(
name|stackMoveDistance
operator|==
literal|0
operator|||
name|stackMoveCounter
operator|-
name|e
operator|.
name|topMove
operator|>
name|stackMoveDistance
condition|)
block|{
comment|// move a hot entry to the top of the stack
comment|// unless it is already there
name|boolean
name|wasEnd
init|=
name|e
operator|==
name|stack
operator|.
name|stackPrev
decl_stmt|;
name|removeFromStack
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasEnd
condition|)
block|{
comment|// if moving the last entry, the last entry
comment|// could now be cold, which is not allowed
name|pruneStack
argument_list|()
expr_stmt|;
block|}
name|addToStack
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|removeFromQueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|stackNext
operator|!=
literal|null
condition|)
block|{
comment|// resident cold entries become hot
comment|// if they are on the stack
name|removeFromStack
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// which means a hot entry needs to become cold
comment|// (this entry is cold, that means there is at least one
comment|// more entry in the stack, which must be hot)
name|convertOldestHotToCold
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// cold entries that are not on the stack
comment|// move to the front of the queue
name|addToQueue
argument_list|(
name|queue
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// in any case, the cold entry is moved to the top of the stack
name|addToStack
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|Callable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|valueLoader
parameter_list|)
throws|throws
name|ExecutionException
block|{
comment|// we can not synchronize on a per-segment object while loading,
comment|// because we don't want to block cache access while loading, and
comment|// because the value loader could access the cache (for example,
comment|// using put, or another get with a loader), which might result in a
comment|// deadlock
comment|// we loop here because another thread might load the value,
comment|// but loading might fail there, so we might need to repeat this
while|while
condition|(
literal|true
condition|)
block|{
name|V
name|value
init|=
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
comment|// the (hopefully) normal case
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|value
return|;
block|}
comment|// if we are within a loader, and are currently loading
comment|// an entry, then we need to avoid a possible deadlock
comment|// (we ensure that while loading an entry, we only load
comment|// entries with a higher hash code, so there is a clear order)
name|Integer
name|outer
init|=
name|CURRENTLY_LOADING
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|outer
operator|!=
literal|null
operator|&&
name|hash
operator|<=
name|outer
condition|)
block|{
comment|// to prevent a deadlock, we also load the value ourselves
return|return
name|load
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|valueLoader
argument_list|)
return|;
block|}
name|ConcurrentHashMap
argument_list|<
name|K
argument_list|,
name|AtomicBoolean
argument_list|>
name|loading
init|=
name|cache
operator|.
name|loadingInProgress
decl_stmt|;
comment|// the object we have to wait for in case another thread loads
comment|// this value
name|AtomicBoolean
name|alreadyLoading
decl_stmt|;
comment|// synchronized on this object, even before we put it in the
comment|// cache, so that all other threads that get this object can
comment|// synchronized and wait for it
name|AtomicBoolean
name|loadNow
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
comment|// we synchronize a bit early here, but that's fine (we don't
comment|// optimize for the case where loading is extremely quick)
synchronized|synchronized
init|(
name|loadNow
init|)
block|{
name|alreadyLoading
operator|=
name|loading
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|loadNow
argument_list|)
expr_stmt|;
if|if
condition|(
name|alreadyLoading
operator|==
literal|null
condition|)
block|{
comment|// we are loading ourselves
try|try
block|{
name|CURRENTLY_LOADING
operator|.
name|set
argument_list|(
name|hash
argument_list|)
expr_stmt|;
return|return
name|load
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|valueLoader
argument_list|)
return|;
block|}
finally|finally
block|{
name|loading
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadNow
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// notify other threads, but only if
comment|// they wait for this to be loaded
name|loadNow
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
name|CURRENTLY_LOADING
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// another thread is (or was) already loading
synchronized|synchronized
init|(
name|alreadyLoading
init|)
block|{
name|alreadyLoading
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// loading might have been finished, so check again
name|AtomicBoolean
name|alreadyLoading2
init|=
name|loading
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|alreadyLoading2
operator|!=
name|alreadyLoading
condition|)
block|{
comment|// loading has completed before we could synchronize,
comment|// so we repeat
continue|continue;
block|}
comment|// still loading: wait
try|try
block|{
comment|// we could wait longer than 10 ms, but we are
comment|// in case notify is not called for some weird reason
comment|// (for example out of memory)
name|alreadyLoading
operator|.
name|wait
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
block|}
name|V
name|load
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|Callable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|valueLoader
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|V
name|value
decl_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
name|value
operator|=
name|valueLoader
operator|.
name|call
argument_list|()
expr_stmt|;
name|loadSuccessCount
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|loadExceptionCount
operator|++
expr_stmt|;
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|long
name|time
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
decl_stmt|;
name|totalLoadTime
operator|+=
name|time
expr_stmt|;
block|}
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|cache
operator|.
name|sizeOf
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|CacheLoader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
throws|throws
name|ExecutionException
block|{
comment|// avoid synchronization if it's in the cache
name|V
name|value
init|=
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|value
return|;
block|}
if|if
condition|(
name|loader
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|value
operator|=
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|value
return|;
block|}
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
name|value
operator|=
name|loader
operator|.
name|load
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|loadSuccessCount
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|loadExceptionCount
operator|++
expr_stmt|;
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|long
name|time
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
decl_stmt|;
name|totalLoadTime
operator|+=
name|time
expr_stmt|;
block|}
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|cache
operator|.
name|sizeOf
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
block|}
specifier|synchronized
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|memory
parameter_list|)
block|{
if|if
condition|(
name|containsKey
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
condition|)
block|{
return|return
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|memory
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|synchronized
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|,
name|int
name|memory
parameter_list|)
block|{
name|V
name|old
init|=
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
operator|&&
name|old
operator|.
name|equals
argument_list|(
name|oldValue
argument_list|)
condition|)
block|{
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|newValue
argument_list|,
name|memory
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|synchronized
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|V
name|old
init|=
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
operator|&&
name|old
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|invalidate
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|RemovalCause
operator|.
name|EXPLICIT
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|synchronized
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|V
name|old
init|=
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
comment|// even if old is null, there might still be a cold entry
name|invalidate
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|RemovalCause
operator|.
name|EXPLICIT
argument_list|)
expr_stmt|;
return|return
name|old
return|;
block|}
specifier|synchronized
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|memory
parameter_list|)
block|{
name|V
name|old
init|=
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
condition|)
block|{
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|memory
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|old
return|;
block|}
specifier|synchronized
name|void
name|refresh
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|CacheLoader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
throws|throws
name|ExecutionException
block|{
if|if
condition|(
name|loader
operator|==
literal|null
condition|)
block|{
comment|// no loader - no refresh
return|return;
block|}
name|V
name|value
decl_stmt|;
name|V
name|old
init|=
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|old
operator|==
literal|null
condition|)
block|{
name|value
operator|=
name|loader
operator|.
name|load
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ListenableFuture
argument_list|<
name|V
argument_list|>
name|future
init|=
name|loader
operator|.
name|reload
argument_list|(
name|key
argument_list|,
name|old
argument_list|)
decl_stmt|;
name|value
operator|=
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
name|loadSuccessCount
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|loadExceptionCount
operator|++
expr_stmt|;
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|long
name|time
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
decl_stmt|;
name|totalLoadTime
operator|+=
name|time
expr_stmt|;
block|}
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|cache
operator|.
name|sizeOf
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**          * Add an entry to the cache. The entry may or may not exist in the          * cache yet. This method will usually mark unknown entries as cold and          * known entries as hot.          *          * @param key the key (may not be null)          * @param hash the hash          * @param value the value (may not be null)          * @param memory the memory used for the given entry          * @return the old value, or null if there was no resident entry          */
specifier|synchronized
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|memory
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The value may not be null"
argument_list|)
throw|;
block|}
name|V
name|old
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|find
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
name|boolean
name|existed
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|existed
operator|=
literal|false
expr_stmt|;
name|old
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|existed
operator|=
literal|true
expr_stmt|;
name|old
operator|=
name|e
operator|.
name|value
expr_stmt|;
name|invalidate
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|RemovalCause
operator|.
name|REPLACED
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
operator|new
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
expr_stmt|;
name|e
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|e
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|e
operator|.
name|memory
operator|=
name|memory
expr_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|array
init|=
name|entries
decl_stmt|;
name|int
name|mask
init|=
name|array
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
name|mask
decl_stmt|;
name|e
operator|.
name|mapNext
operator|=
name|array
index|[
name|index
index|]
expr_stmt|;
name|array
index|[
name|index
index|]
operator|=
name|e
expr_stmt|;
name|usedMemory
operator|+=
name|memory
expr_stmt|;
if|if
condition|(
name|usedMemory
operator|>
name|maxMemory
operator|&&
name|mapSize
operator|>
literal|0
condition|)
block|{
comment|// an old entry needs to be removed
name|evict
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|mapSize
operator|++
expr_stmt|;
comment|// added entries are always added to the stack
name|addToStack
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|existed
condition|)
block|{
comment|// if it was there before (even non-resident), it becomes hot
if|if
condition|(
name|PUT_HOT
condition|)
block|{
name|access
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|old
return|;
block|}
comment|/**          * Remove an entry. Both resident and non-resident entries can be          * removed.          *          * @param key the key (may not be null)          * @param hash the hash          */
specifier|synchronized
name|void
name|invalidate
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|RemovalCause
name|cause
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|array
init|=
name|entries
decl_stmt|;
name|int
name|mask
init|=
name|array
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
name|mask
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|array
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|e
operator|.
name|key
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|array
index|[
name|index
index|]
operator|=
name|e
operator|.
name|mapNext
expr_stmt|;
block|}
else|else
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|last
decl_stmt|;
do|do
block|{
name|last
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|e
operator|.
name|mapNext
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return;
block|}
block|}
do|while
condition|(
operator|!
name|e
operator|.
name|key
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
do|;
name|last
operator|.
name|mapNext
operator|=
name|e
operator|.
name|mapNext
expr_stmt|;
block|}
name|mapSize
operator|--
expr_stmt|;
name|usedMemory
operator|-=
name|e
operator|.
name|memory
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|stackNext
operator|!=
literal|null
condition|)
block|{
name|removeFromStack
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|.
name|isHot
argument_list|()
condition|)
block|{
comment|// when removing a hot entry, the newest cold entry gets hot,
comment|// so the number of hot entries does not change
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nc
init|=
name|queue
operator|.
name|queueNext
decl_stmt|;
if|if
condition|(
name|nc
operator|!=
name|queue
condition|)
block|{
name|removeFromQueue
argument_list|(
name|nc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nc
operator|.
name|stackNext
operator|==
literal|null
condition|)
block|{
name|addToStackBottom
argument_list|(
name|nc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|removeFromQueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|pruneStack
argument_list|()
expr_stmt|;
name|cache
operator|.
name|evicted
argument_list|(
name|e
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
comment|/**          * Evict cold entries (resident and non-resident) until the memory limit is          * reached. The new entry is added as a cold entry, except if it is the only          * entry.          *          * @param newCold a new cold entry          */
specifier|private
name|void
name|evict
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newCold
parameter_list|)
block|{
comment|// ensure there are not too many hot entries: right shift of 5 is
comment|// division by 32, that means if there are only 1/32 (3.125%) or
comment|// less cold entries, a hot entry needs to become cold
while|while
condition|(
name|queueSize
operator|<=
operator|(
name|mapSize
operator|>>>
literal|5
operator|)
operator|&&
name|stackSize
operator|>
literal|0
condition|)
block|{
name|convertOldestHotToCold
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|stackSize
operator|>
literal|0
condition|)
block|{
comment|// the new cold entry is at the top of the queue
name|addToQueue
argument_list|(
name|queue
argument_list|,
name|newCold
argument_list|)
expr_stmt|;
block|}
comment|// the oldest resident cold entries become non-resident
comment|// but at least one cold entry (the new one) must stay
while|while
condition|(
name|usedMemory
operator|>
name|maxMemory
operator|&&
name|queueSize
operator|>
literal|1
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|queue
operator|.
name|queuePrev
decl_stmt|;
name|usedMemory
operator|-=
name|e
operator|.
name|memory
expr_stmt|;
name|evictionCount
operator|++
expr_stmt|;
name|removeFromQueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|cache
operator|.
name|evicted
argument_list|(
name|e
argument_list|,
name|RemovalCause
operator|.
name|SIZE
argument_list|)
expr_stmt|;
name|e
operator|.
name|value
operator|=
literal|null
expr_stmt|;
name|e
operator|.
name|memory
operator|=
literal|0
expr_stmt|;
name|addToQueue
argument_list|(
name|queue2
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// the size of the non-resident-cold entries needs to be limited
while|while
condition|(
name|queue2Size
operator|+
name|queue2Size
operator|>
name|stackSize
condition|)
block|{
name|e
operator|=
name|queue2
operator|.
name|queuePrev
expr_stmt|;
name|int
name|hash
init|=
name|getHash
argument_list|(
name|e
operator|.
name|key
argument_list|)
decl_stmt|;
name|invalidate
argument_list|(
name|e
operator|.
name|key
argument_list|,
name|hash
argument_list|,
name|RemovalCause
operator|.
name|SIZE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|convertOldestHotToCold
parameter_list|()
block|{
comment|// the last entry of the stack is known to be hot
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|last
init|=
name|stack
operator|.
name|stackPrev
decl_stmt|;
if|if
condition|(
name|last
operator|==
name|stack
condition|)
block|{
comment|// never remove the stack head itself (this would mean the
comment|// internal structure of the cache is corrupt)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
comment|// remove from stack - which is done anyway in the stack pruning, but we
comment|// can do it here as well
name|removeFromStack
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|// adding an entry to the queue will make it cold
name|addToQueue
argument_list|(
name|queue
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|pruneStack
argument_list|()
expr_stmt|;
block|}
comment|/**          * Ensure the last entry of the stack is cold.          */
specifier|private
name|void
name|pruneStack
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|last
init|=
name|stack
operator|.
name|stackPrev
decl_stmt|;
comment|// must stop at a hot entry or the stack head,
comment|// but the stack head itself is also hot, so we
comment|// don't have to test it
if|if
condition|(
name|last
operator|.
name|isHot
argument_list|()
condition|)
block|{
break|break;
block|}
comment|// the cold entry is still in the queue
name|removeFromStack
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Try to find an entry in the map.          *          * @param key the key          * @param hash the hash          * @return the entry (might be a non-resident)          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|find
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|array
init|=
name|entries
decl_stmt|;
name|int
name|mask
init|=
name|array
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
name|mask
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|array
index|[
name|index
index|]
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
operator|&&
operator|!
name|e
operator|.
name|key
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|e
operator|=
name|e
operator|.
name|mapNext
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
specifier|private
name|void
name|addToStack
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
name|e
operator|.
name|stackPrev
operator|=
name|stack
expr_stmt|;
name|e
operator|.
name|stackNext
operator|=
name|stack
operator|.
name|stackNext
expr_stmt|;
name|e
operator|.
name|stackNext
operator|.
name|stackPrev
operator|=
name|e
expr_stmt|;
name|stack
operator|.
name|stackNext
operator|=
name|e
expr_stmt|;
name|stackSize
operator|++
expr_stmt|;
name|e
operator|.
name|topMove
operator|=
name|stackMoveCounter
operator|++
expr_stmt|;
block|}
specifier|private
name|void
name|addToStackBottom
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
name|e
operator|.
name|stackNext
operator|=
name|stack
expr_stmt|;
name|e
operator|.
name|stackPrev
operator|=
name|stack
operator|.
name|stackPrev
expr_stmt|;
name|e
operator|.
name|stackPrev
operator|.
name|stackNext
operator|=
name|e
expr_stmt|;
name|stack
operator|.
name|stackPrev
operator|=
name|e
expr_stmt|;
name|stackSize
operator|++
expr_stmt|;
block|}
specifier|private
name|void
name|removeFromStack
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
name|e
operator|.
name|stackPrev
operator|.
name|stackNext
operator|=
name|e
operator|.
name|stackNext
expr_stmt|;
name|e
operator|.
name|stackNext
operator|.
name|stackPrev
operator|=
name|e
operator|.
name|stackPrev
expr_stmt|;
name|e
operator|.
name|stackPrev
operator|=
name|e
operator|.
name|stackNext
operator|=
literal|null
expr_stmt|;
name|stackSize
operator|--
expr_stmt|;
block|}
specifier|private
name|void
name|addToQueue
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|q
parameter_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
name|e
operator|.
name|queuePrev
operator|=
name|q
expr_stmt|;
name|e
operator|.
name|queueNext
operator|=
name|q
operator|.
name|queueNext
expr_stmt|;
name|e
operator|.
name|queueNext
operator|.
name|queuePrev
operator|=
name|e
expr_stmt|;
name|q
operator|.
name|queueNext
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|value
operator|!=
literal|null
condition|)
block|{
name|queueSize
operator|++
expr_stmt|;
block|}
else|else
block|{
name|queue2Size
operator|++
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|removeFromQueue
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
name|e
operator|.
name|queuePrev
operator|.
name|queueNext
operator|=
name|e
operator|.
name|queueNext
expr_stmt|;
name|e
operator|.
name|queueNext
operator|.
name|queuePrev
operator|=
name|e
operator|.
name|queuePrev
expr_stmt|;
name|e
operator|.
name|queuePrev
operator|=
name|e
operator|.
name|queueNext
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|value
operator|!=
literal|null
condition|)
block|{
name|queueSize
operator|--
expr_stmt|;
block|}
else|else
block|{
name|queue2Size
operator|--
expr_stmt|;
block|}
block|}
comment|/**          * Get the list of keys. This method allows to read the internal state of          * the cache.          *          * @param cold if true, only keys for the cold entries are returned          * @param nonResident true for non-resident entries          * @return the key list          */
specifier|synchronized
name|List
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|(
name|boolean
name|cold
parameter_list|,
name|boolean
name|nonResident
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|K
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<
name|K
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cold
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|start
init|=
name|nonResident
condition|?
name|queue2
else|:
name|queue
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|start
operator|.
name|queueNext
init|;
name|e
operator|!=
name|start
condition|;
name|e
operator|=
name|e
operator|.
name|queueNext
control|)
block|{
name|keys
operator|.
name|add
argument_list|(
name|e
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|stack
operator|.
name|stackNext
init|;
name|e
operator|!=
name|stack
condition|;
name|e
operator|=
name|e
operator|.
name|stackNext
control|)
block|{
name|keys
operator|.
name|add
argument_list|(
name|e
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|keys
return|;
block|}
comment|/**          * Check whether there is a resident entry for the given key. This          * method does not adjust the internal state of the cache.          *          * @param key the key (may not be null)          * @param hash the hash          * @return true if there is a resident entry          */
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|find
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
return|return
name|e
operator|!=
literal|null
operator|&&
name|e
operator|.
name|value
operator|!=
literal|null
return|;
block|}
comment|/**          * Get the set of keys for resident entries.          *          * @return the set of keys          */
specifier|synchronized
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|HashSet
argument_list|<
name|K
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|K
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|stack
operator|.
name|stackNext
init|;
name|e
operator|!=
name|stack
condition|;
name|e
operator|=
name|e
operator|.
name|stackNext
control|)
block|{
name|set
operator|.
name|add
argument_list|(
name|e
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|queue
operator|.
name|queueNext
init|;
name|e
operator|!=
name|queue
condition|;
name|e
operator|=
name|e
operator|.
name|queueNext
control|)
block|{
name|set
operator|.
name|add
argument_list|(
name|e
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
comment|/**          * Set the maximum memory this cache should use. This will not          * immediately cause entries to get removed however; it will only change          * the limit. To resize the internal array, call the clear method.          *          * @param maxMemory the maximum size (1 or larger)          */
name|void
name|setMaxMemory
parameter_list|(
name|long
name|maxMemory
parameter_list|)
block|{
if|if
condition|(
name|maxMemory
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Max memory must be larger than 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|maxMemory
operator|=
name|maxMemory
expr_stmt|;
block|}
comment|/**          * Set the average memory used per entry. It is used to calculate the          * length of the internal array.          *          * @param averageMemory the average memory used (1 or larger)          */
name|void
name|setAverageMemory
parameter_list|(
name|int
name|averageMemory
parameter_list|)
block|{
if|if
condition|(
name|averageMemory
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Average memory must be larger than 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|averageMemory
operator|=
name|averageMemory
expr_stmt|;
block|}
block|}
comment|/**      * A cache entry. Each entry is either hot (low inter-reference recency;      * LIR), cold (high inter-reference recency; HIR), or non-resident-cold. Hot      * entries are in the stack only. Cold entries are in the queue, and may be      * in the stack. Non-resident-cold entries have their value set to null and      * are in the stack and in the non-resident queue.      *      * @param<K> the key type      * @param<V> the value type      */
specifier|static
class|class
name|Entry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**          * The key.          */
name|K
name|key
decl_stmt|;
comment|/**          * The value. Set to null for non-resident-cold entries.          */
name|V
name|value
decl_stmt|;
comment|/**          * The estimated memory used.          */
name|int
name|memory
decl_stmt|;
comment|/**          * When the item was last moved to the top of the stack.          */
name|int
name|topMove
decl_stmt|;
comment|/**          * The next entry in the stack.          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|stackNext
decl_stmt|;
comment|/**          * The previous entry in the stack.          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|stackPrev
decl_stmt|;
comment|/**          * The next entry in the queue (either the resident queue or the          * non-resident queue).          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|queueNext
decl_stmt|;
comment|/**          * The previous entry in the queue.          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|queuePrev
decl_stmt|;
comment|/**          * The next entry in the map          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|mapNext
decl_stmt|;
comment|/**          * Whether this entry is hot. Cold entries are in one of the two queues.          *          * @return whether the entry is hot          */
name|boolean
name|isHot
parameter_list|()
block|{
return|return
name|queueNext
operator|==
literal|null
return|;
block|}
block|}
comment|/**      * A builder for the cache.      */
specifier|public
specifier|static
class|class
name|Builder
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
specifier|private
name|String
name|module
decl_stmt|;
specifier|private
name|Weigher
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
decl_stmt|;
specifier|private
name|long
name|maxWeight
decl_stmt|;
specifier|private
name|int
name|averageWeight
init|=
literal|100
decl_stmt|;
specifier|private
name|int
name|segmentCount
init|=
literal|16
decl_stmt|;
specifier|private
name|int
name|stackMoveDistance
init|=
literal|16
decl_stmt|;
specifier|private
name|EvictionCallback
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|evicted
decl_stmt|;
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|recordStats
parameter_list|()
block|{
return|return
name|this
return|;
block|}
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|module
parameter_list|(
name|String
name|module
parameter_list|)
block|{
name|this
operator|.
name|module
operator|=
name|module
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set the weigher which is used if memory usage of an entry is not          * explicitly set (when adding entries).          *           * @param weigher the weigher          * @return this          */
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
parameter_list|(
name|Weigher
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
parameter_list|)
block|{
name|this
operator|.
name|weigher
operator|=
name|weigher
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set the total maximum weight. If the cache is heavier, then entries          * are evicted.          *           * @param maxWeight the maximum weight          * @return this          */
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|maximumWeight
parameter_list|(
name|long
name|maxWeight
parameter_list|)
block|{
name|this
operator|.
name|maxWeight
operator|=
name|maxWeight
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set the average weight of an entry. This is used, together with the          * maximum weight, to calculate the length of the internal array of the          * cache.          *           * For higher performance, the weight should be set relatively low, at          * the cost of some space. To save space, the average weight should be          * set high, at the cost of some performance.          *           * @param averageWeight the average weight          * @return this          */
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|averageWeight
parameter_list|(
name|int
name|averageWeight
parameter_list|)
block|{
name|this
operator|.
name|averageWeight
operator|=
name|averageWeight
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set the maximum size (in number of entries). This is the same as          * setting the average weight of an entry to 1, and the maximum weight          * to the maximum size.          *           * @param maxSize the maximum size          * @return this          */
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|maximumSize
parameter_list|(
name|long
name|maxSize
parameter_list|)
block|{
name|this
operator|.
name|maxWeight
operator|=
name|maxSize
expr_stmt|;
name|this
operator|.
name|averageWeight
operator|=
literal|1
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segmentCount
parameter_list|(
name|int
name|segmentCount
parameter_list|)
block|{
if|if
condition|(
name|Integer
operator|.
name|bitCount
argument_list|(
name|segmentCount
argument_list|)
operator|!=
literal|1
operator|||
name|segmentCount
argument_list|<
literal|0
operator|||
name|segmentCount
argument_list|>
literal|65536
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Illegal segment count: "
operator|+
name|segmentCount
operator|+
literal|", using 16"
argument_list|)
expr_stmt|;
name|segmentCount
operator|=
literal|16
expr_stmt|;
block|}
name|this
operator|.
name|segmentCount
operator|=
name|segmentCount
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|stackMoveDistance
parameter_list|(
name|int
name|stackMoveDistance
parameter_list|)
block|{
if|if
condition|(
name|stackMoveDistance
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Illegal stack move distance: "
operator|+
name|stackMoveDistance
operator|+
literal|", using 16"
argument_list|)
expr_stmt|;
name|stackMoveDistance
operator|=
literal|16
expr_stmt|;
block|}
name|this
operator|.
name|stackMoveDistance
operator|=
name|stackMoveDistance
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|evictionCallback
parameter_list|(
name|EvictionCallback
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|evicted
parameter_list|)
block|{
name|this
operator|.
name|evicted
operator|=
name|evicted
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|CacheLIRS
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|build
parameter_list|()
block|{
return|return
name|build
argument_list|(
literal|null
argument_list|)
return|;
block|}
specifier|public
name|CacheLIRS
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|build
parameter_list|(
name|CacheLoader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cacheLoader
parameter_list|)
block|{
return|return
operator|new
name|CacheLIRS
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|weigher
argument_list|,
name|maxWeight
argument_list|,
name|averageWeight
argument_list|,
name|segmentCount
argument_list|,
name|stackMoveDistance
argument_list|,
name|cacheLoader
argument_list|,
name|evicted
argument_list|,
name|module
argument_list|)
return|;
block|}
block|}
comment|/**      * Create a builder.      *      * @return the builder      */
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newBuilder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getAllPresent
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|keys
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asMap
parameter_list|()
block|{
return|return
operator|new
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
name|long
name|size
init|=
name|CacheLIRS
operator|.
name|this
operator|.
name|size
argument_list|()
decl_stmt|;
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|size
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|CacheLIRS
operator|.
name|this
operator|.
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|CacheLIRS
operator|.
name|this
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|CacheLIRS
operator|.
name|this
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|CacheLIRS
operator|.
name|this
operator|.
name|peek
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|CacheLIRS
operator|.
name|this
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|sizeOf
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|V
name|old
init|=
name|CacheLIRS
operator|.
name|this
operator|.
name|getUnchecked
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
decl_stmt|;
name|CacheLIRS
operator|.
name|this
operator|.
name|invalidate
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|old
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|CacheLIRS
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|CacheLIRS
operator|.
name|this
operator|.
name|keySet
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|CacheLIRS
operator|.
name|this
operator|.
name|values
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
name|CacheLIRS
operator|.
name|this
operator|.
name|entrySet
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|CacheLIRS
operator|.
name|this
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|CacheLIRS
operator|.
name|this
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
return|return
name|CacheLIRS
operator|.
name|this
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|CacheLIRS
operator|.
name|this
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|cleanUp
parameter_list|()
block|{
comment|// nothing to do
block|}
annotation|@
name|Override
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getAll
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|keys
parameter_list|)
throws|throws
name|ExecutionException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|apply
parameter_list|(
name|K
name|key
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
block|}
end_class

end_unit

