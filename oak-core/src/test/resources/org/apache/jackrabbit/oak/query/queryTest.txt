# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Syntax:
# * lines starting with "#" are remarks.
# * lines starting with "select" are queries, followed by expected results and an empty line
# * lines starting with "explain" are followed by expected query plan and an empty line
# * all other lines are are committed into the microkernel (line by line)
# * new tests are typically be added on top, after the syntax docs
# * use ascii character only

# test the property content index

commit /default + "test": { "a": { "id": "10" }, "b": { "id" : "20" }}
commit /jcr:system/indexes + "property:id": {}

explain select * from [nt:base] where id = '10'
nt:base AS nt:base /* propertyIndex "id [10..10]" */

select * from [nt:base] where id = '10'
/default/test/a

select [jcr:path], * from [nt:base] where id = '10'
/test/a, null

explain select * from [nt:base] where id > '10'
nt:base AS nt:base /* traverse "//*" */

commit /default - "test"
commit /jcr:system/indexes - "property:id"

# other tests

commit /default + "test": { "jcr:resource": {}, "resource": { "x" : {}}}

select * from [nt:base] where id = -1

explain select * from [nt:base] as b where ischildnode(b, '/test')
nt:base AS b /* traverse "/default/test/*" */

explain select * from [nt:base] as b where isdescendantnode(b, '/test')
nt:base AS b /* traverse "/default/test//*" */

select * from [nt:base] as b where ischildnode(b, '/test')
/default/test/jcr:resource
/default/test/resource

select * from [nt:base] as b where issamenode(b, '/test')
/default/test

select * from [nt:base] where name() = 'resource'
/default/test/resource

select * from [nt:base] as b where localname(b) = 'resource'
/default/test/jcr:resource
/default/test/resource

select * from [nt:base] as x where isdescendantnode(x, '/')
/default/test
/default/test/jcr:resource
/default/test/resource
/default/test/resource/x

commit /default - "test"

commit /default + "parents": { "p0": {"id": "0"}, "p1": {"id": "1"}, "p2": {"id": "2"}}
commit /default + "children": { "c1": {"p": "1"}, "c2": {"p": "1"}, "c3": {"p": "2"}, "c4": {"p": "3"}}

# relative property
select * from [nt:base] where [c1/p] = '1'
/default/children

select * from [nt:base] as p where p.[jcr:path] = '/parents'
/default/parents

select * from [nt:base] as p inner join [nt:base] as p2 on ischildnode(p2, p) where p.[jcr:path] = '/'
/default, /default/children
/default, /default/parents

select * from [nt:base] as p inner join [nt:base] as p2 on isdescendantnode(p2, p) where p.[jcr:path] = '/parents'
/default/parents, /default/parents/p0
/default/parents, /default/parents/p1
/default/parents, /default/parents/p2

select * from [nt:base] as p inner join [nt:base] as p2 on issamenode(p2, p) where p.[jcr:path] = '/parents'
/default/parents, /default/parents

select id from [nt:base] where id is not null
0
1
2

select id from [nt:base] where id is not null order by id desc
2
1
0

select * from [nt:base] as c right outer join [nt:base] as p on p.id = c.p where p.id is not null
/default/children/c1, /default/parents/p1
/default/children/c2, /default/parents/p1
/default/children/c3, /default/parents/p2
null, /default/parents/p0

select * from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null
/default/parents/p0, null
/default/parents/p1, /default/children/c1
/default/parents/p1, /default/children/c2
/default/parents/p2, /default/children/c3

select * from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null and c.p is null
/default/parents/p0, null

select * from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null and c.p is not null
/default/parents/p1, /default/children/c1
/default/parents/p1, /default/children/c2
/default/parents/p2, /default/children/c3

select * from [nt:base] as p inner join [nt:base] as c on p.id = c.p
/default/parents/p1, /default/children/c1
/default/parents/p1, /default/children/c2
/default/parents/p2, /default/children/c3

explain select * from [nt:base] as p inner join [nt:base] as c on p.id = c.p
nt:base AS p /* traverse "//*" */ INNER JOIN nt:base AS c /* traverse "//*" */

commit /default - "parents"
commit /default - "children"

commit /default + "test": { "hello": { "x": "1" }, "world": { "x": "2" } }
commit /default + "test2": { "id":"1", "x": "2" }

select * from [nt:base]
/
/default
/default/test
/default/test/hello
/default/test/world
/default/test2
/jcr:system
/jcr:system/indexes

select * from [nt:base] where id = '1'
/default/test2

select * from [nt:base] where id = '1' and x = '2'
/default/test2

select * from [nt:base] where id = '1' or x = '2'
/default/test/world
/default/test2

select * from [nt:base] where not (id = '1' or x = '2')
/
/default
/default/test
/default/test/hello
/jcr:system
/jcr:system/indexes

select * from [nt:base] where x is null
/
/default
/default/test
/jcr:system
/jcr:system/indexes

commit /default - "test"
commit /default - "test2"

commit /default + "test": { "name": "hello" }
commit /default + "test2": { "name": "World!" }
commit /default + "test3": { "name": "Hallo" }
commit /default + "test4": { "name": "10%" }
commit /default + "test5": { "name": "10 percent" }

select name from [nt:base] order by upper(name)
10 percent
10%
Hallo
hello
World!
null
null
null
null

select * from [nt:base] where length(name) = 5
/default/test
/default/test3

select * from [nt:base] where upper(name) = 'HELLO'
/default/test

select * from [nt:base] where lower(name) = 'world!'
/default/test2

select * from [nt:base] where name like 'W%'
/default/test2

select * from [nt:base] where name like '%o_%'
/default/test2

select * from [nt:base] where name like '__llo'
/default/test
/default/test3

select * from [nt:base] where upper(name) like 'H_LLO'
/default/test
/default/test3

select * from [nt:base] where upper(name) like 'H\_LLO'

select * from [nt:base] where upper(name) like '10%'
/default/test4
/default/test5

select * from [nt:base] where upper(name) like '10\%'
/default/test4

