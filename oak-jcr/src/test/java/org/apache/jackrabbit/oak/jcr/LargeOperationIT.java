begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|jcr
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|log
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|pow
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|MILLISECONDS
import|;
end_import

begin_import
import|import static
name|javax
operator|.
name|jcr
operator|.
name|observation
operator|.
name|Event
operator|.
name|NODE_ADDED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assume
operator|.
name|assumeTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|NodeIterator
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|Repository
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|RepositoryException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|Session
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|SimpleCredentials
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|observation
operator|.
name|EventIterator
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|observation
operator|.
name|EventListener
import|;
end_import

begin_import
import|import
name|ch
operator|.
name|qos
operator|.
name|logback
operator|.
name|classic
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|ch
operator|.
name|qos
operator|.
name|logback
operator|.
name|classic
operator|.
name|LoggerContext
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|math3
operator|.
name|distribution
operator|.
name|BinomialDistribution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|math3
operator|.
name|exception
operator|.
name|MathIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|math3
operator|.
name|exception
operator|.
name|MathInternalError
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|math3
operator|.
name|exception
operator|.
name|NotPositiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|math3
operator|.
name|exception
operator|.
name|NullArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|math3
operator|.
name|exception
operator|.
name|OutOfRangeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|math3
operator|.
name|exception
operator|.
name|util
operator|.
name|LocalizedFormats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|api
operator|.
name|JackrabbitRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|jcr
operator|.
name|NodeStoreFixture
operator|.
name|DocumentFixture
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|jcr
operator|.
name|NodeStoreFixture
operator|.
name|SegmentFixture
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|jcr
operator|.
name|session
operator|.
name|RefreshStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentNodeStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|segment
operator|.
name|SegmentStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|segment
operator|.
name|file
operator|.
name|FileStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Scalability test asserting certain operations scale not worse than {@code O(n log n)}  * in the size of their input.  *  * These tests are disabled by default due to their long running time. On the command line  * specify {@code -DLargeOperationIT=true} to enable them.  */
end_comment

begin_class
annotation|@
name|RunWith
argument_list|(
name|Parameterized
operator|.
name|class
argument_list|)
specifier|public
class|class
name|LargeOperationIT
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LargeOperationIT
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|enabled
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
name|LargeOperationIT
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * Significance level for the binomial test being performed to establish      * the {@code O(n log n)} performance bound.      * @see #assertOnLgn(String, Iterable, java.util.List, boolean)      */
specifier|public
specifier|static
specifier|final
name|double
name|ALPHA
init|=
literal|0.05
decl_stmt|;
comment|/** Scales defining the input sizes against which the tests run */
specifier|private
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|SEGMENT_SCALES
init|=
name|createSequence
argument_list|(
literal|1024
argument_list|,
literal|1048576
argument_list|,
literal|40
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|MONGO_SCALES
init|=
name|createSequence
argument_list|(
literal|128
argument_list|,
literal|131072
argument_list|,
literal|40
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|NodeStoreFixture
name|fixture
decl_stmt|;
specifier|private
specifier|final
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|scales
decl_stmt|;
specifier|private
name|NodeStore
name|nodeStore
decl_stmt|;
specifier|private
name|Repository
name|repository
decl_stmt|;
specifier|private
name|Session
name|session
decl_stmt|;
specifier|public
name|LargeOperationIT
parameter_list|(
name|NodeStoreFixture
name|fixture
parameter_list|,
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|scales
parameter_list|)
block|{
name|assumeTrue
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
name|this
operator|.
name|fixture
operator|=
name|fixture
expr_stmt|;
name|this
operator|.
name|scales
operator|=
name|scales
expr_stmt|;
block|}
comment|/**      * Create a geometrically increasing sequence of values      * @param from    first value. Must be> 0      * @param to      last value. Must be> {@code from}      * @param count   number of values      * @return  geometrically increasing sequence of {@code count} values      * between {@code from} and {@code to}      */
specifier|private
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|createSequence
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|double
name|slope
init|=
name|pow
argument_list|(
name|to
operator|/
operator|(
name|double
operator|)
name|from
argument_list|,
literal|1
operator|/
operator|(
operator|(
name|double
operator|)
name|count
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|seq
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
name|int
name|v
init|=
name|from
decl_stmt|;
do|do
block|{
name|seq
operator|.
name|add
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
call|(
name|int
call|)
argument_list|(
name|slope
operator|*
name|v
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|c
operator|<
name|count
condition|)
do|;
return|return
name|seq
return|;
block|}
annotation|@
name|Parameterized
operator|.
name|Parameters
specifier|public
specifier|static
name|Collection
argument_list|<
name|Object
index|[]
argument_list|>
name|fixtures
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
operator|new
name|File
argument_list|(
literal|"target"
argument_list|)
argument_list|,
literal|"tar."
operator|+
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
decl_stmt|;
name|SegmentStore
name|segmentStore
init|=
operator|new
name|FileStore
argument_list|(
name|file
argument_list|,
literal|266
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|fixtures
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|SegmentFixture
name|segmentFixture
init|=
operator|new
name|SegmentFixture
argument_list|(
name|segmentStore
argument_list|)
decl_stmt|;
if|if
condition|(
name|segmentFixture
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
name|fixtures
operator|.
name|add
argument_list|(
operator|new
name|Object
index|[]
block|{
name|segmentFixture
block|,
name|SEGMENT_SCALES
block|}
argument_list|)
expr_stmt|;
block|}
name|DocumentFixture
name|documentFixture
init|=
operator|new
name|DocumentFixture
argument_list|()
decl_stmt|;
if|if
condition|(
name|documentFixture
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
name|fixtures
operator|.
name|add
argument_list|(
operator|new
name|Object
index|[]
block|{
name|documentFixture
block|,
name|MONGO_SCALES
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|fixtures
return|;
block|}
specifier|private
name|Session
name|createAdminSession
parameter_list|()
throws|throws
name|RepositoryException
block|{
return|return
name|repository
operator|.
name|login
argument_list|(
operator|new
name|SimpleCredentials
argument_list|(
literal|"admin"
argument_list|,
literal|"admin"
operator|.
name|toCharArray
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|safeLogout
parameter_list|(
name|Session
name|session
parameter_list|)
block|{
try|try
block|{
name|session
operator|.
name|logout
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignore
parameter_list|)
block|{}
block|}
annotation|@
name|Before
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|RepositoryException
block|{
comment|// Disable noisy logging we want to ignore for these tests
operator|(
operator|(
name|LoggerContext
operator|)
name|LoggerFactory
operator|.
name|getILoggerFactory
argument_list|()
operator|)
operator|.
name|getLogger
argument_list|(
name|DocumentNodeStore
operator|.
name|class
argument_list|)
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|ERROR
argument_list|)
expr_stmt|;
operator|(
operator|(
name|LoggerContext
operator|)
name|LoggerFactory
operator|.
name|getILoggerFactory
argument_list|()
operator|)
operator|.
name|getLogger
argument_list|(
literal|"org.apache.jackrabbit.oak.jcr.observation.ChangeProcessor"
argument_list|)
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|ERROR
argument_list|)
expr_stmt|;
operator|(
operator|(
name|LoggerContext
operator|)
name|LoggerFactory
operator|.
name|getILoggerFactory
argument_list|()
operator|)
operator|.
name|getLogger
argument_list|(
name|RefreshStrategy
operator|.
name|class
argument_list|)
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|ERROR
argument_list|)
expr_stmt|;
name|nodeStore
operator|=
name|fixture
operator|.
name|createNodeStore
argument_list|()
expr_stmt|;
name|repository
operator|=
operator|new
name|Jcr
argument_list|(
name|nodeStore
argument_list|)
operator|.
name|createRepository
argument_list|()
expr_stmt|;
name|session
operator|=
name|createAdminSession
argument_list|()
expr_stmt|;
block|}
annotation|@
name|After
specifier|public
name|void
name|tearDown
parameter_list|()
block|{
name|safeLogout
argument_list|(
name|session
argument_list|)
expr_stmt|;
if|if
condition|(
name|repository
operator|instanceof
name|JackrabbitRepository
condition|)
block|{
operator|(
operator|(
name|JackrabbitRepository
operator|)
name|repository
operator|)
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|fixture
operator|.
name|dispose
argument_list|(
name|nodeStore
argument_list|)
expr_stmt|;
block|}
comment|/**      * Assert that the actual runtime performance is bounded by {@code O(n log n)} where      * {@code n} is the size of the input.      *<p>      * This is done by comparing the slope of the measured running times against the      * slope of {@code n log n}  (i.e. {@code d/dn n log n = 1 + log n}) for the respective      * input size. The number of values for which the measured running time does not exceed that      * bound is used as a test statistic for the subsequent      *<a href="http://en.wikipedia.org/wiki/Binomial_test">binomial test</a>. The test passes      * if the binomial test with a significance level of {@link #ALPHA} passes and fails otherwise.      *      * @param name    name of the test      * @param scales  the sizes of the inputs      * @param executionTimes  the execution times corresponding to the {@code scales}      * @param knownIssue  log when the assertion doesn't hold but don't throw {@link AssertionError}      */
specifier|private
specifier|static
name|void
name|assertOnLgn
parameter_list|(
name|String
name|name
parameter_list|,
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|scales
parameter_list|,
name|List
argument_list|<
name|Double
argument_list|>
name|executionTimes
parameter_list|,
name|boolean
name|knownIssue
parameter_list|)
block|{
name|Double
name|n0
init|=
literal|null
decl_stmt|;
name|Double
name|t0
init|=
literal|null
decl_stmt|;
name|int
name|successes
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|ns
init|=
name|scales
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|double
name|t
range|:
name|executionTimes
control|)
block|{
name|double
name|n
init|=
name|ns
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|n0
operator|!=
literal|null
condition|)
block|{
name|double
name|dt
init|=
operator|(
name|t
operator|-
name|t0
operator|)
operator|/
operator|(
name|n
operator|-
name|n0
operator|)
decl_stmt|;
comment|// slope of the measured running times
name|double
name|bound
init|=
literal|1
operator|+
name|log
argument_list|(
name|n
argument_list|)
decl_stmt|;
comment|// bound of the slope for the respective input size
if|if
condition|(
name|dt
operator|<
name|bound
condition|)
block|{
name|successes
operator|++
expr_stmt|;
block|}
block|}
name|n0
operator|=
name|n
expr_stmt|;
name|t0
operator|=
name|t
expr_stmt|;
block|}
comment|// number of trials is one less due to the numeric differentiation
name|int
name|trials
init|=
name|executionTimes
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
name|double
name|p
init|=
operator|new
name|BinomialTest
argument_list|()
operator|.
name|binomialTest
argument_list|(
name|trials
argument_list|,
name|successes
argument_list|,
literal|0.5
argument_list|,
name|BinomialTest
operator|.
name|AlternativeHypothesis
operator|.
name|GREATER_THAN
argument_list|)
decl_stmt|;
name|boolean
name|pass
init|=
name|p
operator|<=
name|ALPHA
decl_stmt|;
if|if
condition|(
name|pass
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} scales O(n lg n). p-value={}<= "
operator|+
name|ALPHA
argument_list|,
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{} does not scale O(n lg n). p-value={}> "
operator|+
name|ALPHA
argument_list|,
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of trials={}, Number of successes={}"
argument_list|,
name|trials
argument_list|,
name|successes
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"scales={}"
argument_list|,
name|scales
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"executionTimes={}"
argument_list|,
name|executionTimes
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|name
operator|+
literal|"does not scale O(n lg n). p-value="
operator|+
name|p
operator|+
literal|"> "
operator|+
name|ALPHA
argument_list|,
name|knownIssue
operator|||
name|pass
argument_list|)
expr_stmt|;
block|}
comment|/**      * Assert that large commits scale linearly wrt. to the number of changed items.      * @throws RepositoryException      * @throws InterruptedException      */
annotation|@
name|Test
specifier|public
name|void
name|largeCommit
parameter_list|()
throws|throws
name|RepositoryException
throws|,
name|InterruptedException
block|{
specifier|final
name|Node
name|n
init|=
name|session
operator|.
name|getRootNode
argument_list|()
operator|.
name|addNode
argument_list|(
literal|"large-commit"
argument_list|,
literal|"oak:Unstructured"
argument_list|)
decl_stmt|;
specifier|final
name|ContentGenerator
name|contentGenerator
init|=
operator|new
name|ContentGenerator
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Double
argument_list|>
name|executionTimes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|scale
range|:
name|scales
control|)
block|{
name|ScalabilityTest
name|test
init|=
operator|new
name|ScalabilityTest
argument_list|(
name|scale
argument_list|)
block|{
annotation|@
name|Override
name|void
name|before
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|contentGenerator
operator|.
name|addNodes
argument_list|(
name|n
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|run
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|session
operator|.
name|save
argument_list|()
expr_stmt|;
block|}
block|}
decl_stmt|;
name|double
name|t
init|=
name|test
operator|.
name|run
argument_list|()
decl_stmt|;
name|executionTimes
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Committing {} node took {} ns/node"
argument_list|,
name|scale
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|assertOnLgn
argument_list|(
literal|"large commit"
argument_list|,
name|scales
argument_list|,
name|executionTimes
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Assert copy scales linearly with the number of items copied      * @throws RepositoryException      * @throws InterruptedException      */
annotation|@
name|Test
specifier|public
name|void
name|largeCopy
parameter_list|()
throws|throws
name|RepositoryException
throws|,
name|InterruptedException
block|{
specifier|final
name|Node
name|n
init|=
name|session
operator|.
name|getRootNode
argument_list|()
operator|.
name|addNode
argument_list|(
literal|"large-copy"
argument_list|,
literal|"oak:Unstructured"
argument_list|)
decl_stmt|;
specifier|final
name|ContentGenerator
name|contentGenerator
init|=
operator|new
name|ContentGenerator
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Double
argument_list|>
name|executionTimes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|scale
range|:
name|scales
control|)
block|{
name|ScalabilityTest
name|test
init|=
operator|new
name|ScalabilityTest
argument_list|(
name|scale
argument_list|)
block|{
annotation|@
name|Override
name|void
name|before
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|Node
name|s
init|=
name|n
operator|.
name|addNode
argument_list|(
literal|"s"
operator|+
name|scale
argument_list|)
decl_stmt|;
name|contentGenerator
operator|.
name|addNodes
argument_list|(
name|s
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|run
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|session
operator|.
name|getWorkspace
argument_list|()
operator|.
name|copy
argument_list|(
literal|"/large-copy/s"
operator|+
name|scale
argument_list|,
literal|"/large-copy/t"
operator|+
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|double
name|t
init|=
name|test
operator|.
name|run
argument_list|()
decl_stmt|;
name|executionTimes
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Copying {} node took {} ns/node"
argument_list|,
name|scale
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|boolean
name|knownIssue
init|=
name|fixture
operator|.
name|getClass
argument_list|()
operator|==
name|DocumentFixture
operator|.
name|class
decl_stmt|;
comment|// FIXME OAK-1698
name|assertOnLgn
argument_list|(
literal|"large copy"
argument_list|,
name|scales
argument_list|,
name|executionTimes
argument_list|,
name|knownIssue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Assert move scales linearly with the number of items copied      * @throws RepositoryException      * @throws InterruptedException      */
annotation|@
name|Test
specifier|public
name|void
name|largeMove
parameter_list|()
throws|throws
name|RepositoryException
throws|,
name|InterruptedException
block|{
specifier|final
name|Node
name|n
init|=
name|session
operator|.
name|getRootNode
argument_list|()
operator|.
name|addNode
argument_list|(
literal|"large-move"
argument_list|,
literal|"oak:Unstructured"
argument_list|)
decl_stmt|;
specifier|final
name|ContentGenerator
name|contentGenerator
init|=
operator|new
name|ContentGenerator
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Double
argument_list|>
name|executionTimes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|scale
range|:
name|scales
control|)
block|{
name|ScalabilityTest
name|test
init|=
operator|new
name|ScalabilityTest
argument_list|(
name|scale
argument_list|)
block|{
annotation|@
name|Override
name|void
name|before
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|Node
name|s
init|=
name|n
operator|.
name|addNode
argument_list|(
literal|"s"
operator|+
name|scale
argument_list|)
decl_stmt|;
name|contentGenerator
operator|.
name|addNodes
argument_list|(
name|s
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|run
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|session
operator|.
name|getWorkspace
argument_list|()
operator|.
name|move
argument_list|(
literal|"/large-move/s"
operator|+
name|scale
argument_list|,
literal|"/large-move/t"
operator|+
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|double
name|t
init|=
name|test
operator|.
name|run
argument_list|()
decl_stmt|;
name|executionTimes
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Moving {} node took {} ns/node"
argument_list|,
name|scale
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|boolean
name|knownIssue
init|=
name|fixture
operator|.
name|getClass
argument_list|()
operator|==
name|DocumentFixture
operator|.
name|class
decl_stmt|;
comment|// FIXME OAK-1698
name|assertOnLgn
argument_list|(
literal|"large move"
argument_list|,
name|scales
argument_list|,
name|executionTimes
argument_list|,
name|knownIssue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Assert adding siblings scales linearly with the number of already existing siblings.      * @throws RepositoryException      * @throws InterruptedException      */
annotation|@
name|Test
specifier|public
name|void
name|manySiblings
parameter_list|()
throws|throws
name|RepositoryException
throws|,
name|InterruptedException
block|{
specifier|final
name|Node
name|n
init|=
name|session
operator|.
name|getRootNode
argument_list|()
operator|.
name|addNode
argument_list|(
literal|"many-siblings"
argument_list|,
literal|"oak:Unstructured"
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Double
argument_list|>
name|executionTimes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|scale
range|:
name|scales
control|)
block|{
name|ScalabilityTest
name|test
init|=
operator|new
name|ScalabilityTest
argument_list|(
name|scale
argument_list|)
block|{
annotation|@
name|Override
name|void
name|before
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|Node
name|s
init|=
name|n
operator|.
name|addNode
argument_list|(
literal|"s"
operator|+
name|scale
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|scale
condition|;
name|k
operator|++
control|)
block|{
name|s
operator|.
name|addNode
argument_list|(
literal|"s"
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
name|void
name|run
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|Node
name|s
init|=
name|n
operator|.
name|getNode
argument_list|(
literal|"s"
operator|+
name|scale
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
literal|100
condition|;
name|k
operator|++
control|)
block|{
name|s
operator|.
name|addNode
argument_list|(
literal|"t"
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
name|session
operator|.
name|save
argument_list|()
expr_stmt|;
block|}
block|}
decl_stmt|;
name|double
name|t
init|=
name|test
operator|.
name|run
argument_list|()
decl_stmt|;
name|executionTimes
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding 100 siblings next to {} siblings took {} ns/node"
argument_list|,
name|scale
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|boolean
name|knownIssue
init|=
name|fixture
operator|.
name|getClass
argument_list|()
operator|==
name|DocumentFixture
operator|.
name|class
decl_stmt|;
comment|// FIXME OAK-1698
name|assertOnLgn
argument_list|(
literal|"many siblings"
argument_list|,
name|scales
argument_list|,
name|executionTimes
argument_list|,
name|knownIssue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Assert processing of pending observation events scales linearly with the      * number of pending events.      * @throws RepositoryException      * @throws InterruptedException      */
annotation|@
name|Test
specifier|public
name|void
name|largeNumberOfPendingEvents
parameter_list|()
throws|throws
name|RepositoryException
throws|,
name|InterruptedException
block|{
specifier|final
name|Node
name|n
init|=
name|session
operator|.
name|getRootNode
argument_list|()
operator|.
name|addNode
argument_list|(
literal|"pending-events"
argument_list|,
literal|"oak:Unstructured"
argument_list|)
decl_stmt|;
specifier|final
name|ContentGenerator
name|contentGenerator
init|=
operator|new
name|ContentGenerator
argument_list|(
literal|1000
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Double
argument_list|>
name|executionTimes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|scale
range|:
name|scales
control|)
block|{
specifier|final
name|Observer
name|observer
init|=
operator|new
name|Observer
argument_list|(
name|scale
argument_list|,
literal|100
argument_list|)
decl_stmt|;
try|try
block|{
name|ScalabilityTest
name|test
init|=
operator|new
name|ScalabilityTest
argument_list|(
name|scale
argument_list|)
block|{
annotation|@
name|Override
name|void
name|before
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|contentGenerator
operator|.
name|addNodes
argument_list|(
name|n
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|run
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|observer
operator|.
name|waitForEvents
argument_list|(
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|double
name|t
init|=
name|test
operator|.
name|run
argument_list|()
decl_stmt|;
name|executionTimes
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} pending events took {} ns/event to process"
argument_list|,
name|scale
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|observer
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignore
parameter_list|)
block|{}
block|}
block|}
name|boolean
name|knownIssue
init|=
name|fixture
operator|.
name|getClass
argument_list|()
operator|==
name|DocumentFixture
operator|.
name|class
decl_stmt|;
comment|// FIXME OAK-1698
name|assertOnLgn
argument_list|(
literal|"large number of pending events"
argument_list|,
name|scales
argument_list|,
name|executionTimes
argument_list|,
name|knownIssue
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|slowListener
parameter_list|()
throws|throws
name|RepositoryException
throws|,
name|ExecutionException
throws|,
name|InterruptedException
block|{
name|Node
name|n
init|=
name|session
operator|.
name|getRootNode
argument_list|()
operator|.
name|addNode
argument_list|(
literal|"slow-events"
argument_list|,
literal|"oak:Unstructured"
argument_list|)
decl_stmt|;
specifier|final
name|DelayedEventHandling
name|delayedEventHandling
init|=
operator|new
name|DelayedEventHandling
argument_list|(
name|n
argument_list|,
literal|100
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|Void
argument_list|>
name|result
init|=
name|delayedEventHandling
operator|.
name|start
argument_list|()
decl_stmt|;
try|try
block|{
name|ArrayList
argument_list|<
name|Double
argument_list|>
name|executionTimes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|scale
range|:
name|scales
control|)
block|{
name|ScalabilityTest
name|test
init|=
operator|new
name|ScalabilityTest
argument_list|(
name|scale
argument_list|)
block|{
annotation|@
name|Override
name|void
name|run
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|delayedEventHandling
operator|.
name|waitForNodes
argument_list|(
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|double
name|t
init|=
name|test
operator|.
name|run
argument_list|()
decl_stmt|;
name|executionTimes
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding {} nodes took {} ns/node"
argument_list|,
name|scale
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|boolean
name|knownIssue
init|=
name|fixture
operator|.
name|getClass
argument_list|()
operator|==
name|DocumentFixture
operator|.
name|class
decl_stmt|;
comment|// FIXME OAK-1698
name|assertOnLgn
argument_list|(
literal|"slow listeners"
argument_list|,
name|scales
argument_list|,
name|executionTimes
argument_list|,
name|knownIssue
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|delayedEventHandling
operator|.
name|stop
argument_list|()
expr_stmt|;
name|result
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
comment|//------------------------------------------------------------< ContentGenerator>---
specifier|private
specifier|static
class|class
name|ContentGenerator
block|{
specifier|private
specifier|static
specifier|final
name|int
name|FAN_OUT
init|=
literal|10
decl_stmt|;
specifier|private
specifier|final
name|int
name|saveInterval
decl_stmt|;
specifier|private
name|int
name|count
decl_stmt|;
specifier|public
name|ContentGenerator
parameter_list|(
name|int
name|saveInterval
parameter_list|)
block|{
name|this
operator|.
name|saveInterval
operator|=
name|saveInterval
expr_stmt|;
block|}
specifier|public
name|ContentGenerator
parameter_list|()
block|{
name|this
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addNodes
parameter_list|(
name|Node
name|node
parameter_list|,
name|int
name|count
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding {} nodes to {}"
argument_list|,
name|count
argument_list|,
name|node
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
while|while
condition|(
name|createContent
argument_list|(
name|node
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|saveInterval
operator|<
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|node
operator|.
name|getSession
argument_list|()
operator|.
name|save
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|createContent
parameter_list|(
name|Node
name|node
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|NodeIterator
name|nodes
init|=
name|node
operator|.
name|getNodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|hasNext
argument_list|()
condition|)
block|{
while|while
condition|(
name|nodes
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|createContent
argument_list|(
name|nodes
operator|.
name|nextNode
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
name|boolean
name|result
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|FAN_OUT
operator|&&
operator|(
name|result
operator|=
name|addNode
argument_list|(
name|node
argument_list|)
operator|)
condition|;
name|c
operator|++
control|)
empty_stmt|;
return|return
name|result
return|;
block|}
block|}
name|boolean
name|addNode
parameter_list|(
name|Node
name|node
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|node
operator|.
name|addNode
argument_list|(
literal|"n"
operator|+
name|count
operator|--
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|%
name|saveInterval
operator|==
literal|0
condition|)
block|{
name|node
operator|.
name|getSession
argument_list|()
operator|.
name|save
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|%
literal|1000
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"add {}"
argument_list|,
name|node
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|isDone
argument_list|()
return|;
block|}
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|count
operator|==
literal|0
return|;
block|}
block|}
comment|//------------------------------------------------------------< ScalabilityTest>---
specifier|private
specifier|abstract
specifier|static
class|class
name|ScalabilityTest
block|{
specifier|private
specifier|final
name|int
name|scale
decl_stmt|;
specifier|protected
name|ScalabilityTest
parameter_list|(
name|int
name|scale
parameter_list|)
block|{
name|this
operator|.
name|scale
operator|=
name|scale
expr_stmt|;
block|}
name|void
name|before
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|RepositoryException
block|{}
specifier|abstract
name|void
name|run
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|RepositoryException
throws|,
name|InterruptedException
function_decl|;
name|void
name|after
parameter_list|(
name|int
name|scale
parameter_list|)
block|{}
specifier|public
name|long
name|run
parameter_list|()
throws|throws
name|RepositoryException
throws|,
name|InterruptedException
block|{
name|before
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|long
name|t0
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|run
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|long
name|dt
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|t0
decl_stmt|;
name|after
argument_list|(
name|scale
argument_list|)
expr_stmt|;
return|return
name|dt
operator|/
name|scale
return|;
block|}
block|}
comment|//------------------------------------------------------------< Observer>---
specifier|private
class|class
name|Observer
implements|implements
name|EventListener
block|{
specifier|private
specifier|final
name|CountDownLatch
name|start
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|int
name|eventCount
decl_stmt|;
specifier|private
specifier|final
name|int
name|listenerCount
decl_stmt|;
specifier|private
specifier|final
name|Session
index|[]
name|sessions
decl_stmt|;
specifier|private
name|CountDownLatch
name|done
decl_stmt|;
specifier|public
name|Observer
parameter_list|(
name|int
name|eventCount
parameter_list|,
name|int
name|listenerCount
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|this
operator|.
name|eventCount
operator|=
name|eventCount
expr_stmt|;
name|this
operator|.
name|listenerCount
operator|=
name|listenerCount
expr_stmt|;
name|this
operator|.
name|sessions
operator|=
operator|new
name|Session
index|[
name|listenerCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|sessions
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
name|sessions
index|[
name|k
index|]
operator|=
name|createAdminSession
argument_list|()
expr_stmt|;
name|sessions
index|[
name|k
index|]
operator|.
name|getWorkspace
argument_list|()
operator|.
name|getObservationManager
argument_list|()
operator|.
name|addEventListener
argument_list|(
name|this
argument_list|,
name|NODE_ADDED
argument_list|,
literal|"/"
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|waitForEvents
parameter_list|(
name|int
name|scale
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|done
operator|=
operator|new
name|CountDownLatch
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|start
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|done
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|dispose
parameter_list|()
block|{
for|for
control|(
name|Session
name|session
range|:
name|sessions
control|)
block|{
name|safeLogout
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onEvent
parameter_list|(
name|EventIterator
name|events
parameter_list|)
block|{
try|try
block|{
name|start
operator|.
name|await
argument_list|()
expr_stmt|;
while|while
condition|(
name|events
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|events
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
name|done
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//------------------------------------------------------------< DelayedEventHandling>---
specifier|private
class|class
name|DelayedEventHandling
implements|implements
name|EventListener
block|{
specifier|private
specifier|final
name|ExecutorService
name|executor
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Semaphore
name|openEvents
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|CountDownLatch
argument_list|>
name|nodeCounter
init|=
operator|new
name|AtomicReference
argument_list|<
name|CountDownLatch
argument_list|>
argument_list|(
operator|new
name|CountDownLatch
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Node
name|node
decl_stmt|;
specifier|private
specifier|final
name|int
name|listenerCount
decl_stmt|;
specifier|private
specifier|final
name|int
name|saveInterval
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|done
decl_stmt|;
specifier|private
name|DelayedEventHandling
parameter_list|(
name|Node
name|node
parameter_list|,
name|int
name|listenerCount
parameter_list|,
name|int
name|saveInterval
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|listenerCount
operator|=
name|listenerCount
expr_stmt|;
name|this
operator|.
name|saveInterval
operator|=
name|saveInterval
expr_stmt|;
block|}
specifier|public
name|Future
argument_list|<
name|Void
argument_list|>
name|start
parameter_list|()
block|{
return|return
name|executor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Session
index|[]
name|sessions
init|=
operator|new
name|Session
index|[
name|listenerCount
index|]
decl_stmt|;
name|ContentGenerator
name|contentGenerator
init|=
operator|new
name|ContentGenerator
argument_list|(
name|saveInterval
argument_list|)
block|{
name|int
name|nodeCount
decl_stmt|;
annotation|@
name|Override
name|boolean
name|addNode
parameter_list|(
name|Node
name|node
parameter_list|)
throws|throws
name|RepositoryException
block|{
name|boolean
name|result
init|=
name|super
operator|.
name|addNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|++
name|nodeCount
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|openEvents
operator|.
name|release
argument_list|(
name|sessions
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|nodeCounter
operator|.
name|get
argument_list|()
operator|.
name|countDown
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|done
return|;
block|}
block|}
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|sessions
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
name|sessions
index|[
name|k
index|]
operator|=
name|createAdminSession
argument_list|()
expr_stmt|;
name|sessions
index|[
name|k
index|]
operator|.
name|getWorkspace
argument_list|()
operator|.
name|getObservationManager
argument_list|()
operator|.
name|addEventListener
argument_list|(
name|DelayedEventHandling
operator|.
name|this
argument_list|,
name|NODE_ADDED
argument_list|,
literal|"/"
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|contentGenerator
operator|.
name|addNodes
argument_list|(
name|node
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
for|for
control|(
name|Session
name|session
range|:
name|sessions
control|)
block|{
name|safeLogout
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|void
name|waitForNodes
parameter_list|(
name|int
name|count
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|CountDownLatch
name|counter
init|=
operator|new
name|CountDownLatch
argument_list|(
name|count
argument_list|)
decl_stmt|;
name|nodeCounter
operator|.
name|set
argument_list|(
name|counter
argument_list|)
expr_stmt|;
name|counter
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onEvent
parameter_list|(
name|EventIterator
name|events
parameter_list|)
block|{
try|try
block|{
while|while
condition|(
name|events
operator|.
name|hasNext
argument_list|()
condition|)
block|{
while|while
condition|(
operator|!
name|done
operator|&&
operator|!
name|openEvents
operator|.
name|tryAcquire
argument_list|(
literal|10
argument_list|,
name|MILLISECONDS
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|done
condition|)
block|{
break|break;
block|}
name|events
operator|.
name|nextEvent
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//------------------------------------------------------------< BinomialTest>---
comment|// FIXME this class is copied from commons-math3:3.3-SNAPSHOT. Remove once 3.3 is released
comment|/**      * Implements binomial test statistics.      *<p>      * Exact test for the statistical significance of deviations from a      * theoretically expected distribution of observations into two categories.      *      * @see<a href="http://en.wikipedia.org/wiki/Binomial_test">Binomial test (Wikipedia)</a>      * @version $Id: BinomialTest.java 1532638 2013-10-16 04:29:31Z psteitz $      * @since 3.3      */
specifier|private
specifier|static
class|class
name|BinomialTest
block|{
comment|/**          * Represents an alternative hypothesis for a hypothesis test.          *          * @version $Id: AlternativeHypothesis.java 1531128 2013-10-10 22:09:25Z tn $          * @since 3.3          */
specifier|public
enum|enum
name|AlternativeHypothesis
block|{
comment|/**              * Represents a two-sided test. H0: p=p0, H1: p&ne; p0              */
name|TWO_SIDED
block|,
comment|/**              * Represents a right-sided test. H0: p&le; p0, H1: p&gt; p0.              */
name|GREATER_THAN
block|,
comment|/**              * Represents a left-sided test. H0: p&ge; p0, H1: p&lt; p0.              */
name|LESS_THAN
block|}
comment|/**          * Returns whether the null hypothesis can be rejected with the given confidence level.          *<p>          *<strong>Preconditions</strong>:          *<ul>          *<li>Number of trials must be&ge; 0.</li>          *<li>Number of successes must be&ge; 0.</li>          *<li>Number of successes must be&le; number of trials.</li>          *<li>Probability must be&ge; 0 and&le; 1.</li>          *</ul>          *          * @param numberOfTrials number of trials performed          * @param numberOfSuccesses number of successes observed          * @param probability assumed probability of a single trial under the null hypothesis          * @param alternativeHypothesis type of hypothesis being evaluated (one- or two-sided)          * @param alpha significance level of the test          * @return true if the null hypothesis can be rejected with confidence {@code 1 - alpha}          * @throws org.apache.commons.math3.exception.NotPositiveException if {@code numberOfTrials} or {@code numberOfSuccesses} is negative          * @throws org.apache.commons.math3.exception.OutOfRangeException if {@code probability} is not between 0 and 1          * @throws org.apache.commons.math3.exception.MathIllegalArgumentException if {@code numberOfTrials}&lt; {@code numberOfSuccesses} or          * if {@code alternateHypothesis} is null.          * @see org.apache.jackrabbit.oak.jcr.LargeOperationIT.BinomialTest.AlternativeHypothesis          */
specifier|public
name|boolean
name|binomialTest
parameter_list|(
name|int
name|numberOfTrials
parameter_list|,
name|int
name|numberOfSuccesses
parameter_list|,
name|double
name|probability
parameter_list|,
name|AlternativeHypothesis
name|alternativeHypothesis
parameter_list|,
name|double
name|alpha
parameter_list|)
block|{
name|double
name|pValue
init|=
name|binomialTest
argument_list|(
name|numberOfTrials
argument_list|,
name|numberOfSuccesses
argument_list|,
name|probability
argument_list|,
name|alternativeHypothesis
argument_list|)
decl_stmt|;
return|return
name|pValue
operator|<
name|alpha
return|;
block|}
comment|/**          * Returns the<i>observed significance level</i>, or          *<a href="http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">p-value</a>,          * associated with a<a href="http://en.wikipedia.org/wiki/Binomial_test"> Binomial test</a>.          *<p>          * The number returned is the smallest significance level at which one can reject the null hypothesis.          * The form of the hypothesis depends on {@code alternativeHypothesis}.</p>          *<p>          * The p-Value represents the likelihood of getting a result at least as extreme as the sample,          * given the provided {@code probability} of success on a single trial. For single-sided tests,          * this value can be directly derived from the Binomial distribution. For the two-sided test,          * the implementation works as follows: we start by looking at the most extreme cases          * (0 success and n success where n is the number of trials from the sample) and determine their likelihood.          * The lower value is added to the p-Value (if both values are equal, both are added). Then we continue with          * the next extreme value, until we added the value for the actual observed sample.</p>          *<p>          *<strong>Preconditions</strong>:          *<ul>          *<li>Number of trials must be&ge; 0.</li>          *<li>Number of successes must be&ge; 0.</li>          *<li>Number of successes must be&le; number of trials.</li>          *<li>Probability must be&ge; 0 and&le; 1.</li>          *</ul></p>          *          * @param numberOfTrials number of trials performed          * @param numberOfSuccesses number of successes observed          * @param probability assumed probability of a single trial under the null hypothesis          * @param alternativeHypothesis type of hypothesis being evaluated (one- or two-sided)          * @return p-value          * @throws org.apache.commons.math3.exception.NotPositiveException if {@code numberOfTrials} or {@code numberOfSuccesses} is negative          * @throws org.apache.commons.math3.exception.OutOfRangeException if {@code probability} is not between 0 and 1          * @throws org.apache.commons.math3.exception.MathIllegalArgumentException if {@code numberOfTrials}&lt; {@code numberOfSuccesses} or          * if {@code alternateHypothesis} is null.          * @see org.apache.jackrabbit.oak.jcr.LargeOperationIT.BinomialTest.AlternativeHypothesis          */
specifier|public
name|double
name|binomialTest
parameter_list|(
name|int
name|numberOfTrials
parameter_list|,
name|int
name|numberOfSuccesses
parameter_list|,
name|double
name|probability
parameter_list|,
name|AlternativeHypothesis
name|alternativeHypothesis
parameter_list|)
block|{
if|if
condition|(
name|numberOfTrials
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|NotPositiveException
argument_list|(
name|numberOfTrials
argument_list|)
throw|;
block|}
if|if
condition|(
name|numberOfSuccesses
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|NotPositiveException
argument_list|(
name|numberOfSuccesses
argument_list|)
throw|;
block|}
if|if
condition|(
name|probability
argument_list|<
literal|0
operator|||
name|probability
argument_list|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|OutOfRangeException
argument_list|(
name|probability
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
throw|;
block|}
if|if
condition|(
name|numberOfTrials
operator|<
name|numberOfSuccesses
condition|)
block|{
throw|throw
operator|new
name|MathIllegalArgumentException
argument_list|(
name|LocalizedFormats
operator|.
name|BINOMIAL_INVALID_PARAMETERS_ORDER
argument_list|,
name|numberOfTrials
argument_list|,
name|numberOfSuccesses
argument_list|)
throw|;
block|}
if|if
condition|(
name|alternativeHypothesis
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullArgumentException
argument_list|()
throw|;
block|}
specifier|final
name|BinomialDistribution
name|distribution
init|=
operator|new
name|BinomialDistribution
argument_list|(
name|numberOfTrials
argument_list|,
name|probability
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|alternativeHypothesis
condition|)
block|{
case|case
name|GREATER_THAN
case|:
return|return
literal|1
operator|-
name|distribution
operator|.
name|cumulativeProbability
argument_list|(
name|numberOfSuccesses
operator|-
literal|1
argument_list|)
return|;
case|case
name|LESS_THAN
case|:
return|return
name|distribution
operator|.
name|cumulativeProbability
argument_list|(
name|numberOfSuccesses
argument_list|)
return|;
case|case
name|TWO_SIDED
case|:
name|int
name|criticalValueLow
init|=
literal|0
decl_stmt|;
name|int
name|criticalValueHigh
init|=
name|numberOfTrials
decl_stmt|;
name|double
name|pTotal
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|double
name|pLow
init|=
name|distribution
operator|.
name|probability
argument_list|(
name|criticalValueLow
argument_list|)
decl_stmt|;
name|double
name|pHigh
init|=
name|distribution
operator|.
name|probability
argument_list|(
name|criticalValueHigh
argument_list|)
decl_stmt|;
if|if
condition|(
name|pLow
operator|==
name|pHigh
condition|)
block|{
name|pTotal
operator|+=
literal|2
operator|*
name|pLow
expr_stmt|;
name|criticalValueLow
operator|++
expr_stmt|;
name|criticalValueHigh
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pLow
operator|<
name|pHigh
condition|)
block|{
name|pTotal
operator|+=
name|pLow
expr_stmt|;
name|criticalValueLow
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pTotal
operator|+=
name|pHigh
expr_stmt|;
name|criticalValueHigh
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|criticalValueLow
operator|>
name|numberOfSuccesses
operator|||
name|criticalValueHigh
operator|<
name|numberOfSuccesses
condition|)
block|{
break|break;
block|}
block|}
return|return
name|pTotal
return|;
default|default:
throw|throw
operator|new
name|MathInternalError
argument_list|(
name|LocalizedFormats
operator|.
name|OUT_OF_RANGE_SIMPLE
argument_list|,
name|alternativeHypothesis
argument_list|,
name|AlternativeHypothesis
operator|.
name|TWO_SIDED
argument_list|,
name|AlternativeHypothesis
operator|.
name|LESS_THAN
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

