begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|rdb
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateUtils
operator|.
name|checkConditions
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DatabaseMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSetMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Deflater
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPOutputStream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|sql
operator|.
name|DataSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|cache
operator|.
name|CacheStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|cache
operator|.
name|CacheValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentMK
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentStoreException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Revision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|StableRevisionComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Key
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Operation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|cache
operator|.
name|CacheInvalidationStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|mongo
operator|.
name|MongoDocumentStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|StringValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|Cache
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Striped
import|;
end_import

begin_comment
comment|/**  * Implementation of {@link DocumentStore} for relational databases.  *   *<h3>Supported Databases</h3>  *<p>  * The code is supposed to be sufficiently generic to run with a variety of  * database implementations. However, the tables are created when required to  * simplify testing, and<em>that</em> code specifically supports these  * databases:  *<ul>  *<li>h2</li>  *<li>IBM DB2</li>  *<li>Postgres</li>  *<li>MariaDB (MySQL) (experimental)</li>  *<li>Oracle (experimental)</li>  *</ul>  *   *<h3>Table Layout</h3>  *<p>  * Data for each of the DocumentStore's {@link Collection}s is stored in its own  * database table (with a name matching the collection).  *<p>  * The tables essentially implement key/value storage, where the key usually is  * derived from an Oak path, and the value is a serialization of a  * {@link Document} (or a part of one). Additional fields are used for queries,  * debugging, and concurrency control:  *<table style="text-align: left;">  *<thead>  *<tr>  *<th>Column</th>  *<th>Type</th>  *<th>Description</th>  *</tr>  *</thead><tbody>  *<tr>  *<th>ID</th>  *<td>varchar(512) not null primary key</td>  *<td>the document's key (for databases that can not handle 512 character  * primary keys, such as MySQL, varbinary is possible as well; note that this  * currently needs to be hardcoded)</td>  *</tr>  *<tr>  *<th>MODIFIED</th>  *<td>bigint</td>  *<td>low-resolution timestamp  *</tr>  *<tr>  *<th>HASBINARY</th>  *<td>smallint</td>  *<td>flag indicating whether the document has binary properties  *</tr>  *<tr>  *<th>DELETEDONCE</th>  *<td>smallint</td>  *<td>flag indicating whether the document has been deleted once  *</tr>  *<tr>  *<th>MODCOUNT</th>  *<td>bigint</td>  *<td>modification counter, used for avoiding overlapping updates</td>  *</tr>  *<tr>  *<th>DSIZE</th>  *<td>bigint</td>  *<td>the approximate size of the document's JSON serialization (for debugging  * purposes)</td>  *</tr>  *<tr>  *<th>DATA</th>  *<td>varchar(16384)</td>  *<td>the document's JSON serialization (only used for small document sizes, in  * which case BDATA (below) is not set), or a sequence of JSON serialized update  * operations to be applied against the last full serialization</td>  *</tr>  *<tr>  *<th>BDATA</th>  *<td>blob</td>  *<td>the document's JSON serialization (usually GZIPped, only used for "large"  * documents)</td>  *</tr>  *</tbody>  *</table>  *<p>  * The names of database tables can be prefixed; the purpose is mainly for  * testing, as tables can also be dropped automatically when the store is  * disposed (this only happens for those tables that have been created on  * demand)  *<p>  *<em>Note that the database needs to be created/configured to support all Unicode  * characters in text fields, and to collate by Unicode code point (in DB2: "collate using identity",  * in Postgres: "C").  * THIS IS NOT THE DEFAULT!</em>  *<p>  *<em>For MySQL, the database parameter "max_allowed_packet" needs to be increased to support ~16 blobs.</em>  *   *<h3>Caching</h3>  *<p>  * The cache borrows heavily from the {@link MongoDocumentStore} implementation;  * however it does not support the off-heap mechanism yet.  *   *<h3>Queries</h3>  *<p>  * The implementation currently supports only three indexed properties:  * "_bin", "deletedOnce", and "_modified". Attempts to use a different indexed property will  * cause a {@link DocumentStoreException}.  */
end_comment

begin_class
specifier|public
class|class
name|RDBDocumentStore
implements|implements
name|DocumentStore
block|{
comment|/**      * Creates a {@linkplain RDBDocumentStore} instance using the provided      * {@link DataSource}, {@link DocumentMK.Builder}, and {@link RDBOptions}.      */
specifier|public
name|RDBDocumentStore
parameter_list|(
name|DataSource
name|ds
parameter_list|,
name|DocumentMK
operator|.
name|Builder
name|builder
parameter_list|,
name|RDBOptions
name|options
parameter_list|)
block|{
try|try
block|{
name|initialize
argument_list|(
name|ds
argument_list|,
name|builder
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"initializing RDB document store"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates a {@linkplain RDBDocumentStore} instance using the provided      * {@link DataSource}, {@link DocumentMK.Builder}, and default      * {@link RDBOptions}.      */
specifier|public
name|RDBDocumentStore
parameter_list|(
name|DataSource
name|ds
parameter_list|,
name|DocumentMK
operator|.
name|Builder
name|builder
parameter_list|)
block|{
name|this
argument_list|(
name|ds
argument_list|,
name|builder
argument_list|,
operator|new
name|RDBOptions
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|find
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
return|return
name|find
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|find
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
specifier|final
name|String
name|id
parameter_list|,
name|int
name|maxCacheAge
parameter_list|)
block|{
return|return
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|maxCacheAge
argument_list|)
return|;
block|}
annotation|@
name|Nonnull
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|query
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|query
argument_list|(
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Nonnull
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|query
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|String
name|indexedProperty
parameter_list|,
name|long
name|startValue
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|internalQuery
argument_list|(
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
name|indexedProperty
argument_list|,
name|startValue
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|remove
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|delete
argument_list|(
name|collection
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|remove
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
block|{
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|delete
argument_list|(
name|collection
argument_list|,
name|ids
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|int
name|remove
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
name|toRemove
parameter_list|)
block|{
name|int
name|num
init|=
name|delete
argument_list|(
name|collection
argument_list|,
name|toRemove
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|id
range|:
name|toRemove
operator|.
name|keySet
argument_list|()
control|)
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|create
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updateOps
parameter_list|)
block|{
return|return
name|internalCreate
argument_list|(
name|collection
argument_list|,
name|updateOps
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|update
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|,
name|UpdateOp
name|updateOp
parameter_list|)
block|{
name|internalUpdate
argument_list|(
name|collection
argument_list|,
name|keys
argument_list|,
name|updateOp
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|createOrUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
return|return
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|findAndUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
return|return
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CacheInvalidationStats
name|invalidateCache
parameter_list|()
block|{
for|for
control|(
name|NodeDocument
name|nd
range|:
name|nodesCache
operator|.
name|asMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|nd
operator|.
name|markUpToDate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|invalidateCache
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|invalidateCache
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|,
name|boolean
name|remove
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|invalidateNodesCache
argument_list|(
name|id
argument_list|,
name|remove
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|invalidateNodesCache
parameter_list|(
name|String
name|id
parameter_list|,
name|boolean
name|remove
parameter_list|)
block|{
name|StringValue
name|key
init|=
operator|new
name|StringValue
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|Lock
name|lock
init|=
name|getAndLock
argument_list|(
name|id
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|remove
condition|)
block|{
name|nodesCache
operator|.
name|invalidate
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NodeDocument
name|entry
init|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|markUpToDate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// used for diagnostics
specifier|private
name|String
name|droppedTables
init|=
literal|""
decl_stmt|;
specifier|public
name|String
name|getDroppedTables
parameter_list|()
block|{
return|return
name|this
operator|.
name|droppedTables
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|dispose
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|tablesToBeDropped
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|dropped
init|=
literal|""
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempting to drop: "
operator|+
name|this
operator|.
name|tablesToBeDropped
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|tname
range|:
name|this
operator|.
name|tablesToBeDropped
control|)
block|{
name|Connection
name|con
init|=
literal|null
decl_stmt|;
try|try
block|{
name|con
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
literal|"drop table "
operator|+
name|tname
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
name|dropped
operator|+=
name|tname
operator|+
literal|" "
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempting to drop: "
operator|+
name|tname
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeStatement
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempting to drop: "
operator|+
name|tname
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|con
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|droppedTables
operator|=
name|dropped
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|ch
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|getIfCached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|!=
name|Collection
operator|.
name|NODES
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|NodeDocument
name|doc
init|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
operator|new
name|StringValue
argument_list|(
name|id
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|castAsT
argument_list|(
name|doc
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|CacheStats
name|getCacheStats
parameter_list|()
block|{
return|return
name|this
operator|.
name|cacheStats
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getMetadata
parameter_list|()
block|{
return|return
name|metadata
return|;
block|}
comment|// implementation
enum|enum
name|FETCHFIRSTSYNTAX
block|{
name|FETCHFIRST
block|,
name|LIMIT
block|,
name|TOP
block|}
empty_stmt|;
specifier|private
specifier|static
name|void
name|versionCheck
parameter_list|(
name|DatabaseMetaData
name|md
parameter_list|,
name|int
name|xmaj
parameter_list|,
name|int
name|xmin
parameter_list|,
name|String
name|description
parameter_list|)
throws|throws
name|SQLException
block|{
name|int
name|maj
init|=
name|md
operator|.
name|getDatabaseMajorVersion
argument_list|()
decl_stmt|;
name|int
name|min
init|=
name|md
operator|.
name|getDatabaseMinorVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|maj
operator|<
name|xmaj
operator|||
operator|(
name|maj
operator|==
name|xmaj
operator|&&
name|min
operator|<
name|xmin
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unsupported "
operator|+
name|description
operator|+
literal|" version: "
operator|+
name|maj
operator|+
literal|"."
operator|+
name|min
operator|+
literal|", expected at least "
operator|+
name|xmaj
operator|+
literal|"."
operator|+
name|xmin
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Defines variation in the capabilities of different RDBs.      */
specifier|protected
enum|enum
name|DB
block|{
name|DEFAULT
argument_list|(
literal|"default"
argument_list|)
block|{         }
block|,
name|H2
argument_list|(
literal|"H2"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|checkVersion
parameter_list|(
name|DatabaseMetaData
name|md
parameter_list|)
throws|throws
name|SQLException
block|{
name|versionCheck
argument_list|(
name|md
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
block|}
block|,
name|POSTGRES
argument_list|(
literal|"PostgreSQL"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|checkVersion
parameter_list|(
name|DatabaseMetaData
name|md
parameter_list|)
throws|throws
name|SQLException
block|{
name|versionCheck
argument_list|(
name|md
argument_list|,
literal|9
argument_list|,
literal|3
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getTableCreationStatement
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
return|return
operator|(
literal|"create table "
operator|+
name|tableName
operator|+
literal|" (ID varchar(512) not null primary key, MODIFIED bigint, HASBINARY smallint, DELETEDONCE smallint, MODCOUNT bigint, CMODCOUNT bigint, DSIZE bigint, DATA varchar(16384), BDATA bytea)"
operator|)
return|;
block|}
block|}
block|,
name|DB2
argument_list|(
literal|"DB2"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|checkVersion
parameter_list|(
name|DatabaseMetaData
name|md
parameter_list|)
throws|throws
name|SQLException
block|{
name|versionCheck
argument_list|(
name|md
argument_list|,
literal|10
argument_list|,
literal|5
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
block|}
block|,
name|ORACLE
argument_list|(
literal|"Oracle"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|checkVersion
parameter_list|(
name|DatabaseMetaData
name|md
parameter_list|)
throws|throws
name|SQLException
block|{
name|versionCheck
argument_list|(
name|md
argument_list|,
literal|12
argument_list|,
literal|1
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getInitializationStatement
parameter_list|()
block|{
comment|// see https://issues.apache.org/jira/browse/OAK-1914
comment|// for some reason, the default for NLS_SORT is incorrect
return|return
operator|(
literal|"ALTER SESSION SET NLS_SORT='BINARY'"
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getTableCreationStatement
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
comment|// see https://issues.apache.org/jira/browse/OAK-1914
return|return
operator|(
literal|"create table "
operator|+
name|tableName
operator|+
literal|" (ID varchar(512) not null primary key, MODIFIED number, HASBINARY number, DELETEDONCE number, MODCOUNT number, CMODCOUNT number, DSIZE number, DATA varchar(4000), BDATA blob)"
operator|)
return|;
block|}
block|}
block|,
name|MYSQL
argument_list|(
literal|"MySQL"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|checkVersion
parameter_list|(
name|DatabaseMetaData
name|md
parameter_list|)
throws|throws
name|SQLException
block|{
name|versionCheck
argument_list|(
name|md
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isPrimaryColumnByteEncoded
parameter_list|()
block|{
comment|// TODO: we should dynamically detect this
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getTableCreationStatement
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
comment|// see https://issues.apache.org/jira/browse/OAK-1913
return|return
operator|(
literal|"create table "
operator|+
name|tableName
operator|+
literal|" (ID varbinary(512) not null primary key, MODIFIED bigint, HASBINARY smallint, DELETEDONCE smallint, MODCOUNT bigint, CMODCOUNT bigint, DSIZE bigint, DATA varchar(16000), BDATA longblob)"
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FETCHFIRSTSYNTAX
name|getFetchFirstSyntax
parameter_list|()
block|{
return|return
name|FETCHFIRSTSYNTAX
operator|.
name|LIMIT
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getConcatQueryString
parameter_list|(
name|int
name|dataOctetLimit
parameter_list|,
name|int
name|dataLength
parameter_list|)
block|{
return|return
literal|"CONCAT(DATA, ?)"
return|;
block|}
block|}
block|,
name|MSSQL
argument_list|(
literal|"Microsoft SQL Server"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|checkVersion
parameter_list|(
name|DatabaseMetaData
name|md
parameter_list|)
throws|throws
name|SQLException
block|{
name|versionCheck
argument_list|(
name|md
argument_list|,
literal|11
argument_list|,
literal|0
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isPrimaryColumnByteEncoded
parameter_list|()
block|{
comment|// TODO: we should dynamically detect this
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getTableCreationStatement
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
comment|// see https://issues.apache.org/jira/browse/OAK-2395
return|return
operator|(
literal|"create table "
operator|+
name|tableName
operator|+
literal|" (ID varbinary(512) not null primary key, MODIFIED bigint, HASBINARY smallint, DELETEDONCE smallint, MODCOUNT bigint, CMODCOUNT bigint, DSIZE bigint, DATA nvarchar(4000), BDATA varbinary(max))"
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FETCHFIRSTSYNTAX
name|getFetchFirstSyntax
parameter_list|()
block|{
return|return
name|FETCHFIRSTSYNTAX
operator|.
name|TOP
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getConcatQueryString
parameter_list|(
name|int
name|dataOctetLimit
parameter_list|,
name|int
name|dataLength
parameter_list|)
block|{
comment|/*                  * To avoid truncation when concatenating force an error when                  * limit is above the octet limit                  */
return|return
literal|"CASE WHEN LEN(DATA)<= "
operator|+
operator|(
name|dataOctetLimit
operator|-
name|dataLength
operator|)
operator|+
literal|" THEN (DATA + CAST(? AS nvarchar("
operator|+
name|dataOctetLimit
operator|+
literal|"))) ELSE (DATA + CAST(DATA AS nvarchar(max))) END"
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getGreatestQueryString
parameter_list|(
name|String
name|column
parameter_list|)
block|{
return|return
literal|"(select MAX(mod) from (VALUES ("
operator|+
name|column
operator|+
literal|"), (?)) AS ALLMOD(mod))"
return|;
block|}
block|}
block|;
comment|/**          * Check the database brand and version          */
specifier|public
name|void
name|checkVersion
parameter_list|(
name|DatabaseMetaData
name|md
parameter_list|)
throws|throws
name|SQLException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unknown database type: "
operator|+
name|md
operator|.
name|getDatabaseProductName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**          * If the primary column is encoded in bytes.          * Default false          * @return boolean          */
specifier|public
name|boolean
name|isPrimaryColumnByteEncoded
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**          * Allows case in select. Default true.          */
specifier|public
name|boolean
name|allowsCaseInSelect
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**          * Query syntax for "FETCH FIRST"          */
specifier|public
name|FETCHFIRSTSYNTAX
name|getFetchFirstSyntax
parameter_list|()
block|{
return|return
name|FETCHFIRSTSYNTAX
operator|.
name|FETCHFIRST
return|;
block|}
comment|/**          * Returns the CONCAT function or its equivalent function or sub-query.          * Note that the function MUST NOT cause a truncated value to be          * written!          *          * @param dataOctetLimit          *            expected capacity of data column          * @param dataLength          *            length of string to be inserted          *           * @return the concat query string          */
specifier|public
name|String
name|getConcatQueryString
parameter_list|(
name|int
name|dataOctetLimit
parameter_list|,
name|int
name|dataLength
parameter_list|)
block|{
return|return
literal|"DATA || CAST(? AS varchar("
operator|+
name|dataOctetLimit
operator|+
literal|"))"
return|;
block|}
comment|/**          * Returns the GREATEST function or its equivalent function or sub-query          * supported.          *          * @return the greatest query string          */
specifier|public
name|String
name|getGreatestQueryString
parameter_list|(
name|String
name|column
parameter_list|)
block|{
return|return
literal|"GREATEST("
operator|+
name|column
operator|+
literal|", ?)"
return|;
block|}
comment|/**          * Query for any required initialization of the DB.          *           * @return the DB initialization SQL string          */
specifier|public
annotation|@
name|Nonnull
name|String
name|getInitializationStatement
parameter_list|()
block|{
return|return
literal|""
return|;
block|}
comment|/**          * Table creation statement string          *          * @param tableName          * @return the table creation string          */
specifier|public
name|String
name|getTableCreationStatement
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
return|return
literal|"create table "
operator|+
name|tableName
operator|+
literal|" (ID varchar(512) not null primary key, MODIFIED bigint, HASBINARY smallint, DELETEDONCE smallint, MODCOUNT bigint, CMODCOUNT bigint, DSIZE bigint, DATA varchar(16384), BDATA blob("
operator|+
literal|1024
operator|*
literal|1024
operator|*
literal|1024
operator|+
literal|"))"
return|;
block|}
specifier|protected
name|String
name|description
decl_stmt|;
specifier|private
name|DB
parameter_list|(
name|String
name|description
parameter_list|)
block|{
name|this
operator|.
name|description
operator|=
name|description
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|description
return|;
block|}
annotation|@
name|Nonnull
specifier|public
specifier|static
name|DB
name|getValue
parameter_list|(
name|String
name|desc
parameter_list|)
block|{
for|for
control|(
name|DB
name|db
range|:
name|DB
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|db
operator|.
name|description
operator|.
name|equals
argument_list|(
name|desc
argument_list|)
condition|)
block|{
return|return
name|db
return|;
block|}
elseif|else
if|if
condition|(
name|db
operator|==
name|DB2
operator|&&
name|desc
operator|.
name|startsWith
argument_list|(
literal|"DB2/"
argument_list|)
condition|)
block|{
return|return
name|db
return|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"DB type "
operator|+
name|desc
operator|+
literal|" unknown, trying default settings"
argument_list|)
expr_stmt|;
name|DEFAULT
operator|.
name|description
operator|=
name|desc
operator|+
literal|" - using default settings"
expr_stmt|;
return|return
name|DEFAULT
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|String
name|MODIFIED
init|=
literal|"_modified"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|MODCOUNT
init|=
literal|"_modCount"
decl_stmt|;
comment|/**      * Optional counter for changes to "_collisions" map ({@link NodeDocument#COLLISIONS}).      */
specifier|private
specifier|static
specifier|final
name|String
name|COLLISIONSMODCOUNT
init|=
literal|"_collisionsModCount"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ID
init|=
literal|"_id"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RDBDocumentStore
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Comparator
argument_list|<
name|Revision
argument_list|>
name|comparator
init|=
name|StableRevisionComparator
operator|.
name|REVERSE
decl_stmt|;
specifier|private
name|Exception
name|callStack
decl_stmt|;
specifier|private
name|RDBConnectionHandler
name|ch
decl_stmt|;
comment|// from options
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|tablesToBeDropped
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// table names
specifier|private
name|String
name|tnNodes
decl_stmt|,
name|tnClusterNodes
decl_stmt|,
name|tnSettings
decl_stmt|;
comment|// ratio between Java characters and UTF-8 encoding
comment|// a) single characters will fit into 3 bytes
comment|// b) a surrogate pair (two Java characters) will fit into 4 bytes
comment|// thus...
specifier|private
specifier|static
specifier|final
name|int
name|CHAR2OCTETRATIO
init|=
literal|3
decl_stmt|;
comment|// capacity of DATA column
specifier|private
name|int
name|dataLimitInOctets
init|=
literal|16384
decl_stmt|;
comment|// number of retries for updates
specifier|private
specifier|static
specifier|final
name|int
name|RETRIES
init|=
literal|10
decl_stmt|;
comment|// see OAK-2044
specifier|protected
specifier|static
specifier|final
name|boolean
name|USECMODCOUNT
init|=
literal|true
decl_stmt|;
comment|// DB-specific information
specifier|private
name|DB
name|db
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|metadata
decl_stmt|;
comment|// set of supported indexed properties
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|INDEXEDPROPERTIES
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|MODIFIED
block|,
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
block|,
name|NodeDocument
operator|.
name|DELETED_ONCE
block|}
argument_list|)
argument_list|)
decl_stmt|;
comment|// set of properties not serialized to JSON
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|COLUMNPROPERTIES
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|ID
block|,
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
block|,
name|NodeDocument
operator|.
name|DELETED_ONCE
block|,
name|COLLISIONSMODCOUNT
block|,
name|MODIFIED
block|,
name|MODCOUNT
block|}
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|RDBDocumentSerializer
name|SR
init|=
operator|new
name|RDBDocumentSerializer
argument_list|(
name|this
argument_list|,
name|COLUMNPROPERTIES
argument_list|)
decl_stmt|;
specifier|private
name|void
name|initialize
parameter_list|(
name|DataSource
name|ds
parameter_list|,
name|DocumentMK
operator|.
name|Builder
name|builder
parameter_list|,
name|RDBOptions
name|options
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|tnNodes
operator|=
name|RDBJDBCTools
operator|.
name|createTableName
argument_list|(
name|options
operator|.
name|getTablePrefix
argument_list|()
argument_list|,
literal|"NODES"
argument_list|)
expr_stmt|;
name|this
operator|.
name|tnClusterNodes
operator|=
name|RDBJDBCTools
operator|.
name|createTableName
argument_list|(
name|options
operator|.
name|getTablePrefix
argument_list|()
argument_list|,
literal|"CLUSTERNODES"
argument_list|)
expr_stmt|;
name|this
operator|.
name|tnSettings
operator|=
name|RDBJDBCTools
operator|.
name|createTableName
argument_list|(
name|options
operator|.
name|getTablePrefix
argument_list|()
argument_list|,
literal|"SETTINGS"
argument_list|)
expr_stmt|;
name|this
operator|.
name|ch
operator|=
operator|new
name|RDBConnectionHandler
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|this
operator|.
name|callStack
operator|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|?
operator|new
name|Exception
argument_list|(
literal|"call stack of RDBDocumentStore creation"
argument_list|)
else|:
literal|null
expr_stmt|;
name|this
operator|.
name|nodesCache
operator|=
name|builder
operator|.
name|buildDocumentCache
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|cacheStats
operator|=
operator|new
name|CacheStats
argument_list|(
name|nodesCache
argument_list|,
literal|"Document-Documents"
argument_list|,
name|builder
operator|.
name|getWeigher
argument_list|()
argument_list|,
name|builder
operator|.
name|getDocumentCacheSize
argument_list|()
argument_list|)
expr_stmt|;
name|Connection
name|con
init|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
decl_stmt|;
name|DatabaseMetaData
name|md
init|=
name|con
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|String
name|dbDesc
init|=
name|md
operator|.
name|getDatabaseProductName
argument_list|()
operator|+
literal|" "
operator|+
name|md
operator|.
name|getDatabaseProductVersion
argument_list|()
decl_stmt|;
name|String
name|driverDesc
init|=
name|md
operator|.
name|getDriverName
argument_list|()
operator|+
literal|" "
operator|+
name|md
operator|.
name|getDriverVersion
argument_list|()
decl_stmt|;
name|String
name|dbUrl
init|=
name|md
operator|.
name|getURL
argument_list|()
decl_stmt|;
name|this
operator|.
name|db
operator|=
name|DB
operator|.
name|getValue
argument_list|(
name|md
operator|.
name|getDatabaseProductName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metadata
operator|=
name|ImmutableMap
operator|.
expr|<
name|String
operator|,
name|String
operator|>
name|builder
argument_list|()
operator|.
name|put
argument_list|(
literal|"type"
argument_list|,
literal|"rdb"
argument_list|)
operator|.
name|put
argument_list|(
literal|"db"
argument_list|,
name|md
operator|.
name|getDatabaseProductName
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"version"
argument_list|,
name|md
operator|.
name|getDatabaseProductVersion
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|db
operator|.
name|checkVersion
argument_list|(
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
literal|""
operator|.
name|equals
argument_list|(
name|db
operator|.
name|getInitializationStatement
argument_list|()
argument_list|)
condition|)
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
name|db
operator|.
name|getInitializationStatement
argument_list|()
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeStatement
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|tablesCreated
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tablesPresent
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|createTableFor
argument_list|(
name|con
argument_list|,
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
name|tablesCreated
argument_list|,
name|tablesPresent
argument_list|)
expr_stmt|;
name|createTableFor
argument_list|(
name|con
argument_list|,
name|Collection
operator|.
name|NODES
argument_list|,
name|tablesCreated
argument_list|,
name|tablesPresent
argument_list|)
expr_stmt|;
name|createTableFor
argument_list|(
name|con
argument_list|,
name|Collection
operator|.
name|SETTINGS
argument_list|,
name|tablesCreated
argument_list|,
name|tablesPresent
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
name|con
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|.
name|isDropTablesOnClose
argument_list|()
condition|)
block|{
name|tablesToBeDropped
operator|.
name|addAll
argument_list|(
name|tablesCreated
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"RDBDocumentStore instantiated for database "
operator|+
name|dbDesc
operator|+
literal|", using driver: "
operator|+
name|driverDesc
operator|+
literal|", connecting to: "
operator|+
name|dbUrl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tablesPresent
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Tables present upon startup: "
operator|+
name|tablesPresent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tablesCreated
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Tables created upon startup: "
operator|+
name|tablesCreated
operator|+
operator|(
name|options
operator|.
name|isDropTablesOnClose
argument_list|()
condition|?
literal|" (will be dropped on exit)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|createTableFor
parameter_list|(
name|Connection
name|con
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
name|col
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tablesCreated
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tablesPresent
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|dbname
init|=
name|this
operator|.
name|db
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|con
operator|.
name|getMetaData
argument_list|()
operator|.
name|getURL
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dbname
operator|+=
literal|" ("
operator|+
name|con
operator|.
name|getMetaData
argument_list|()
operator|.
name|getURL
argument_list|()
operator|+
literal|")"
expr_stmt|;
block|}
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|col
argument_list|)
decl_stmt|;
name|PreparedStatement
name|checkStatement
init|=
literal|null
decl_stmt|;
name|ResultSet
name|checkResultSet
init|=
literal|null
decl_stmt|;
name|Statement
name|creatStatement
init|=
literal|null
decl_stmt|;
try|try
block|{
name|checkStatement
operator|=
name|con
operator|.
name|prepareStatement
argument_list|(
literal|"select DATA from "
operator|+
name|tableName
operator|+
literal|" where ID = ?"
argument_list|)
expr_stmt|;
name|checkStatement
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
literal|"0:/"
argument_list|)
expr_stmt|;
name|checkResultSet
operator|=
name|checkStatement
operator|.
name|executeQuery
argument_list|()
expr_stmt|;
if|if
condition|(
name|col
operator|.
name|equals
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|)
condition|)
block|{
comment|// try to discover size of DATA column
name|ResultSetMetaData
name|met
init|=
name|checkResultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|this
operator|.
name|dataLimitInOctets
operator|=
name|met
operator|.
name|getPrecision
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tablesPresent
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// table does not appear to exist
name|con
operator|.
name|rollback
argument_list|()
expr_stmt|;
try|try
block|{
name|creatStatement
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|creatStatement
operator|.
name|execute
argument_list|(
name|this
operator|.
name|db
operator|.
name|getTableCreationStatement
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|creatStatement
operator|.
name|close
argument_list|()
expr_stmt|;
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
name|tablesCreated
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|.
name|equals
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|)
condition|)
block|{
name|PreparedStatement
name|pstmt
init|=
name|con
operator|.
name|prepareStatement
argument_list|(
literal|"select DATA from "
operator|+
name|tableName
operator|+
literal|" where ID = ?"
argument_list|)
decl_stmt|;
name|pstmt
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
literal|"0:/"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|pstmt
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
name|ResultSetMetaData
name|met
init|=
name|rs
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|this
operator|.
name|dataLimitInOctets
operator|=
name|met
operator|.
name|getPrecision
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex2
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to create table "
operator|+
name|tableName
operator|+
literal|" in "
operator|+
name|dbname
argument_list|,
name|ex2
argument_list|)
expr_stmt|;
throw|throw
name|ex2
throw|;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeResultSet
argument_list|(
name|checkResultSet
argument_list|)
expr_stmt|;
name|this
operator|.
name|ch
operator|.
name|closeStatement
argument_list|(
name|checkStatement
argument_list|)
expr_stmt|;
name|this
operator|.
name|ch
operator|.
name|closeStatement
argument_list|(
name|creatStatement
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|finalize
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|ch
operator|!=
literal|null
operator|&&
name|this
operator|.
name|callStack
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"finalizing RDBDocumentStore that was not disposed"
argument_list|,
name|this
operator|.
name|callStack
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|readDocumentCached
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
specifier|final
name|String
name|id
parameter_list|,
name|int
name|maxCacheAge
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|!=
name|Collection
operator|.
name|NODES
condition|)
block|{
return|return
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
name|CacheValue
name|cacheKey
init|=
operator|new
name|StringValue
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|NodeDocument
name|doc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|maxCacheAge
operator|>
literal|0
condition|)
block|{
comment|// first try without lock
name|doc
operator|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|cacheKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|long
name|lastCheckTime
init|=
name|doc
operator|.
name|getLastCheckTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastCheckTime
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|maxCacheAge
operator|==
name|Integer
operator|.
name|MAX_VALUE
operator|||
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastCheckTime
operator|<
name|maxCacheAge
condition|)
block|{
return|return
name|castAsT
argument_list|(
name|unwrap
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
block|}
try|try
block|{
name|Lock
name|lock
init|=
name|getAndLock
argument_list|(
name|id
argument_list|)
decl_stmt|;
try|try
block|{
comment|// caller really wants the cache to be cleared
if|if
condition|(
name|maxCacheAge
operator|==
literal|0
condition|)
block|{
name|invalidateNodesCache
argument_list|(
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|doc
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|NodeDocument
name|cachedDoc
init|=
name|doc
decl_stmt|;
name|doc
operator|=
name|nodesCache
operator|.
name|get
argument_list|(
name|cacheKey
argument_list|,
operator|new
name|Callable
argument_list|<
name|NodeDocument
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|NodeDocument
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|NodeDocument
name|doc
init|=
operator|(
name|NodeDocument
operator|)
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|cachedDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|seal
argument_list|()
expr_stmt|;
block|}
return|return
name|wrap
argument_list|(
name|doc
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// inspect the doc whether it can be used
name|long
name|lastCheckTime
init|=
name|doc
operator|.
name|getLastCheckTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastCheckTime
operator|!=
literal|0
operator|&&
operator|(
name|maxCacheAge
operator|==
literal|0
operator|||
name|maxCacheAge
operator|==
name|Integer
operator|.
name|MAX_VALUE
operator|)
condition|)
block|{
comment|// we either just cleared the cache or the caller does
comment|// not care;
block|}
elseif|else
if|if
condition|(
name|lastCheckTime
operator|!=
literal|0
operator|&&
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastCheckTime
operator|<
name|maxCacheAge
operator|)
condition|)
block|{
comment|// is new enough
block|}
else|else
block|{
comment|// need to at least revalidate
name|NodeDocument
name|ndoc
init|=
operator|(
name|NodeDocument
operator|)
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|cachedDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|ndoc
operator|!=
literal|null
condition|)
block|{
name|ndoc
operator|.
name|seal
argument_list|()
expr_stmt|;
block|}
name|doc
operator|=
name|wrap
argument_list|(
name|ndoc
argument_list|)
expr_stmt|;
name|nodesCache
operator|.
name|put
argument_list|(
name|cacheKey
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|castAsT
argument_list|(
name|unwrap
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Failed to load document with "
operator|+
name|id
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|internalCreate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updates
parameter_list|)
block|{
try|try
block|{
comment|// try up to CHUNKSIZE ops in one transaction
for|for
control|(
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|chunks
range|:
name|Lists
operator|.
name|partition
argument_list|(
name|updates
argument_list|,
name|CHUNKSIZE
argument_list|)
control|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateOp
name|update
range|:
name|chunks
control|)
block|{
name|T
name|doc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|update
operator|.
name|increment
argument_list|(
name|MODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasChangesToCollisions
argument_list|(
name|update
argument_list|)
condition|)
block|{
name|update
operator|.
name|increment
argument_list|(
name|COLLISIONSMODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|doc
argument_list|,
name|update
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|update
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"ID mismatch - UpdateOp: "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|", ID property: "
operator|+
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
name|docs
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|insertDocuments
argument_list|(
name|collection
argument_list|,
name|docs
argument_list|)
expr_stmt|;
for|for
control|(
name|T
name|doc
range|:
name|docs
control|)
block|{
name|addToCache
argument_list|(
name|collection
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|ex
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|internalCreateOrUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|,
name|boolean
name|allowCreate
parameter_list|,
name|boolean
name|checkConditions
parameter_list|)
block|{
name|T
name|oldDoc
init|=
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|allowCreate
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|update
operator|.
name|isNew
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"Document does not exist: "
operator|+
name|update
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
name|T
name|doc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|checkConditions
operator|&&
operator|!
name|checkConditions
argument_list|(
name|doc
argument_list|,
name|update
operator|.
name|getConditions
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|update
operator|.
name|increment
argument_list|(
name|MODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasChangesToCollisions
argument_list|(
name|update
argument_list|)
condition|)
block|{
name|update
operator|.
name|increment
argument_list|(
name|COLLISIONSMODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|doc
argument_list|,
name|update
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
try|try
block|{
name|insertDocuments
argument_list|(
name|collection
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|doc
argument_list|)
argument_list|)
expr_stmt|;
name|addToCache
argument_list|(
name|collection
argument_list|,
name|doc
argument_list|)
expr_stmt|;
return|return
name|oldDoc
return|;
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|ex
parameter_list|)
block|{
comment|// may have failed due to a race condition; try update instead
comment|// this is an edge case, so it's ok to bypass the cache
comment|// (avoiding a race condition where the DB is already updated
comment|// but the cache is not)
name|oldDoc
operator|=
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// something else went wrong
name|LOG
operator|.
name|error
argument_list|(
literal|"insert failed, but document "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|" is not present, aborting"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|ex
operator|)
throw|;
block|}
return|return
name|internalUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
name|oldDoc
argument_list|,
name|checkConditions
argument_list|,
name|RETRIES
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|T
name|result
init|=
name|internalUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
name|oldDoc
argument_list|,
name|checkConditions
argument_list|,
name|RETRIES
argument_list|)
decl_stmt|;
if|if
condition|(
name|allowCreate
operator|&&
name|result
operator|==
literal|null
condition|)
block|{
comment|// TODO OAK-2655 need to implement some kind of retry
name|LOG
operator|.
name|error
argument_list|(
literal|"update of "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|" failed, race condition?"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"update of "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|" failed, race condition?"
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
block|}
comment|/**      * @return previous version of document or<code>null</code>      */
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|internalUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|,
name|T
name|oldDoc
parameter_list|,
name|boolean
name|checkConditions
parameter_list|,
name|int
name|maxRetries
parameter_list|)
block|{
name|T
name|doc
init|=
name|applyChanges
argument_list|(
name|collection
argument_list|,
name|oldDoc
argument_list|,
name|update
argument_list|,
name|checkConditions
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
comment|// conditions not met
return|return
literal|null
return|;
block|}
else|else
block|{
name|Lock
name|l
init|=
name|getAndLock
argument_list|(
name|update
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|int
name|retries
init|=
name|maxRetries
decl_stmt|;
while|while
condition|(
operator|!
name|success
operator|&&
name|retries
operator|>
literal|0
condition|)
block|{
name|long
name|lastmodcount
init|=
name|modcountOf
argument_list|(
name|oldDoc
argument_list|)
decl_stmt|;
name|success
operator|=
name|updateDocument
argument_list|(
name|collection
argument_list|,
name|doc
argument_list|,
name|update
argument_list|,
name|lastmodcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|retries
operator|-=
literal|1
expr_stmt|;
name|oldDoc
operator|=
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|long
name|newmodcount
init|=
name|modcountOf
argument_list|(
name|oldDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastmodcount
operator|==
name|newmodcount
condition|)
block|{
comment|// cached copy did not change so it probably was
comment|// updated by a different instance, get a fresh one
name|oldDoc
operator|=
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// document was there but is now gone
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to apply update because document is gone in the meantime: "
operator|+
name|update
operator|.
name|getId
argument_list|()
argument_list|,
operator|new
name|Exception
argument_list|(
literal|"call stack"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|doc
operator|=
name|applyChanges
argument_list|(
name|collection
argument_list|,
name|oldDoc
argument_list|,
name|update
argument_list|,
name|checkConditions
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|applyToCache
argument_list|(
operator|(
name|NodeDocument
operator|)
name|oldDoc
argument_list|,
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"failed update of "
operator|+
name|doc
operator|.
name|getId
argument_list|()
operator|+
literal|" (race?) after "
operator|+
name|maxRetries
operator|+
literal|" retries"
argument_list|)
throw|;
block|}
return|return
name|oldDoc
return|;
block|}
finally|finally
block|{
name|l
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|applyChanges
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|T
name|oldDoc
parameter_list|,
name|UpdateOp
name|update
parameter_list|,
name|boolean
name|checkConditions
parameter_list|)
block|{
name|T
name|doc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|oldDoc
operator|.
name|deepCopy
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkConditions
operator|&&
operator|!
name|checkConditions
argument_list|(
name|doc
argument_list|,
name|update
operator|.
name|getConditions
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|hasChangesToCollisions
argument_list|(
name|update
argument_list|)
condition|)
block|{
name|update
operator|.
name|increment
argument_list|(
name|COLLISIONSMODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|increment
argument_list|(
name|MODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|doc
argument_list|,
name|update
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|doc
operator|.
name|seal
argument_list|()
expr_stmt|;
return|return
name|doc
return|;
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|internalUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
if|if
condition|(
name|isAppendableUpdate
argument_list|(
name|update
argument_list|)
operator|&&
operator|!
name|requiresPreviousState
argument_list|(
name|update
argument_list|)
condition|)
block|{
name|long
name|modified
init|=
name|getModifiedFromUpdate
argument_list|(
name|update
argument_list|)
decl_stmt|;
name|String
name|appendData
init|=
name|SR
operator|.
name|asString
argument_list|(
name|update
argument_list|)
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|chunkedIds
range|:
name|Lists
operator|.
name|partition
argument_list|(
name|ids
argument_list|,
name|CHUNKSIZE
argument_list|)
control|)
block|{
comment|// remember what we already have in the cache
name|Map
argument_list|<
name|String
argument_list|,
name|NodeDocument
argument_list|>
name|cachedDocs
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|cachedDocs
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|NodeDocument
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|key
range|:
name|chunkedIds
control|)
block|{
name|cachedDocs
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
operator|new
name|StringValue
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|success
operator|=
name|dbBatchedAppendingUpdate
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|chunkedIds
argument_list|,
name|modified
argument_list|,
name|appendData
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|NodeDocument
argument_list|>
name|entry
range|:
name|cachedDocs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|T
name|oldDoc
init|=
name|castAsT
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// make sure concurrently loaded document is
comment|// invalidated
name|nodesCache
operator|.
name|invalidate
argument_list|(
operator|new
name|StringValue
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|T
name|newDoc
init|=
name|applyChanges
argument_list|(
name|collection
argument_list|,
name|oldDoc
argument_list|,
name|update
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDoc
operator|!=
literal|null
condition|)
block|{
name|applyToCache
argument_list|(
operator|(
name|NodeDocument
operator|)
name|oldDoc
argument_list|,
operator|(
name|NodeDocument
operator|)
name|newDoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|String
name|id
range|:
name|chunkedIds
control|)
block|{
name|UpdateOp
name|up
init|=
name|update
operator|.
name|copy
argument_list|()
decl_stmt|;
name|up
operator|=
name|up
operator|.
name|shallowCopy
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|up
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
name|UpdateOp
name|up
init|=
name|update
operator|.
name|copy
argument_list|()
decl_stmt|;
name|up
operator|=
name|up
operator|.
name|shallowCopy
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|up
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|internalQuery
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|String
name|indexedProperty
parameter_list|,
name|long
name|startValue
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexedProperty
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|INDEXEDPROPERTIES
operator|.
name|contains
argument_list|(
name|indexedProperty
argument_list|)
operator|)
condition|)
block|{
name|String
name|message
init|=
literal|"indexed property "
operator|+
name|indexedProperty
operator|+
literal|" not supported, query was '>= '"
operator|+
name|startValue
operator|+
literal|"'; supported properties are "
operator|+
name|INDEXEDPROPERTIES
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|message
argument_list|)
throw|;
block|}
try|try
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getROConnection
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|RDBRow
argument_list|>
name|dbresult
init|=
name|dbQuery
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
name|indexedProperty
argument_list|,
name|startValue
argument_list|,
name|limit
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
for|for
control|(
name|RDBRow
name|r
range|:
name|dbresult
control|)
block|{
name|T
name|doc
init|=
name|runThroughCache
argument_list|(
name|collection
argument_list|,
name|r
argument_list|,
name|now
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"SQL exception on query"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|String
name|getTable
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|CLUSTER_NODES
condition|)
block|{
return|return
name|this
operator|.
name|tnClusterNodes
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
return|return
name|this
operator|.
name|tnNodes
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|SETTINGS
condition|)
block|{
return|return
name|this
operator|.
name|tnSettings
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown collection: "
operator|+
name|collection
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|readDocumentUncached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|,
name|NodeDocument
name|cachedDoc
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|long
name|lastmodcount
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|cachedDoc
operator|!=
literal|null
condition|)
block|{
name|lastmodcount
operator|=
name|modcountOf
argument_list|(
name|cachedDoc
argument_list|)
expr_stmt|;
block|}
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getROConnection
argument_list|()
expr_stmt|;
name|RDBRow
name|row
init|=
name|dbRead
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|id
argument_list|,
name|lastmodcount
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
if|if
condition|(
name|lastmodcount
operator|==
name|row
operator|.
name|getModcount
argument_list|()
condition|)
block|{
comment|// we can re-use the cached document
name|cachedDoc
operator|.
name|markUpToDate
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|castAsT
argument_list|(
name|cachedDoc
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|SR
operator|.
name|fromRow
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|delete
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|dbDelete
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|int
name|delete
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
block|{
name|int
name|numDeleted
init|=
literal|0
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|sublist
range|:
name|Lists
operator|.
name|partition
argument_list|(
name|ids
argument_list|,
literal|64
argument_list|)
control|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|numDeleted
operator|+=
name|dbDelete
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|sublist
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|numDeleted
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|int
name|delete
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
name|toRemove
parameter_list|)
block|{
name|int
name|numDeleted
init|=
literal|0
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
name|subMap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
argument_list|>
name|it
init|=
name|toRemove
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
name|entry
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|subMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|subMap
operator|.
name|size
argument_list|()
operator|==
literal|64
operator|||
operator|!
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|numDeleted
operator|+=
name|dbDelete
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|subMap
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
name|DocumentStoreException
operator|.
name|convert
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
name|subMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|numDeleted
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|updateDocument
parameter_list|(
annotation|@
name|Nonnull
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
annotation|@
name|Nonnull
name|T
name|document
parameter_list|,
annotation|@
name|Nonnull
name|UpdateOp
name|update
parameter_list|,
name|Long
name|oldmodcount
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|Long
name|modified
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|MODIFIED
argument_list|)
decl_stmt|;
name|Number
name|flagB
init|=
operator|(
name|Number
operator|)
name|document
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
argument_list|)
decl_stmt|;
name|Boolean
name|hasBinary
init|=
name|flagB
operator|!=
literal|null
operator|&&
name|flagB
operator|.
name|intValue
argument_list|()
operator|==
name|NodeDocument
operator|.
name|HAS_BINARY_VAL
decl_stmt|;
name|Boolean
name|flagD
init|=
operator|(
name|Boolean
operator|)
name|document
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|DELETED_ONCE
argument_list|)
decl_stmt|;
name|Boolean
name|deletedOnce
init|=
name|flagD
operator|!=
literal|null
operator|&&
name|flagD
operator|.
name|booleanValue
argument_list|()
decl_stmt|;
name|Long
name|modcount
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|MODCOUNT
argument_list|)
decl_stmt|;
name|Long
name|cmodcount
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|COLLISIONSMODCOUNT
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
comment|// every 16th update is a full rewrite
if|if
condition|(
name|isAppendableUpdate
argument_list|(
name|update
argument_list|)
operator|&&
name|modcount
operator|%
literal|16
operator|!=
literal|0
condition|)
block|{
name|String
name|appendData
init|=
name|SR
operator|.
name|asString
argument_list|(
name|update
argument_list|)
decl_stmt|;
if|if
condition|(
name|appendData
operator|.
name|length
argument_list|()
operator|<
name|this
operator|.
name|dataLimitInOctets
operator|/
name|CHAR2OCTETRATIO
condition|)
block|{
try|try
block|{
name|success
operator|=
name|dbAppendingUpdate
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|modified
argument_list|,
name|hasBinary
argument_list|,
name|deletedOnce
argument_list|,
name|modcount
argument_list|,
name|cmodcount
argument_list|,
name|oldmodcount
argument_list|,
name|appendData
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|continueIfStringOverflow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|String
name|data
init|=
name|SR
operator|.
name|asString
argument_list|(
name|document
argument_list|)
decl_stmt|;
name|success
operator|=
name|dbUpdate
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|modified
argument_list|,
name|hasBinary
argument_list|,
name|deletedOnce
argument_list|,
name|modcount
argument_list|,
name|cmodcount
argument_list|,
name|oldmodcount
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|continueIfStringOverflow
parameter_list|(
name|SQLException
name|ex
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|state
init|=
name|ex
operator|.
name|getSQLState
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"22001"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
comment|/* everybody */
operator|||
operator|(
literal|"72000"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|&&
literal|1489
operator|==
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|)
comment|/* Oracle */
condition|)
block|{
comment|// ok
block|}
else|else
block|{
throw|throw
operator|(
name|ex
operator|)
throw|;
block|}
block|}
comment|/*      * currently we use append for all updates, but this might change in the      * future      */
specifier|private
specifier|static
name|boolean
name|isAppendableUpdate
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
comment|/*      * check whether this update operation requires knowledge about the previous      * state      */
specifier|private
specifier|static
name|boolean
name|requiresPreviousState
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
return|return
operator|!
name|update
operator|.
name|getConditions
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|long
name|getModifiedFromUpdate
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Key
argument_list|,
name|Operation
argument_list|>
name|change
range|:
name|update
operator|.
name|getChanges
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Operation
name|op
init|=
name|change
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|type
operator|==
name|UpdateOp
operator|.
name|Operation
operator|.
name|Type
operator|.
name|MAX
operator|||
name|op
operator|.
name|type
operator|==
name|UpdateOp
operator|.
name|Operation
operator|.
name|Type
operator|.
name|SET
condition|)
block|{
if|if
condition|(
name|MODIFIED
operator|.
name|equals
argument_list|(
name|change
operator|.
name|getKey
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|op
operator|.
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|0L
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|insertDocuments
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|documents
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
for|for
control|(
name|T
name|document
range|:
name|documents
control|)
block|{
name|String
name|data
init|=
name|SR
operator|.
name|asString
argument_list|(
name|document
argument_list|)
decl_stmt|;
name|Long
name|modified
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|MODIFIED
argument_list|)
decl_stmt|;
name|Number
name|flagB
init|=
operator|(
name|Number
operator|)
name|document
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
argument_list|)
decl_stmt|;
name|Boolean
name|hasBinary
init|=
name|flagB
operator|!=
literal|null
operator|&&
name|flagB
operator|.
name|intValue
argument_list|()
operator|==
name|NodeDocument
operator|.
name|HAS_BINARY_VAL
decl_stmt|;
name|Boolean
name|flagD
init|=
operator|(
name|Boolean
operator|)
name|document
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|DELETED_ONCE
argument_list|)
decl_stmt|;
name|Boolean
name|deletedOnce
init|=
name|flagD
operator|!=
literal|null
operator|&&
name|flagD
operator|.
name|booleanValue
argument_list|()
decl_stmt|;
name|Long
name|modcount
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|MODCOUNT
argument_list|)
decl_stmt|;
name|Long
name|cmodcount
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|COLLISIONSMODCOUNT
argument_list|)
decl_stmt|;
name|String
name|id
init|=
name|document
operator|.
name|getId
argument_list|()
decl_stmt|;
name|ids
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|dbInsert
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|id
argument_list|,
name|modified
argument_list|,
name|hasBinary
argument_list|,
name|deletedOnce
argument_list|,
name|modcount
argument_list|,
name|cmodcount
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"insert of "
operator|+
name|ids
operator|+
literal|" failed"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
comment|// configuration
comment|// Whether to use GZIP compression
specifier|private
specifier|static
specifier|final
name|boolean
name|NOGZIP
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.NOGZIP"
argument_list|)
decl_stmt|;
comment|// Number of documents to insert at once for batch create
specifier|private
specifier|static
specifier|final
name|int
name|CHUNKSIZE
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.CHUNKSIZE"
argument_list|,
literal|64
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
name|asBytes
parameter_list|(
name|String
name|data
parameter_list|)
block|{
name|byte
index|[]
name|bytes
decl_stmt|;
try|try
block|{
name|bytes
operator|=
name|data
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"UTF-8 not supported??"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
if|if
condition|(
name|NOGZIP
condition|)
block|{
return|return
name|bytes
return|;
block|}
else|else
block|{
try|try
block|{
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|data
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|GZIPOutputStream
name|gos
init|=
operator|new
name|GZIPOutputStream
argument_list|(
name|bos
argument_list|)
block|{
block|{
comment|// TODO: make this configurable
name|this
operator|.
name|def
operator|.
name|setLevel
parameter_list|(
name|Deflater
operator|.
name|BEST_SPEED
parameter_list|)
constructor_decl|;
block|}
block|}
decl_stmt|;
name|gos
operator|.
name|write
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|gos
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|bos
operator|.
name|toByteArray
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while gzipping contents"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|setIdInStatement
parameter_list|(
name|PreparedStatement
name|stmt
parameter_list|,
name|int
name|idx
parameter_list|,
name|String
name|id
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|db
operator|.
name|isPrimaryColumnByteEncoded
argument_list|()
condition|)
block|{
try|try
block|{
name|stmt
operator|.
name|setBytes
argument_list|(
name|idx
argument_list|,
name|id
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"UTF-8 not supported??"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|stmt
operator|.
name|setString
argument_list|(
name|idx
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|getIdFromRS
parameter_list|(
name|ResultSet
name|rs
parameter_list|,
name|int
name|idx
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|id
decl_stmt|;
if|if
condition|(
name|db
operator|.
name|isPrimaryColumnByteEncoded
argument_list|()
condition|)
block|{
try|try
block|{
name|id
operator|=
operator|new
name|String
argument_list|(
name|rs
operator|.
name|getBytes
argument_list|(
name|idx
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"UTF-8 not supported??"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|id
operator|=
name|rs
operator|.
name|getString
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
return|return
name|id
return|;
block|}
annotation|@
name|CheckForNull
specifier|private
name|RDBRow
name|dbRead
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|id
parameter_list|,
name|long
name|lastmodcount
parameter_list|)
throws|throws
name|SQLException
block|{
name|PreparedStatement
name|stmt
decl_stmt|;
name|boolean
name|useCaseStatement
init|=
name|lastmodcount
operator|!=
operator|-
literal|1
operator|&&
name|this
operator|.
name|db
operator|.
name|allowsCaseInSelect
argument_list|()
decl_stmt|;
if|if
condition|(
name|useCaseStatement
condition|)
block|{
comment|// either we don't have a previous version of the document
comment|// or the database does not support CASE in SELECT
name|stmt
operator|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"select MODIFIED, MODCOUNT, CMODCOUNT, HASBINARY, DELETEDONCE, DATA, BDATA from "
operator|+
name|tableName
operator|+
literal|" where ID = ?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the case statement causes the actual row data not to be
comment|// sent in case we already have it
name|stmt
operator|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"select MODIFIED, MODCOUNT, CMODCOUNT, HASBINARY, DELETEDONCE, case MODCOUNT when ? then null else DATA end as DATA, "
operator|+
literal|"case MODCOUNT when ? then null else BDATA end as BDATA from "
operator|+
name|tableName
operator|+
literal|" where ID = ?"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|useCaseStatement
condition|)
block|{
name|setIdInStatement
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stmt
operator|.
name|setLong
argument_list|(
literal|1
argument_list|,
name|lastmodcount
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setLong
argument_list|(
literal|2
argument_list|,
name|lastmodcount
argument_list|)
expr_stmt|;
name|setIdInStatement
argument_list|(
name|stmt
argument_list|,
literal|3
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|long
name|modified
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|long
name|modcount
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|long
name|cmodcount
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|long
name|hasBinary
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|long
name|deletedOnce
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|String
name|data
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bdata
init|=
name|rs
operator|.
name|getBytes
argument_list|(
literal|7
argument_list|)
decl_stmt|;
return|return
operator|new
name|RDBRow
argument_list|(
name|id
argument_list|,
name|hasBinary
operator|==
literal|1
argument_list|,
name|deletedOnce
operator|==
literal|1
argument_list|,
name|modified
argument_list|,
name|modcount
argument_list|,
name|cmodcount
argument_list|,
name|data
argument_list|,
name|bdata
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"attempting to read "
operator|+
name|id
operator|+
literal|" (id length is "
operator|+
name|id
operator|.
name|length
argument_list|()
operator|+
literal|")"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// DB2 throws an SQLException for invalid keys; handle this more
comment|// gracefully
if|if
condition|(
literal|"22001"
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
throw|throw
operator|(
name|ex
operator|)
throw|;
block|}
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|RDBRow
argument_list|>
name|dbQuery
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|minId
parameter_list|,
name|String
name|maxId
parameter_list|,
name|String
name|indexedProperty
parameter_list|,
name|long
name|startValue
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|t
init|=
literal|"select "
decl_stmt|;
if|if
condition|(
name|limit
operator|!=
name|Integer
operator|.
name|MAX_VALUE
operator|&&
name|this
operator|.
name|db
operator|.
name|getFetchFirstSyntax
argument_list|()
operator|==
name|FETCHFIRSTSYNTAX
operator|.
name|TOP
condition|)
block|{
name|t
operator|+=
literal|"TOP "
operator|+
name|limit
operator|+
literal|" "
expr_stmt|;
block|}
name|t
operator|+=
literal|"ID, MODIFIED, MODCOUNT, CMODCOUNT, HASBINARY, DELETEDONCE, DATA, BDATA from "
operator|+
name|tableName
operator|+
literal|" where ID> ? and ID< ?"
expr_stmt|;
if|if
condition|(
name|indexedProperty
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|MODIFIED
operator|.
name|equals
argument_list|(
name|indexedProperty
argument_list|)
condition|)
block|{
name|t
operator|+=
literal|" and MODIFIED>= ?"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
operator|.
name|equals
argument_list|(
name|indexedProperty
argument_list|)
condition|)
block|{
if|if
condition|(
name|startValue
operator|!=
name|NodeDocument
operator|.
name|HAS_BINARY_VAL
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"unsupported value for property "
operator|+
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
argument_list|)
throw|;
block|}
name|t
operator|+=
literal|" and HASBINARY = 1"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NodeDocument
operator|.
name|DELETED_ONCE
operator|.
name|equals
argument_list|(
name|indexedProperty
argument_list|)
condition|)
block|{
if|if
condition|(
name|startValue
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"unsupported value for property "
operator|+
name|NodeDocument
operator|.
name|DELETED_ONCE
argument_list|)
throw|;
block|}
name|t
operator|+=
literal|" and DELETEDONCE = 1"
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"unsupported indexed property: "
operator|+
name|indexedProperty
argument_list|)
throw|;
block|}
block|}
name|t
operator|+=
literal|" order by ID"
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
switch|switch
condition|(
name|this
operator|.
name|db
operator|.
name|getFetchFirstSyntax
argument_list|()
condition|)
block|{
case|case
name|LIMIT
case|:
name|t
operator|+=
literal|" LIMIT "
operator|+
name|limit
expr_stmt|;
break|break;
case|case
name|FETCHFIRST
case|:
name|t
operator|+=
literal|" FETCH FIRST "
operator|+
name|limit
operator|+
literal|" ROWS ONLY"
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|PreparedStatement
name|stmt
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RDBRow
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|RDBRow
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|si
init|=
literal|1
decl_stmt|;
name|setIdInStatement
argument_list|(
name|stmt
argument_list|,
name|si
operator|++
argument_list|,
name|minId
argument_list|)
expr_stmt|;
name|setIdInStatement
argument_list|(
name|stmt
argument_list|,
name|si
operator|++
argument_list|,
name|maxId
argument_list|)
expr_stmt|;
if|if
condition|(
name|MODIFIED
operator|.
name|equals
argument_list|(
name|indexedProperty
argument_list|)
condition|)
block|{
name|stmt
operator|.
name|setLong
argument_list|(
name|si
operator|++
argument_list|,
name|startValue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|!=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|stmt
operator|.
name|setFetchSize
argument_list|(
name|limit
argument_list|)
expr_stmt|;
block|}
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
operator|&&
name|result
operator|.
name|size
argument_list|()
operator|<
name|limit
condition|)
block|{
name|String
name|id
init|=
name|getIdFromRS
argument_list|(
name|rs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|.
name|compareTo
argument_list|(
name|minId
argument_list|)
operator|<
literal|0
operator|||
name|id
operator|.
name|compareTo
argument_list|(
name|maxId
argument_list|)
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"unexpected query result: '"
operator|+
name|minId
operator|+
literal|"'< '"
operator|+
name|id
operator|+
literal|"'< '"
operator|+
name|maxId
operator|+
literal|"' - broken DB collation?"
argument_list|)
throw|;
block|}
name|long
name|modified
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|long
name|modcount
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|long
name|cmodcount
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|long
name|hasBinary
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|long
name|deletedOnce
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|String
name|data
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|7
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bdata
init|=
name|rs
operator|.
name|getBytes
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|RDBRow
argument_list|(
name|id
argument_list|,
name|hasBinary
operator|==
literal|1
argument_list|,
name|deletedOnce
operator|==
literal|1
argument_list|,
name|modified
argument_list|,
name|modcount
argument_list|,
name|cmodcount
argument_list|,
name|data
argument_list|,
name|bdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|boolean
name|dbUpdate
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|id
parameter_list|,
name|Long
name|modified
parameter_list|,
name|Boolean
name|hasBinary
parameter_list|,
name|Boolean
name|deletedOnce
parameter_list|,
name|Long
name|modcount
parameter_list|,
name|Long
name|cmodcount
parameter_list|,
name|Long
name|oldmodcount
parameter_list|,
name|String
name|data
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|t
init|=
literal|"update "
operator|+
name|tableName
operator|+
literal|" set MODIFIED = ?, HASBINARY = ?, DELETEDONCE = ?, MODCOUNT = ?, CMODCOUNT = ?, DSIZE = ?, DATA = ?, BDATA = ? where ID = ?"
decl_stmt|;
if|if
condition|(
name|oldmodcount
operator|!=
literal|null
condition|)
block|{
name|t
operator|+=
literal|" and MODCOUNT = ?"
expr_stmt|;
block|}
name|PreparedStatement
name|stmt
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|t
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|si
init|=
literal|1
decl_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modified
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|hasBinary
condition|?
literal|1
else|:
literal|0
argument_list|,
name|Types
operator|.
name|SMALLINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|deletedOnce
condition|?
literal|1
else|:
literal|0
argument_list|,
name|Types
operator|.
name|SMALLINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|cmodcount
operator|==
literal|null
condition|?
name|Long
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
else|:
name|cmodcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|length
argument_list|()
operator|<
name|this
operator|.
name|dataLimitInOctets
operator|/
name|CHAR2OCTETRATIO
condition|)
block|{
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setBinaryStream
argument_list|(
name|si
operator|++
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
literal|"\"blob\""
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bytes
init|=
name|asBytes
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|stmt
operator|.
name|setBytes
argument_list|(
name|si
operator|++
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
name|setIdInStatement
argument_list|(
name|stmt
argument_list|,
name|si
operator|++
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmodcount
operator|!=
literal|null
condition|)
block|{
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|oldmodcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
block|}
name|int
name|result
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DB update failed for "
operator|+
name|tableName
operator|+
literal|"/"
operator|+
name|id
operator|+
literal|" with oldmodcount="
operator|+
name|oldmodcount
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|==
literal|1
return|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|dbAppendingUpdate
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|id
parameter_list|,
name|Long
name|modified
parameter_list|,
name|Boolean
name|hasBinary
parameter_list|,
name|Boolean
name|deletedOnce
parameter_list|,
name|Long
name|modcount
parameter_list|,
name|Long
name|cmodcount
parameter_list|,
name|Long
name|oldmodcount
parameter_list|,
name|String
name|appendData
parameter_list|)
throws|throws
name|SQLException
block|{
name|StringBuilder
name|t
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|t
operator|.
name|append
argument_list|(
literal|"update "
operator|+
name|tableName
operator|+
literal|" set MODIFIED = "
operator|+
name|this
operator|.
name|db
operator|.
name|getGreatestQueryString
argument_list|(
literal|"MODIFIED"
argument_list|)
operator|+
literal|", HASBINARY = ?, DELETEDONCE = ?, MODCOUNT = ?, CMODCOUNT = ?, DSIZE = DSIZE + ?, "
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
literal|"DATA = "
operator|+
name|this
operator|.
name|db
operator|.
name|getConcatQueryString
argument_list|(
name|this
operator|.
name|dataLimitInOctets
argument_list|,
name|appendData
operator|.
name|length
argument_list|()
argument_list|)
operator|+
literal|" "
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
literal|"where ID = ?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmodcount
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|append
argument_list|(
literal|" and MODCOUNT = ?"
argument_list|)
expr_stmt|;
block|}
name|PreparedStatement
name|stmt
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|si
init|=
literal|1
decl_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modified
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|hasBinary
condition|?
literal|1
else|:
literal|0
argument_list|,
name|Types
operator|.
name|SMALLINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|deletedOnce
condition|?
literal|1
else|:
literal|0
argument_list|,
name|Types
operator|.
name|SMALLINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|cmodcount
operator|==
literal|null
condition|?
name|Long
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
else|:
name|cmodcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
literal|1
operator|+
name|appendData
operator|.
name|length
argument_list|()
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
literal|","
operator|+
name|appendData
argument_list|)
expr_stmt|;
name|setIdInStatement
argument_list|(
name|stmt
argument_list|,
name|si
operator|++
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmodcount
operator|!=
literal|null
condition|)
block|{
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|oldmodcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
block|}
name|int
name|result
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DB append update failed for "
operator|+
name|tableName
operator|+
literal|"/"
operator|+
name|id
operator|+
literal|" with oldmodcount="
operator|+
name|oldmodcount
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|==
literal|1
return|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|dbBatchedAppendingUpdate
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|,
name|Long
name|modified
parameter_list|,
name|String
name|appendData
parameter_list|)
throws|throws
name|SQLException
block|{
name|StringBuilder
name|t
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|t
operator|.
name|append
argument_list|(
literal|"update "
operator|+
name|tableName
operator|+
literal|" set MODIFIED = "
operator|+
name|this
operator|.
name|db
operator|.
name|getGreatestQueryString
argument_list|(
literal|"MODIFIED"
argument_list|)
operator|+
literal|", MODCOUNT = MODCOUNT + 1, DSIZE = DSIZE + ?, "
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
literal|"DATA = "
operator|+
name|this
operator|.
name|db
operator|.
name|getConcatQueryString
argument_list|(
name|this
operator|.
name|dataLimitInOctets
argument_list|,
name|appendData
operator|.
name|length
argument_list|()
argument_list|)
operator|+
literal|" "
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
literal|"where ID in ("
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ids
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|t
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|append
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|PreparedStatement
name|stmt
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|si
init|=
literal|1
decl_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modified
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
literal|1
operator|+
name|appendData
operator|.
name|length
argument_list|()
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
literal|","
operator|+
name|appendData
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
name|setIdInStatement
argument_list|(
name|stmt
argument_list|,
name|si
operator|++
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|int
name|result
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|ids
operator|.
name|size
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DB update failed: only "
operator|+
name|result
operator|+
literal|" of "
operator|+
name|ids
operator|.
name|size
argument_list|()
operator|+
literal|" updated. Table: "
operator|+
name|tableName
operator|+
literal|", IDs:"
operator|+
name|ids
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|==
name|ids
operator|.
name|size
argument_list|()
return|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|dbInsert
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|id
parameter_list|,
name|Long
name|modified
parameter_list|,
name|Boolean
name|hasBinary
parameter_list|,
name|Boolean
name|deletedOnce
parameter_list|,
name|Long
name|modcount
parameter_list|,
name|Long
name|cmodcount
parameter_list|,
name|String
name|data
parameter_list|)
throws|throws
name|SQLException
block|{
name|PreparedStatement
name|stmt
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"insert into "
operator|+
name|tableName
operator|+
literal|"(ID, MODIFIED, HASBINARY, DELETEDONCE, MODCOUNT, CMODCOUNT, DSIZE, DATA, BDATA) values (?, ?, ?, ?, ?, ?, ?, ?, ?)"
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|si
init|=
literal|1
decl_stmt|;
name|setIdInStatement
argument_list|(
name|stmt
argument_list|,
name|si
operator|++
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modified
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|hasBinary
condition|?
literal|1
else|:
literal|0
argument_list|,
name|Types
operator|.
name|SMALLINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|deletedOnce
condition|?
literal|1
else|:
literal|0
argument_list|,
name|Types
operator|.
name|SMALLINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|cmodcount
operator|==
literal|null
condition|?
name|Long
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
else|:
name|cmodcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|length
argument_list|()
operator|<
name|this
operator|.
name|dataLimitInOctets
operator|/
name|CHAR2OCTETRATIO
condition|)
block|{
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setBinaryStream
argument_list|(
name|si
operator|++
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
literal|"\"blob\""
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bytes
init|=
name|asBytes
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|stmt
operator|.
name|setBytes
argument_list|(
name|si
operator|++
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
name|int
name|result
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DB insert failed for "
operator|+
name|tableName
operator|+
literal|"/"
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|==
literal|1
return|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|dbDelete
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
throws|throws
name|SQLException
block|{
name|PreparedStatement
name|stmt
decl_stmt|;
name|int
name|cnt
init|=
name|ids
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|1
condition|)
block|{
name|stmt
operator|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"delete from "
operator|+
name|tableName
operator|+
literal|" where ID=?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|StringBuilder
name|inClause
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|inClause
operator|.
name|append
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|cnt
operator|-
literal|1
condition|)
block|{
name|inClause
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
name|stmt
operator|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"delete from "
operator|+
name|tableName
operator|+
literal|" where ID in ("
operator|+
name|inClause
operator|.
name|toString
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|setIdInStatement
argument_list|(
name|stmt
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|ids
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|result
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|cnt
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DB delete failed for "
operator|+
name|tableName
operator|+
literal|"/"
operator|+
name|ids
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|dbDelete
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
name|toDelete
parameter_list|)
throws|throws
name|SQLException
throws|,
name|DocumentStoreException
block|{
name|String
name|or
init|=
literal|""
decl_stmt|;
name|StringBuilder
name|whereClause
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
name|entry
range|:
name|toDelete
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|whereClause
operator|.
name|append
argument_list|(
name|or
argument_list|)
expr_stmt|;
name|or
operator|=
literal|" or "
expr_stmt|;
name|whereClause
operator|.
name|append
argument_list|(
literal|"ID=?"
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
name|c
range|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|c
operator|.
name|getKey
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|MODIFIED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"Unsupported condition: "
operator|+
name|c
argument_list|)
throw|;
block|}
name|whereClause
operator|.
name|append
argument_list|(
literal|" and MODIFIED"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|getValue
argument_list|()
operator|.
name|type
operator|==
name|Condition
operator|.
name|Type
operator|.
name|EQUALS
operator|&&
name|c
operator|.
name|getValue
argument_list|()
operator|.
name|value
operator|instanceof
name|Long
condition|)
block|{
name|whereClause
operator|.
name|append
argument_list|(
literal|"=?"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|getValue
argument_list|()
operator|.
name|type
operator|==
name|Condition
operator|.
name|Type
operator|.
name|EXISTS
condition|)
block|{
name|whereClause
operator|.
name|append
argument_list|(
literal|" is not null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"Unsupported condition: "
operator|+
name|c
argument_list|)
throw|;
block|}
block|}
block|}
name|PreparedStatement
name|stmt
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"delete from "
operator|+
name|tableName
operator|+
literal|" where "
operator|+
name|whereClause
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
name|entry
range|:
name|toDelete
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|setIdInStatement
argument_list|(
name|stmt
argument_list|,
name|i
operator|++
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
name|c
range|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|c
operator|.
name|getValue
argument_list|()
operator|.
name|type
operator|==
name|Condition
operator|.
name|Type
operator|.
name|EQUALS
condition|)
block|{
name|stmt
operator|.
name|setLong
argument_list|(
name|i
operator|++
argument_list|,
operator|(
name|Long
operator|)
name|c
operator|.
name|getValue
argument_list|()
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|stmt
operator|.
name|executeUpdate
argument_list|()
return|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setReadWriteMode
parameter_list|(
name|String
name|readWriteMode
parameter_list|)
block|{
comment|// ignored
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|castAsT
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
operator|(
name|T
operator|)
name|doc
return|;
block|}
comment|// Memory Cache
specifier|private
name|Cache
argument_list|<
name|CacheValue
argument_list|,
name|NodeDocument
argument_list|>
name|nodesCache
decl_stmt|;
specifier|private
name|CacheStats
name|cacheStats
decl_stmt|;
specifier|private
specifier|final
name|Striped
argument_list|<
name|Lock
argument_list|>
name|locks
init|=
name|Striped
operator|.
name|lock
argument_list|(
literal|64
argument_list|)
decl_stmt|;
specifier|private
name|Lock
name|getAndLock
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|Lock
name|l
init|=
name|locks
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|l
operator|.
name|lock
argument_list|()
expr_stmt|;
return|return
name|l
return|;
block|}
annotation|@
name|CheckForNull
specifier|private
specifier|static
name|NodeDocument
name|unwrap
parameter_list|(
annotation|@
name|Nonnull
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|==
name|NodeDocument
operator|.
name|NULL
condition|?
literal|null
else|:
name|doc
return|;
block|}
annotation|@
name|Nonnull
specifier|private
specifier|static
name|NodeDocument
name|wrap
parameter_list|(
annotation|@
name|CheckForNull
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|==
literal|null
condition|?
name|NodeDocument
operator|.
name|NULL
else|:
name|doc
return|;
block|}
annotation|@
name|Nonnull
specifier|private
specifier|static
name|String
name|idOf
parameter_list|(
annotation|@
name|Nonnull
name|Document
name|doc
parameter_list|)
block|{
name|String
name|id
init|=
name|doc
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"non-null ID expected"
argument_list|)
throw|;
block|}
return|return
name|id
return|;
block|}
specifier|private
specifier|static
name|long
name|modcountOf
parameter_list|(
annotation|@
name|Nonnull
name|Document
name|doc
parameter_list|)
block|{
name|Number
name|n
init|=
name|doc
operator|.
name|getModCount
argument_list|()
decl_stmt|;
return|return
name|n
operator|!=
literal|null
condition|?
name|n
operator|.
name|longValue
argument_list|()
else|:
operator|-
literal|1
return|;
block|}
comment|/**      * Adds a document to the {@link #nodesCache} iff there is no document in      * the cache with the document key. This method does not acquire a lock from      * {@link #locks}! The caller must ensure a lock is held for the given      * document.      *       * @param doc      *            the document to add to the cache.      * @return either the given<code>doc</code> or the document already present      *         in the cache.      */
annotation|@
name|Nonnull
specifier|private
name|NodeDocument
name|addToCache
parameter_list|(
annotation|@
name|Nonnull
specifier|final
name|NodeDocument
name|doc
parameter_list|)
block|{
if|if
condition|(
name|doc
operator|==
name|NodeDocument
operator|.
name|NULL
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"doc must not be NULL document"
argument_list|)
throw|;
block|}
name|doc
operator|.
name|seal
argument_list|()
expr_stmt|;
comment|// make sure we only cache the document if it wasn't
comment|// changed and cached by some other thread in the
comment|// meantime. That is, use get() with a Callable,
comment|// which is only used when the document isn't there
try|try
block|{
name|CacheValue
name|key
init|=
operator|new
name|StringValue
argument_list|(
name|idOf
argument_list|(
name|doc
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|NodeDocument
name|cached
init|=
name|nodesCache
operator|.
name|get
argument_list|(
name|key
argument_list|,
operator|new
name|Callable
argument_list|<
name|NodeDocument
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|NodeDocument
name|call
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
name|NodeDocument
operator|.
name|NULL
condition|)
block|{
return|return
name|cached
return|;
block|}
else|else
block|{
name|nodesCache
operator|.
name|invalidate
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// will never happen because call() just returns
comment|// the already available doc
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Nonnull
specifier|private
name|void
name|applyToCache
parameter_list|(
annotation|@
name|Nonnull
specifier|final
name|NodeDocument
name|oldDoc
parameter_list|,
annotation|@
name|Nonnull
specifier|final
name|NodeDocument
name|newDoc
parameter_list|)
block|{
name|NodeDocument
name|cached
init|=
name|addToCache
argument_list|(
name|newDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|==
name|newDoc
condition|)
block|{
comment|// successful
return|return;
block|}
elseif|else
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// this is an insert and some other thread was quicker
comment|// loading it into the cache -> return now
return|return;
block|}
else|else
block|{
name|CacheValue
name|key
init|=
operator|new
name|StringValue
argument_list|(
name|idOf
argument_list|(
name|newDoc
argument_list|)
argument_list|)
decl_stmt|;
comment|// this is an update (oldDoc != null)
if|if
condition|(
name|Objects
operator|.
name|equal
argument_list|(
name|cached
operator|.
name|getModCount
argument_list|()
argument_list|,
name|oldDoc
operator|.
name|getModCount
argument_list|()
argument_list|)
condition|)
block|{
name|nodesCache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the cache entry was modified by some other thread in
comment|// the meantime. the updated cache entry may or may not
comment|// include this update. we cannot just apply our update
comment|// on top of the cached entry.
comment|// therefore we must invalidate the cache entry
name|nodesCache
operator|.
name|invalidate
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|addToCache
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|T
name|doc
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|Lock
name|lock
init|=
name|getAndLock
argument_list|(
name|idOf
argument_list|(
name|doc
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|addToCache
argument_list|(
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|runThroughCache
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|RDBRow
name|row
parameter_list|,
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|!=
name|Collection
operator|.
name|NODES
condition|)
block|{
comment|// not in the cache anyway
return|return
name|SR
operator|.
name|fromRow
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
return|;
block|}
name|String
name|id
init|=
name|row
operator|.
name|getId
argument_list|()
decl_stmt|;
name|CacheValue
name|cacheKey
init|=
operator|new
name|StringValue
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|NodeDocument
name|inCache
init|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|cacheKey
argument_list|)
decl_stmt|;
name|Number
name|modCount
init|=
name|row
operator|.
name|getModcount
argument_list|()
decl_stmt|;
comment|// do not overwrite document in cache if the
comment|// existing one in the cache is newer
if|if
condition|(
name|inCache
operator|!=
literal|null
operator|&&
name|inCache
operator|!=
name|NodeDocument
operator|.
name|NULL
condition|)
block|{
comment|// check mod count
name|Number
name|cachedModCount
init|=
name|inCache
operator|.
name|getModCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|cachedModCount
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Missing "
operator|+
name|Document
operator|.
name|MOD_COUNT
argument_list|)
throw|;
block|}
if|if
condition|(
name|modCount
operator|.
name|longValue
argument_list|()
operator|<=
name|cachedModCount
operator|.
name|longValue
argument_list|()
condition|)
block|{
comment|// we can use the cached document
name|inCache
operator|.
name|markUpToDate
argument_list|(
name|now
argument_list|)
expr_stmt|;
return|return
name|castAsT
argument_list|(
name|inCache
argument_list|)
return|;
block|}
block|}
name|NodeDocument
name|fresh
init|=
operator|(
name|NodeDocument
operator|)
name|SR
operator|.
name|fromRow
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
decl_stmt|;
name|fresh
operator|.
name|seal
argument_list|()
expr_stmt|;
name|Lock
name|lock
init|=
name|getAndLock
argument_list|(
name|id
argument_list|)
decl_stmt|;
try|try
block|{
name|inCache
operator|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|cacheKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|inCache
operator|!=
literal|null
operator|&&
name|inCache
operator|!=
name|NodeDocument
operator|.
name|NULL
condition|)
block|{
comment|// check mod count
name|Number
name|cachedModCount
init|=
name|inCache
operator|.
name|getModCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|cachedModCount
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Missing "
operator|+
name|Document
operator|.
name|MOD_COUNT
argument_list|)
throw|;
block|}
if|if
condition|(
name|modCount
operator|.
name|longValue
argument_list|()
operator|>
name|cachedModCount
operator|.
name|longValue
argument_list|()
condition|)
block|{
name|nodesCache
operator|.
name|put
argument_list|(
name|cacheKey
argument_list|,
name|fresh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fresh
operator|=
name|inCache
expr_stmt|;
block|}
block|}
else|else
block|{
name|nodesCache
operator|.
name|put
argument_list|(
name|cacheKey
argument_list|,
name|fresh
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|castAsT
argument_list|(
name|fresh
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|hasChangesToCollisions
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
if|if
condition|(
operator|!
name|USECMODCOUNT
condition|)
return|return
literal|false
return|;
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|,
name|Operation
argument_list|>
name|e
range|:
name|checkNotNull
argument_list|(
name|update
argument_list|)
operator|.
name|getChanges
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Key
name|k
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Operation
name|op
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|type
operator|==
name|Operation
operator|.
name|Type
operator|.
name|SET_MAP_ENTRY
condition|)
block|{
if|if
condition|(
name|NodeDocument
operator|.
name|COLLISIONS
operator|.
name|equals
argument_list|(
name|k
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

