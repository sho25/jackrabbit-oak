begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|property
operator|.
name|strategy
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
operator|.
name|newHashSet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|property
operator|.
name|strategy
operator|.
name|OrderedContentMirrorStoreStrategy
operator|.
name|NEXT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|property
operator|.
name|strategy
operator|.
name|OrderedContentMirrorStoreStrategy
operator|.
name|START
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|EmptyNodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|ChildNodeEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterators
import|;
end_import

begin_comment
comment|/**  *  */
end_comment

begin_class
specifier|public
class|class
name|OrderedContentMirrorStorageStrategyTest
block|{
comment|/**      * ascending ordered set of keys. Useful for testing      */
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|KEYS
init|=
operator|new
name|String
index|[]
block|{
literal|"donald"
block|,
literal|"goofy"
block|,
literal|"mickey"
block|,
literal|"minnie"
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|EMPTY_KEY_SET
init|=
name|newHashSet
argument_list|()
decl_stmt|;
comment|/**      * checks that the fist item/key is inserted with an empty property 'next'      *       * expected structure:      *       *<code>      * :index : {      *    :start : { :next=n0 },      *    n0 : {       *       :next=,      *       foo : {      *          bar: { match=true}      *       }      *    }      * }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|firstAndOnlyItem
parameter_list|()
block|{
specifier|final
name|String
name|PATH
init|=
literal|"/foo/bar"
decl_stmt|;
specifier|final
name|String
index|[]
name|PATH_NODES
init|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|PATH
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|String
name|N0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|NodeBuilder
name|node
init|=
literal|null
decl_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|":index should be left alone with not changes"
argument_list|,
name|index
operator|.
name|hasProperty
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|":index should have the :start node"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n0"
argument_list|,
name|N0
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should exists in the index"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n0 should point nowhere as it's the last (and only) element"
argument_list|,
literal|""
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
comment|// checking content structure below n0
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|PATH_NODES
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should contain 'foo'"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|PATH_NODES
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"'foo' should contain 'bar'"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"the 'foo' node should have 'match=true'"
argument_list|,
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the saving of 2 new keys that comes already ordered      *       * final state of the index will be      *       *<code>      *    :index : {      *       :start : { :next=n0 },      *       n0 : { :next=n1 },      *       n1 : { :next= }             *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|first2newKeysAlreadyOrdered
parameter_list|()
block|{
specifier|final
name|String
name|PATH
init|=
literal|"/foo/bar"
decl_stmt|;
specifier|final
name|String
name|N0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|N1
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|NodeBuilder
name|node
init|=
literal|null
decl_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
comment|// first node
comment|// arrives
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|":index should have :start"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n0"
argument_list|,
name|N0
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|":index should have n0"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n0 should point nowhere at this stage"
argument_list|,
literal|""
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|N1
argument_list|)
argument_list|)
expr_stmt|;
comment|// second node
comment|// arrives
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|":index should still have :start"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should still point to n0"
argument_list|,
name|N0
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should still exists"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n0 should point to n1"
argument_list|,
name|N1
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|N1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n1 should exists"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n1 should point nowhere"
argument_list|,
literal|""
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Test the iteration of an empty index      */
annotation|@
name|Test
specifier|public
name|void
name|childNodeEntriesEmptyIndex
parameter_list|()
block|{
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeState
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
name|children
init|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"A returned Iterable cannot be null"
argument_list|,
name|children
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the iteration of the index with 2 shuffled items      *       *<code>      *    :index : {      *       :start : { :next=n1 },      *       n0 : { :next= },      *       n1 : { :next=n0 }      *    }      *</code>      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|childNodeEntriesACoupleOfMixedItems
parameter_list|()
block|{
specifier|final
name|String
name|N0
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|String
name|N1
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|NodeState
name|NODE_0
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
literal|""
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
specifier|final
name|NodeState
name|NODE_1
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|N0
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// setting-up the index structure
name|index
operator|.
name|child
argument_list|(
name|START
argument_list|)
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|N1
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|N0
argument_list|,
name|NODE_0
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|N1
argument_list|,
name|NODE_1
argument_list|)
expr_stmt|;
name|NodeState
name|indexState
init|=
name|index
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
name|children
init|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"The iterable cannot be null"
argument_list|,
name|children
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Expecting 2 items in the index"
argument_list|,
literal|2
argument_list|,
name|Iterators
operator|.
name|size
argument_list|(
name|children
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensuring the right sequence
name|ChildNodeEntry
name|entry
init|=
literal|null
decl_stmt|;
name|children
operator|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|ChildNodeEntry
argument_list|>
name|it
init|=
name|children
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"We should have 2 elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The first element should be n1"
argument_list|,
name|N1
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|NODE_1
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"We should have 1 elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The second element should be n0"
argument_list|,
name|N0
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|NODE_0
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"We should have be at the end of the list"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the iteration of the index with 2 shuffled items without the :start      * node      *       *<code>      *    :index : {      *       :start : { :next=n1 },      *       n0 : { :next= },      *       n1 : { :next=n0 }      *    }      *</code>      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|childNodeEntriesACoupleOfMixedItemsNoStart
parameter_list|()
block|{
specifier|final
name|String
name|N0
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|String
name|N1
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|NodeState
name|NODE_0
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
literal|""
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
specifier|final
name|NodeState
name|NODE_1
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|N0
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// setting-up the index structure
name|index
operator|.
name|child
argument_list|(
name|START
argument_list|)
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|N1
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|N0
argument_list|,
name|NODE_0
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|N1
argument_list|,
name|NODE_1
argument_list|)
expr_stmt|;
name|NodeState
name|indexState
init|=
name|index
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
name|children
init|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"The iterable cannot be null"
argument_list|,
name|children
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Expecting 2 items in the index"
argument_list|,
literal|2
argument_list|,
name|Iterators
operator|.
name|size
argument_list|(
name|children
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensuring the right sequence
name|ChildNodeEntry
name|entry
init|=
literal|null
decl_stmt|;
name|children
operator|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|ChildNodeEntry
argument_list|>
name|it
init|=
name|children
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"We should have 2 elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The first element should be n1"
argument_list|,
name|N1
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|NODE_1
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"We should have 1 elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The second element should be n0"
argument_list|,
name|N0
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|NODE_0
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"We should have be at the end of the list"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the iteration of the index with 2 shuffled items including the      * :start node as first      *       *<code>      *    :index : {      *       :start : { :next=n1 },      *       n0 : { :next= },      *       n1 : { :next=n0 }      *    }      *</code>      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|childNodeEntriesACoupleOfMixedItemsWithStart
parameter_list|()
block|{
specifier|final
name|String
name|N0
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|String
name|N1
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|NodeState
name|NODE_START
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|N1
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
specifier|final
name|NodeState
name|NODE_0
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
literal|""
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
specifier|final
name|NodeState
name|NODE_1
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|N0
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// setting-up the index structure
name|index
operator|.
name|setChildNode
argument_list|(
name|START
argument_list|,
name|NODE_START
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|N0
argument_list|,
name|NODE_0
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|N1
argument_list|,
name|NODE_1
argument_list|)
expr_stmt|;
name|NodeState
name|indexState
init|=
name|index
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
name|children
init|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"The iterable cannot be null"
argument_list|,
name|children
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Expecting 3 items in the index"
argument_list|,
literal|3
argument_list|,
name|Iterators
operator|.
name|size
argument_list|(
name|children
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensuring the right sequence
name|ChildNodeEntry
name|entry
init|=
literal|null
decl_stmt|;
name|children
operator|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|ChildNodeEntry
argument_list|>
name|it
init|=
name|children
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"We should still have elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The first element should be :start"
argument_list|,
name|START
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|NODE_START
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"We should still have elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The second element should be n1"
argument_list|,
name|N1
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|NODE_1
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"We should still have elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The third element should be n0"
argument_list|,
name|N0
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|NODE_0
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"We should be at the end of the list"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the iteration over an empty list when the :start is required. In      * this case :start should always be returned      *       *<code>      *    :index : {      *       :start : { :next= }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|childNodeEntriesNoItemsWithStart
parameter_list|()
block|{
name|NodeState
name|NODE_START
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
literal|""
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
comment|// setting-up the index
name|index
operator|.
name|setChildNode
argument_list|(
name|START
argument_list|,
name|NODE_START
argument_list|)
expr_stmt|;
name|Iterable
argument_list|<
name|?
extends|extends
name|ChildNodeEntry
argument_list|>
name|children
init|=
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|index
operator|.
name|getNodeState
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong size of Iterable"
argument_list|,
literal|1
argument_list|,
name|Iterators
operator|.
name|size
argument_list|(
name|children
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|?
extends|extends
name|ChildNodeEntry
argument_list|>
name|it
init|=
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|index
operator|.
name|getNodeState
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"We should have at least 1 element"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|ChildNodeEntry
name|entry
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|":start is expected"
argument_list|,
name|START
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"wrong node returned"
argument_list|,
name|NODE_START
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"We should be at the end of the list"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the case where we want an iterator for the children of a brand new      * index. In this case :start doesn't exists but if we ask for it we should      * return it.      */
annotation|@
name|Test
specifier|public
name|void
name|childNodeEntriesNewIndexWithStart
parameter_list|()
block|{
name|NodeState
name|NODE_START
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
literal|""
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|?
extends|extends
name|ChildNodeEntry
argument_list|>
name|children
init|=
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|index
operator|.
name|getNodeState
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong number of children"
argument_list|,
literal|1
argument_list|,
name|Iterators
operator|.
name|size
argument_list|(
name|children
argument_list|)
argument_list|)
expr_stmt|;
name|children
operator|=
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|index
operator|.
name|getNodeState
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"at least one item expected"
argument_list|,
name|children
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|ChildNodeEntry
name|child
init|=
name|children
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|START
argument_list|,
name|child
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|NODE_START
argument_list|,
name|child
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|children
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the insert of two shuffled items      *       * Building final a structure like      *       *<code>      *    :index : {      *       :start : { :next=n1 },      *       n0 : { :next= },      *       n1 : { :next=n0 }      *    }      *</code>      *       * where:      *       *<code>      *    Stage 1      *    =======      *       *    :index : {      *       :start : { :next = n0 },      *       n0 : {      *          :next =       *       }      *    }      *       *    Stage 2      *    =======      *       *    :index : {      *       :start : { :next = n1 },      *       n0 : {      *          :next =      *       },      *       n1 : {      *          :next = n0      *       }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|twoShuffledItems
parameter_list|()
block|{
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeState
name|root
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|root
operator|.
name|builder
argument_list|()
decl_stmt|;
name|String
name|key1st
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|String
name|key2nd
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
name|NodeState
name|ns
init|=
literal|null
decl_stmt|;
comment|// Stage 1
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/foo/bar"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|key1st
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start is expected to point to the 1st node"
argument_list|,
name|key1st
argument_list|,
name|ns
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|key1st
argument_list|)
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"At Stage 1 the first node is expected to point nowhere as it's the last"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|ns
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/foo/bar"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|key2nd
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start is expected to point to the 2nd node"
argument_list|,
name|key2nd
argument_list|,
name|ns
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|key1st
argument_list|)
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"At stage 2 the first element should point nowhere as it's the last"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|ns
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|key2nd
argument_list|)
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"At Stage 2 the second element should point to the first one"
argument_list|,
name|key1st
argument_list|,
name|ns
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the insert of shuffled items      *       * Building a final structure like      *       *<code>      *    {      *       :start : { :next = n1 },      *       n0 : {      *          :next = ""      *       },      *       n1 : {      *          :next = n2      *       },      *       n2 : {      *          :next = n0      *       }      *    }      *</code>      *       * where:      *       *<code>      *    Stage 1      *    =======      *       *    {      *       :start : { :next = n0 },      *       n0 : {      *          :next =       *       }      *    }      *       *    Stage 2      *    =======      *       *    {      *       :start : { :next = n1 },      *       n0 : { :next = },      *       n1 : { :next = n0 }      *    }      *          *    Stage 3      *    =======      *          *    {      *       :start : { :next = n1 },      *       n0 : { :next = },      *       n1 : { :next = n2 },      *       n2 : { :next = n0 }      *    }      *          *    Stage 4      *    =======      *       *    {      *       :start : { :next = n1 },      *       n0 : { :next = n3 },      *       n1 : { :next = n2 },      *       n2 : { :next = n0 },      *       n3 : { :next = }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|fourShuffledElements
parameter_list|()
block|{
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|String
name|n0
init|=
name|KEYS
index|[
literal|2
index|]
decl_stmt|;
name|String
name|n1
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
name|String
name|n2
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|String
name|n3
init|=
name|KEYS
index|[
literal|3
index|]
decl_stmt|;
comment|// Stage 1
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to the first node"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"the first node should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n1"
argument_list|,
name|n1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"'n1' should point to 'n0'"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should still be point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 3
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n1"
argument_list|,
name|n1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n1 should be pointing to n2"
argument_list|,
name|n2
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n2 should be pointing to n0"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n2
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should still be the last item of the list"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 4
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n3
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n1"
argument_list|,
name|n1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n1 should be pointing to n2"
argument_list|,
name|n2
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n2 should be pointing to n0"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n2
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n0 should be pointing to n3"
argument_list|,
name|n3
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n3 should be the last element"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n3
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * perform a test where the index gets updated if an already existent      * node/key gets updated by changing the key and the key contains only 1      * item.      *       * Where the second key is greater than the first.      *       *<code>      *    Stage 1      *    =======      *          *    :index : {      *       :start { :next = n0 },      *       n0 : {      *          :next =,      *          content : {      *             foobar : {      *                match = true      *             }      *          }      *       }      *    }      *          *    Stage 2      *    =======      *          *    :index : {      *       :start : { :next = n1 },      *       n1 : {      *          :next =,      *          content : {      *             foobar : {      *                match = true      *             }      *          }      *       }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|singleKeyUpdate
parameter_list|()
block|{
specifier|final
name|String
name|N0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|N1
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|String
name|PATH
init|=
literal|"/content/foobar"
decl_stmt|;
specifier|final
name|String
index|[]
name|NODES
init|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|PATH
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|NodeBuilder
name|node
init|=
literal|null
decl_stmt|;
comment|// Stage 1
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|":start should exists"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n0"
argument_list|,
name|N0
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|":index should have n0"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|NODES
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should have /content"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|NODES
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"/content should contain /foobar"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"/foobar should have match=true"
argument_list|,
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|,
name|newHashSet
argument_list|(
name|N1
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should now point to N1"
argument_list|,
name|N1
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|N1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"N1 should exists"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"N1 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|NODES
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"N1 should have /content"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|NODES
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"/content should contain /foobar"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"/foobar should have match=true"
argument_list|,
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      *<p>      * find a previous item given a key in an index with 1 element only      *</p>      *       *<p>      *<i>it relies on the functionality of the store.update() for creating the      * index</i>      *</p>      *       *<code>      *    :index {      *       :start : { :next=n0 },      *       n0 = { :next= }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|findPrevious1ItemIndex
parameter_list|()
block|{
specifier|final
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
specifier|final
name|String
name|N0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|NodeState
name|NODE_START
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|N0
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
specifier|final
name|NodeState
name|NODE_0
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
literal|""
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
specifier|final
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|START
argument_list|,
name|NODE_START
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|N0
argument_list|,
name|NODE_0
argument_list|)
expr_stmt|;
name|NodeState
name|indexState
init|=
name|index
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|ChildNodeEntry
name|previous
init|=
name|store
operator|.
name|findPrevious
argument_list|(
name|indexState
argument_list|,
name|NODE_0
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|previous
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"the :start node is expected"
argument_list|,
name|NODE_START
argument_list|,
name|previous
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the use case where a document change the indexed property. For      * example document that change author.      *       *<p>      *<i>it relies on the functionality of the store.update() for creating the      * index</i>      *</p>      *       *<code>      *    Stage 1      *    =======      *          *    :index : {      *       :start : { :next = n0 },      *       n0 : {      *          :next = ,      *          content : {      *             one { match=true },      *             two { match=true }      *          }      *       }      *    }      *          *    Stage 2      *    =======      *          *    :index : {      *       :start : { :next = n0 },      *       n0 : {      *          :next = n1,      *          content : {      *             one : { match = true }      *          }      *       },      *       n1 : {      *          :next = ,      *          content : {      *             two : { match = true }      *          }      *       }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|documentChangingKey
parameter_list|()
block|{
specifier|final
name|String
name|PATH0
init|=
literal|"/content/one"
decl_stmt|;
specifier|final
name|String
name|PATH1
init|=
literal|"/content/two"
decl_stmt|;
specifier|final
name|String
name|N0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|N1
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
comment|// Stage 1 - initialising the index
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH0
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH1
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensuring the right structure
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|START
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|N1
argument_list|)
argument_list|)
expr_stmt|;
name|NodeBuilder
name|node
init|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|":start pointing to wrong node"
argument_list|,
name|N0
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"N0 should go nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// checking the first document
name|String
index|[]
name|path
init|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|PATH0
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|PATH0
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH1
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|,
name|newHashSet
argument_list|(
name|N1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|START
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|N1
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start pointing to wrong node"
argument_list|,
name|N0
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|N1
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|PATH0
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|PATH1
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// we know both the
comment|// documents share
comment|// the same /content
name|assertFalse
argument_list|(
literal|"/content/two should no longer be under N0"
argument_list|,
name|node
operator|.
name|hasChildNode
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|N1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"N1 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|PATH1
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test when a document is deleted and is the only one under the indexed key      *       *<p>      *<i>it relies on the functionality of the store.update() for creating the      * index</i>      *</p>      *       *<code>      *    Stage 1      *    =======      *          *    :index : {      *       :start : { :next = n0 },      *       n0 : {      *          :next = ,      *          sampledoc : { match = true }      *       }      *    }      *          *    Stage 2      *    =======      *          *    :index : {      *       :start : { :next = }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|deleteTheOnlyDocument
parameter_list|()
block|{
specifier|final
name|String
name|N0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|PATH
init|=
literal|"/sampledoc"
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
comment|// Stage 1 - initialising the index
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
comment|// we assume it works and therefore not checking the status of the index
comment|// let's go straight to Stage 2
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|,
name|EMPTY_KEY_SET
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"The node should have been removed"
argument_list|,
name|index
operator|.
name|hasChildNode
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"as the index should be empty, :start should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test when the document is deleted but there're still some documents left      * under the indexed key      *       *<p>      *<i>it relies on the functionality of the store.update() for creating the      * index</i>      *</p>      *       *<code>      *    Stage 1      *    =======      *          *    :index : {      *       :start : { :next = n0 },      *       n0 : {      *          :next = ,      *          doc1 : { match=true },      *          doc2 : { match=true }      *       }      *    }      *          *    Stage 2      *    =======      *          *    :index : {      *       :start : { :next = n0 },      *       n0 : {      *          :next  =,      *          doc2 : { match = true }      *       }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|deleteOneOfTheDocuments
parameter_list|()
block|{
specifier|final
name|String
name|N0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|DOC1
init|=
literal|"doc1"
decl_stmt|;
specifier|final
name|String
name|DOC2
init|=
literal|"doc2"
decl_stmt|;
specifier|final
name|String
name|PATH1
init|=
literal|"/"
operator|+
name|DOC1
decl_stmt|;
specifier|final
name|String
name|PATH2
init|=
literal|"/"
operator|+
name|DOC2
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH1
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH2
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
comment|// we trust the store at this point and skip a double-check. Let's move
comment|// to Stage 2!
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH1
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|,
name|EMPTY_KEY_SET
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|START
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should still point to N0"
argument_list|,
name|N0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
operator|.
name|hasChildNode
argument_list|(
name|DOC1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
operator|.
name|hasChildNode
argument_list|(
name|DOC2
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|DOC2
argument_list|)
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test when the only document is deleted from an indexed key but there're      * still some keys left in the index      *       *<p>      *<i>it relies on the functionality of the store.update() for creating the      * index</i>      *</p>      *       *<code>      *    Stage 1      *    =======      *          *    :index : {      *       :start : { :next = n1 },      *       n0 : {      *          :next = ,      *          content : {      *             doc0 : { match = true }      *          }      *       },      *       n1 : {      *          :next = n2,      *          content : {      *             doc1 : { match = true }      *          }      *       }      *       n2 : {      *          :next = n0,      *          content : {      *             doc2 : { match = true }      *          }      *       }      *    }      *          *    Stage 2      *    =======      *          *    :index : {      *       :start : { :next = n1 },      *       n0 : {      *          :next = ,      *          content : {      *             doc0 : { match = true }      *          }      *       },      *       n1 : {      *          :next = n0,      *          content : {      *             doc1 : { match = true }      *          }      *       }      *    }      *          *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|deleteTheOnlyDocumentInMultiKeysIndex
parameter_list|()
block|{
specifier|final
name|String
name|PATH0
init|=
literal|"/content/doc0"
decl_stmt|;
specifier|final
name|String
name|PATH1
init|=
literal|"/content/doc1"
decl_stmt|;
specifier|final
name|String
name|PATH2
init|=
literal|"/content/doc2"
decl_stmt|;
specifier|final
name|String
name|N0
init|=
name|KEYS
index|[
literal|2
index|]
decl_stmt|;
specifier|final
name|String
name|N1
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|N2
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
comment|// Stage 1
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH0
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH1
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|N1
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH2
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|N2
argument_list|)
argument_list|)
expr_stmt|;
comment|// as we trust the store we skip the check and goes straight to Stage 2.
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|PATH2
argument_list|,
name|newHashSet
argument_list|(
name|N2
argument_list|)
argument_list|,
name|EMPTY_KEY_SET
argument_list|)
expr_stmt|;
comment|// checking key nodes
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|START
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|N0
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|N1
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|N2
argument_list|)
argument_list|)
expr_stmt|;
comment|// checking pointers
name|assertEquals
argument_list|(
name|N1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|N0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|N1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// checking sub-nodes
name|String
index|[]
name|subNodes
init|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|PATH0
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
operator|.
name|hasChildNode
argument_list|(
name|subNodes
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|subNodes
index|[
literal|0
index|]
argument_list|)
operator|.
name|hasChildNode
argument_list|(
name|subNodes
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|N0
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|subNodes
index|[
literal|0
index|]
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|subNodes
index|[
literal|1
index|]
argument_list|)
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
name|subNodes
operator|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|PATH1
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|N1
argument_list|)
operator|.
name|hasChildNode
argument_list|(
name|subNodes
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|N1
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|subNodes
index|[
literal|0
index|]
argument_list|)
operator|.
name|hasChildNode
argument_list|(
name|subNodes
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|N1
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|subNodes
index|[
literal|0
index|]
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|subNodes
index|[
literal|1
index|]
argument_list|)
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

