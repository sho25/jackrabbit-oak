begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|writer
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|MergePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentCommitInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  *  This {@link MergePolicy} extends Lucene's {@link org.apache.lucene.index.TieredMergePolicy} by providing mitigation  *  to the aggressiveness of merges in case the index is under high commit load.  *  That's because in the case of Oak we currently have that we store Lucene indexes in storage systems which require  *  themselves some garbage collection task to be executed to get rid of deleted / unused files, similarly to what Lucene's  *  merge does.  *  So the bottom line is that with this {@link MergePolicy} we should have less but bigger merges, only after commit rate  *  is under a certain threshold (in terms of added docs per sec and MBs per sec).  *  *  Auto tuning params:  *  In this merge policy we would like to avoid having to adjust parameters by hand, but rather have them "auto tune".  *  This means that the no. of merges should be mitigated with respect to a max commit rate (docs, mb), but also adapt to  *  the average commit rate and anyway do not let the no. of segments explode.  *  */
end_comment

begin_class
specifier|public
class|class
name|CommitMitigatingTieredMergePolicy
extends|extends
name|MergePolicy
block|{
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Default noCFSRatio.  If a merge's size is&gt;= 10% of      *  the index, then we disable compound file for it.      *  @see MergePolicy#setNoCFSRatio */
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_NO_CFS_RATIO
init|=
literal|0.1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_MAX_COMMIT_RATE_DOCS
init|=
literal|1000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_MAX_COMMIT_RATE_MB
init|=
literal|5
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_NO_OF_SEGS_FOR_MITIGATION
init|=
literal|20
decl_stmt|;
specifier|private
name|int
name|maxMergeAtOnce
init|=
literal|10
decl_stmt|;
specifier|private
name|long
name|maxMergedSegmentBytes
init|=
literal|5
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024L
decl_stmt|;
specifier|private
name|int
name|maxMergeAtOnceExplicit
init|=
literal|30
decl_stmt|;
specifier|private
name|long
name|floorSegmentBytes
init|=
literal|2
operator|*
literal|1024
operator|*
literal|1024L
decl_stmt|;
specifier|private
name|double
name|segsPerTier
init|=
literal|10.0
decl_stmt|;
specifier|private
name|double
name|forceMergeDeletesPctAllowed
init|=
literal|10.0
decl_stmt|;
specifier|private
name|double
name|reclaimDeletesWeight
init|=
literal|1.5
decl_stmt|;
specifier|private
name|double
name|maxCommitRateDocs
init|=
name|DEFAULT_MAX_COMMIT_RATE_DOCS
decl_stmt|;
specifier|private
name|double
name|maxCommitRateMB
init|=
name|DEFAULT_MAX_COMMIT_RATE_MB
decl_stmt|;
specifier|private
name|int
name|maxNoOfSegsForMitigation
init|=
name|DEFAULT_MAX_NO_OF_SEGS_FOR_MITIGATION
decl_stmt|;
specifier|private
name|double
name|docCount
init|=
literal|0d
decl_stmt|;
specifier|private
name|double
name|mb
init|=
literal|0d
decl_stmt|;
specifier|private
name|double
name|time
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|/**      * initial values for time series      */
specifier|private
name|double
name|avgCommitRateDocs
init|=
literal|0d
decl_stmt|;
specifier|private
name|double
name|avgCommitRateMB
init|=
literal|0d
decl_stmt|;
specifier|private
name|double
name|avgSegs
init|=
literal|0
decl_stmt|;
comment|/**      * length of time series analysis for commit rate and no. of segments      */
specifier|private
name|double
name|timeSeriesLength
init|=
literal|50d
decl_stmt|;
comment|/**      * current step in current time series batch      */
specifier|private
name|double
name|timeSeriesCount
init|=
literal|0d
decl_stmt|;
comment|/**      * single exponential smoothing ratio (0< alpha< 1)      *      * values towards 0 tend to give more weight to past inputs      * values close to 1 weigh recent values more      */
specifier|private
name|double
name|alpha
init|=
literal|0.7
decl_stmt|;
comment|/** Sole constructor, setting all settings to their      *  defaults. */
specifier|public
name|CommitMitigatingTieredMergePolicy
parameter_list|()
block|{
name|super
argument_list|(
name|DEFAULT_NO_CFS_RATIO
argument_list|,
name|MergePolicy
operator|.
name|DEFAULT_MAX_CFS_SEGMENT_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/** Maximum number of segments to be merged at a time      *  during "normal" merging.  For explicit merging (eg,      *  forceMerge or forceMergeDeletes was called), see {@link      *  #setMaxMergeAtOnceExplicit}.  Default is 10.      *      * @param v the max no. of merges      * @return this merge policy instance      *      **/
specifier|public
name|CommitMitigatingTieredMergePolicy
name|setMaxMergeAtOnce
parameter_list|(
name|int
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxMergeAtOnce must be> 1 (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|maxMergeAtOnce
operator|=
name|v
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Maximum number of segments allowed for mitigation to happen.      * This is supposed to avoid having too few merges due to high commit rates      * @param maxNoOfSegsForMitigation max no. of segments per mitigation      * @return this merge policy instance      */
specifier|public
name|CommitMitigatingTieredMergePolicy
name|setMaxNoOfSegsForMitigation
parameter_list|(
name|int
name|maxNoOfSegsForMitigation
parameter_list|)
block|{
name|this
operator|.
name|maxNoOfSegsForMitigation
operator|=
name|maxNoOfSegsForMitigation
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * set the maximum no. of docs per sec accepted for a merge to happen      *      * @param maxCommitRate maxCommitRate maximum commit rate (docs/sec)      * @return this merge policy instance      */
specifier|public
name|CommitMitigatingTieredMergePolicy
name|setMaxCommitRateDocs
parameter_list|(
name|double
name|maxCommitRate
parameter_list|)
block|{
name|this
operator|.
name|maxCommitRateDocs
operator|=
name|maxCommitRate
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the current maxMergeAtOnce setting.      *      * @return the max merge at once that can be performed      * @see #setMaxMergeAtOnce */
specifier|public
name|int
name|getMaxMergeAtOnce
parameter_list|()
block|{
return|return
name|maxMergeAtOnce
return|;
block|}
comment|// TODO: should addIndexes do explicit merging, too?  And,
comment|// if user calls IW.maybeMerge "explicitly"
comment|/** Maximum number of segments to be merged at a time,      *  during forceMerge or forceMergeDeletes. Default is 30.      *      * @param v the no. of max merges      * @return this merge policy instance      **/
specifier|public
name|CommitMitigatingTieredMergePolicy
name|setMaxMergeAtOnceExplicit
parameter_list|(
name|int
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxMergeAtOnceExplicit must be> 1 (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|maxMergeAtOnceExplicit
operator|=
name|v
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the current maxMergeAtOnceExplicit setting.      * @return the maxMergeAtOnceExplicit value      *      * @see #setMaxMergeAtOnceExplicit */
specifier|public
name|int
name|getMaxMergeAtOnceExplicit
parameter_list|()
block|{
return|return
name|maxMergeAtOnceExplicit
return|;
block|}
comment|/** Maximum sized segment to produce during      *  normal merging.  This setting is approximate: the      *  estimate of the merged segment size is made by summing      *  sizes of to-be-merged segments (compensating for      *  percent deleted docs).  Default is 5 GB.      *      * @param v the maximum segment size in MB      * @return this merge policy instance      **/
specifier|public
name|CommitMitigatingTieredMergePolicy
name|setMaxMergedSegmentMB
parameter_list|(
name|double
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<
literal|0.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxMergedSegmentMB must be>=0 (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|v
operator|*=
literal|1024
operator|*
literal|1024
expr_stmt|;
name|maxMergedSegmentBytes
operator|=
operator|(
name|v
operator|>
name|Long
operator|.
name|MAX_VALUE
operator|)
condition|?
name|Long
operator|.
name|MAX_VALUE
else|:
operator|(
name|long
operator|)
name|v
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the current maxMergedSegmentMB setting.      *      * @return the max merged segment size in MB      *      * @see #getMaxMergedSegmentMB */
specifier|public
name|double
name|getMaxMergedSegmentMB
parameter_list|()
block|{
return|return
name|maxMergedSegmentBytes
operator|/
literal|1024
operator|/
literal|1024.
return|;
block|}
comment|/** Controls how aggressively merges that reclaim more      *  deletions are favored.  Higher values will more      *  aggressively target merges that reclaim deletions, but      *  be careful not to go so high that way too much merging      *  takes place; a value of 3.0 is probably nearly too      *  high.  A value of 0.0 means deletions don't impact      *  merge selection.      *      *  @param v the reclaim deletes weight      *  @return this merge policy instance      **/
specifier|public
name|CommitMitigatingTieredMergePolicy
name|setReclaimDeletesWeight
parameter_list|(
name|double
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<
literal|0.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"reclaimDeletesWeight must be>= 0.0 (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|reclaimDeletesWeight
operator|=
name|v
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** See {@link #setReclaimDeletesWeight}.      * @return the reclaim deletes weight      *      **/
specifier|public
name|double
name|getReclaimDeletesWeight
parameter_list|()
block|{
return|return
name|reclaimDeletesWeight
return|;
block|}
comment|/** Segments smaller than this are "rounded up" to this      *  size, ie treated as equal (floor) size for merge      *  selection.  This is to prevent frequent flushing of      *  tiny segments from allowing a long tail in the index.      *  Default is 2 MB.      *      * @param v floor segment size in MB      * @return this merge policy instance      *      **/
specifier|public
name|CommitMitigatingTieredMergePolicy
name|setFloorSegmentMB
parameter_list|(
name|double
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<=
literal|0.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"floorSegmentMB must be>= 0.0 (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|v
operator|*=
literal|1024
operator|*
literal|1024
expr_stmt|;
name|floorSegmentBytes
operator|=
operator|(
name|v
operator|>
name|Long
operator|.
name|MAX_VALUE
operator|)
condition|?
name|Long
operator|.
name|MAX_VALUE
else|:
operator|(
name|long
operator|)
name|v
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the current floorSegmentMB.      * @return the floor segment size in MB      *      *  @see #setFloorSegmentMB */
specifier|public
name|double
name|getFloorSegmentMB
parameter_list|()
block|{
return|return
name|floorSegmentBytes
operator|/
operator|(
literal|1024
operator|*
literal|1024.
operator|)
return|;
block|}
comment|/** When forceMergeDeletes is called, we only merge away a      *  segment if its delete percentage is over this      *  threshold.  Default is 10%.      *      * @param v the force merge deletes allowed percentage      * @return this merge policy instance      *      **/
specifier|public
name|CommitMitigatingTieredMergePolicy
name|setForceMergeDeletesPctAllowed
parameter_list|(
name|double
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
argument_list|<
literal|0.0
operator|||
name|v
argument_list|>
literal|100.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"forceMergeDeletesPctAllowed must be between 0.0 and 100.0 inclusive (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|forceMergeDeletesPctAllowed
operator|=
name|v
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the current forceMergeDeletesPctAllowed setting.      * @return the forceMergeDeletesPctAllowed      *      * @see #setForceMergeDeletesPctAllowed */
specifier|public
name|double
name|getForceMergeDeletesPctAllowed
parameter_list|()
block|{
return|return
name|forceMergeDeletesPctAllowed
return|;
block|}
comment|/** Sets the allowed number of segments per tier.  Smaller      *  values mean more merging but fewer segments.      *      *<p><b>NOTE</b>: this value should be&gt;= the {@link      *  #setMaxMergeAtOnce} otherwise you'll force too much      *  merging to occur.</p>      *      *<p>Default is 10.0.</p>      *      * @param v segments per tier      * @return this merge policy instance      *      **/
specifier|public
name|CommitMitigatingTieredMergePolicy
name|setSegmentsPerTier
parameter_list|(
name|double
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<
literal|2.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"segmentsPerTier must be>= 2.0 (got "
operator|+
name|v
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|segsPerTier
operator|=
name|v
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns the current segmentsPerTier setting.      * @return segments per tier      *      * @see #setSegmentsPerTier */
specifier|public
name|double
name|getSegmentsPerTier
parameter_list|()
block|{
return|return
name|segsPerTier
return|;
block|}
comment|/**      * set the max no. of committed MBs for a merge to happen      * @param maxCommitRateMB max commit rate in MB (mb/sec)      * @return this merge policy instance      */
specifier|public
name|CommitMitigatingTieredMergePolicy
name|setMaxCommitRateMB
parameter_list|(
name|int
name|maxCommitRateMB
parameter_list|)
block|{
name|this
operator|.
name|maxCommitRateMB
operator|=
name|maxCommitRateMB
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|private
class|class
name|SegmentByteSizeDescending
implements|implements
name|Comparator
argument_list|<
name|SegmentCommitInfo
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|SegmentCommitInfo
name|o1
parameter_list|,
name|SegmentCommitInfo
name|o2
parameter_list|)
block|{
try|try
block|{
specifier|final
name|long
name|sz1
init|=
name|size
argument_list|(
name|o1
argument_list|)
decl_stmt|;
specifier|final
name|long
name|sz2
init|=
name|size
argument_list|(
name|o2
argument_list|)
decl_stmt|;
if|if
condition|(
name|sz1
operator|>
name|sz2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|sz2
operator|>
name|sz1
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
name|o1
operator|.
name|info
operator|.
name|name
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|info
operator|.
name|name
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Holds score and explanation for a single candidate      *  merge. */
specifier|protected
specifier|static
specifier|abstract
class|class
name|MergeScore
block|{
comment|/** Sole constructor. (For invocation by subclass          *  constructors, typically implicit.) */
specifier|protected
name|MergeScore
parameter_list|()
block|{         }
comment|/** Returns the score for this merge candidate; lower          *  scores are better. */
specifier|abstract
name|double
name|getScore
parameter_list|()
function_decl|;
comment|/** Human readable explanation of how the merge got this          *  score. */
specifier|abstract
name|String
name|getExplanation
parameter_list|()
function_decl|;
block|}
annotation|@
name|Override
specifier|public
name|MergeSpecification
name|findMerges
parameter_list|(
name|MergeTrigger
name|mergeTrigger
parameter_list|,
name|SegmentInfos
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|segmentSize
init|=
name|infos
operator|.
name|size
argument_list|()
decl_stmt|;
name|timeSeriesCount
operator|++
expr_stmt|;
if|if
condition|(
name|timeSeriesCount
operator|%
name|timeSeriesLength
operator|==
literal|0
condition|)
block|{
comment|// reset averages
name|avgCommitRateDocs
operator|=
literal|0d
expr_stmt|;
name|avgCommitRateMB
operator|=
literal|0d
expr_stmt|;
name|avgSegs
operator|=
literal|0d
expr_stmt|;
block|}
name|avgSegs
operator|=
name|singleExpSmoothing
argument_list|(
name|segmentSize
argument_list|,
name|avgSegs
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"segments: current {}, average {}"
argument_list|,
name|segmentSize
argument_list|,
name|avgSegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"findMerges: "
operator|+
name|segmentSize
operator|+
literal|" segments, "
operator|+
name|avgSegs
operator|+
literal|" average"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|segmentSize
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// if no. of segments exceeds the maximum, adjust the maximum rates to allow more merges (less commit/rate mitigation)
if|if
condition|(
name|segmentSize
operator|>
name|maxNoOfSegsForMitigation
condition|)
block|{
if|if
condition|(
name|avgCommitRateDocs
operator|>
name|maxCommitRateDocs
condition|)
block|{
name|double
name|v
init|=
name|singleExpSmoothing
argument_list|(
name|avgCommitRateDocs
argument_list|,
name|maxCommitRateDocs
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"adjusted maxCommitRateDocs from {} to {}"
argument_list|,
name|maxCommitRateDocs
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|maxCommitRateDocs
operator|=
name|v
expr_stmt|;
block|}
if|if
condition|(
name|avgCommitRateMB
operator|>
name|maxCommitRateMB
condition|)
block|{
name|double
name|v
init|=
name|singleExpSmoothing
argument_list|(
name|avgCommitRateMB
argument_list|,
name|maxCommitRateMB
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"adjusted maxCommitRateMB from {} to {}"
argument_list|,
name|maxCommitRateMB
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|maxCommitRateMB
operator|=
name|v
expr_stmt|;
block|}
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|double
name|timeDelta
init|=
operator|(
name|now
operator|/
literal|1000d
operator|)
operator|-
operator|(
name|time
operator|/
literal|1000d
operator|)
decl_stmt|;
name|double
name|commitRate
init|=
name|Math
operator|.
name|abs
argument_list|(
name|docCount
operator|-
name|infos
operator|.
name|totalDocCount
argument_list|()
argument_list|)
operator|/
name|timeDelta
decl_stmt|;
name|time
operator|=
name|now
expr_stmt|;
name|avgCommitRateDocs
operator|=
name|singleExpSmoothing
argument_list|(
name|commitRate
argument_list|,
name|avgCommitRateDocs
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"commit rate: current {}, average {} docs/sec"
argument_list|,
name|commitRate
argument_list|,
name|avgCommitRateDocs
argument_list|)
expr_stmt|;
name|docCount
operator|=
name|infos
operator|.
name|totalDocCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
name|commitRate
operator|+
literal|"doc/s (max: "
operator|+
name|maxCommitRateDocs
operator|+
literal|", avg: "
operator|+
name|avgCommitRateDocs
operator|+
literal|" doc/s)"
argument_list|)
expr_stmt|;
block|}
comment|// do not mitigate if there're too many segments to avoid affecting performance
if|if
condition|(
name|commitRate
operator|>
name|maxCommitRateDocs
operator|&&
name|segmentSize
operator|<
name|maxNoOfSegsForMitigation
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Collection
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|merging
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|getMergingSegments
argument_list|()
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|toBeMerged
init|=
operator|new
name|HashSet
argument_list|<
name|SegmentCommitInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|infosSorted
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentCommitInfo
argument_list|>
argument_list|(
name|infos
operator|.
name|asList
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|infosSorted
argument_list|,
operator|new
name|SegmentByteSizeDescending
argument_list|()
argument_list|)
expr_stmt|;
comment|// Compute total index bytes& print details about the index
name|long
name|totIndexBytes
init|=
literal|0
decl_stmt|;
name|long
name|minSegmentBytes
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|infosSorted
control|)
block|{
specifier|final
name|long
name|segBytes
init|=
name|size
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|String
name|extra
init|=
name|merging
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|?
literal|" [merging]"
else|:
literal|""
decl_stmt|;
if|if
condition|(
name|segBytes
operator|>=
name|maxMergedSegmentBytes
operator|/
literal|2.0
condition|)
block|{
name|extra
operator|+=
literal|" [skip: too large]"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|segBytes
operator|<
name|floorSegmentBytes
condition|)
block|{
name|extra
operator|+=
literal|" [floored]"
expr_stmt|;
block|}
name|message
argument_list|(
literal|"  seg="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|info
argument_list|)
operator|+
literal|" size="
operator|+
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%.3f"
argument_list|,
name|segBytes
operator|/
literal|1024
operator|/
literal|1024.
argument_list|)
operator|+
literal|" MB"
operator|+
name|extra
argument_list|)
expr_stmt|;
block|}
name|minSegmentBytes
operator|=
name|Math
operator|.
name|min
argument_list|(
name|segBytes
argument_list|,
name|minSegmentBytes
argument_list|)
expr_stmt|;
comment|// Accum total byte size
name|totIndexBytes
operator|+=
name|segBytes
expr_stmt|;
block|}
comment|// If we have too-large segments, grace them out
comment|// of the maxSegmentCount:
name|int
name|tooBigCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|tooBigCount
operator|<
name|infosSorted
operator|.
name|size
argument_list|()
operator|&&
name|size
argument_list|(
name|infosSorted
operator|.
name|get
argument_list|(
name|tooBigCount
argument_list|)
argument_list|)
operator|>=
name|maxMergedSegmentBytes
operator|/
literal|2.0
condition|)
block|{
name|totIndexBytes
operator|-=
name|size
argument_list|(
name|infosSorted
operator|.
name|get
argument_list|(
name|tooBigCount
argument_list|)
argument_list|)
expr_stmt|;
name|tooBigCount
operator|++
expr_stmt|;
block|}
name|minSegmentBytes
operator|=
name|floorSize
argument_list|(
name|minSegmentBytes
argument_list|)
expr_stmt|;
comment|// Compute max allowed segs in the index
name|long
name|levelSize
init|=
name|minSegmentBytes
decl_stmt|;
name|long
name|bytesLeft
init|=
name|totIndexBytes
decl_stmt|;
name|double
name|allowedSegCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|double
name|segCountLevel
init|=
name|bytesLeft
operator|/
operator|(
name|double
operator|)
name|levelSize
decl_stmt|;
if|if
condition|(
name|segCountLevel
operator|<
name|segsPerTier
condition|)
block|{
name|allowedSegCount
operator|+=
name|Math
operator|.
name|ceil
argument_list|(
name|segCountLevel
argument_list|)
expr_stmt|;
break|break;
block|}
name|allowedSegCount
operator|+=
name|segsPerTier
expr_stmt|;
name|bytesLeft
operator|-=
name|segsPerTier
operator|*
name|levelSize
expr_stmt|;
name|levelSize
operator|*=
name|maxMergeAtOnce
expr_stmt|;
block|}
name|int
name|allowedSegCountInt
init|=
operator|(
name|int
operator|)
name|allowedSegCount
decl_stmt|;
name|MergeSpecification
name|spec
init|=
literal|null
decl_stmt|;
comment|// Cycle to possibly select more than one merge:
while|while
condition|(
literal|true
condition|)
block|{
name|long
name|mergingBytes
init|=
literal|0
decl_stmt|;
name|double
name|idxBytes
init|=
literal|0
decl_stmt|;
comment|// Gather eligible segments for merging, ie segments
comment|// not already being merged and not already picked (by
comment|// prior iteration of this loop) for merging:
specifier|final
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|eligible
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentCommitInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|tooBigCount
init|;
name|idx
operator|<
name|infosSorted
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|SegmentCommitInfo
name|info
init|=
name|infosSorted
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|merging
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|mergingBytes
operator|+=
name|info
operator|.
name|sizeInBytes
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|toBeMerged
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|eligible
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|idxBytes
operator|+=
name|info
operator|.
name|sizeInBytes
argument_list|()
expr_stmt|;
block|}
name|idxBytes
operator|/=
literal|1024
operator|*
literal|1000
expr_stmt|;
specifier|final
name|boolean
name|maxMergeIsRunning
init|=
name|mergingBytes
operator|>=
name|maxMergedSegmentBytes
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  allowedSegmentCount="
operator|+
name|allowedSegCountInt
operator|+
literal|" vs count="
operator|+
name|infosSorted
operator|.
name|size
argument_list|()
operator|+
literal|" (eligible count="
operator|+
name|eligible
operator|.
name|size
argument_list|()
operator|+
literal|") tooBigCount="
operator|+
name|tooBigCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eligible
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|spec
return|;
block|}
name|double
name|bytes
init|=
name|idxBytes
operator|-
name|this
operator|.
name|mb
decl_stmt|;
name|double
name|mbRate
init|=
name|bytes
operator|/
name|timeDelta
decl_stmt|;
name|avgCommitRateMB
operator|=
name|singleExpSmoothing
argument_list|(
name|mbRate
argument_list|,
name|avgCommitRateMB
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"commit rate: current {}, average {} MB/sec"
argument_list|,
name|mbRate
argument_list|,
name|avgCommitRateMB
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
name|mbRate
operator|+
literal|"mb/s (max: "
operator|+
name|maxCommitRateMB
operator|+
literal|", avg: "
operator|+
name|avgCommitRateMB
operator|+
literal|" MB/s)"
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|mb
operator|=
name|idxBytes
expr_stmt|;
comment|// do not mitigate if there're too many segments to avoid affecting performance
if|if
condition|(
name|mbRate
operator|>
name|maxCommitRateMB
operator|&&
name|segmentSize
operator|<
name|maxNoOfSegsForMitigation
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|eligible
operator|.
name|size
argument_list|()
operator|>=
name|allowedSegCountInt
condition|)
block|{
comment|// OK we are over budget -- find best merge!
name|MergeScore
name|bestScore
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|best
init|=
literal|null
decl_stmt|;
name|boolean
name|bestTooLarge
init|=
literal|false
decl_stmt|;
name|long
name|bestMergeBytes
init|=
literal|0
decl_stmt|;
comment|// Consider all merge starts:
for|for
control|(
name|int
name|startIdx
init|=
literal|0
init|;
name|startIdx
operator|<=
name|eligible
operator|.
name|size
argument_list|()
operator|-
name|maxMergeAtOnce
condition|;
name|startIdx
operator|++
control|)
block|{
name|long
name|totAfterMergeBytes
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|candidate
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentCommitInfo
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|hitTooLarge
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|startIdx
init|;
name|idx
operator|<
name|eligible
operator|.
name|size
argument_list|()
operator|&&
name|candidate
operator|.
name|size
argument_list|()
operator|<
name|maxMergeAtOnce
condition|;
name|idx
operator|++
control|)
block|{
specifier|final
name|SegmentCommitInfo
name|info
init|=
name|eligible
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
specifier|final
name|long
name|segBytes
init|=
name|size
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|totAfterMergeBytes
operator|+
name|segBytes
operator|>
name|maxMergedSegmentBytes
condition|)
block|{
name|hitTooLarge
operator|=
literal|true
expr_stmt|;
comment|// NOTE: we continue, so that we can try
comment|// "packing" smaller segments into this merge
comment|// to see if we can get closer to the max
comment|// size; this in general is not perfect since
comment|// this is really "bin packing" and we'd have
comment|// to try different permutations.
continue|continue;
block|}
name|candidate
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|totAfterMergeBytes
operator|+=
name|segBytes
expr_stmt|;
block|}
specifier|final
name|MergeScore
name|score
init|=
name|score
argument_list|(
name|candidate
argument_list|,
name|hitTooLarge
argument_list|,
name|mergingBytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  maybe="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|candidate
argument_list|)
operator|+
literal|" score="
operator|+
name|score
operator|.
name|getScore
argument_list|()
operator|+
literal|" "
operator|+
name|score
operator|.
name|getExplanation
argument_list|()
operator|+
literal|" tooLarge="
operator|+
name|hitTooLarge
operator|+
literal|" size="
operator|+
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%.3f MB"
argument_list|,
name|totAfterMergeBytes
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If we are already running a max sized merge
comment|// (maxMergeIsRunning), don't allow another max
comment|// sized merge to kick off:
if|if
condition|(
operator|(
name|bestScore
operator|==
literal|null
operator|||
name|score
operator|.
name|getScore
argument_list|()
operator|<
name|bestScore
operator|.
name|getScore
argument_list|()
operator|)
operator|&&
operator|(
operator|!
name|hitTooLarge
operator|||
operator|!
name|maxMergeIsRunning
operator|)
condition|)
block|{
name|best
operator|=
name|candidate
expr_stmt|;
name|bestScore
operator|=
name|score
expr_stmt|;
name|bestTooLarge
operator|=
name|hitTooLarge
expr_stmt|;
name|bestMergeBytes
operator|=
name|totAfterMergeBytes
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|spec
operator|==
literal|null
condition|)
block|{
name|spec
operator|=
operator|new
name|MergeSpecification
argument_list|()
expr_stmt|;
block|}
specifier|final
name|OneMerge
name|merge
init|=
operator|new
name|OneMerge
argument_list|(
name|best
argument_list|)
decl_stmt|;
name|spec
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|merge
operator|.
name|segments
control|)
block|{
name|toBeMerged
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"  add merge="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
operator|+
literal|" size="
operator|+
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%.3f MB"
argument_list|,
name|bestMergeBytes
operator|/
literal|1024.
operator|/
literal|1024.
argument_list|)
operator|+
literal|" score="
operator|+
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%.3f"
argument_list|,
name|bestScore
operator|.
name|getScore
argument_list|()
argument_list|)
operator|+
literal|" "
operator|+
name|bestScore
operator|.
name|getExplanation
argument_list|()
operator|+
operator|(
name|bestTooLarge
condition|?
literal|" [max merge]"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
name|spec
return|;
block|}
block|}
else|else
block|{
return|return
name|spec
return|;
block|}
block|}
block|}
comment|/**      * single exponential smoothing      * @param input current time series value      * @param smoothedValue previous smoothed value      * @return the new smoothed value      */
specifier|private
name|double
name|singleExpSmoothing
parameter_list|(
name|double
name|input
parameter_list|,
name|double
name|smoothedValue
parameter_list|)
block|{
return|return
name|alpha
operator|*
name|input
operator|+
operator|(
literal|1
operator|-
name|alpha
operator|)
operator|*
name|smoothedValue
return|;
block|}
comment|/** Expert: scores one merge; subclasses can override.      * @param candidate a list of candidate segments      * @param hitTooLarge hit too large setting      * @param mergingBytes the bytes to merge      * @return a merge score      **/
specifier|protected
name|MergeScore
name|score
parameter_list|(
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|candidate
parameter_list|,
name|boolean
name|hitTooLarge
parameter_list|,
name|long
name|mergingBytes
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|totBeforeMergeBytes
init|=
literal|0
decl_stmt|;
name|long
name|totAfterMergeBytes
init|=
literal|0
decl_stmt|;
name|long
name|totAfterMergeBytesFloored
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|candidate
control|)
block|{
specifier|final
name|long
name|segBytes
init|=
name|size
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|totAfterMergeBytes
operator|+=
name|segBytes
expr_stmt|;
name|totAfterMergeBytesFloored
operator|+=
name|floorSize
argument_list|(
name|segBytes
argument_list|)
expr_stmt|;
name|totBeforeMergeBytes
operator|+=
name|info
operator|.
name|sizeInBytes
argument_list|()
expr_stmt|;
block|}
comment|// Roughly measure "skew" of the merge, i.e. how
comment|// "balanced" the merge is (whether the segments are
comment|// about the same size), which can range from
comment|// 1.0/numSegsBeingMerged (good) to 1.0 (poor). Heavily
comment|// lopsided merges (skew near 1.0) is no good; it means
comment|// O(N^2) merge cost over time:
specifier|final
name|double
name|skew
decl_stmt|;
if|if
condition|(
name|hitTooLarge
condition|)
block|{
comment|// Pretend the merge has perfect skew; skew doesn't
comment|// matter in this case because this merge will not
comment|// "cascade" and so it cannot lead to N^2 merge cost
comment|// over time:
name|skew
operator|=
literal|1.0
operator|/
name|maxMergeAtOnce
expr_stmt|;
block|}
else|else
block|{
name|skew
operator|=
operator|(
operator|(
name|double
operator|)
name|floorSize
argument_list|(
name|size
argument_list|(
name|candidate
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|/
name|totAfterMergeBytesFloored
expr_stmt|;
block|}
comment|// Strongly favor merges with less skew (smaller
comment|// mergeScore is better):
name|double
name|mergeScore
init|=
name|skew
decl_stmt|;
comment|// Gently favor smaller merges over bigger ones.  We
comment|// don't want to make this exponent too large else we
comment|// can end up doing poor merges of small segments in
comment|// order to avoid the large merges:
name|mergeScore
operator|*=
name|Math
operator|.
name|pow
argument_list|(
name|totAfterMergeBytes
argument_list|,
literal|0.05
argument_list|)
expr_stmt|;
comment|// Strongly favor merges that reclaim deletes:
specifier|final
name|double
name|nonDelRatio
init|=
operator|(
operator|(
name|double
operator|)
name|totAfterMergeBytes
operator|)
operator|/
name|totBeforeMergeBytes
decl_stmt|;
name|mergeScore
operator|*=
name|Math
operator|.
name|pow
argument_list|(
name|nonDelRatio
argument_list|,
name|reclaimDeletesWeight
argument_list|)
expr_stmt|;
specifier|final
name|double
name|finalMergeScore
init|=
name|mergeScore
decl_stmt|;
return|return
operator|new
name|MergeScore
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|double
name|getScore
parameter_list|()
block|{
return|return
name|finalMergeScore
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getExplanation
parameter_list|()
block|{
return|return
literal|"skew="
operator|+
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%.3f"
argument_list|,
name|skew
argument_list|)
operator|+
literal|" nonDelRatio="
operator|+
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%.3f"
argument_list|,
name|nonDelRatio
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeSpecification
name|findForcedMerges
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|,
name|int
name|maxSegmentCount
parameter_list|,
name|Map
argument_list|<
name|SegmentCommitInfo
argument_list|,
name|Boolean
argument_list|>
name|segmentsToMerge
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"findForcedMerges maxSegmentCount="
operator|+
name|maxSegmentCount
operator|+
literal|" infos="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|infos
argument_list|)
operator|+
literal|" segmentsToMerge="
operator|+
name|segmentsToMerge
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|eligible
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentCommitInfo
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|forceMergeRunning
init|=
literal|false
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|merging
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|getMergingSegments
argument_list|()
decl_stmt|;
name|boolean
name|segmentIsOriginal
init|=
literal|false
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|infos
control|)
block|{
specifier|final
name|Boolean
name|isOriginal
init|=
name|segmentsToMerge
operator|.
name|get
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|isOriginal
operator|!=
literal|null
condition|)
block|{
name|segmentIsOriginal
operator|=
name|isOriginal
expr_stmt|;
if|if
condition|(
operator|!
name|merging
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|eligible
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|forceMergeRunning
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|eligible
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|(
name|maxSegmentCount
operator|>
literal|1
operator|&&
name|eligible
operator|.
name|size
argument_list|()
operator|<=
name|maxSegmentCount
operator|)
operator|||
operator|(
name|maxSegmentCount
operator|==
literal|1
operator|&&
name|eligible
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|(
operator|!
name|segmentIsOriginal
operator|||
name|isMerged
argument_list|(
name|infos
argument_list|,
name|eligible
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"already merged"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|eligible
argument_list|,
operator|new
name|SegmentByteSizeDescending
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"eligible="
operator|+
name|eligible
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"forceMergeRunning="
operator|+
name|forceMergeRunning
argument_list|)
expr_stmt|;
block|}
name|int
name|end
init|=
name|eligible
operator|.
name|size
argument_list|()
decl_stmt|;
name|MergeSpecification
name|spec
init|=
literal|null
decl_stmt|;
comment|// Do full merges, first, backwards:
while|while
condition|(
name|end
operator|>=
name|maxMergeAtOnceExplicit
operator|+
name|maxSegmentCount
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|spec
operator|==
literal|null
condition|)
block|{
name|spec
operator|=
operator|new
name|MergeSpecification
argument_list|()
expr_stmt|;
block|}
specifier|final
name|OneMerge
name|merge
init|=
operator|new
name|OneMerge
argument_list|(
name|eligible
operator|.
name|subList
argument_list|(
name|end
operator|-
name|maxMergeAtOnceExplicit
argument_list|,
name|end
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"add merge="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spec
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|end
operator|-=
name|maxMergeAtOnceExplicit
expr_stmt|;
block|}
if|if
condition|(
name|spec
operator|==
literal|null
operator|&&
operator|!
name|forceMergeRunning
condition|)
block|{
comment|// Do final merge
specifier|final
name|int
name|numToMerge
init|=
name|end
operator|-
name|maxSegmentCount
operator|+
literal|1
decl_stmt|;
specifier|final
name|OneMerge
name|merge
init|=
operator|new
name|OneMerge
argument_list|(
name|eligible
operator|.
name|subList
argument_list|(
name|end
operator|-
name|numToMerge
argument_list|,
name|end
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"add final merge="
operator|+
name|merge
operator|.
name|segString
argument_list|(
name|writer
operator|.
name|get
argument_list|()
operator|.
name|getDirectory
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spec
operator|=
operator|new
name|MergeSpecification
argument_list|()
expr_stmt|;
name|spec
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
block|}
return|return
name|spec
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeSpecification
name|findForcedDeletesMerges
parameter_list|(
name|SegmentInfos
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"findForcedDeletesMerges infos="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|infos
argument_list|)
operator|+
literal|" forceMergeDeletesPctAllowed="
operator|+
name|forceMergeDeletesPctAllowed
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|eligible
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentCommitInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|SegmentCommitInfo
argument_list|>
name|merging
init|=
name|writer
operator|.
name|get
argument_list|()
operator|.
name|getMergingSegments
argument_list|()
decl_stmt|;
for|for
control|(
name|SegmentCommitInfo
name|info
range|:
name|infos
control|)
block|{
name|double
name|pctDeletes
init|=
literal|100.
operator|*
operator|(
operator|(
name|double
operator|)
name|writer
operator|.
name|get
argument_list|()
operator|.
name|numDeletedDocs
argument_list|(
name|info
argument_list|)
operator|)
operator|/
name|info
operator|.
name|info
operator|.
name|getDocCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|pctDeletes
operator|>
name|forceMergeDeletesPctAllowed
operator|&&
operator|!
name|merging
operator|.
name|contains
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|eligible
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eligible
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|eligible
argument_list|,
operator|new
name|SegmentByteSizeDescending
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"eligible="
operator|+
name|eligible
argument_list|)
expr_stmt|;
block|}
name|int
name|start
init|=
literal|0
decl_stmt|;
name|MergeSpecification
name|spec
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|eligible
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Don't enforce max merged size here: app is explicitly
comment|// calling forceMergeDeletes, and knows this may take a
comment|// long time / produce big segments (like forceMerge):
specifier|final
name|int
name|end
init|=
name|Math
operator|.
name|min
argument_list|(
name|start
operator|+
name|maxMergeAtOnceExplicit
argument_list|,
name|eligible
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|==
literal|null
condition|)
block|{
name|spec
operator|=
operator|new
name|MergeSpecification
argument_list|()
expr_stmt|;
block|}
specifier|final
name|OneMerge
name|merge
init|=
operator|new
name|OneMerge
argument_list|(
name|eligible
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
argument_list|()
condition|)
block|{
name|message
argument_list|(
literal|"add merge="
operator|+
name|writer
operator|.
name|get
argument_list|()
operator|.
name|segString
argument_list|(
name|merge
operator|.
name|segments
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spec
operator|.
name|add
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|start
operator|=
name|end
expr_stmt|;
block|}
return|return
name|spec
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{     }
specifier|private
name|long
name|floorSize
parameter_list|(
name|long
name|bytes
parameter_list|)
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
name|floorSegmentBytes
argument_list|,
name|bytes
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|verbose
parameter_list|()
block|{
specifier|final
name|IndexWriter
name|w
init|=
name|writer
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|w
operator|!=
literal|null
operator|&&
name|w
operator|.
name|getConfig
argument_list|()
operator|.
name|getInfoStream
argument_list|()
operator|.
name|isEnabled
argument_list|(
literal|"TMP"
argument_list|)
return|;
block|}
specifier|private
name|void
name|message
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|writer
operator|.
name|get
argument_list|()
operator|.
name|getConfig
argument_list|()
operator|.
name|getInfoStream
argument_list|()
operator|.
name|message
argument_list|(
literal|"TMP"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"["
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergeAtOnce="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergeAtOnce
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergeAtOnceExplicit="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergeAtOnceExplicit
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxMergedSegmentMB="
argument_list|)
operator|.
name|append
argument_list|(
name|maxMergedSegmentBytes
operator|/
literal|1024
operator|/
literal|1024.
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"floorSegmentMB="
argument_list|)
operator|.
name|append
argument_list|(
name|floorSegmentBytes
operator|/
literal|1024
operator|/
literal|1024.
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"forceMergeDeletesPctAllowed="
argument_list|)
operator|.
name|append
argument_list|(
name|forceMergeDeletesPctAllowed
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"segmentsPerTier="
argument_list|)
operator|.
name|append
argument_list|(
name|segsPerTier
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"maxCFSSegmentSizeMB="
argument_list|)
operator|.
name|append
argument_list|(
name|getMaxCFSSegmentSizeMB
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"noCFSRatio="
argument_list|)
operator|.
name|append
argument_list|(
name|noCFSRatio
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

