begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|security
operator|.
name|authentication
operator|.
name|token
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|SecureRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|GregorianCalendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|RepositoryException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|SimpleCredentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|JcrConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|api
operator|.
name|security
operator|.
name|authentication
operator|.
name|token
operator|.
name|TokenCredentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|api
operator|.
name|security
operator|.
name|user
operator|.
name|Authorizable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|api
operator|.
name|security
operator|.
name|user
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|api
operator|.
name|security
operator|.
name|user
operator|.
name|UserManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|CommitFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|PropertyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Root
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|namepath
operator|.
name|NamePathMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|identifier
operator|.
name|IdentifierManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|name
operator|.
name|NamespaceConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|security
operator|.
name|ConfigurationParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|security
operator|.
name|authentication
operator|.
name|ImpersonationCredentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|security
operator|.
name|authentication
operator|.
name|token
operator|.
name|TokenInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|security
operator|.
name|authentication
operator|.
name|token
operator|.
name|TokenProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|security
operator|.
name|user
operator|.
name|UserConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|security
operator|.
name|user
operator|.
name|util
operator|.
name|PasswordUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|util
operator|.
name|NodeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|util
operator|.
name|TreeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|util
operator|.
name|ISO8601
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|util
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Type
operator|.
name|STRING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|identifier
operator|.
name|IdentifierManager
operator|.
name|getIdentifier
import|;
end_import

begin_comment
comment|/**  * Default implementation of the {@code TokenProvider} interface that keeps login  * tokens in the content repository. As a precondition the configured the user  * management implementation must provide paths for all  * {@link org.apache.jackrabbit.api.security.user.User users} that refer to  * a valid {@link Tree} in the content repository.  *<p>  *<h3>Backwards compatibility with Jackrabbit 2.x</h3>  * For security reasons the nodes storing the token information now have a  * dedicated node type (rep:Token) which has the following definition:  *<pre>  *     [rep:Token]> mix:referenceable  *      - rep:token.key (STRING) protected mandatory  *      - rep:token.exp (DATE) protected mandatory  *      - * (UNDEFINED) protected  *      - * (UNDEFINED) multiple protected  *</pre>  * Consequently the hash of the token and the expiration time of tokens generated  * by this provider can no longer be manipulated using regular JCR item  * modifications.<p>  *<p>  * Existing login tokens generated by Jackrabbit 2.x which are migrated to  * OAK will still be valid (unless they expire) due to the fact that  * {@link #getTokenInfo(String)} and the implementation of the {@link TokenInfo}  * interface will not validate the node type of the token node associated with  * a given token.  */
end_comment

begin_class
class|class
name|TokenProviderImpl
implements|implements
name|TokenProvider
implements|,
name|TokenConstants
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TokenProviderImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Default expiration time in ms for login tokens is 2 hours.      */
specifier|private
specifier|static
specifier|final
name|long
name|DEFAULT_TOKEN_EXPIRATION
init|=
literal|2
operator|*
literal|3600
operator|*
literal|1000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_KEY_SIZE
init|=
literal|8
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|DELIM
init|=
literal|'_'
decl_stmt|;
specifier|private
specifier|final
name|Root
name|root
decl_stmt|;
specifier|private
specifier|final
name|ConfigurationParameters
name|options
decl_stmt|;
specifier|private
specifier|final
name|long
name|tokenExpiration
decl_stmt|;
specifier|private
specifier|final
name|UserManager
name|userManager
decl_stmt|;
specifier|private
specifier|final
name|IdentifierManager
name|identifierManager
decl_stmt|;
name|TokenProviderImpl
parameter_list|(
name|Root
name|root
parameter_list|,
name|ConfigurationParameters
name|options
parameter_list|,
name|UserConfiguration
name|userConfiguration
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|this
operator|.
name|tokenExpiration
operator|=
name|options
operator|.
name|getConfigValue
argument_list|(
name|PARAM_TOKEN_EXPIRATION
argument_list|,
name|DEFAULT_TOKEN_EXPIRATION
argument_list|)
expr_stmt|;
name|this
operator|.
name|userManager
operator|=
name|userConfiguration
operator|.
name|getUserManager
argument_list|(
name|root
argument_list|,
name|NamePathMapper
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|identifierManager
operator|=
operator|new
name|IdentifierManager
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
comment|//------------------------------------------------------< TokenProvider>---
comment|/**      * Returns {@code true} if {@code SimpleCredentials} can be extracted from      * the specified credentials object and that simple credentials object has      * a {@link #TOKEN_ATTRIBUTE} attribute with an empty value.      *      * @param credentials The current credentials.      * @return {@code true} if the specified credentials are {@link SimpleCredentials}      *         or {@link ImpersonationCredentials} and if the (extracted) simple credentials      *         object contain a {@link #TOKEN_ATTRIBUTE} attribute with an empty value;      *         {@code false} otherwise.      */
annotation|@
name|Override
specifier|public
name|boolean
name|doCreateToken
parameter_list|(
annotation|@
name|Nonnull
name|Credentials
name|credentials
parameter_list|)
block|{
name|SimpleCredentials
name|sc
init|=
name|extractSimpleCredentials
argument_list|(
name|credentials
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|Object
name|attr
init|=
name|sc
operator|.
name|getAttribute
argument_list|(
name|TOKEN_ATTRIBUTE
argument_list|)
decl_stmt|;
return|return
operator|(
name|attr
operator|!=
literal|null
operator|&&
literal|""
operator|.
name|equals
argument_list|(
name|attr
operator|.
name|toString
argument_list|()
argument_list|)
operator|)
return|;
block|}
block|}
comment|/**      * Create a separate token node underneath a dedicated token store within      * the user home node. That token node contains the hashed token, the      * expiration time and additional mandatory attributes that will be verified      * during login.      *      * @param credentials The current credentials.      * @return A new {@code TokenInfo} or {@code null} if the token could not      *         be created.      */
annotation|@
name|CheckForNull
annotation|@
name|Override
specifier|public
name|TokenInfo
name|createToken
parameter_list|(
annotation|@
name|Nonnull
name|Credentials
name|credentials
parameter_list|)
block|{
name|SimpleCredentials
name|sc
init|=
name|extractSimpleCredentials
argument_list|(
name|credentials
argument_list|)
decl_stmt|;
name|TokenInfo
name|tokenInfo
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|sc
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|attrNames
init|=
name|sc
operator|.
name|getAttributeNames
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|attributes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|attrNames
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|attrName
range|:
name|sc
operator|.
name|getAttributeNames
argument_list|()
control|)
block|{
name|attributes
operator|.
name|put
argument_list|(
name|attrName
argument_list|,
name|sc
operator|.
name|getAttribute
argument_list|(
name|attrName
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|tokenInfo
operator|=
name|createToken
argument_list|(
name|sc
operator|.
name|getUserID
argument_list|()
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokenInfo
operator|!=
literal|null
condition|)
block|{
comment|// also set the new token to the simple credentials.
name|sc
operator|.
name|setAttribute
argument_list|(
name|TOKEN_ATTRIBUTE
argument_list|,
name|tokenInfo
operator|.
name|getToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tokenInfo
return|;
block|}
comment|/**      * Create a separate token node underneath a dedicated token store within      * the user home node. That token node contains the hashed token, the      * expiration time and additional mandatory attributes that will be verified      * during login.      *      * @param userId     The identifier of the user for which a new token should      *                   be created.      * @param attributes The attributes associated with the new token.      * @return A new {@code TokenInfo} or {@code null} if the token could not      *         be created.      */
annotation|@
name|Override
specifier|public
name|TokenInfo
name|createToken
parameter_list|(
annotation|@
name|Nonnull
name|String
name|userId
parameter_list|,
annotation|@
name|Nonnull
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|attributes
parameter_list|)
block|{
name|String
name|error
init|=
literal|"Failed to create login token. {}"
decl_stmt|;
name|User
name|user
init|=
name|getUser
argument_list|(
name|userId
argument_list|)
decl_stmt|;
name|NodeUtil
name|tokenParent
init|=
name|getTokenParent
argument_list|(
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenParent
operator|!=
literal|null
operator|&&
name|user
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|String
name|id
init|=
name|user
operator|.
name|getID
argument_list|()
decl_stmt|;
name|long
name|creationTime
init|=
operator|new
name|Date
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|long
name|exp
decl_stmt|;
if|if
condition|(
name|attributes
operator|.
name|containsKey
argument_list|(
name|PARAM_TOKEN_EXPIRATION
argument_list|)
condition|)
block|{
name|exp
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|attributes
operator|.
name|get
argument_list|(
name|PARAM_TOKEN_EXPIRATION
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
name|tokenExpiration
expr_stmt|;
block|}
name|long
name|expTime
init|=
name|createExpirationTime
argument_list|(
name|creationTime
argument_list|,
name|exp
argument_list|)
decl_stmt|;
name|String
name|uuid
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TokenInfo
name|tokenInfo
decl_stmt|;
try|try
block|{
name|String
name|tokenName
init|=
name|generateTokenName
argument_list|(
name|creationTime
argument_list|)
decl_stmt|;
name|tokenInfo
operator|=
name|createTokenNode
argument_list|(
name|tokenParent
argument_list|,
name|tokenName
argument_list|,
name|expTime
argument_list|,
name|uuid
argument_list|,
name|id
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
name|root
operator|.
name|commit
argument_list|(
name|CommitMarker
operator|.
name|asCommitAttributes
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CommitFailedException
name|e
parameter_list|)
block|{
comment|// conflict while creating token node -> retry
name|log
operator|.
name|debug
argument_list|(
literal|"Failed to create token node. Using random name as fallback."
argument_list|)
expr_stmt|;
name|root
operator|.
name|refresh
argument_list|()
expr_stmt|;
name|tokenInfo
operator|=
name|createTokenNode
argument_list|(
name|tokenParent
argument_list|,
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|expTime
argument_list|,
name|uuid
argument_list|,
name|id
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
name|root
operator|.
name|commit
argument_list|(
name|CommitMarker
operator|.
name|asCommitAttributes
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|tokenInfo
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
comment|// error while generating login token
name|log
operator|.
name|error
argument_list|(
name|error
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
comment|// error while generating login token
name|log
operator|.
name|error
argument_list|(
name|error
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CommitFailedException
name|e
parameter_list|)
block|{
comment|// conflict while committing changes
name|log
operator|.
name|warn
argument_list|(
name|error
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RepositoryException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|error
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to get/create token store for user "
operator|+
name|userId
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Retrieves the token information associated with the specified login      * token. If no accessible {@code Tree} exists for the given token or if      * the token is not associated with a valid user this method returns {@code null}.      *      * @param token A valid login token.      * @return The {@code TokenInfo} associated with the specified token or      *         {@code null} of the corresponding information does not exist or is not      *         associated with a valid user.      */
annotation|@
name|Override
specifier|public
name|TokenInfo
name|getTokenInfo
parameter_list|(
annotation|@
name|Nonnull
name|String
name|token
parameter_list|)
block|{
name|int
name|pos
init|=
name|token
operator|.
name|indexOf
argument_list|(
name|DELIM
argument_list|)
decl_stmt|;
name|String
name|nodeId
init|=
operator|(
name|pos
operator|==
operator|-
literal|1
operator|)
condition|?
name|token
else|:
name|token
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|Tree
name|tokenTree
init|=
name|identifierManager
operator|.
name|getTree
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
name|String
name|userId
init|=
name|getUserId
argument_list|(
name|tokenTree
argument_list|)
decl_stmt|;
if|if
condition|(
name|userId
operator|==
literal|null
operator|||
operator|!
name|isValidTokenTree
argument_list|(
name|tokenTree
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|new
name|TokenInfoImpl
argument_list|(
operator|new
name|NodeUtil
argument_list|(
name|tokenTree
argument_list|)
argument_list|,
name|token
argument_list|,
name|userId
argument_list|)
return|;
block|}
block|}
comment|//--------------------------------------------------------------------------
specifier|private
specifier|static
name|long
name|createExpirationTime
parameter_list|(
name|long
name|creationTime
parameter_list|,
name|long
name|tokenExpiration
parameter_list|)
block|{
return|return
name|creationTime
operator|+
name|tokenExpiration
return|;
block|}
specifier|private
specifier|static
name|long
name|getExpirationTime
parameter_list|(
name|NodeUtil
name|tokenNode
parameter_list|,
name|long
name|defaultValue
parameter_list|)
block|{
return|return
name|tokenNode
operator|.
name|getLong
argument_list|(
name|TOKEN_ATTRIBUTE_EXPIRY
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
annotation|@
name|CheckForNull
specifier|private
specifier|static
name|SimpleCredentials
name|extractSimpleCredentials
parameter_list|(
name|Credentials
name|credentials
parameter_list|)
block|{
if|if
condition|(
name|credentials
operator|instanceof
name|SimpleCredentials
condition|)
block|{
return|return
operator|(
name|SimpleCredentials
operator|)
name|credentials
return|;
block|}
if|if
condition|(
name|credentials
operator|instanceof
name|ImpersonationCredentials
condition|)
block|{
name|Credentials
name|base
init|=
operator|(
operator|(
name|ImpersonationCredentials
operator|)
name|credentials
operator|)
operator|.
name|getBaseCredentials
argument_list|()
decl_stmt|;
if|if
condition|(
name|base
operator|instanceof
name|SimpleCredentials
condition|)
block|{
return|return
operator|(
name|SimpleCredentials
operator|)
name|base
return|;
block|}
block|}
comment|// cannot extract SimpleCredentials
return|return
literal|null
return|;
block|}
annotation|@
name|Nonnull
specifier|private
specifier|static
name|String
name|generateKey
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|SecureRandom
name|random
init|=
operator|new
name|SecureRandom
argument_list|()
decl_stmt|;
name|byte
name|key
index|[]
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|random
operator|.
name|nextBytes
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|StringBuilder
name|res
init|=
operator|new
name|StringBuilder
argument_list|(
name|key
operator|.
name|length
operator|*
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
name|b
range|:
name|key
control|)
block|{
name|res
operator|.
name|append
argument_list|(
name|Text
operator|.
name|hexTable
index|[
operator|(
name|b
operator|>>
literal|4
operator|)
operator|&
literal|15
index|]
argument_list|)
expr_stmt|;
name|res
operator|.
name|append
argument_list|(
name|Text
operator|.
name|hexTable
index|[
name|b
operator|&
literal|15
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|res
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Nonnull
specifier|private
specifier|static
name|String
name|getKeyValue
parameter_list|(
annotation|@
name|Nonnull
name|String
name|key
parameter_list|,
annotation|@
name|Nonnull
name|String
name|userId
parameter_list|)
block|{
return|return
name|key
operator|+
name|userId
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isValidTokenTree
parameter_list|(
annotation|@
name|CheckForNull
name|Tree
name|tokenTree
parameter_list|)
block|{
if|if
condition|(
name|tokenTree
operator|==
literal|null
operator|||
operator|!
name|tokenTree
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|TOKENS_NODE_NAME
operator|.
name|equals
argument_list|(
name|tokenTree
operator|.
name|getParent
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|TOKEN_NT_NAME
operator|.
name|equals
argument_list|(
name|TreeUtil
operator|.
name|getPrimaryTypeName
argument_list|(
name|tokenTree
argument_list|)
argument_list|)
return|;
block|}
block|}
annotation|@
name|Nonnull
specifier|private
specifier|static
name|String
name|generateTokenName
parameter_list|(
name|long
name|creationTime
parameter_list|)
block|{
name|Calendar
name|creation
init|=
name|GregorianCalendar
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|creation
operator|.
name|setTimeInMillis
argument_list|(
name|creationTime
argument_list|)
expr_stmt|;
return|return
name|Text
operator|.
name|replace
argument_list|(
name|ISO8601
operator|.
name|format
argument_list|(
name|creation
argument_list|)
argument_list|,
literal|":"
argument_list|,
literal|"."
argument_list|)
return|;
block|}
annotation|@
name|CheckForNull
specifier|private
name|Tree
name|getTokenTree
parameter_list|(
annotation|@
name|Nonnull
name|TokenInfo
name|tokenInfo
parameter_list|)
block|{
if|if
condition|(
name|tokenInfo
operator|instanceof
name|TokenInfoImpl
condition|)
block|{
return|return
name|root
operator|.
name|getTree
argument_list|(
operator|(
operator|(
name|TokenInfoImpl
operator|)
name|tokenInfo
operator|)
operator|.
name|tokenPath
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
name|String
name|getUserId
parameter_list|(
annotation|@
name|CheckForNull
name|Tree
name|tokenTree
parameter_list|)
block|{
if|if
condition|(
name|tokenTree
operator|!=
literal|null
operator|&&
name|tokenTree
operator|.
name|exists
argument_list|()
condition|)
block|{
try|try
block|{
name|String
name|userPath
init|=
name|Text
operator|.
name|getRelativeParent
argument_list|(
name|tokenTree
operator|.
name|getPath
argument_list|()
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Authorizable
name|authorizable
init|=
name|userManager
operator|.
name|getAuthorizableByPath
argument_list|(
name|userPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|authorizable
operator|!=
literal|null
operator|&&
operator|!
name|authorizable
operator|.
name|isGroup
argument_list|()
operator|&&
operator|!
operator|(
operator|(
name|User
operator|)
name|authorizable
operator|)
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
return|return
name|authorizable
operator|.
name|getID
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|RepositoryException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Cannot determine userID from token: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|CheckForNull
specifier|private
name|User
name|getUser
parameter_list|(
annotation|@
name|Nonnull
name|String
name|userId
parameter_list|)
block|{
try|try
block|{
name|Authorizable
name|user
init|=
name|userManager
operator|.
name|getAuthorizable
argument_list|(
name|userId
argument_list|)
decl_stmt|;
if|if
condition|(
name|user
operator|!=
literal|null
operator|&&
operator|!
name|user
operator|.
name|isGroup
argument_list|()
condition|)
block|{
return|return
operator|(
name|User
operator|)
name|user
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Cannot create login token: No corresponding node for User "
operator|+
name|userId
operator|+
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RepositoryException
name|e
parameter_list|)
block|{
comment|// error while accessing user.
name|log
operator|.
name|debug
argument_list|(
literal|"Error while accessing user "
operator|+
name|userId
operator|+
literal|'.'
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|CheckForNull
specifier|private
name|NodeUtil
name|getTokenParent
parameter_list|(
annotation|@
name|CheckForNull
name|User
name|user
parameter_list|)
block|{
if|if
condition|(
name|user
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|NodeUtil
name|tokenParent
init|=
literal|null
decl_stmt|;
name|String
name|parentPath
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|userPath
init|=
name|user
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|parentPath
operator|=
name|userPath
operator|+
literal|'/'
operator|+
name|TOKENS_NODE_NAME
expr_stmt|;
name|NodeUtil
name|userNode
init|=
operator|new
name|NodeUtil
argument_list|(
name|root
operator|.
name|getTree
argument_list|(
name|userPath
argument_list|)
argument_list|)
decl_stmt|;
name|tokenParent
operator|=
name|userNode
operator|.
name|getOrAddChild
argument_list|(
name|TOKENS_NODE_NAME
argument_list|,
name|TOKENS_NT_NAME
argument_list|)
expr_stmt|;
name|root
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RepositoryException
name|e
parameter_list|)
block|{
comment|// error while creating token node.
name|log
operator|.
name|debug
argument_list|(
literal|"Error while creating token node {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CommitFailedException
name|e
parameter_list|)
block|{
comment|// conflict while creating token store for this user -> refresh and
comment|// try to get the tree from the updated root.
name|log
operator|.
name|debug
argument_list|(
literal|"Conflict while creating token store -> retrying {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|.
name|refresh
argument_list|()
expr_stmt|;
name|Tree
name|parentTree
init|=
name|root
operator|.
name|getTree
argument_list|(
name|parentPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentTree
operator|.
name|exists
argument_list|()
condition|)
block|{
name|tokenParent
operator|=
operator|new
name|NodeUtil
argument_list|(
name|parentTree
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tokenParent
return|;
block|}
comment|/**      * Create a new token node below the specified {@code parent}.      *      * @param parent The parent node.      * @param expTime The expiration time of the new token.      * @param uuid The uuid of the token node.      * @param id The id of the user that issues the token.      * @param attributes The additional attributes of the token to be created.      * @return The new token info      * @throws AccessDeniedException If the editing session cannot access the      * new token node.      *      */
specifier|private
name|TokenInfo
name|createTokenNode
parameter_list|(
annotation|@
name|Nonnull
name|NodeUtil
name|parent
parameter_list|,
annotation|@
name|Nonnull
name|String
name|tokenName
parameter_list|,
name|long
name|expTime
parameter_list|,
annotation|@
name|Nonnull
name|String
name|uuid
parameter_list|,
annotation|@
name|Nonnull
name|String
name|id
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|attributes
parameter_list|)
throws|throws
name|AccessDeniedException
throws|,
name|UnsupportedEncodingException
throws|,
name|NoSuchAlgorithmException
block|{
name|NodeUtil
name|tokenNode
init|=
name|parent
operator|.
name|addChild
argument_list|(
name|tokenName
argument_list|,
name|TOKEN_NT_NAME
argument_list|)
decl_stmt|;
name|tokenNode
operator|.
name|setString
argument_list|(
name|JcrConstants
operator|.
name|JCR_UUID
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
name|String
name|key
init|=
name|generateKey
argument_list|(
name|options
operator|.
name|getConfigValue
argument_list|(
name|PARAM_TOKEN_LENGTH
argument_list|,
name|DEFAULT_KEY_SIZE
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|nodeId
init|=
name|getIdentifier
argument_list|(
name|tokenNode
operator|.
name|getTree
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|token
init|=
name|nodeId
operator|+
name|DELIM
operator|+
name|key
decl_stmt|;
name|String
name|keyHash
init|=
name|PasswordUtil
operator|.
name|buildPasswordHash
argument_list|(
name|getKeyValue
argument_list|(
name|key
argument_list|,
name|id
argument_list|)
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|tokenNode
operator|.
name|setString
argument_list|(
name|TOKEN_ATTRIBUTE_KEY
argument_list|,
name|keyHash
argument_list|)
expr_stmt|;
name|tokenNode
operator|.
name|setDate
argument_list|(
name|TOKEN_ATTRIBUTE_EXPIRY
argument_list|,
name|expTime
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|name
range|:
name|attributes
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|RESERVED_ATTRIBUTES
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|attr
init|=
name|attributes
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|tokenNode
operator|.
name|setString
argument_list|(
name|name
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|TokenInfoImpl
argument_list|(
name|tokenNode
argument_list|,
name|token
argument_list|,
name|id
argument_list|)
return|;
block|}
comment|//--------------------------------------------------------------------------
comment|/**      * TokenInfo      */
specifier|private
specifier|final
class|class
name|TokenInfoImpl
implements|implements
name|TokenInfo
block|{
specifier|private
specifier|final
name|String
name|token
decl_stmt|;
specifier|private
specifier|final
name|String
name|tokenPath
decl_stmt|;
specifier|private
specifier|final
name|String
name|userId
decl_stmt|;
specifier|private
specifier|final
name|long
name|expirationTime
decl_stmt|;
specifier|private
specifier|final
name|String
name|key
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mandatoryAttributes
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|publicAttributes
decl_stmt|;
specifier|private
name|TokenInfoImpl
parameter_list|(
name|NodeUtil
name|tokenNode
parameter_list|,
name|String
name|token
parameter_list|,
name|String
name|userId
parameter_list|)
block|{
name|this
operator|.
name|token
operator|=
name|token
expr_stmt|;
name|this
operator|.
name|tokenPath
operator|=
name|tokenNode
operator|.
name|getTree
argument_list|()
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|this
operator|.
name|userId
operator|=
name|userId
expr_stmt|;
name|expirationTime
operator|=
name|getExpirationTime
argument_list|(
name|tokenNode
argument_list|,
name|Long
operator|.
name|MIN_VALUE
argument_list|)
expr_stmt|;
name|key
operator|=
name|tokenNode
operator|.
name|getString
argument_list|(
name|TOKEN_ATTRIBUTE_KEY
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|mandatoryAttributes
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|publicAttributes
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|PropertyState
name|propertyState
range|:
name|tokenNode
operator|.
name|getTree
argument_list|()
operator|.
name|getProperties
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|propertyState
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|propertyState
operator|.
name|getValue
argument_list|(
name|STRING
argument_list|)
decl_stmt|;
if|if
condition|(
name|RESERVED_ATTRIBUTES
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|isMandatoryAttribute
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|mandatoryAttributes
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isInfoAttribute
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|// info attribute
name|publicAttributes
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|// else: jcr specific property
block|}
block|}
comment|//------------------------------------------------------< TokenInfo>---
annotation|@
name|Nonnull
annotation|@
name|Override
specifier|public
name|String
name|getUserId
parameter_list|()
block|{
return|return
name|userId
return|;
block|}
annotation|@
name|Nonnull
annotation|@
name|Override
specifier|public
name|String
name|getToken
parameter_list|()
block|{
return|return
name|token
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isExpired
parameter_list|(
name|long
name|loginTime
parameter_list|)
block|{
return|return
name|expirationTime
operator|<
name|loginTime
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|resetExpiration
parameter_list|(
name|long
name|loginTime
parameter_list|)
block|{
comment|// for backwards compatibility use true as default value for the 'tokenRefresh' configuration
if|if
condition|(
name|options
operator|.
name|getConfigValue
argument_list|(
name|PARAM_TOKEN_REFRESH
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|Tree
name|tokenTree
init|=
name|getTokenTree
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenTree
operator|!=
literal|null
operator|&&
name|tokenTree
operator|.
name|exists
argument_list|()
condition|)
block|{
name|NodeUtil
name|tokenNode
init|=
operator|new
name|NodeUtil
argument_list|(
name|tokenTree
argument_list|)
decl_stmt|;
if|if
condition|(
name|isExpired
argument_list|(
name|loginTime
argument_list|)
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Attempt to reset an expired token."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|expirationTime
operator|-
name|loginTime
operator|<=
name|tokenExpiration
operator|/
literal|2
condition|)
block|{
try|try
block|{
name|long
name|expTime
init|=
name|createExpirationTime
argument_list|(
name|loginTime
argument_list|,
name|tokenExpiration
argument_list|)
decl_stmt|;
name|tokenNode
operator|.
name|setDate
argument_list|(
name|TOKEN_ATTRIBUTE_EXPIRY
argument_list|,
name|expTime
argument_list|)
expr_stmt|;
name|root
operator|.
name|commit
argument_list|(
name|CommitMarker
operator|.
name|asCommitAttributes
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Successfully reset token expiration time."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|CommitFailedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Failed to reset token expiration {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|.
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|()
block|{
name|Tree
name|tokenTree
init|=
name|getTokenTree
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenTree
operator|!=
literal|null
operator|&&
name|tokenTree
operator|.
name|exists
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
name|tokenTree
operator|.
name|remove
argument_list|()
condition|)
block|{
name|root
operator|.
name|commit
argument_list|(
name|CommitMarker
operator|.
name|asCommitAttributes
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
catch|catch
parameter_list|(
name|CommitFailedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Error while removing expired token {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|TokenCredentials
name|tokenCredentials
parameter_list|)
block|{
name|String
name|tk
init|=
name|tokenCredentials
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|tk
operator|.
name|lastIndexOf
argument_list|(
name|DELIM
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>
operator|-
literal|1
condition|)
block|{
name|tk
operator|=
name|tk
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|==
literal|null
operator|||
operator|!
name|PasswordUtil
operator|.
name|isSame
argument_list|(
name|key
argument_list|,
name|getKeyValue
argument_list|(
name|tk
argument_list|,
name|userId
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mandatory
range|:
name|mandatoryAttributes
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|mandatory
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|expectedValue
init|=
name|mandatory
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|expectedValue
operator|.
name|equals
argument_list|(
name|tokenCredentials
operator|.
name|getAttribute
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// update set of informative attributes on the credentials
comment|// based on the properties present on the token node.
name|Collection
argument_list|<
name|String
argument_list|>
name|attrNames
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|tokenCredentials
operator|.
name|getAttributeNames
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|attr
range|:
name|publicAttributes
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|attr
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|attrNames
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tokenCredentials
operator|.
name|setAttribute
argument_list|(
name|name
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Nonnull
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPrivateAttributes
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|mandatoryAttributes
argument_list|)
return|;
block|}
annotation|@
name|Nonnull
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPublicAttributes
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|publicAttributes
argument_list|)
return|;
block|}
comment|/**          * Returns {@code true} if the specified {@code attributeName}          * starts with or equals {@link #TOKEN_ATTRIBUTE}.          *          * @param attributeName The attribute name.          * @return {@code true} if the specified {@code attributeName}          *         starts with or equals {@link #TOKEN_ATTRIBUTE}.          */
specifier|private
name|boolean
name|isMandatoryAttribute
parameter_list|(
name|String
name|attributeName
parameter_list|)
block|{
return|return
name|attributeName
operator|!=
literal|null
operator|&&
name|attributeName
operator|.
name|startsWith
argument_list|(
name|TOKEN_ATTRIBUTE
argument_list|)
return|;
block|}
comment|/**          * Returns {@code false} if the specified attribute name doesn't have          * a 'jcr' or 'rep' namespace prefix; {@code true} otherwise. This is          * a lazy evaluation in order to avoid testing the defining node type of          * the associated jcr property.          *          * @param attributeName The attribute name.          * @return {@code true} if the specified property name doesn't seem          *         to represent repository internal information.          */
specifier|private
name|boolean
name|isInfoAttribute
parameter_list|(
name|String
name|attributeName
parameter_list|)
block|{
name|String
name|prefix
init|=
name|Text
operator|.
name|getNamespacePrefix
argument_list|(
name|attributeName
argument_list|)
decl_stmt|;
return|return
operator|!
name|NamespaceConstants
operator|.
name|RESERVED_PREFIXES
operator|.
name|contains
argument_list|(
name|prefix
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

