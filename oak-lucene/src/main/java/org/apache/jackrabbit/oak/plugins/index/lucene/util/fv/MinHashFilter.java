begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|util
operator|.
name|fv
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|CharTermAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|OffsetAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionIncrementAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|PositionLengthAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|TypeAttribute
import|;
end_import

begin_comment
comment|/**  * Generate min hash tokens from an incoming stream of tokens. The incoming tokens would typically be 5 word shingles.  *   * The number of hashes used and the number of minimum values for each hash can be set. You could have 1 hash and keep  * the 100 lowest values or 100 hashes and keep the lowest one for each. Hashes can also be bucketed in ranges over the  * 128-bit hash space,  *   * A 128-bit hash is used internally. 5 word shingles from 10e5 words generate 10e25 combinations So a 64 bit hash would  * have collisions (1.8e19)  *   * When using different hashes 32 bits are used for the hash position leaving scope for 8e28 unique hashes. A single  * hash will use all 128 bits.  *  */
end_comment

begin_class
class|class
name|MinHashFilter
extends|extends
name|TokenFilter
block|{
specifier|private
specifier|static
specifier|final
name|int
name|HASH_CACHE_SIZE
init|=
literal|512
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|LongPair
index|[]
name|cachedIntHashes
init|=
operator|new
name|LongPair
index|[
name|HASH_CACHE_SIZE
index|]
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_HASH_COUNT
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_HASH_SET_SIZE
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_BUCKET_COUNT
init|=
literal|512
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|MIN_HASH_TYPE
init|=
literal|"MIN_HASH"
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|FixedSizeTreeSet
argument_list|<
name|LongPair
argument_list|>
argument_list|>
argument_list|>
name|minHashSets
decl_stmt|;
specifier|private
name|int
name|hashSetSize
init|=
name|DEFAULT_HASH_SET_SIZE
decl_stmt|;
specifier|private
name|int
name|bucketCount
init|=
name|DEFAULT_BUCKET_COUNT
decl_stmt|;
specifier|private
name|int
name|hashCount
init|=
name|DEFAULT_HASH_COUNT
decl_stmt|;
specifier|private
name|boolean
name|requiresInitialisation
init|=
literal|true
decl_stmt|;
specifier|private
name|State
name|endState
decl_stmt|;
specifier|private
name|int
name|hashPosition
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|int
name|bucketPosition
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|long
name|bucketSize
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|withRotation
decl_stmt|;
specifier|private
name|int
name|endOffset
decl_stmt|;
specifier|private
name|boolean
name|exhausted
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|CharTermAttribute
name|termAttribute
init|=
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|OffsetAttribute
name|offsetAttribute
init|=
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|TypeAttribute
name|typeAttribute
init|=
name|addAttribute
argument_list|(
name|TypeAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|PositionIncrementAttribute
name|posIncAttribute
init|=
name|addAttribute
argument_list|(
name|PositionIncrementAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|PositionLengthAttribute
name|posLenAttribute
init|=
name|addAttribute
argument_list|(
name|PositionLengthAttribute
operator|.
name|class
argument_list|)
decl_stmt|;
static|static
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|HASH_CACHE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|cachedIntHashes
index|[
name|i
index|]
operator|=
operator|new
name|LongPair
argument_list|()
expr_stmt|;
name|murmurhash3_x64_128
argument_list|(
name|getBytes
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|cachedIntHashes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|byte
index|[]
name|getBytes
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|byte
index|[]
name|answer
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|answer
index|[
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|answer
index|[
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|i
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|answer
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|i
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|answer
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|i
operator|>>
literal|24
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
comment|/**    * create a MinHash filter    *    * @param input the token stream    * @param hashCount the no. of hashes    * @param bucketCount the no. of buckets for hashing    * @param hashSetSize the no. of min hashes to keep    * @param withRotation whether rotate or not hashes while incrementing tokens    */
specifier|public
name|MinHashFilter
parameter_list|(
name|TokenStream
name|input
parameter_list|,
name|int
name|hashCount
parameter_list|,
name|int
name|bucketCount
parameter_list|,
name|int
name|hashSetSize
parameter_list|,
name|boolean
name|withRotation
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashCount
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"hashCount must be greater than zero"
argument_list|)
throw|;
block|}
if|if
condition|(
name|bucketCount
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"bucketCount must be greater than zero"
argument_list|)
throw|;
block|}
if|if
condition|(
name|hashSetSize
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"hashSetSize must be greater than zero"
argument_list|)
throw|;
block|}
name|this
operator|.
name|hashCount
operator|=
name|hashCount
expr_stmt|;
name|this
operator|.
name|bucketCount
operator|=
name|bucketCount
expr_stmt|;
name|this
operator|.
name|hashSetSize
operator|=
name|hashSetSize
expr_stmt|;
name|this
operator|.
name|withRotation
operator|=
name|withRotation
expr_stmt|;
name|this
operator|.
name|bucketSize
operator|=
operator|(
literal|1L
operator|<<
literal|32
operator|)
operator|/
name|bucketCount
expr_stmt|;
if|if
condition|(
operator|(
literal|1L
operator|<<
literal|32
operator|)
operator|%
name|bucketCount
operator|!=
literal|0
condition|)
block|{
name|bucketSize
operator|++
expr_stmt|;
block|}
name|minHashSets
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|hashCount
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|hashCount
condition|;
name|i
operator|++
control|)
block|{
name|ArrayList
argument_list|<
name|FixedSizeTreeSet
argument_list|<
name|LongPair
argument_list|>
argument_list|>
name|buckets
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|bucketCount
argument_list|)
decl_stmt|;
name|minHashSets
operator|.
name|add
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|this
operator|.
name|bucketCount
condition|;
name|j
operator|++
control|)
block|{
name|FixedSizeTreeSet
argument_list|<
name|LongPair
argument_list|>
name|minSet
init|=
operator|new
name|FixedSizeTreeSet
argument_list|<>
argument_list|(
name|this
operator|.
name|hashSetSize
argument_list|)
decl_stmt|;
name|buckets
operator|.
name|add
argument_list|(
name|minSet
argument_list|)
expr_stmt|;
block|}
block|}
name|doRest
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Pull the underlying stream of tokens
comment|// Hash each token found
comment|// Generate the required number of variants of this hash
comment|// Keep the minimum hash value found so far of each variant
name|int
name|positionIncrement
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|requiresInitialisation
condition|)
block|{
name|requiresInitialisation
operator|=
literal|false
expr_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
comment|// First time through so we pull and hash everything
while|while
condition|(
name|input
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
name|String
name|current
init|=
operator|new
name|String
argument_list|(
name|termAttribute
operator|.
name|buffer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|termAttribute
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hashCount
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|bytes
init|=
name|current
operator|.
name|getBytes
argument_list|(
literal|"UTF-16LE"
argument_list|)
decl_stmt|;
name|LongPair
name|hash
init|=
operator|new
name|LongPair
argument_list|()
decl_stmt|;
name|murmurhash3_x64_128
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|LongPair
name|rehashed
init|=
name|combineOrdered
argument_list|(
name|hash
argument_list|,
name|getIntHash
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|minHashSets
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|rehashed
operator|.
name|val2
operator|>>>
literal|32
operator|)
operator|/
name|bucketSize
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
name|rehashed
argument_list|)
expr_stmt|;
block|}
name|endOffset
operator|=
name|offsetAttribute
operator|.
name|endOffset
argument_list|()
expr_stmt|;
block|}
name|exhausted
operator|=
literal|true
expr_stmt|;
name|input
operator|.
name|end
argument_list|()
expr_stmt|;
comment|// We need the end state so an underlying shingle filter can have its state restored correctly.
name|endState
operator|=
name|captureState
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
return|return
literal|false
return|;
block|}
name|positionIncrement
operator|=
literal|1
expr_stmt|;
comment|// fix up any wrap around bucket values. ...
if|if
condition|(
name|withRotation
operator|&&
operator|(
name|hashSetSize
operator|==
literal|1
operator|)
condition|)
block|{
for|for
control|(
name|int
name|hashLoop
init|=
literal|0
init|;
name|hashLoop
operator|<
name|hashCount
condition|;
name|hashLoop
operator|++
control|)
block|{
for|for
control|(
name|int
name|bucketLoop
init|=
literal|0
init|;
name|bucketLoop
operator|<
name|bucketCount
condition|;
name|bucketLoop
operator|++
control|)
block|{
if|if
condition|(
name|minHashSets
operator|.
name|get
argument_list|(
name|hashLoop
argument_list|)
operator|.
name|get
argument_list|(
name|bucketLoop
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|int
name|bucketOffset
init|=
literal|1
init|;
name|bucketOffset
operator|<
name|bucketCount
condition|;
name|bucketOffset
operator|++
control|)
block|{
if|if
condition|(
name|minHashSets
operator|.
name|get
argument_list|(
name|hashLoop
argument_list|)
operator|.
name|get
argument_list|(
operator|(
name|bucketLoop
operator|+
name|bucketOffset
operator|)
operator|%
name|bucketCount
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LongPair
name|replacementHash
init|=
name|minHashSets
operator|.
name|get
argument_list|(
name|hashLoop
argument_list|)
operator|.
name|get
argument_list|(
operator|(
name|bucketLoop
operator|+
name|bucketOffset
operator|)
operator|%
name|bucketCount
argument_list|)
operator|.
name|first
argument_list|()
decl_stmt|;
name|minHashSets
operator|.
name|get
argument_list|(
name|hashLoop
argument_list|)
operator|.
name|get
argument_list|(
name|bucketLoop
argument_list|)
operator|.
name|add
argument_list|(
name|replacementHash
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
name|clearAttributes
argument_list|()
expr_stmt|;
while|while
condition|(
name|hashPosition
operator|<
name|hashCount
condition|)
block|{
if|if
condition|(
name|hashPosition
operator|==
operator|-
literal|1
condition|)
block|{
name|hashPosition
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|bucketPosition
operator|<
name|bucketCount
condition|)
block|{
if|if
condition|(
name|bucketPosition
operator|==
operator|-
literal|1
condition|)
block|{
name|bucketPosition
operator|++
expr_stmt|;
block|}
else|else
block|{
name|LongPair
name|hash
init|=
name|minHashSets
operator|.
name|get
argument_list|(
name|hashPosition
argument_list|)
operator|.
name|get
argument_list|(
name|bucketPosition
argument_list|)
operator|.
name|pollFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|hash
operator|!=
literal|null
condition|)
block|{
name|termAttribute
operator|.
name|setEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
name|hashCount
operator|>
literal|1
condition|)
block|{
name|termAttribute
operator|.
name|append
argument_list|(
name|int0
argument_list|(
name|hashPosition
argument_list|)
argument_list|)
expr_stmt|;
name|termAttribute
operator|.
name|append
argument_list|(
name|int1
argument_list|(
name|hashPosition
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|high
init|=
name|hash
operator|.
name|val2
decl_stmt|;
name|termAttribute
operator|.
name|append
argument_list|(
name|long0
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|termAttribute
operator|.
name|append
argument_list|(
name|long1
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|termAttribute
operator|.
name|append
argument_list|(
name|long2
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|termAttribute
operator|.
name|append
argument_list|(
name|long3
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|low
init|=
name|hash
operator|.
name|val1
decl_stmt|;
name|termAttribute
operator|.
name|append
argument_list|(
name|long0
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|termAttribute
operator|.
name|append
argument_list|(
name|long1
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashCount
operator|==
literal|1
condition|)
block|{
name|termAttribute
operator|.
name|append
argument_list|(
name|long2
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|termAttribute
operator|.
name|append
argument_list|(
name|long3
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|posIncAttribute
operator|.
name|setPositionIncrement
argument_list|(
name|positionIncrement
argument_list|)
expr_stmt|;
name|offsetAttribute
operator|.
name|setOffset
argument_list|(
literal|0
argument_list|,
name|endOffset
argument_list|)
expr_stmt|;
name|typeAttribute
operator|.
name|setType
argument_list|(
name|MIN_HASH_TYPE
argument_list|)
expr_stmt|;
name|posLenAttribute
operator|.
name|setPositionLength
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|bucketPosition
operator|++
expr_stmt|;
block|}
block|}
block|}
name|bucketPosition
operator|=
operator|-
literal|1
expr_stmt|;
name|hashPosition
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
name|LongPair
name|getIntHash
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
name|HASH_CACHE_SIZE
condition|)
block|{
return|return
name|cachedIntHashes
index|[
name|i
index|]
return|;
block|}
else|else
block|{
name|LongPair
name|answer
init|=
operator|new
name|LongPair
argument_list|()
decl_stmt|;
name|murmurhash3_x64_128
argument_list|(
name|getBytes
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|answer
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|end
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|exhausted
condition|)
block|{
name|input
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
name|restoreState
argument_list|(
name|endState
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|doRest
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|doRest
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hashCount
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|bucketCount
condition|;
name|j
operator|++
control|)
block|{
name|minHashSets
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
name|endState
operator|=
literal|null
expr_stmt|;
name|hashPosition
operator|=
operator|-
literal|1
expr_stmt|;
name|bucketPosition
operator|=
operator|-
literal|1
expr_stmt|;
name|requiresInitialisation
operator|=
literal|true
expr_stmt|;
name|exhausted
operator|=
literal|false
expr_stmt|;
block|}
specifier|private
specifier|static
name|char
name|long0
parameter_list|(
name|long
name|x
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|x
operator|>>
literal|48
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|char
name|long1
parameter_list|(
name|long
name|x
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|x
operator|>>
literal|32
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|char
name|long2
parameter_list|(
name|long
name|x
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|x
operator|>>
literal|16
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|char
name|long3
parameter_list|(
name|long
name|x
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|x
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|char
name|int0
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|x
operator|>>
literal|16
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|char
name|int1
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|x
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isLessThanUnsigned
parameter_list|(
name|long
name|n1
parameter_list|,
name|long
name|n2
parameter_list|)
block|{
return|return
operator|(
name|n1
operator|<
name|n2
operator|)
operator|^
operator|(
operator|(
name|n1
operator|<
literal|0
operator|)
operator|!=
operator|(
name|n2
operator|<
literal|0
operator|)
operator|)
return|;
block|}
specifier|static
class|class
name|FixedSizeTreeSet
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|<
name|E
parameter_list|>
parameter_list|>
extends|extends
name|TreeSet
argument_list|<
name|E
argument_list|>
block|{
comment|/**      *       */
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|8237117170340299630L
decl_stmt|;
specifier|private
specifier|final
name|int
name|capacity
decl_stmt|;
name|FixedSizeTreeSet
parameter_list|()
block|{
name|this
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
name|FixedSizeTreeSet
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|capacity
operator|=
name|capacity
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
specifier|final
name|E
name|toAdd
parameter_list|)
block|{
if|if
condition|(
name|capacity
operator|<=
name|size
argument_list|()
condition|)
block|{
specifier|final
name|E
name|lastElm
init|=
name|last
argument_list|()
decl_stmt|;
if|if
condition|(
name|toAdd
operator|.
name|compareTo
argument_list|(
name|lastElm
argument_list|)
operator|>
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|pollLast
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|super
operator|.
name|add
argument_list|(
name|toAdd
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|LongPair
name|combineOrdered
parameter_list|(
name|LongPair
modifier|...
name|hashCodes
parameter_list|)
block|{
name|LongPair
name|result
init|=
operator|new
name|LongPair
argument_list|()
decl_stmt|;
for|for
control|(
name|LongPair
name|hashCode
range|:
name|hashCodes
control|)
block|{
name|result
operator|.
name|val1
operator|=
name|result
operator|.
name|val1
operator|*
literal|37
operator|+
name|hashCode
operator|.
name|val1
expr_stmt|;
name|result
operator|.
name|val2
operator|=
name|result
operator|.
name|val2
operator|*
literal|37
operator|+
name|hashCode
operator|.
name|val2
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/** 128 bits of state */
specifier|static
specifier|final
class|class
name|LongPair
implements|implements
name|Comparable
argument_list|<
name|LongPair
argument_list|>
block|{
specifier|public
name|long
name|val1
decl_stmt|;
specifier|public
name|long
name|val2
decl_stmt|;
comment|/*      * (non-Javadoc)      *       * @see java.lang.Comparable#compareTo(java.lang.Object)      */
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|LongPair
name|other
parameter_list|)
block|{
if|if
condition|(
name|isLessThanUnsigned
argument_list|(
name|val2
argument_list|,
name|other
operator|.
name|val2
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|val2
operator|==
name|other
operator|.
name|val2
condition|)
block|{
if|if
condition|(
name|isLessThanUnsigned
argument_list|(
name|val1
argument_list|,
name|other
operator|.
name|val1
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|val1
operator|==
name|other
operator|.
name|val1
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|LongPair
name|longPair
init|=
operator|(
name|LongPair
operator|)
name|o
decl_stmt|;
return|return
name|val1
operator|==
name|longPair
operator|.
name|val1
operator|&&
name|val2
operator|==
name|longPair
operator|.
name|val2
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
call|(
name|int
call|)
argument_list|(
name|val1
operator|^
operator|(
name|val1
operator|>>>
literal|32
operator|)
argument_list|)
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
call|(
name|int
call|)
argument_list|(
name|val2
operator|^
operator|(
name|val2
operator|>>>
literal|32
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/** Gets a long from a byte buffer in little endian byte order. */
specifier|private
specifier|static
name|long
name|getLongLittleEndian
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
operator|(
operator|(
name|long
operator|)
name|buf
index|[
name|offset
operator|+
literal|7
index|]
operator|<<
literal|56
operator|)
comment|// no mask needed
operator||
operator|(
operator|(
name|buf
index|[
name|offset
operator|+
literal|6
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|buf
index|[
name|offset
operator|+
literal|5
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
name|buf
index|[
name|offset
operator|+
literal|4
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|buf
index|[
name|offset
operator|+
literal|3
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|buf
index|[
name|offset
operator|+
literal|2
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|buf
index|[
name|offset
operator|+
literal|1
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|buf
index|[
name|offset
index|]
operator|&
literal|0xffL
operator|)
operator|)
return|;
comment|// no shift needed
block|}
comment|/** Returns the MurmurHash3_x64_128 hash, placing the result in "out". */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"fallthrough"
argument_list|)
comment|// the huge switch is designed to use fall through into cases!
specifier|static
name|void
name|murmurhash3_x64_128
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|seed
parameter_list|,
name|LongPair
name|out
parameter_list|)
block|{
comment|// The original algorithm does have a 32 bit unsigned seed.
comment|// We have to mask to match the behavior of the unsigned types and prevent sign extension.
name|long
name|h1
init|=
name|seed
operator|&
literal|0x00000000FFFFFFFFL
decl_stmt|;
name|long
name|h2
init|=
name|seed
operator|&
literal|0x00000000FFFFFFFFL
decl_stmt|;
specifier|final
name|long
name|c1
init|=
literal|0x87c37b91114253d5L
decl_stmt|;
specifier|final
name|long
name|c2
init|=
literal|0x4cf5ad432745937fL
decl_stmt|;
name|int
name|roundedEnd
init|=
name|offset
operator|+
operator|(
name|len
operator|&
literal|0xFFFFFFF0
operator|)
decl_stmt|;
comment|// round down to 16 byte block
for|for
control|(
name|int
name|i
init|=
name|offset
init|;
name|i
operator|<
name|roundedEnd
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|long
name|k1
init|=
name|getLongLittleEndian
argument_list|(
name|key
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|long
name|k2
init|=
name|getLongLittleEndian
argument_list|(
name|key
argument_list|,
name|i
operator|+
literal|8
argument_list|)
decl_stmt|;
name|k1
operator|*=
name|c1
expr_stmt|;
name|k1
operator|=
name|Long
operator|.
name|rotateLeft
argument_list|(
name|k1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|k1
operator|*=
name|c2
expr_stmt|;
name|h1
operator|^=
name|k1
expr_stmt|;
name|h1
operator|=
name|Long
operator|.
name|rotateLeft
argument_list|(
name|h1
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|h1
operator|+=
name|h2
expr_stmt|;
name|h1
operator|=
name|h1
operator|*
literal|5
operator|+
literal|0x52dce729
expr_stmt|;
name|k2
operator|*=
name|c2
expr_stmt|;
name|k2
operator|=
name|Long
operator|.
name|rotateLeft
argument_list|(
name|k2
argument_list|,
literal|33
argument_list|)
expr_stmt|;
name|k2
operator|*=
name|c1
expr_stmt|;
name|h2
operator|^=
name|k2
expr_stmt|;
name|h2
operator|=
name|Long
operator|.
name|rotateLeft
argument_list|(
name|h2
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|h1
expr_stmt|;
name|h2
operator|=
name|h2
operator|*
literal|5
operator|+
literal|0x38495ab5
expr_stmt|;
block|}
name|long
name|k1
init|=
literal|0
decl_stmt|;
name|long
name|k2
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|len
operator|&
literal|15
condition|)
block|{
case|case
literal|15
case|:
name|k2
operator|=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|14
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|48
expr_stmt|;
case|case
literal|14
case|:
name|k2
operator||=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|13
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|40
expr_stmt|;
case|case
literal|13
case|:
name|k2
operator||=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|12
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|32
expr_stmt|;
case|case
literal|12
case|:
name|k2
operator||=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|11
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|24
expr_stmt|;
case|case
literal|11
case|:
name|k2
operator||=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|10
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|16
expr_stmt|;
case|case
literal|10
case|:
name|k2
operator||=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|9
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|8
expr_stmt|;
case|case
literal|9
case|:
name|k2
operator||=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|8
index|]
operator|&
literal|0xffL
operator|)
expr_stmt|;
name|k2
operator|*=
name|c2
expr_stmt|;
name|k2
operator|=
name|Long
operator|.
name|rotateLeft
argument_list|(
name|k2
argument_list|,
literal|33
argument_list|)
expr_stmt|;
name|k2
operator|*=
name|c1
expr_stmt|;
name|h2
operator|^=
name|k2
expr_stmt|;
case|case
literal|8
case|:
name|k1
operator|=
operator|(
operator|(
name|long
operator|)
name|key
index|[
name|roundedEnd
operator|+
literal|7
index|]
operator|)
operator|<<
literal|56
expr_stmt|;
case|case
literal|7
case|:
name|k1
operator||=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|6
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|48
expr_stmt|;
case|case
literal|6
case|:
name|k1
operator||=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|5
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|40
expr_stmt|;
case|case
literal|5
case|:
name|k1
operator||=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|4
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|32
expr_stmt|;
case|case
literal|4
case|:
name|k1
operator||=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|3
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|24
expr_stmt|;
case|case
literal|3
case|:
name|k1
operator||=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|2
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|16
expr_stmt|;
case|case
literal|2
case|:
name|k1
operator||=
operator|(
name|key
index|[
name|roundedEnd
operator|+
literal|1
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|8
expr_stmt|;
case|case
literal|1
case|:
name|k1
operator||=
operator|(
name|key
index|[
name|roundedEnd
index|]
operator|&
literal|0xffL
operator|)
expr_stmt|;
name|k1
operator|*=
name|c1
expr_stmt|;
name|k1
operator|=
name|Long
operator|.
name|rotateLeft
argument_list|(
name|k1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|k1
operator|*=
name|c2
expr_stmt|;
name|h1
operator|^=
name|k1
expr_stmt|;
block|}
comment|// ----------
comment|// finalization
name|h1
operator|^=
name|len
expr_stmt|;
name|h2
operator|^=
name|len
expr_stmt|;
name|h1
operator|+=
name|h2
expr_stmt|;
name|h2
operator|+=
name|h1
expr_stmt|;
name|h1
operator|=
name|fmix64
argument_list|(
name|h1
argument_list|)
expr_stmt|;
name|h2
operator|=
name|fmix64
argument_list|(
name|h2
argument_list|)
expr_stmt|;
name|h1
operator|+=
name|h2
expr_stmt|;
name|h2
operator|+=
name|h1
expr_stmt|;
name|out
operator|.
name|val1
operator|=
name|h1
expr_stmt|;
name|out
operator|.
name|val2
operator|=
name|h2
expr_stmt|;
block|}
specifier|private
specifier|static
name|long
name|fmix64
parameter_list|(
name|long
name|k
parameter_list|)
block|{
name|k
operator|^=
name|k
operator|>>>
literal|33
expr_stmt|;
name|k
operator|*=
literal|0xff51afd7ed558ccdL
expr_stmt|;
name|k
operator|^=
name|k
operator|>>>
literal|33
expr_stmt|;
name|k
operator|*=
literal|0xc4ceb9fe1a85ec53L
expr_stmt|;
name|k
operator|^=
name|k
operator|>>>
literal|33
expr_stmt|;
return|return
name|k
return|;
block|}
block|}
end_class

end_unit

