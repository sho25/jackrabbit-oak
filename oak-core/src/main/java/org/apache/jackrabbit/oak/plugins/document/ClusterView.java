begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|json
operator|.
name|JsopBuilder
import|;
end_import

begin_comment
comment|/**  * A ClusterView represents the state of a cluster at a particular moment in  * time.  *<p>  * This is a combination of what is stored in the ClusterViewDocument and the  * list of instances that currently have a backlog.  *<p>  * In order to be able to differentiate and clearly identify the different  * states an instance is in, the ClusterView uses a slightly different  * terminology of states that it reports:  *<ul>  *<li>Active: (same as in the ClusterViewDocument) an instance that is alive  * and has no recoveryLock set. Whether or not the lease has timed out is  * ignored. If the lease would be timed out, this would be immediately noticed  * by one of the instances and the affected instance would thus be recovered  * soon.</li>  *<li>Deactivating: An instance that is either recovering (which is the state  * reported from the ClusterViewDocument) - ie it was active until now but the  * lease has just timed out and one of the peer instances noticed so it does a  * recovery now - or it is inactive but some of its changes are still in the  * backlog (the latter is not tracked in the ClusterViewDocument, instead  * instances with a backlog are in the 'inactive' bucket there).</li>  *<li>Inactive: An instance that is both inactive from a  * clusterNodes/ClusterViewDocument point of view (ie no longer active and  * already recovered) and it has no backlog anymore.</li>  *</ul>  * The JSON generated by the ClusterView (which is propagated to JMX) has the  * following fields:  *<ul>  *<li>seq = sequence number: this is a monotonically increasing number assigned  * to each incarnation of the persisted clusterView (in the settings  * collection). It can be used to take note of the fact that a view has changed  * even though perhaps all activeIds are still the same (eg when the listener  * would have missed a few changes). It can also be used to tell with certainty  * that 'anything has changed' compared to the clusterView with a previous  * sequence number</li>  *<li>final = is final: this is a boolean indicating whether or not the view  * with a particular sequence number is final (not going to change anymore) or  * whether the discovery lite takes the freedom to modify the view in the future  * (false). So whenever 'final' is false, then the view must be treated as 'in  * flux' and perhaps the user should wait with doing any conclusions. That's not  * to say that if 'final' is false, that the information provided in  * active/deactivating/inactive is wrong - that's of course not the case - that  * info is always correct. But when 'final' is false it just means that  * active/deactivating/inactive for a given sequence number might change.</li>  *<li>id = cluster view id: this is the unique, stable identifier of the local  * cluster. The idea of this id is to provide both an actual identifier for the  * local cluster as well as a 'namespace' for the instanceIds therein. The  * instanceIds are all just simply integers and can of course be the same for  * instances in different clusters.</li>  *<li>me = my local instance id: this is the id of the local instance as  * managed by DocumentNodeStore</li>  *<li>active = active instance ids: this is the list of instance ids that are  * all currently active in the local cluster. The ids are managed by  * DocumentNodeStore</li>  *<li>deactivating = deactivating instance ids: this is the list of instance  * ids that are all in the process of deactivating and for which therefore some  * data might still be making its way to the local instance. So any changes that  * were done by instances that are deactivating might not yet be visible locally  *</li>  *<li>deactive = deactive instance ids: this is the list of instance ids that  * are not running nor do they have any data pending to become visible by the  * local instance</li>  *</ul>  */
end_comment

begin_class
class|class
name|ClusterView
block|{
comment|/**      * the json containing the complete information of the state of this      * ClusterView. Created at constructor time for performance reasons (json      * will be polled via JMX very frequently, thus must be provided fast)      */
specifier|private
specifier|final
name|String
name|json
decl_stmt|;
comment|/**      * Factory method that creates a ClusterView given a ClusterViewDocument and      * a list of instances that currently have a backlog.      *<p>      * The ClusterViewDocument contains instances in the following states:      *<ul>      *<li>active</li>      *<li>recovering</li>      *<li>inactive</li>      *</ul>      * The ClusterView however reports these upwards as follows:      *<ul>      *<li>active: this is 1:1 the active ones from the ClusterViewDocument</li>      *<li>deactivating: this includes the recovering ones from the      * ClusterViewDocument plus those passed to this method in the backlogIds      * parameter</li>      *<li>inactive: this is the inactive ones from the ClusterViewDocument      *<b>minus</li> the backlogIds passed</li>      *</ul>      *       * @param localInstanceId      *            the id of the local instance (me)      * @param clusterViewDoc      *            the ClusterViewDocument which contains the currently persisted      *            cluster view      * @param backlogIds      *            the ids that the local instances still has not finished a      *            background read for and thus still have a backlog      * @return the ClusterView representing the provided info      */
specifier|static
name|ClusterView
name|fromDocument
parameter_list|(
name|int
name|localInstanceId
parameter_list|,
name|ClusterViewDocument
name|clusterViewDoc
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|backlogIds
parameter_list|)
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|activeIds
init|=
name|clusterViewDoc
operator|.
name|getActiveIds
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|deactivatingIds
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|deactivatingIds
operator|.
name|addAll
argument_list|(
name|clusterViewDoc
operator|.
name|getRecoveringIds
argument_list|()
argument_list|)
expr_stmt|;
name|deactivatingIds
operator|.
name|addAll
argument_list|(
name|backlogIds
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|inactiveIds
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|inactiveIds
operator|.
name|addAll
argument_list|(
name|clusterViewDoc
operator|.
name|getInactiveIds
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inactiveIds
operator|.
name|removeAll
argument_list|(
name|backlogIds
argument_list|)
operator|&&
name|backlogIds
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// then not all backlogIds were listed is inactive - which is
comment|// contrary to the expectation
comment|// in which case we indeed do a paranoia exception here:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"not all backlogIds ("
operator|+
name|backlogIds
operator|+
literal|") are part of inactiveIds ("
operator|+
name|clusterViewDoc
operator|.
name|getInactiveIds
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
return|return
operator|new
name|ClusterView
argument_list|(
name|clusterViewDoc
operator|.
name|getViewSeqNum
argument_list|()
argument_list|,
name|backlogIds
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|,
name|clusterViewDoc
operator|.
name|getClusterViewId
argument_list|()
argument_list|,
name|localInstanceId
argument_list|,
name|activeIds
argument_list|,
name|deactivatingIds
argument_list|,
name|inactiveIds
argument_list|)
return|;
block|}
name|ClusterView
parameter_list|(
specifier|final
name|long
name|viewSeqNum
parameter_list|,
specifier|final
name|boolean
name|viewFinal
parameter_list|,
specifier|final
name|String
name|clusterViewId
parameter_list|,
specifier|final
name|int
name|localId
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|activeIds
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|deactivatingIds
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|inactiveIds
parameter_list|)
block|{
if|if
condition|(
name|viewSeqNum
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"viewSeqNum must be zero or higher: "
operator|+
name|viewSeqNum
argument_list|)
throw|;
block|}
if|if
condition|(
name|clusterViewId
operator|==
literal|null
operator|||
name|clusterViewId
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"clusterViewId must not be zero or empty: "
operator|+
name|clusterViewId
argument_list|)
throw|;
block|}
if|if
condition|(
name|localId
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"localId must not be zero or higher: "
operator|+
name|localId
argument_list|)
throw|;
block|}
if|if
condition|(
name|activeIds
operator|==
literal|null
operator|||
name|activeIds
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"activeIds must not be null or empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|deactivatingIds
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"deactivatingIds must not be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|inactiveIds
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"inactiveIds must not be null"
argument_list|)
throw|;
block|}
name|json
operator|=
name|asJson
argument_list|(
name|viewSeqNum
argument_list|,
name|viewFinal
argument_list|,
name|clusterViewId
argument_list|,
name|localId
argument_list|,
name|activeIds
argument_list|,
name|deactivatingIds
argument_list|,
name|inactiveIds
argument_list|)
expr_stmt|;
block|}
comment|/**      * Converts the provided parameters into the clusterview json that will be      * provided via JMX      **/
specifier|private
name|String
name|asJson
parameter_list|(
specifier|final
name|long
name|viewSeqNum
parameter_list|,
specifier|final
name|boolean
name|viewFinal
parameter_list|,
specifier|final
name|String
name|clusterViewId
parameter_list|,
specifier|final
name|int
name|localId
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|activeIds
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|deactivatingIds
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|inactiveIds
parameter_list|)
block|{
name|JsopBuilder
name|builder
init|=
operator|new
name|JsopBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|object
argument_list|()
expr_stmt|;
name|builder
operator|.
name|key
argument_list|(
literal|"seq"
argument_list|)
operator|.
name|value
argument_list|(
name|viewSeqNum
argument_list|)
expr_stmt|;
name|builder
operator|.
name|key
argument_list|(
literal|"final"
argument_list|)
operator|.
name|value
argument_list|(
name|viewFinal
argument_list|)
expr_stmt|;
name|builder
operator|.
name|key
argument_list|(
literal|"id"
argument_list|)
operator|.
name|value
argument_list|(
name|clusterViewId
argument_list|)
expr_stmt|;
name|builder
operator|.
name|key
argument_list|(
literal|"me"
argument_list|)
operator|.
name|value
argument_list|(
name|localId
argument_list|)
expr_stmt|;
name|builder
operator|.
name|key
argument_list|(
literal|"active"
argument_list|)
operator|.
name|array
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|it
init|=
name|activeIds
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Integer
name|anInstance
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|builder
operator|.
name|value
argument_list|(
name|anInstance
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|endArray
argument_list|()
expr_stmt|;
name|builder
operator|.
name|key
argument_list|(
literal|"deactivating"
argument_list|)
operator|.
name|array
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|it
init|=
name|deactivatingIds
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Integer
name|anInstance
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|builder
operator|.
name|value
argument_list|(
name|anInstance
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|endArray
argument_list|()
expr_stmt|;
name|builder
operator|.
name|key
argument_list|(
literal|"inactive"
argument_list|)
operator|.
name|array
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|it
init|=
name|inactiveIds
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Integer
name|anInstance
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|builder
operator|.
name|value
argument_list|(
name|anInstance
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|endArray
argument_list|()
expr_stmt|;
name|builder
operator|.
name|endObject
argument_list|()
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Debugging toString() **/
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"a ClusterView["
operator|+
name|json
operator|+
literal|"]"
return|;
block|}
comment|/** This is the main getter that will be polled via JMX **/
name|String
name|asDescriptorValue
parameter_list|()
block|{
return|return
name|json
return|;
block|}
block|}
end_class

end_unit

