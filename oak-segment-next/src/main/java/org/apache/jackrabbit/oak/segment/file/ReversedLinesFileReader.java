begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|file
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetEncoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|UnsupportedCharsetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|Charsets
import|;
end_import

begin_comment
comment|/**  * Reads lines in a file reversely (similar to a BufferedReader, but starting at  * the last line). Useful for e.g. searching in log files.  *  * FIXME: this is a copy of org.apache.commons.io.input.ReversedLinesFileReader  * with a fix for IO-471. Replace again once commons-io has released a fixed version.  */
end_comment

begin_class
class|class
name|ReversedLinesFileReader
implements|implements
name|Closeable
block|{
specifier|private
specifier|final
name|int
name|blockSize
decl_stmt|;
specifier|private
specifier|final
name|Charset
name|encoding
decl_stmt|;
specifier|private
specifier|final
name|RandomAccessFile
name|randomAccessFile
decl_stmt|;
specifier|private
specifier|final
name|long
name|totalByteLength
decl_stmt|;
specifier|private
specifier|final
name|long
name|totalBlockCount
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
index|[]
name|newLineSequences
decl_stmt|;
specifier|private
specifier|final
name|int
name|avoidNewlineSplitBufferSize
decl_stmt|;
specifier|private
specifier|final
name|int
name|byteDecrement
decl_stmt|;
specifier|private
name|FilePart
name|currentFilePart
decl_stmt|;
specifier|private
name|boolean
name|trailingNewlineOfFileSkipped
init|=
literal|false
decl_stmt|;
comment|/**      * Creates a ReversedLinesFileReader with default block size of 4KB and the      * platform's default encoding.      *      * @param file      *            the file to be read      * @throws IOException  if an I/O error occurs      */
specifier|public
name|ReversedLinesFileReader
parameter_list|(
specifier|final
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|file
argument_list|,
literal|4096
argument_list|,
name|Charset
operator|.
name|defaultCharset
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a ReversedLinesFileReader with the given block size and encoding.      *      * @param file      *            the file to be read      * @param blockSize      *            size of the internal buffer (for ideal performance this should      *            match with the block size of the underlying file system).      * @param encoding      *            the encoding of the file      * @throws IOException  if an I/O error occurs      * @since 2.3      */
specifier|public
name|ReversedLinesFileReader
parameter_list|(
specifier|final
name|File
name|file
parameter_list|,
specifier|final
name|int
name|blockSize
parameter_list|,
specifier|final
name|Charset
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|blockSize
operator|=
name|blockSize
expr_stmt|;
name|this
operator|.
name|encoding
operator|=
name|encoding
expr_stmt|;
name|randomAccessFile
operator|=
operator|new
name|RandomAccessFile
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|totalByteLength
operator|=
name|randomAccessFile
operator|.
name|length
argument_list|()
expr_stmt|;
name|int
name|lastBlockLength
init|=
call|(
name|int
call|)
argument_list|(
name|totalByteLength
operator|%
name|blockSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastBlockLength
operator|>
literal|0
condition|)
block|{
name|totalBlockCount
operator|=
name|totalByteLength
operator|/
name|blockSize
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|totalBlockCount
operator|=
name|totalByteLength
operator|/
name|blockSize
expr_stmt|;
if|if
condition|(
name|totalByteLength
operator|>
literal|0
condition|)
block|{
name|lastBlockLength
operator|=
name|blockSize
expr_stmt|;
block|}
block|}
name|currentFilePart
operator|=
operator|new
name|FilePart
argument_list|(
name|totalBlockCount
argument_list|,
name|lastBlockLength
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// --- check& prepare encoding ---
name|Charset
name|charset
init|=
name|Charsets
operator|.
name|toCharset
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
name|CharsetEncoder
name|charsetEncoder
init|=
name|charset
operator|.
name|newEncoder
argument_list|()
decl_stmt|;
name|float
name|maxBytesPerChar
init|=
name|charsetEncoder
operator|.
name|maxBytesPerChar
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxBytesPerChar
operator|==
literal|1f
condition|)
block|{
comment|// all one byte encodings are no problem
name|byteDecrement
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|charset
operator|==
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
condition|)
block|{
comment|// UTF-8 works fine out of the box, for multibyte sequences a second UTF-8 byte can never be a newline byte
comment|// http://en.wikipedia.org/wiki/UTF-8
name|byteDecrement
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|charset
operator|==
name|Charset
operator|.
name|forName
argument_list|(
literal|"Shift_JIS"
argument_list|)
operator|||
comment|// Same as for UTF-8 http://www.herongyang.com/Unicode/JIS-Shift-JIS-Encoding.html
name|charset
operator|==
name|Charset
operator|.
name|forName
argument_list|(
literal|"windows-31j"
argument_list|)
operator|||
comment|// Windows code page 932 (Japanese)
name|charset
operator|==
name|Charset
operator|.
name|forName
argument_list|(
literal|"x-windows-949"
argument_list|)
operator|||
comment|// Windows code page 949 (Korean)
name|charset
operator|==
name|Charset
operator|.
name|forName
argument_list|(
literal|"gbk"
argument_list|)
operator|||
comment|// Windows code page 936 (Simplified Chinese)
name|charset
operator|==
name|Charset
operator|.
name|forName
argument_list|(
literal|"x-windows-950"
argument_list|)
condition|)
block|{
comment|// Windows code page 950 (Traditional Chinese)
name|byteDecrement
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|charset
operator|==
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-16BE"
argument_list|)
operator|||
name|charset
operator|==
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-16LE"
argument_list|)
condition|)
block|{
comment|// UTF-16 new line sequences are not allowed as second tuple of four byte sequences,
comment|// however byte order has to be specified
name|byteDecrement
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|charset
operator|==
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-16"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedEncodingException
argument_list|(
literal|"For UTF-16, you need to specify the byte order (use UTF-16BE or UTF-16LE)"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedEncodingException
argument_list|(
literal|"Encoding "
operator|+
name|encoding
operator|+
literal|" is not supported yet (feel free to submit a patch)"
argument_list|)
throw|;
block|}
comment|// NOTE: The new line sequences are matched in the order given, so it is important that \r\n is BEFORE \n
name|newLineSequences
operator|=
operator|new
name|byte
index|[]
index|[]
block|{
literal|"\r\n"
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
block|,
literal|"\n"
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
block|,
literal|"\r"
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
block|}
expr_stmt|;
name|avoidNewlineSplitBufferSize
operator|=
name|newLineSequences
index|[
literal|0
index|]
operator|.
name|length
expr_stmt|;
block|}
comment|/**      * Creates a ReversedLinesFileReader with the given block size and encoding.      *      * @param file      *            the file to be read      * @param blockSize      *            size of the internal buffer (for ideal performance this should      *            match with the block size of the underlying file system).      * @param encoding      *            the encoding of the file      * @throws IOException  if an I/O error occurs      * @throws UnsupportedCharsetException      *             thrown instead of {@link UnsupportedEncodingException} in version 2.2 if the encoding is not      *             supported.      */
specifier|public
name|ReversedLinesFileReader
parameter_list|(
specifier|final
name|File
name|file
parameter_list|,
specifier|final
name|int
name|blockSize
parameter_list|,
specifier|final
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|file
argument_list|,
name|blockSize
argument_list|,
name|Charsets
operator|.
name|toCharset
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the lines of the file from bottom to top.      *      * @return the next line or null if the start of the file is reached      * @throws IOException  if an I/O error occurs      */
specifier|public
name|String
name|readLine
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|line
init|=
name|currentFilePart
operator|.
name|readLine
argument_list|()
decl_stmt|;
while|while
condition|(
name|line
operator|==
literal|null
condition|)
block|{
name|currentFilePart
operator|=
name|currentFilePart
operator|.
name|rollOver
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentFilePart
operator|!=
literal|null
condition|)
block|{
name|line
operator|=
name|currentFilePart
operator|.
name|readLine
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// no more fileparts: we're done, leave line set to null
break|break;
block|}
block|}
comment|// aligned behaviour with BufferedReader that doesn't return a last, empty line
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|line
argument_list|)
operator|&&
operator|!
name|trailingNewlineOfFileSkipped
condition|)
block|{
name|trailingNewlineOfFileSkipped
operator|=
literal|true
expr_stmt|;
name|line
operator|=
name|readLine
argument_list|()
expr_stmt|;
block|}
return|return
name|line
return|;
block|}
comment|/**      * Closes underlying resources.      *      * @throws IOException  if an I/O error occurs      */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|randomAccessFile
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
specifier|private
class|class
name|FilePart
block|{
specifier|private
specifier|final
name|long
name|no
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|data
decl_stmt|;
specifier|private
name|byte
index|[]
name|leftOver
decl_stmt|;
specifier|private
name|int
name|currentLastBytePos
decl_stmt|;
comment|/**          * ctor          * @param no the part number          * @param length its length          * @param leftOverOfLastFilePart remainder          * @throws IOException if there is a problem reading the file          */
specifier|private
name|FilePart
parameter_list|(
specifier|final
name|long
name|no
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|byte
index|[]
name|leftOverOfLastFilePart
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|no
operator|=
name|no
expr_stmt|;
name|int
name|dataLength
init|=
name|length
operator|+
operator|(
name|leftOverOfLastFilePart
operator|!=
literal|null
condition|?
name|leftOverOfLastFilePart
operator|.
name|length
else|:
literal|0
operator|)
decl_stmt|;
name|this
operator|.
name|data
operator|=
operator|new
name|byte
index|[
name|dataLength
index|]
expr_stmt|;
specifier|final
name|long
name|off
init|=
operator|(
name|no
operator|-
literal|1
operator|)
operator|*
name|blockSize
decl_stmt|;
comment|// read data
if|if
condition|(
name|no
operator|>
literal|0
comment|/* file not empty */
condition|)
block|{
name|randomAccessFile
operator|.
name|seek
argument_list|(
name|off
argument_list|)
expr_stmt|;
specifier|final
name|int
name|countRead
init|=
name|randomAccessFile
operator|.
name|read
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|countRead
operator|!=
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Count of requested bytes and actually read bytes don't match"
argument_list|)
throw|;
block|}
block|}
comment|// copy left over part into data arr
if|if
condition|(
name|leftOverOfLastFilePart
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|leftOverOfLastFilePart
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
name|length
argument_list|,
name|leftOverOfLastFilePart
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|currentLastBytePos
operator|=
name|data
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|leftOver
operator|=
literal|null
expr_stmt|;
block|}
comment|/**          * Handles block rollover          *          * @return the new FilePart or null          * @throws IOException if there was a problem reading the file          */
specifier|private
name|FilePart
name|rollOver
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentLastBytePos
operator|>
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Current currentLastCharPos unexpectedly positive... "
operator|+
literal|"last readLine() should have returned something! currentLastCharPos="
operator|+
name|currentLastBytePos
argument_list|)
throw|;
block|}
if|if
condition|(
name|no
operator|>
literal|1
condition|)
block|{
return|return
operator|new
name|FilePart
argument_list|(
name|no
operator|-
literal|1
argument_list|,
name|blockSize
argument_list|,
name|leftOver
argument_list|)
return|;
block|}
else|else
block|{
comment|// NO 1 was the last FilePart, we're finished
if|if
condition|(
name|leftOver
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unexpected leftover of the last block: leftOverOfThisFilePart="
operator|+
operator|new
name|String
argument_list|(
name|leftOver
argument_list|,
name|encoding
argument_list|)
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**          * Reads a line.          *          * @return the line or null          * @throws IOException if there is an error reading from the file          */
specifier|private
name|String
name|readLine
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|line
init|=
literal|null
decl_stmt|;
name|int
name|newLineMatchByteCount
decl_stmt|;
name|boolean
name|isLastFilePart
init|=
name|no
operator|==
literal|1
decl_stmt|;
name|int
name|i
init|=
name|currentLastBytePos
decl_stmt|;
while|while
condition|(
name|i
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|isLastFilePart
operator|&&
name|i
operator|<
name|avoidNewlineSplitBufferSize
condition|)
block|{
comment|// avoidNewlineSplitBuffer: for all except the last file part we
comment|// take a few bytes to the next file part to avoid splitting of newlines
name|createLeftOver
argument_list|()
expr_stmt|;
break|break;
comment|// skip last few bytes and leave it to the next file part
block|}
comment|// --- check for newline ---
if|if
condition|(
operator|(
name|newLineMatchByteCount
operator|=
name|getNewLineMatchByteCount
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
operator|)
operator|>
literal|0
comment|/* found newline */
condition|)
block|{
specifier|final
name|int
name|lineStart
init|=
name|i
operator|+
literal|1
decl_stmt|;
name|int
name|lineLengthBytes
init|=
name|currentLastBytePos
operator|-
name|lineStart
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|lineLengthBytes
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unexpected negative line length="
operator|+
name|lineLengthBytes
argument_list|)
throw|;
block|}
name|byte
index|[]
name|lineData
init|=
operator|new
name|byte
index|[
name|lineLengthBytes
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
name|lineStart
argument_list|,
name|lineData
argument_list|,
literal|0
argument_list|,
name|lineLengthBytes
argument_list|)
expr_stmt|;
name|line
operator|=
operator|new
name|String
argument_list|(
name|lineData
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|currentLastBytePos
operator|=
name|i
operator|-
name|newLineMatchByteCount
expr_stmt|;
break|break;
comment|// found line
block|}
comment|// --- move cursor ---
name|i
operator|-=
name|byteDecrement
expr_stmt|;
comment|// --- end of file part handling ---
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|createLeftOver
argument_list|()
expr_stmt|;
break|break;
comment|// end of file part
block|}
block|}
comment|// --- last file part handling ---
if|if
condition|(
name|isLastFilePart
operator|&&
name|leftOver
operator|!=
literal|null
condition|)
block|{
comment|// there will be no line break anymore, this is the first line of the file
name|line
operator|=
operator|new
name|String
argument_list|(
name|leftOver
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|leftOver
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|line
return|;
block|}
comment|/**          * Creates the buffer containing any left over bytes.          */
specifier|private
name|void
name|createLeftOver
parameter_list|()
block|{
name|int
name|lineLengthBytes
init|=
name|currentLastBytePos
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|lineLengthBytes
operator|>
literal|0
condition|)
block|{
comment|// create left over for next block
name|leftOver
operator|=
operator|new
name|byte
index|[
name|lineLengthBytes
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|leftOver
argument_list|,
literal|0
argument_list|,
name|lineLengthBytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|leftOver
operator|=
literal|null
expr_stmt|;
block|}
name|currentLastBytePos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/**          * Finds the new-line sequence and return its length.          *          * @param data buffer to scan          * @param i start offset in buffer          * @return length of newline sequence or 0 if none found          */
specifier|private
name|int
name|getNewLineMatchByteCount
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|i
parameter_list|)
block|{
for|for
control|(
name|byte
index|[]
name|newLineSequence
range|:
name|newLineSequences
control|)
block|{
name|boolean
name|match
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|newLineSequence
operator|.
name|length
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|k
init|=
name|i
operator|+
name|j
operator|-
operator|(
name|newLineSequence
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
name|match
operator|&=
name|k
operator|>=
literal|0
operator|&&
name|data
index|[
name|k
index|]
operator|==
name|newLineSequence
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|match
condition|)
block|{
return|return
name|newLineSequence
operator|.
name|length
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
block|}
block|}
end_class

end_unit

