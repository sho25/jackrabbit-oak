begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|file
operator|.
name|tar
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|file
operator|.
name|tar
operator|.
name|index
operator|.
name|IndexEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|spi
operator|.
name|persistence
operator|.
name|SegmentArchiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|NotNull
import|;
end_import

begin_comment
comment|/**  * Instances of this class represent the garbage collection generation related  * information of a segment. It consists of the segment's generation, its full  * generation and its compaction flag. The segment's generation records the number  * of garbage collection cycles a segment went through and is incremented with  * every garbage collection regardless its type. The segment's full generation  * records the number of full garbage collection cycles a segment went through.  * It is only incremented on full garbage collection cycles. The segment's compaction  * flag is set for those segments that have been created by a compaction operation.  * It is never set for segments created by normal write operations or defer  * compactions triggered by such. Segments written by normal repository writes will  * inherit the generation and full generation of the segment written by the previous  * compaction process with the compacted flag cleared.  *<p>  * The information recorded in this way allows to determine the reclamation status  * of a segment by just looking at the {@code GCGeneration} instances of that segment  * and of the segment containing the repository head: Let {@code s} be a segment,  * {@code h} be the segment containing the current repository head and {@code n} be  * the number of retained generations.  *<ul>  *<li>{@code s} is old iff {@code h.generation - s.generation>= n}</li>  *<li>{@code s} is in the same compaction tail than h iff  *         {@code s.isCompacted&& s.fullGeneration == h.fullGeneration}</li>  *<li>{@code s} is reclaimable iff {@code s} is old and {@code s} is not in the same compaction tail than {@code h}</li>  *</ul>  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|GCGeneration
block|{
specifier|public
specifier|static
specifier|final
name|GCGeneration
name|NULL
init|=
operator|new
name|GCGeneration
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|GCGeneration
name|newGCGeneration
parameter_list|(
name|int
name|generation
parameter_list|,
name|int
name|fullGeneration
parameter_list|,
name|boolean
name|isCompacted
parameter_list|)
block|{
return|return
operator|new
name|GCGeneration
argument_list|(
name|generation
argument_list|,
name|fullGeneration
argument_list|,
name|isCompacted
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|GCGeneration
name|newGCGeneration
parameter_list|(
name|SegmentArchiveEntry
name|indexEntry
parameter_list|)
block|{
return|return
operator|new
name|GCGeneration
argument_list|(
name|indexEntry
operator|.
name|getGeneration
argument_list|()
argument_list|,
name|indexEntry
operator|.
name|getFullGeneration
argument_list|()
argument_list|,
name|indexEntry
operator|.
name|isCompacted
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|final
name|int
name|generation
decl_stmt|;
specifier|private
specifier|final
name|int
name|fullGeneration
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|isCompacted
decl_stmt|;
specifier|private
name|GCGeneration
parameter_list|(
name|int
name|generation
parameter_list|,
name|int
name|fullGeneration
parameter_list|,
name|boolean
name|isCompacted
parameter_list|)
block|{
name|this
operator|.
name|generation
operator|=
name|generation
expr_stmt|;
name|this
operator|.
name|fullGeneration
operator|=
name|fullGeneration
expr_stmt|;
name|this
operator|.
name|isCompacted
operator|=
name|isCompacted
expr_stmt|;
block|}
specifier|public
name|int
name|getGeneration
parameter_list|()
block|{
return|return
name|generation
return|;
block|}
specifier|public
name|int
name|getFullGeneration
parameter_list|()
block|{
return|return
name|fullGeneration
return|;
block|}
specifier|public
name|boolean
name|isCompacted
parameter_list|()
block|{
return|return
name|isCompacted
return|;
block|}
comment|/**      * Create a new instance with the generation and the full generation incremented by one      * and the compaction flag left unchanged.      */
annotation|@
name|NotNull
specifier|public
name|GCGeneration
name|nextFull
parameter_list|()
block|{
return|return
operator|new
name|GCGeneration
argument_list|(
name|generation
operator|+
literal|1
argument_list|,
name|fullGeneration
operator|+
literal|1
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Create a new instance with the generation incremented by one and the full      * generation and the compaction flag left unchanged.      */
annotation|@
name|NotNull
specifier|public
name|GCGeneration
name|nextTail
parameter_list|()
block|{
return|return
operator|new
name|GCGeneration
argument_list|(
name|generation
operator|+
literal|1
argument_list|,
name|fullGeneration
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Create a new instance with the compaction flag unset and the generation and the      * full generation left unchanged.      */
annotation|@
name|NotNull
specifier|public
name|GCGeneration
name|nonGC
parameter_list|()
block|{
return|return
operator|new
name|GCGeneration
argument_list|(
name|generation
argument_list|,
name|fullGeneration
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Compare this generation with {@code gcGeneration}      * @param gcGeneration  the generation this generation is compared against.      * @return  Number of generations between this generation and {@code gcGeneration}      */
specifier|public
name|int
name|compareWith
parameter_list|(
annotation|@
name|NotNull
name|GCGeneration
name|gcGeneration
parameter_list|)
block|{
return|return
name|generation
operator|-
name|checkNotNull
argument_list|(
name|gcGeneration
argument_list|)
operator|.
name|generation
return|;
block|}
comment|/**      * Compare this full generation the full generation of {@code gcGeneration}      * @param gcGeneration  the generation this generation is compared against.      * @return  Number of generations between the full generations of this generation      *          and {@code gcGeneration}      */
specifier|public
name|int
name|compareFullGenerationWith
parameter_list|(
annotation|@
name|NotNull
name|GCGeneration
name|gcGeneration
parameter_list|)
block|{
return|return
name|fullGeneration
operator|-
name|checkNotNull
argument_list|(
name|gcGeneration
argument_list|)
operator|.
name|fullGeneration
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|other
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|other
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|GCGeneration
name|that
init|=
operator|(
name|GCGeneration
operator|)
name|other
decl_stmt|;
return|return
name|generation
operator|==
name|that
operator|.
name|generation
operator|&&
name|fullGeneration
operator|==
name|that
operator|.
name|fullGeneration
operator|&&
name|isCompacted
operator|==
name|that
operator|.
name|isCompacted
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hashCode
argument_list|(
name|generation
argument_list|,
name|fullGeneration
argument_list|,
name|isCompacted
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"GCGeneration{"
operator|+
literal|"generation="
operator|+
name|generation
operator|+
literal|','
operator|+
literal|"fullGeneration="
operator|+
name|fullGeneration
operator|+
literal|','
operator|+
literal|"isCompacted="
operator|+
name|isCompacted
operator|+
literal|'}'
return|;
block|}
block|}
end_class

end_unit

