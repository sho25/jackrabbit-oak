begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|index
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|core
operator|.
name|MicroKernelImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|api
operator|.
name|MicroKernel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|json
operator|.
name|JsopBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|json
operator|.
name|JsopReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|json
operator|.
name|JsopTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|simple
operator|.
name|NodeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|simple
operator|.
name|NodeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|util
operator|.
name|ExceptionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|util
operator|.
name|SimpleLRUCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|index
operator|.
name|PropertyContentIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|QueryIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|QueryIndexProvider
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_comment
comment|/**  * A index mechanism. An index is bound to a certain repository, and supports  * one or more indexes.  */
end_comment

begin_class
specifier|public
class|class
name|Indexer
implements|implements
name|QueryIndexProvider
block|{
comment|// TODO discuss where to store index config data
specifier|private
specifier|static
specifier|final
name|String
name|INDEX_CONFIG_ROOT
init|=
literal|"/jcr:system/indexes"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|DISABLED
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"mk.indexDisabled"
argument_list|)
decl_stmt|;
specifier|private
name|MicroKernel
name|mk
decl_stmt|;
specifier|private
name|String
name|revision
decl_stmt|;
specifier|private
name|String
name|indexRootNode
decl_stmt|;
specifier|private
name|StringBuilder
name|buffer
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|Index
argument_list|>
name|indexes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Index
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|BTreePage
argument_list|>
name|modified
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BTreePage
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|SimpleLRUCache
argument_list|<
name|String
argument_list|,
name|BTreePage
argument_list|>
name|cache
init|=
name|SimpleLRUCache
operator|.
name|newInstance
argument_list|(
literal|100
argument_list|)
decl_stmt|;
specifier|private
name|String
name|readRevision
decl_stmt|;
specifier|public
name|Indexer
parameter_list|(
name|MicroKernel
name|mk
parameter_list|,
name|String
name|indexRootNode
parameter_list|)
block|{
name|this
operator|.
name|mk
operator|=
name|mk
expr_stmt|;
name|this
operator|.
name|indexRootNode
operator|=
name|indexRootNode
expr_stmt|;
block|}
specifier|public
name|Indexer
parameter_list|(
name|MicroKernel
name|mk
parameter_list|)
block|{
name|this
argument_list|(
name|mk
argument_list|,
name|INDEX_CONFIG_ROOT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|()
block|{
if|if
condition|(
operator|!
name|PathUtils
operator|.
name|isAbsolute
argument_list|(
name|indexRootNode
argument_list|)
condition|)
block|{
name|indexRootNode
operator|=
literal|"/"
operator|+
name|indexRootNode
expr_stmt|;
block|}
name|revision
operator|=
name|mk
operator|.
name|getHeadRevision
argument_list|()
expr_stmt|;
name|readRevision
operator|=
name|revision
expr_stmt|;
if|if
condition|(
operator|!
name|mk
operator|.
name|nodeExists
argument_list|(
name|indexRootNode
argument_list|,
name|revision
argument_list|)
condition|)
block|{
name|JsopBuilder
name|jsop
init|=
operator|new
name|JsopBuilder
argument_list|()
decl_stmt|;
name|String
name|p
init|=
literal|"/"
decl_stmt|;
for|for
control|(
name|String
name|e
range|:
name|PathUtils
operator|.
name|elements
argument_list|(
name|indexRootNode
argument_list|)
control|)
block|{
name|p
operator|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|p
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mk
operator|.
name|nodeExists
argument_list|(
name|p
argument_list|,
name|revision
argument_list|)
condition|)
block|{
name|jsop
operator|.
name|tag
argument_list|(
literal|'+'
argument_list|)
operator|.
name|key
argument_list|(
name|PathUtils
operator|.
name|relativize
argument_list|(
literal|"/"
argument_list|,
name|p
argument_list|)
argument_list|)
operator|.
name|object
argument_list|()
operator|.
name|endObject
argument_list|()
operator|.
name|newline
argument_list|()
expr_stmt|;
block|}
block|}
name|revision
operator|=
name|mk
operator|.
name|commit
argument_list|(
literal|"/"
argument_list|,
name|jsop
operator|.
name|toString
argument_list|()
argument_list|,
name|revision
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|node
init|=
name|mk
operator|.
name|getNodes
argument_list|(
name|indexRootNode
argument_list|,
name|revision
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
do|do
block|{
name|String
name|key
init|=
name|t
operator|.
name|readString
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|t
operator|.
name|read
argument_list|()
expr_stmt|;
name|String
name|value
init|=
name|t
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|','
argument_list|)
condition|)
do|;
name|String
name|rev
init|=
name|map
operator|.
name|get
argument_list|(
literal|"rev"
argument_list|)
decl_stmt|;
if|if
condition|(
name|rev
operator|!=
literal|null
condition|)
block|{
name|readRevision
operator|=
name|rev
expr_stmt|;
block|}
for|for
control|(
name|String
name|k
range|:
name|map
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Index
name|p
init|=
name|PropertyIndex
operator|.
name|fromNodeName
argument_list|(
name|this
argument_list|,
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
block|{
name|p
operator|=
name|PrefixIndex
operator|.
name|fromNodeName
argument_list|(
name|this
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|indexes
operator|.
name|put
argument_list|(
name|p
operator|.
name|getName
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|PropertyIndex
name|createPropertyIndex
parameter_list|(
name|String
name|property
parameter_list|,
name|boolean
name|unique
parameter_list|)
block|{
name|PropertyIndex
name|index
init|=
operator|new
name|PropertyIndex
argument_list|(
name|this
argument_list|,
name|property
argument_list|,
name|unique
argument_list|)
decl_stmt|;
name|PropertyIndex
name|existing
init|=
operator|(
name|PropertyIndex
operator|)
name|indexes
operator|.
name|get
argument_list|(
name|index
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|!=
literal|null
condition|)
block|{
return|return
name|existing
return|;
block|}
name|buildAndAddIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
specifier|public
name|PrefixIndex
name|createPrefixIndex
parameter_list|(
name|String
name|prefix
parameter_list|)
block|{
name|PrefixIndex
name|index
init|=
operator|new
name|PrefixIndex
argument_list|(
name|this
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
name|PrefixIndex
name|existing
init|=
operator|(
name|PrefixIndex
operator|)
name|indexes
operator|.
name|get
argument_list|(
name|index
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|!=
literal|null
condition|)
block|{
return|return
name|existing
return|;
block|}
name|buildAndAddIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
name|boolean
name|nodeExists
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|revision
operator|=
name|mk
operator|.
name|getHeadRevision
argument_list|()
expr_stmt|;
return|return
name|mk
operator|.
name|nodeExists
argument_list|(
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRootNode
argument_list|,
name|name
argument_list|)
argument_list|,
name|revision
argument_list|)
return|;
block|}
name|void
name|commit
parameter_list|(
name|String
name|jsop
parameter_list|)
block|{
name|revision
operator|=
name|mk
operator|.
name|commit
argument_list|(
name|indexRootNode
argument_list|,
name|jsop
argument_list|,
name|revision
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|BTreePage
name|getPageIfCached
parameter_list|(
name|BTree
name|tree
parameter_list|,
name|BTreeNode
name|parent
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|String
name|p
init|=
name|getPath
argument_list|(
name|tree
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
return|return
name|modified
operator|.
name|get
argument_list|(
name|p
argument_list|)
return|;
block|}
specifier|private
name|String
name|getPath
parameter_list|(
name|BTree
name|tree
parameter_list|,
name|BTreeNode
name|parent
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|String
name|p
init|=
name|parent
operator|==
literal|null
condition|?
name|name
else|:
name|PathUtils
operator|.
name|concat
argument_list|(
name|parent
operator|.
name|getPath
argument_list|()
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|String
name|indexRoot
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRootNode
argument_list|,
name|tree
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRoot
argument_list|,
name|p
argument_list|)
return|;
block|}
name|BTreePage
name|getPage
parameter_list|(
name|BTree
name|tree
parameter_list|,
name|BTreeNode
name|parent
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|String
name|p
init|=
name|getPath
argument_list|(
name|tree
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|BTreePage
name|page
decl_stmt|;
name|page
operator|=
name|modified
operator|.
name|get
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
return|return
name|page
return|;
block|}
name|String
name|cacheId
init|=
name|p
operator|+
literal|"@"
operator|+
name|revision
decl_stmt|;
name|page
operator|=
name|cache
operator|.
name|get
argument_list|(
name|cacheId
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
return|return
name|page
return|;
block|}
name|String
name|json
init|=
name|mk
operator|.
name|getNodes
argument_list|(
name|p
argument_list|,
name|revision
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|==
literal|null
condition|)
block|{
name|page
operator|=
operator|new
name|BTreeLeaf
argument_list|(
name|tree
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
operator|new
name|String
index|[
literal|0
index|]
argument_list|,
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NodeImpl
name|n
init|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|json
argument_list|)
decl_stmt|;
name|String
name|keys
init|=
name|n
operator|.
name|getProperty
argument_list|(
literal|"keys"
argument_list|)
decl_stmt|;
name|String
name|values
init|=
name|n
operator|.
name|getProperty
argument_list|(
literal|"values"
argument_list|)
decl_stmt|;
name|String
name|children
init|=
name|n
operator|.
name|getProperty
argument_list|(
literal|"children"
argument_list|)
decl_stmt|;
if|if
condition|(
name|children
operator|!=
literal|null
condition|)
block|{
name|BTreeNode
name|node
init|=
operator|new
name|BTreeNode
argument_list|(
name|tree
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|readArray
argument_list|(
name|keys
argument_list|)
argument_list|,
name|readArray
argument_list|(
name|values
argument_list|)
argument_list|,
name|readArray
argument_list|(
name|children
argument_list|)
argument_list|)
decl_stmt|;
name|page
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|BTreeLeaf
name|leaf
init|=
operator|new
name|BTreeLeaf
argument_list|(
name|tree
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|readArray
argument_list|(
name|keys
argument_list|)
argument_list|,
name|readArray
argument_list|(
name|values
argument_list|)
argument_list|)
decl_stmt|;
name|page
operator|=
name|leaf
expr_stmt|;
block|}
block|}
name|cache
operator|.
name|put
argument_list|(
name|cacheId
argument_list|,
name|page
argument_list|)
expr_stmt|;
return|return
name|page
return|;
block|}
specifier|private
specifier|static
name|String
index|[]
name|readArray
parameter_list|(
name|String
name|json
parameter_list|)
block|{
if|if
condition|(
name|json
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|dataList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|json
argument_list|)
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|matches
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
do|do
block|{
name|dataList
operator|.
name|add
argument_list|(
name|t
operator|.
name|readString
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|','
argument_list|)
condition|)
do|;
name|t
operator|.
name|read
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|data
init|=
operator|new
name|String
index|[
name|dataList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|dataList
operator|.
name|toArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
name|void
name|buffer
parameter_list|(
name|String
name|diff
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|==
literal|null
condition|)
block|{
name|buffer
operator|=
operator|new
name|StringBuilder
argument_list|(
name|diff
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|.
name|append
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
name|void
name|commit
parameter_list|()
block|{
comment|// TODO remove this method once MicroKernelImpl supports
comment|// move + add node
if|if
condition|(
name|mk
operator|instanceof
name|MicroKernelImpl
condition|)
block|{
name|commitChanges
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|modified
parameter_list|(
name|BTree
name|tree
parameter_list|,
name|BTreePage
name|page
parameter_list|,
name|boolean
name|deleted
parameter_list|)
block|{
name|String
name|indexRoot
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRootNode
argument_list|,
name|tree
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|p
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRoot
argument_list|,
name|page
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|deleted
condition|)
block|{
name|modified
operator|.
name|remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|modified
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|moveCache
parameter_list|(
name|BTree
name|tree
parameter_list|,
name|String
name|oldPath
parameter_list|)
block|{
name|String
name|indexRoot
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRootNode
argument_list|,
name|tree
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|o
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRoot
argument_list|,
name|oldPath
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|BTreePage
argument_list|>
name|moved
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BTreePage
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|BTreePage
argument_list|>
name|e
range|:
name|modified
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|startsWith
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|moved
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|s
range|:
name|moved
operator|.
name|keySet
argument_list|()
control|)
block|{
name|modified
operator|.
name|remove
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BTreePage
name|p
range|:
name|moved
operator|.
name|values
argument_list|()
control|)
block|{
name|String
name|n
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRoot
argument_list|,
name|p
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|modified
operator|.
name|put
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|commitChanges
parameter_list|()
block|{
if|if
condition|(
name|buffer
operator|!=
literal|null
condition|)
block|{
name|String
name|jsop
init|=
name|buffer
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// System.out.println(jsop);
name|revision
operator|=
name|mk
operator|.
name|commit
argument_list|(
name|indexRootNode
argument_list|,
name|jsop
argument_list|,
name|revision
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|buffer
operator|=
literal|null
expr_stmt|;
name|modified
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|synchronized
name|void
name|updateUntil
parameter_list|(
name|String
name|toRevision
parameter_list|)
block|{
if|if
condition|(
name|DISABLED
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|toRevision
operator|.
name|equals
argument_list|(
name|readRevision
argument_list|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|toRevision
operator|=
name|mk
operator|.
name|getHeadRevision
argument_list|()
expr_stmt|;
block|}
name|String
name|journal
init|=
name|mk
operator|.
name|getJournal
argument_list|(
name|readRevision
argument_list|,
name|toRevision
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|journal
argument_list|)
decl_stmt|;
name|String
name|lastRevision
init|=
name|readRevision
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
name|readRevision
operator|=
name|toRevision
expr_stmt|;
comment|// nothing to update
return|return;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
do|do
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
do|do
block|{
name|String
name|key
init|=
name|t
operator|.
name|readString
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|t
operator|.
name|read
argument_list|()
expr_stmt|;
name|String
name|value
init|=
name|t
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|','
argument_list|)
condition|)
do|;
name|String
name|rev
init|=
name|map
operator|.
name|get
argument_list|(
literal|"id"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rev
operator|.
name|equals
argument_list|(
name|readRevision
argument_list|)
condition|)
block|{
name|String
name|jsop
init|=
name|map
operator|.
name|get
argument_list|(
literal|"changes"
argument_list|)
decl_stmt|;
name|JsopTokenizer
name|tokenizer
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|jsop
argument_list|)
decl_stmt|;
name|updateIndex
argument_list|(
literal|""
argument_list|,
name|tokenizer
argument_list|,
name|lastRevision
argument_list|)
expr_stmt|;
block|}
name|lastRevision
operator|=
name|rev
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|','
argument_list|)
condition|)
do|;
name|updateEnd
argument_list|(
name|toRevision
argument_list|)
expr_stmt|;
block|}
comment|/**      * Finish updating the index.      *      * @param toRevision the new index revision      * @return the new head revision      */
specifier|public
name|String
name|updateEnd
parameter_list|(
name|String
name|toRevision
parameter_list|)
block|{
name|readRevision
operator|=
name|toRevision
expr_stmt|;
name|JsopBuilder
name|jsop
init|=
operator|new
name|JsopBuilder
argument_list|()
decl_stmt|;
name|jsop
operator|.
name|tag
argument_list|(
literal|'^'
argument_list|)
operator|.
name|key
argument_list|(
literal|"rev"
argument_list|)
operator|.
name|value
argument_list|(
name|readRevision
argument_list|)
expr_stmt|;
name|buffer
argument_list|(
name|jsop
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|commitChanges
argument_list|()
expr_stmt|;
return|return
name|revision
return|;
block|}
comment|/**      * Update the index with the given changes.      *      * @param rootPath the root path      * @param t the changes      * @param lastRevision      */
specifier|public
name|void
name|updateIndex
parameter_list|(
name|String
name|rootPath
parameter_list|,
name|JsopReader
name|t
parameter_list|,
name|String
name|lastRevision
parameter_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|r
init|=
name|t
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|JsopReader
operator|.
name|END
condition|)
block|{
break|break;
block|}
name|String
name|path
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|rootPath
argument_list|,
name|t
operator|.
name|readString
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|target
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|'+'
case|:
block|{
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|NodeMap
name|map
init|=
operator|new
name|NodeMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
name|NodeImpl
name|n
init|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|map
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|addOrRemoveRecursive
argument_list|(
name|n
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|value
init|=
name|t
operator|.
name|readRawValue
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|nodePath
init|=
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|NodeImpl
name|node
init|=
operator|new
name|NodeImpl
argument_list|(
name|map
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|node
operator|.
name|setPath
argument_list|(
name|nodePath
argument_list|)
expr_stmt|;
name|String
name|propertyName
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|node
operator|.
name|cloneAndSetProperty
argument_list|(
name|propertyName
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addOrRemoveRecursive
argument_list|(
name|node
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'*'
case|:
comment|// TODO support and test copy operation ("*"),
comment|// specially in combination with other operations
comment|// possibly split up the commit in this case
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|target
operator|=
name|t
operator|.
name|readString
argument_list|()
expr_stmt|;
name|moveOrCopyNode
argument_list|(
name|path
argument_list|,
literal|false
argument_list|,
name|target
argument_list|,
name|lastRevision
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|moveOrCopyNode
argument_list|(
name|path
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|lastRevision
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
block|{
name|removeProperty
argument_list|(
name|path
argument_list|,
name|lastRevision
argument_list|)
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|matches
argument_list|(
name|JsopReader
operator|.
name|NULL
argument_list|)
condition|)
block|{
comment|// ignore
block|}
else|else
block|{
name|String
name|value
init|=
name|t
operator|.
name|readRawValue
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|addProperty
argument_list|(
name|path
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'>'
case|:
comment|// TODO does move work correctly
comment|// in combination with other operations?
comment|// possibly split up the commit in this case
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|String
name|position
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
name|position
operator|=
name|t
operator|.
name|readString
argument_list|()
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|target
operator|=
name|t
operator|.
name|readString
argument_list|()
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|position
operator|=
literal|null
expr_stmt|;
name|target
operator|=
name|t
operator|.
name|readString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
literal|"last"
operator|.
name|equals
argument_list|(
name|position
argument_list|)
operator|||
literal|"first"
operator|.
name|equals
argument_list|(
name|position
argument_list|)
condition|)
block|{
name|target
operator|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|target
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"before"
operator|.
name|equals
argument_list|(
name|position
argument_list|)
operator|||
literal|"after"
operator|.
name|equals
argument_list|(
name|position
argument_list|)
condition|)
block|{
name|target
operator|=
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|target
operator|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|target
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|position
operator|==
literal|null
condition|)
block|{
comment|// move
block|}
else|else
block|{
throw|throw
name|ExceptionFactory
operator|.
name|get
argument_list|(
literal|"position: "
operator|+
name|position
argument_list|)
throw|;
block|}
name|moveOrCopyNode
argument_list|(
name|path
argument_list|,
literal|true
argument_list|,
name|target
argument_list|,
name|lastRevision
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"token: "
operator|+
operator|(
name|char
operator|)
name|t
operator|.
name|getTokenType
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|addOrRemoveRecursive
parameter_list|(
name|NodeImpl
name|n
parameter_list|,
name|boolean
name|remove
parameter_list|,
name|boolean
name|add
parameter_list|)
block|{
if|if
condition|(
name|isInIndex
argument_list|(
name|n
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
comment|// don't index the index
return|return;
block|}
for|for
control|(
name|Index
name|index
range|:
name|indexes
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|remove
condition|)
block|{
name|index
operator|.
name|addOrRemoveNode
argument_list|(
name|n
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|add
condition|)
block|{
name|index
operator|.
name|addOrRemoveNode
argument_list|(
name|n
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|n
operator|.
name|getChildNodeNames
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|addOrRemoveRecursive
argument_list|(
name|n
operator|.
name|getNode
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
argument_list|,
name|remove
argument_list|,
name|add
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|isInIndex
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
name|PathUtils
operator|.
name|isAncestor
argument_list|(
name|indexRootNode
argument_list|,
name|path
argument_list|)
operator|||
name|indexRootNode
operator|.
name|equals
argument_list|(
name|path
argument_list|)
return|;
block|}
specifier|private
name|void
name|removeProperty
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|lastRevision
parameter_list|)
block|{
if|if
condition|(
name|isInIndex
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|// don't index the index
return|return;
block|}
name|String
name|nodePath
init|=
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|String
name|property
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mk
operator|.
name|nodeExists
argument_list|(
name|nodePath
argument_list|,
name|lastRevision
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// TODO remove: support large trees
name|String
name|node
init|=
name|mk
operator|.
name|getNodes
argument_list|(
name|nodePath
argument_list|,
name|lastRevision
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeMap
name|map
init|=
operator|new
name|NodeMap
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|NodeImpl
name|n
init|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|map
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|.
name|hasProperty
argument_list|(
name|property
argument_list|)
condition|)
block|{
name|n
operator|.
name|setPath
argument_list|(
name|nodePath
argument_list|)
expr_stmt|;
for|for
control|(
name|Index
name|index
range|:
name|indexes
operator|.
name|values
argument_list|()
control|)
block|{
name|index
operator|.
name|addOrRemoveProperty
argument_list|(
name|nodePath
argument_list|,
name|property
argument_list|,
name|n
operator|.
name|getProperty
argument_list|(
name|property
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|addProperty
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|isInIndex
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|// don't index the index
return|return;
block|}
name|String
name|nodePath
init|=
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|String
name|property
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
for|for
control|(
name|Index
name|index
range|:
name|indexes
operator|.
name|values
argument_list|()
control|)
block|{
name|index
operator|.
name|addOrRemoveProperty
argument_list|(
name|nodePath
argument_list|,
name|property
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|moveOrCopyNode
parameter_list|(
name|String
name|sourcePath
parameter_list|,
name|boolean
name|remove
parameter_list|,
name|String
name|targetPath
parameter_list|,
name|String
name|lastRevision
parameter_list|)
block|{
if|if
condition|(
name|isInIndex
argument_list|(
name|sourcePath
argument_list|)
condition|)
block|{
comment|// don't index the index
return|return;
block|}
if|if
condition|(
operator|!
name|mk
operator|.
name|nodeExists
argument_list|(
name|sourcePath
argument_list|,
name|lastRevision
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// TODO move: support large trees
name|String
name|node
init|=
name|mk
operator|.
name|getNodes
argument_list|(
name|sourcePath
argument_list|,
name|lastRevision
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeMap
name|map
init|=
operator|new
name|NodeMap
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|NodeImpl
name|n
init|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|map
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|sourcePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|remove
condition|)
block|{
name|addOrRemoveRecursive
argument_list|(
name|n
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetPath
operator|!=
literal|null
condition|)
block|{
name|t
operator|=
operator|new
name|JsopTokenizer
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|map
operator|=
operator|new
name|NodeMap
argument_list|()
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|n
operator|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|map
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|targetPath
argument_list|)
expr_stmt|;
name|addOrRemoveRecursive
argument_list|(
name|n
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|buildAndAddIndex
parameter_list|(
name|Index
name|index
parameter_list|)
block|{
name|addRecursive
argument_list|(
name|index
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|indexes
operator|.
name|put
argument_list|(
name|index
operator|.
name|getName
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addRecursive
parameter_list|(
name|Index
name|index
parameter_list|,
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|isInIndex
argument_list|(
name|path
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// TODO add: support large child node lists
name|String
name|node
init|=
name|mk
operator|.
name|getNodes
argument_list|(
name|path
argument_list|,
name|readRevision
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeMap
name|map
init|=
operator|new
name|NodeMap
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|NodeImpl
name|n
init|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|map
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|index
operator|.
name|addOrRemoveNode
argument_list|(
name|n
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|n
operator|.
name|getChildNodeNames
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|addRecursive
argument_list|(
name|index
argument_list|,
name|PathUtils
operator|.
name|concat
argument_list|(
name|path
argument_list|,
name|it
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|QueryIndex
argument_list|>
name|getQueryIndexes
parameter_list|(
name|MicroKernel
name|mk
parameter_list|)
block|{
if|if
condition|(
name|mk
operator|!=
name|this
operator|.
name|mk
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|ArrayList
argument_list|<
name|QueryIndex
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|QueryIndex
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Index
name|index
range|:
name|indexes
operator|.
name|values
argument_list|()
control|)
block|{
name|QueryIndex
name|qi
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|index
operator|instanceof
name|PropertyIndex
condition|)
block|{
name|qi
operator|=
operator|new
name|PropertyContentIndex
argument_list|(
name|mk
argument_list|,
operator|(
name|PropertyIndex
operator|)
name|index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|PrefixIndex
condition|)
block|{
comment|// TODO support prefix indexes?
block|}
name|list
operator|.
name|add
argument_list|(
name|qi
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
block|}
end_class

end_unit

