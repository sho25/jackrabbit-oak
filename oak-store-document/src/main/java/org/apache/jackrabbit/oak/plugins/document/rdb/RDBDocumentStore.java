begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|rdb
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
operator|.
name|newArrayList
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
operator|.
name|partition
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateUtils
operator|.
name|checkConditions
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|rdb
operator|.
name|RDBJDBCTools
operator|.
name|asDocumentStoreException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|rdb
operator|.
name|RDBJDBCTools
operator|.
name|closeResultSet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|rdb
operator|.
name|RDBJDBCTools
operator|.
name|closeStatement
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|rdb
operator|.
name|RDBJDBCTools
operator|.
name|createTableName
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|Utils
operator|.
name|getModuleVersion
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DatabaseMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSetMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Deflater
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPOutputStream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|sql
operator|.
name|DataSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|cache
operator|.
name|CacheStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|cache
operator|.
name|CacheValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentNodeStoreBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentStoreException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentStoreStatsCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Key
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Operation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|cache
operator|.
name|CacheChangesTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|cache
operator|.
name|CacheInvalidationStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|cache
operator|.
name|ModificationStamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|cache
operator|.
name|NodeDocumentCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|locks
operator|.
name|NodeDocumentLocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|locks
operator|.
name|StripedNodeDocumentLocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|mongo
operator|.
name|MongoDocumentStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|CloseableIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|NotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Stopwatch
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterators
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_comment
comment|/**  * Implementation of {@link DocumentStore} for relational databases.  *   *<h2 id="apidocs.supported-databases">Supported Databases</h2>  *<p>  * The code is supposed to be sufficiently generic to run with a variety of  * database implementations. However, the tables are created when required to  * simplify testing, and<em>that</em> code specifically supports these  * databases:  *<ul>  *<li>H2DB</li>  *<li>Apache Derby</li>  *<li>IBM DB2</li>  *<li>PostgreSQL</li>  *<li>MariaDB (MySQL)</li>  *<li>Microsoft SQL Server</li>  *<li>Oracle</li>  *</ul>  *   *<h2 id="apidocs.table-layout">Table Layout</h2>  *<p>  * Data for each of the DocumentStore's {@link Collection}s is stored in its own  * database table (with a name matching the collection).  *<p>  * The tables essentially implement key/value storage, where the key usually is  * derived from an Oak path, and the value is a serialization of a  * {@link Document} (or a part of one). Additional fields are used for queries,  * debugging, and concurrency control:  *<table style="text-align: left;">  *<caption>RDBDocumentStore Column Layout</caption>  *<thead>  *<tr>  *<th>Column</th>  *<th>Type</th>  *<th>Description</th>  *</tr>  *</thead><tbody>  *<tr>  *<th>ID</th>  *<td>varchar(512) not null primary key</td>  *<td>The document's key (for databases that can not handle 512 character  * primary keys, such as MySQL, varbinary is possible as well).</td>  *</tr>  *<tr>  *<th>MODIFIED</th>  *<td>bigint</td>  *<td>Low-resolution timestamp.  *</tr>  *<tr>  *<th>HASBINARY</th>  *<td>smallint</td>  *<td>Flag indicating whether the document has binary properties.  *</tr>  *<tr>  *<th>DELETEDONCE</th>  *<td>smallint</td>  *<td>Flag indicating whether the document has been deleted once.  *</tr>  *<tr>  *<th>MODCOUNT</th>  *<td>bigint</td>  *<td>Modification counter, used for avoiding overlapping updates.</td>  *</tr>  *<tr>  *<th>DSIZE</th>  *<td>bigint</td>  *<td>The approximate size of the document's JSON serialization (for debugging  * purposes).</td>  *</tr>  *<tr>  *<th>VERSION</th>  *<td>smallint</td>  *<td>The schema version the code writing to a row (or inserting it) was aware  * of (introduced with schema version 1). Not set for rows written by version 0  * client code.</td>  *</tr>  *<tr>  *<th>SDTYPE</th>  *<td>smallint</td>  *<td>Split Document type.</td>  *</tr>  *<tr>  *<th>SDMAXREVTIME</th>  *<td>bigint</td>  *<td>Split document max revision time..</td>  *</tr>  *<tr>  *<th>DATA</th>  *<td>varchar(16384)</td>  *<td>The document's JSON serialization (only used for small document sizes, in  * which case BDATA (below) is not set), or a sequence of JSON serialized update  * operations to be applied against the last full serialization.</td>  *</tr>  *<tr>  *<th>BDATA</th>  *<td>blob</td>  *<td>The document's JSON serialization (usually GZIPped, only used for "large"  * documents).</td>  *</tr>  *</tbody>  *</table>  *<p>  * The names of database tables can be prefixed; the purpose is mainly for  * testing, as tables can also be dropped automatically when the store is  * disposed (this only happens for those tables that have been created on  * demand).  *<h3 id="apidocs.versioning">Versioning</h3>  *<p>  * The initial database layout used in OAK 1.0 through 1.6 is version 0.  *<p>  * Version 1 introduces an additional "version" column, which records the schema  * version of the code writing to the database (upon insert and update). This is  * in preparation of future layout changes which might introduce new columns.  *<p>  * Version 2 introduces an additional "sdtype" and "sdmaxrevtime".  *<p>  * The code deals with both version 0, version 1 and version 2 table layouts. By  * default, it tries to create version 2 tables, and also tries to upgrade  * existing version 0 and 1 tables to version 2.  *<h3>DB-specific information</h3>  *<p>  * Databases need to be configured so that:  *<ul>  *<li>Text fields support all Unicode code points,</li>  *<li>Collation of text fields happens by Unicode code point,</li>  *<li>and BLOBs need to support at least 16 MB.</li>  *</ul>  *<p>  * See the  *<a href="https://jackrabbit.apache.org/oak/docs/nodestore/document/rdb-document-store.html#database-creation">RDBDocumentStore documentation</a>  * for more information.  *<h3 id="apidocs.table-creation">Table Creation</h3>  *<p>  * The code tries to create the tables when they are not present. Likewise, it  * tries to upgrade to a newer schema when needed.  *<p>  * Users/Administrators who prefer to stay in control over table generation can  * create them "manually". The oak-run "<a href="https://jackrabbit.apache.org/oak/docs/nodestore/document/rdb-document-store.html#rdbddldump"><code>rdbddldump</code></a>"  * command can be used to print out the DDL statements that would have been used for auto-creation  * and/or automatic schema updates.  *   *<h2>Caching</h2>  *<p>  * The cache borrows heavily from the {@link MongoDocumentStore} implementation.  *   *<h2>Queries</h2>  *<p>  * The implementation currently supports only three indexed properties: "_bin",  * "deletedOnce", and "_modified". Attempts to use a different indexed property  * will cause a {@link DocumentStoreException}.  */
end_comment

begin_class
specifier|public
class|class
name|RDBDocumentStore
implements|implements
name|DocumentStore
block|{
comment|/**      * Creates a {@linkplain RDBDocumentStore} instance using the provided      * {@link DataSource}, {@link DocumentNodeStoreBuilder}, and {@link RDBOptions}.      */
specifier|public
name|RDBDocumentStore
parameter_list|(
name|DataSource
name|ds
parameter_list|,
name|DocumentNodeStoreBuilder
argument_list|<
name|?
argument_list|>
name|builder
parameter_list|,
name|RDBOptions
name|options
parameter_list|)
block|{
try|try
block|{
name|initialize
argument_list|(
name|ds
argument_list|,
name|builder
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
name|asDocumentStoreException
argument_list|(
name|ex
argument_list|,
literal|"initializing RDB document store"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates a {@linkplain RDBDocumentStore} instance using the provided      * {@link DataSource}, {@link DocumentNodeStoreBuilder}, and default      * {@link RDBOptions}.      */
specifier|public
name|RDBDocumentStore
parameter_list|(
name|DataSource
name|ds
parameter_list|,
name|DocumentNodeStoreBuilder
argument_list|<
name|?
argument_list|>
name|builder
parameter_list|)
block|{
name|this
argument_list|(
name|ds
argument_list|,
name|builder
argument_list|,
operator|new
name|RDBOptions
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|find
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
return|return
name|find
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|find
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
specifier|final
name|String
name|id
parameter_list|,
name|int
name|maxCacheAge
parameter_list|)
block|{
return|return
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|maxCacheAge
argument_list|)
return|;
block|}
annotation|@
name|NotNull
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|query
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|query
argument_list|(
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|NotNull
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|query
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|String
name|indexedProperty
parameter_list|,
name|long
name|startValue
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|List
argument_list|<
name|QueryCondition
argument_list|>
name|conditions
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexedProperty
operator|!=
literal|null
condition|)
block|{
name|conditions
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
operator|new
name|QueryCondition
argument_list|(
name|indexedProperty
argument_list|,
literal|">="
argument_list|,
name|startValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|internalQuery
argument_list|(
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
name|EMPTY_KEY_PATTERN
argument_list|,
name|conditions
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|NotNull
specifier|protected
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|query
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|excludeKeyPatterns
parameter_list|,
name|List
argument_list|<
name|QueryCondition
argument_list|>
name|conditions
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|internalQuery
argument_list|(
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
name|excludeKeyPatterns
argument_list|,
name|conditions
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|remove
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
try|try
block|{
name|delete
argument_list|(
name|collection
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|remove
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
block|{
try|try
block|{
name|delete
argument_list|(
name|collection
argument_list|,
name|ids
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|int
name|remove
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|toRemove
parameter_list|)
block|{
try|try
block|{
return|return
name|delete
argument_list|(
name|collection
argument_list|,
name|toRemove
argument_list|)
return|;
block|}
finally|finally
block|{
for|for
control|(
name|String
name|id
range|:
name|toRemove
operator|.
name|keySet
argument_list|()
control|)
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|int
name|remove
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|indexedProperty
parameter_list|,
name|long
name|startValue
parameter_list|,
name|long
name|endValue
parameter_list|)
throws|throws
name|DocumentStoreException
block|{
try|try
block|{
name|List
argument_list|<
name|QueryCondition
argument_list|>
name|conditions
init|=
operator|new
name|ArrayList
argument_list|<
name|QueryCondition
argument_list|>
argument_list|()
decl_stmt|;
name|conditions
operator|.
name|add
argument_list|(
operator|new
name|QueryCondition
argument_list|(
name|indexedProperty
argument_list|,
literal|">"
argument_list|,
name|startValue
argument_list|)
argument_list|)
expr_stmt|;
name|conditions
operator|.
name|add
argument_list|(
operator|new
name|QueryCondition
argument_list|(
name|indexedProperty
argument_list|,
literal|"<"
argument_list|,
name|endValue
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|deleteWithCondition
argument_list|(
name|collection
argument_list|,
name|conditions
argument_list|)
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
comment|// this method is currently being used only for Journal
comment|// collection while GC. But, to keep sanctity of the API, we
comment|// need to acknowledge that Nodes collection could've been used.
comment|// But, in this signature, there's no useful way to invalidate
comment|// cache.
comment|// So, we use the hammer for this task
name|invalidateCache
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|create
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updateOps
parameter_list|)
block|{
return|return
name|internalCreate
argument_list|(
name|collection
argument_list|,
name|updateOps
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|createOrUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
name|UpdateUtils
operator|.
name|assertUnconditional
argument_list|(
name|update
argument_list|)
expr_stmt|;
return|return
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
name|update
operator|.
name|isNew
argument_list|()
argument_list|,
literal|false
argument_list|,
name|RETRIES
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|createOrUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updateOps
parameter_list|)
block|{
comment|// fall back to sequential mode if batches are turned off using system
comment|// property, or the number of update operations is small
if|if
condition|(
operator|!
name|BATCHUPDATES
operator|||
name|updateOps
operator|.
name|size
argument_list|()
operator|<
name|MINIMALBULKUPDATESIZE
condition|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|(
name|updateOps
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|UpdateOp
name|update
range|:
name|updateOps
control|)
block|{
name|results
operator|.
name|add
argument_list|(
name|createOrUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
else|else
block|{
return|return
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|updateOps
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|int
name|MINIMALBULKUPDATESIZE
init|=
literal|3
decl_stmt|;
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|internalCreateOrUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updateOps
parameter_list|)
block|{
specifier|final
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|UpdateOp
argument_list|,
name|T
argument_list|>
name|results
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|UpdateOp
argument_list|,
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
name|operationsToCover
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|UpdateOp
argument_list|>
name|duplicates
init|=
operator|new
name|HashSet
argument_list|<
name|UpdateOp
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateOp
name|updateOp
range|:
name|updateOps
control|)
block|{
name|UpdateUtils
operator|.
name|assertUnconditional
argument_list|(
name|updateOp
argument_list|)
expr_stmt|;
if|if
condition|(
name|operationsToCover
operator|.
name|containsKey
argument_list|(
name|updateOp
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|duplicates
operator|.
name|add
argument_list|(
name|updateOp
argument_list|)
expr_stmt|;
name|results
operator|.
name|put
argument_list|(
name|updateOp
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UpdateOp
name|clone
init|=
name|updateOp
operator|.
name|copy
argument_list|()
decl_stmt|;
name|addUpdateCounters
argument_list|(
name|clone
argument_list|)
expr_stmt|;
name|operationsToCover
operator|.
name|put
argument_list|(
name|clone
operator|.
name|getId
argument_list|()
argument_list|,
name|clone
argument_list|)
expr_stmt|;
name|results
operator|.
name|put
argument_list|(
name|clone
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|oldDocs
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|oldDocs
operator|.
name|putAll
argument_list|(
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|operationsToCover
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// iteration count
while|while
condition|(
name|operationsToCover
operator|.
name|size
argument_list|()
operator|>=
name|MINIMALBULKUPDATESIZE
condition|)
block|{
comment|// We should try to insert documents only during the first
comment|// iteration. In the 2nd and 3rd iterations we only deal with
comment|// conflicting documents, so they already exist in the database
comment|// and there's no point in inserting them.
name|boolean
name|upsert
init|=
name|i
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|++
operator|==
literal|3
condition|)
block|{
comment|// operations that conflicted in 3 consecutive bulk
comment|// updates should be applied sequentially
break|break;
block|}
for|for
control|(
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|partition
range|:
name|partition
argument_list|(
name|newArrayList
argument_list|(
name|operationsToCover
operator|.
name|values
argument_list|()
argument_list|)
argument_list|,
name|CHUNKSIZE
argument_list|)
control|)
block|{
name|Map
argument_list|<
name|UpdateOp
argument_list|,
name|T
argument_list|>
name|successfulUpdates
init|=
name|bulkUpdate
argument_list|(
name|collection
argument_list|,
name|partition
argument_list|,
name|oldDocs
argument_list|,
name|upsert
argument_list|)
decl_stmt|;
name|results
operator|.
name|putAll
argument_list|(
name|successfulUpdates
argument_list|)
expr_stmt|;
name|operationsToCover
operator|.
name|values
argument_list|()
operator|.
name|removeAll
argument_list|(
name|successfulUpdates
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if there are some changes left, we'll apply them one after another
for|for
control|(
name|UpdateOp
name|updateOp
range|:
name|updateOps
control|)
block|{
name|UpdateOp
name|conflictedOp
init|=
name|operationsToCover
operator|.
name|remove
argument_list|(
name|updateOp
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|conflictedOp
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"createOrUpdate: update conflict on {}, invalidating cache and retrying..."
argument_list|,
name|updateOp
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|nodesCache
operator|.
name|invalidate
argument_list|(
name|updateOp
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"createOrUpdate: update conflict on {}, retrying..."
argument_list|,
name|updateOp
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|results
operator|.
name|put
argument_list|(
name|conflictedOp
argument_list|,
name|createOrUpdate
argument_list|(
name|collection
argument_list|,
name|updateOp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|duplicates
operator|.
name|contains
argument_list|(
name|updateOp
argument_list|)
condition|)
block|{
name|results
operator|.
name|put
argument_list|(
name|updateOp
argument_list|,
name|createOrUpdate
argument_list|(
name|collection
argument_list|,
name|updateOp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|stats
operator|.
name|doneCreateOrUpdate
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|Lists
operator|.
name|transform
argument_list|(
name|updateOps
argument_list|,
operator|new
name|Function
argument_list|<
name|UpdateOp
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|UpdateOp
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getId
argument_list|()
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|(
name|results
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|readDocumentCached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|documents
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|NodeDocument
name|cached
init|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
operator|&&
name|cached
operator|!=
name|NodeDocument
operator|.
name|NULL
condition|)
block|{
name|T
name|doc
init|=
name|castAsT
argument_list|(
name|unwrap
argument_list|(
name|cached
argument_list|)
argument_list|)
decl_stmt|;
name|documents
operator|.
name|put
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|documentsToRead
init|=
name|Sets
operator|.
name|difference
argument_list|(
name|keys
argument_list|,
name|documents
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|readDocuments
init|=
name|readDocumentsUncached
argument_list|(
name|collection
argument_list|,
name|documentsToRead
argument_list|)
decl_stmt|;
name|documents
operator|.
name|putAll
argument_list|(
name|readDocuments
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
for|for
control|(
name|T
name|doc
range|:
name|readDocuments
operator|.
name|values
argument_list|()
control|)
block|{
name|nodesCache
operator|.
name|putIfAbsent
argument_list|(
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|documents
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|readDocumentsUncached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getROConnection
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|RDBRow
argument_list|>
name|rows
init|=
name|db
operator|.
name|read
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|keys
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|rows
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|RDBRow
name|row
init|=
name|rows
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|T
name|document
init|=
name|convertFromDBObject
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
decl_stmt|;
name|result
operator|.
name|put
argument_list|(
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|document
argument_list|)
expr_stmt|;
block|}
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
name|asDocumentStoreException
argument_list|(
name|ex
argument_list|,
literal|"trying to read: "
operator|+
name|keys
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Nullable
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|CacheChangesTracker
name|obtainTracker
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
return|return
name|this
operator|.
name|nodesCache
operator|.
name|registerTracker
argument_list|(
name|keys
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Nullable
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|CacheChangesTracker
name|obtainTracker
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
return|return
name|this
operator|.
name|nodesCache
operator|.
name|registerTracker
argument_list|(
name|fromKey
argument_list|,
name|toKey
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|Map
argument_list|<
name|UpdateOp
argument_list|,
name|T
argument_list|>
name|bulkUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updates
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|oldDocs
parameter_list|,
name|boolean
name|upsert
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|missingDocs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateOp
name|op
range|:
name|updates
control|)
block|{
if|if
condition|(
operator|!
name|oldDocs
operator|.
name|containsKey
argument_list|(
name|op
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|missingDocs
operator|.
name|add
argument_list|(
name|op
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"bulkUpdate: cached docs to be updated: {}"
argument_list|,
name|dumpKeysAndModcounts
argument_list|(
name|oldDocs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|freshDocs
init|=
name|readDocumentsUncached
argument_list|(
name|collection
argument_list|,
name|missingDocs
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"bulkUpdate: fresh docs to be updated: {}"
argument_list|,
name|dumpKeysAndModcounts
argument_list|(
name|freshDocs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oldDocs
operator|.
name|putAll
argument_list|(
name|freshDocs
argument_list|)
expr_stmt|;
try|try
init|(
name|CacheChangesTracker
name|tracker
init|=
name|obtainTracker
argument_list|(
name|collection
argument_list|,
name|Sets
operator|.
name|union
argument_list|(
name|oldDocs
operator|.
name|keySet
argument_list|()
argument_list|,
name|missingDocs
argument_list|)
argument_list|)
init|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|docsToUpdate
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|(
name|updates
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|keysToUpdate
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateOp
name|update
range|:
name|updates
control|)
block|{
name|String
name|id
init|=
name|update
operator|.
name|getId
argument_list|()
decl_stmt|;
name|T
name|modifiedDoc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|T
name|oldDoc
init|=
name|oldDocs
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|oldDoc
operator|.
name|deepCopy
argument_list|(
name|modifiedDoc
argument_list|)
expr_stmt|;
block|}
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|modifiedDoc
argument_list|,
name|update
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
operator|||
name|update
operator|.
name|isNew
argument_list|()
condition|)
block|{
comment|// only create if updateOp allows it
name|docsToUpdate
operator|.
name|add
argument_list|(
name|modifiedDoc
argument_list|)
expr_stmt|;
block|}
name|keysToUpdate
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|successfulUpdates
init|=
name|db
operator|.
name|update
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|docsToUpdate
argument_list|,
name|upsert
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|failedUpdates
init|=
name|Sets
operator|.
name|difference
argument_list|(
name|keysToUpdate
argument_list|,
name|successfulUpdates
argument_list|)
decl_stmt|;
name|oldDocs
operator|.
name|keySet
argument_list|()
operator|.
name|removeAll
argument_list|(
name|failedUpdates
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"bulkUpdate: success for {}, failure for {}"
argument_list|,
name|successfulUpdates
argument_list|,
name|failedUpdates
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|List
argument_list|<
name|NodeDocument
argument_list|>
name|docsToCache
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|doc
range|:
name|docsToUpdate
control|)
block|{
if|if
condition|(
name|successfulUpdates
operator|.
name|contains
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|docsToCache
operator|.
name|add
argument_list|(
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
name|nodesCache
operator|.
name|putNonConflictingDocs
argument_list|(
name|tracker
argument_list|,
name|docsToCache
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|UpdateOp
argument_list|,
name|T
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|UpdateOp
argument_list|,
name|T
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateOp
name|op
range|:
name|updates
control|)
block|{
if|if
condition|(
name|successfulUpdates
operator|.
name|contains
argument_list|(
name|op
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|oldDocs
operator|.
name|get
argument_list|(
name|op
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
throw|throw
name|handleException
argument_list|(
literal|"update failed for: "
operator|+
name|keysToUpdate
argument_list|,
name|ex
argument_list|,
name|collection
argument_list|,
name|keysToUpdate
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|findAndUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
return|return
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|RETRIES
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CacheInvalidationStats
name|invalidateCache
parameter_list|()
block|{
for|for
control|(
name|CacheValue
name|key
range|:
name|nodesCache
operator|.
name|keys
argument_list|()
control|)
block|{
name|invalidateCache
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
name|key
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|CacheInvalidationStats
name|invalidateCache
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|)
block|{
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|invalidateCache
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|invalidateCache
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|invalidateCache
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|,
name|boolean
name|remove
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|invalidateNodesCache
argument_list|(
name|id
argument_list|,
name|remove
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|invalidateNodesCache
parameter_list|(
name|String
name|id
parameter_list|,
name|boolean
name|remove
parameter_list|)
block|{
try|try
init|(
name|CacheLock
name|lock
init|=
name|acquireLockFor
argument_list|(
name|id
argument_list|)
init|)
block|{
if|if
condition|(
name|remove
condition|)
block|{
name|nodesCache
operator|.
name|invalidate
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodesCache
operator|.
name|markChanged
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|NodeDocument
name|entry
init|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|markUpToDate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|determineServerTimeDifferenceMillis
parameter_list|()
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getROConnection
argument_list|()
expr_stmt|;
name|long
name|result
init|=
name|this
operator|.
name|db
operator|.
name|determineServerTimeDifferenceMillis
argument_list|(
name|connection
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Trying to determine time difference to server"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|asDocumentStoreException
argument_list|(
name|ex
argument_list|,
literal|"Trying to determine time difference to server"
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
comment|// used for diagnostics
specifier|private
name|String
name|droppedTables
init|=
literal|""
decl_stmt|;
specifier|public
name|String
name|getDroppedTables
parameter_list|()
block|{
return|return
name|this
operator|.
name|droppedTables
return|;
block|}
comment|// table names
specifier|private
specifier|static
name|Map
argument_list|<
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
argument_list|,
name|String
argument_list|>
name|TABLEMAP
decl_stmt|;
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|TABLENAMES
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
argument_list|,
name|String
argument_list|>
name|tmp
init|=
operator|new
name|HashMap
argument_list|<
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|tmp
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
literal|"CLUSTERNODES"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|JOURNAL
argument_list|,
literal|"JOURNAL"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
literal|"NODES"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|,
literal|"SETTINGS"
argument_list|)
expr_stmt|;
name|TABLEMAP
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tl
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|TABLEMAP
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|TABLENAMES
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|getTableNames
parameter_list|()
block|{
return|return
name|TABLENAMES
return|;
block|}
comment|/**      * Holds the data about a table that can vary: name, whether the primary key      * is binary, and the estimated size of the "data" column.      */
specifier|static
class|class
name|RDBTableMetaData
block|{
specifier|private
specifier|final
name|String
name|catalog
decl_stmt|;
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
name|boolean
name|idIsBinary
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|hasVersion
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|hasSplitDocs
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|dataLimitInOctets
init|=
literal|16384
decl_stmt|;
specifier|private
name|String
name|schemaInfo
init|=
literal|""
decl_stmt|;
specifier|private
name|String
name|indexInfo
init|=
literal|""
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|columnOnlyProperties
init|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|COLUMNPROPERTIES
argument_list|)
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|columnProperties
init|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|COLUMNPROPERTIES
argument_list|)
decl_stmt|;
specifier|public
name|RDBTableMetaData
parameter_list|(
annotation|@
name|Nullable
name|String
name|catalog
parameter_list|,
annotation|@
name|NotNull
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|catalog
operator|=
name|catalog
operator|==
literal|null
condition|?
literal|""
else|:
name|catalog
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
specifier|public
name|int
name|getDataLimitInOctets
parameter_list|()
block|{
return|return
name|this
operator|.
name|dataLimitInOctets
return|;
block|}
specifier|public
name|String
name|getCatalog
parameter_list|()
block|{
return|return
name|this
operator|.
name|catalog
return|;
block|}
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getColumnProperties
parameter_list|()
block|{
return|return
name|this
operator|.
name|columnProperties
return|;
block|}
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getColumnOnlyProperties
parameter_list|()
block|{
return|return
name|this
operator|.
name|columnOnlyProperties
return|;
block|}
specifier|public
name|String
name|getIndexInfo
parameter_list|()
block|{
return|return
name|this
operator|.
name|indexInfo
return|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|this
operator|.
name|name
return|;
block|}
specifier|public
name|String
name|getSchemaInfo
parameter_list|()
block|{
return|return
name|this
operator|.
name|schemaInfo
return|;
block|}
specifier|public
name|boolean
name|isIdBinary
parameter_list|()
block|{
return|return
name|this
operator|.
name|idIsBinary
return|;
block|}
specifier|public
name|boolean
name|hasSplitDocs
parameter_list|()
block|{
return|return
name|this
operator|.
name|hasSplitDocs
return|;
block|}
specifier|public
name|boolean
name|hasVersion
parameter_list|()
block|{
return|return
name|this
operator|.
name|hasVersion
return|;
block|}
specifier|public
name|void
name|setIdIsBinary
parameter_list|(
name|boolean
name|idIsBinary
parameter_list|)
block|{
name|this
operator|.
name|idIsBinary
operator|=
name|idIsBinary
expr_stmt|;
block|}
specifier|public
name|void
name|setHasSplitDocs
parameter_list|(
name|boolean
name|hasSplitDocs
parameter_list|)
block|{
name|this
operator|.
name|hasSplitDocs
operator|=
name|hasSplitDocs
expr_stmt|;
name|this
operator|.
name|columnProperties
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|hasSplitDocs
condition|?
name|COLUMNPROPERTIES2
else|:
name|COLUMNPROPERTIES
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setHasVersion
parameter_list|(
name|boolean
name|hasVersion
parameter_list|)
block|{
name|this
operator|.
name|hasVersion
operator|=
name|hasVersion
expr_stmt|;
block|}
specifier|public
name|void
name|setDataLimitInOctets
parameter_list|(
name|int
name|dataLimitInOctets
parameter_list|)
block|{
name|this
operator|.
name|dataLimitInOctets
operator|=
name|dataLimitInOctets
expr_stmt|;
block|}
specifier|public
name|void
name|setSchemaInfo
parameter_list|(
name|String
name|schemaInfo
parameter_list|)
block|{
name|this
operator|.
name|schemaInfo
operator|=
name|schemaInfo
expr_stmt|;
block|}
specifier|public
name|void
name|setIndexInfo
parameter_list|(
name|String
name|indexInfo
parameter_list|)
block|{
name|this
operator|.
name|indexInfo
operator|=
name|indexInfo
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
name|Map
argument_list|<
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
argument_list|,
name|RDBTableMetaData
argument_list|>
name|tableMeta
init|=
operator|new
name|HashMap
argument_list|<
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
argument_list|,
name|RDBTableMetaData
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|dispose
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|tablesToBeDropped
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|dropped
init|=
literal|""
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempting to drop: "
operator|+
name|this
operator|.
name|tablesToBeDropped
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|tname
range|:
name|this
operator|.
name|tablesToBeDropped
control|)
block|{
name|Connection
name|con
init|=
literal|null
decl_stmt|;
try|try
block|{
name|con
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
literal|"drop table "
operator|+
name|tname
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
name|dropped
operator|+=
name|tname
operator|+
literal|" "
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempting to drop: "
operator|+
name|tname
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|closeStatement
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempting to drop: "
operator|+
name|tname
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|con
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|droppedTables
operator|=
name|dropped
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|this
operator|.
name|ch
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"closing connection handler"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|this
operator|.
name|nodesCache
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error occurred while closing nodes cache"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"RDBDocumentStore ("
operator|+
name|getModuleVersion
argument_list|()
operator|+
literal|") disposed"
operator|+
name|getCnStats
argument_list|()
operator|+
operator|(
name|this
operator|.
name|droppedTables
operator|.
name|isEmpty
argument_list|()
condition|?
literal|""
else|:
literal|" (tables dropped: "
operator|+
name|this
operator|.
name|droppedTables
operator|+
literal|")"
operator|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|getIfCached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|!=
name|Collection
operator|.
name|NODES
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|NodeDocument
name|doc
init|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|doc
operator|=
operator|(
name|doc
operator|!=
literal|null
operator|)
condition|?
name|unwrap
argument_list|(
name|doc
argument_list|)
else|:
literal|null
expr_stmt|;
return|return
name|castAsT
argument_list|(
name|doc
argument_list|)
return|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|getIfCached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|,
name|long
name|modCount
parameter_list|)
block|{
name|T
name|doc
init|=
name|getIfCached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
operator|&&
name|doc
operator|.
name|getModCount
argument_list|()
operator|==
name|modCount
condition|)
block|{
return|return
name|doc
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Iterable
argument_list|<
name|CacheStats
argument_list|>
name|getCacheStats
parameter_list|()
block|{
return|return
name|nodesCache
operator|.
name|getCacheStats
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getMetadata
parameter_list|()
block|{
return|return
name|metadata
return|;
block|}
comment|/**      * Statistics are generated for each table. The following fields are always      * added:      *<dl>      *<dt><em>tableName</em>.ns</dt>      *<dd>fully qualified name of the database table</dd>      *<dt><em>tableName</em>.schemaInfo</dt>      *<dd>DDL information for table, as obtained during startup</dd>      *<dt><em>tableName</em>.indexInfo</dt>      *<dd>DDL information for associated indexes, as obtained during      * startup</dd>      *<dt><em>tableName</em>.count</dt>      *<dd>exact number of rows</dd>      *</dl>      * In addition, some statistics information for      * {@link Collection#CLUSTER_NODES} is added:      *<dl>      *<dt>clusterNodes.updates</dt>      *<dd>Writes to the table, counted by cluster node ID</dd>      *</dl>      * Finally, additional database-specific statistics may be added; see      * descriptions in      * {@link RDBDocumentStoreDB#getAdditionalStatistics(RDBConnectionHandler, String, String)}      * for details.      **/
annotation|@
name|NotNull
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getStats
parameter_list|()
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|tableMeta
operator|.
name|forEach
argument_list|(
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
name|toMapBuilder
argument_list|(
name|builder
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"statistics obtained: "
operator|+
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|toMapBuilder
parameter_list|(
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|builder
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|RDBTableMetaData
name|meta
parameter_list|)
block|{
name|String
name|prefix
init|=
name|collection
operator|.
name|toString
argument_list|()
decl_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|prefix
operator|+
literal|".ns"
argument_list|,
name|meta
operator|.
name|getCatalog
argument_list|()
operator|+
literal|"."
operator|+
name|meta
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|prefix
operator|+
literal|".schemaInfo"
argument_list|,
name|meta
operator|.
name|getSchemaInfo
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|prefix
operator|+
literal|".indexInfo"
argument_list|,
name|meta
operator|.
name|getIndexInfo
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Collection
operator|.
name|CLUSTER_NODES
operator|.
name|equals
argument_list|(
name|collection
argument_list|)
condition|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|prefix
operator|+
literal|".updates"
argument_list|,
name|getCnStats
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// live data
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
name|this
operator|.
name|dbInfo
operator|.
name|getAdditionalStatistics
argument_list|(
name|this
operator|.
name|ch
argument_list|,
name|meta
operator|.
name|getCatalog
argument_list|()
argument_list|,
name|meta
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|map
operator|.
name|forEach
argument_list|(
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
name|builder
operator|.
name|put
argument_list|(
name|prefix
operator|+
literal|"."
operator|+
name|k
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|long
name|c
init|=
name|queryCount
argument_list|(
name|collection
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|prefix
operator|+
literal|".count"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getting entry count for "
operator|+
name|prefix
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|// implementation
specifier|private
specifier|static
specifier|final
name|String
name|MODIFIED
init|=
literal|"_modified"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|MODCOUNT
init|=
literal|"_modCount"
decl_stmt|;
comment|/**      * Optional counter for changes to "_collisions" map ({@link NodeDocument#COLLISIONS}).      */
specifier|public
specifier|static
specifier|final
name|String
name|COLLISIONSMODCOUNT
init|=
literal|"_collisionsModCount"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ID
init|=
literal|"_id"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RDBDocumentStore
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|Exception
name|callStack
decl_stmt|;
specifier|private
name|RDBConnectionHandler
name|ch
decl_stmt|;
comment|// from options
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|tablesToBeDropped
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// ratio between Java characters and UTF-8 encoding
comment|// a) single characters will fit into 3 bytes
comment|// b) a surrogate pair (two Java characters) will fit into 4 bytes
comment|// thus...
specifier|public
specifier|static
specifier|final
name|int
name|CHAR2OCTETRATIO
init|=
literal|3
decl_stmt|;
comment|// number of retries for updates
specifier|private
specifier|static
specifier|final
name|int
name|RETRIES
init|=
literal|10
decl_stmt|;
comment|// see OAK-2044
specifier|protected
specifier|static
specifier|final
name|boolean
name|USECMODCOUNT
init|=
literal|true
decl_stmt|;
comment|// Database schema supported by this version
specifier|protected
specifier|static
specifier|final
name|int
name|SCHEMA
init|=
literal|2
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Key
name|MODIFIEDKEY
init|=
operator|new
name|Key
argument_list|(
name|MODIFIED
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// DB-specific information
specifier|private
name|RDBDocumentStoreDB
name|dbInfo
decl_stmt|;
comment|// utility class for performing low-level operations
specifier|private
name|RDBDocumentStoreJDBC
name|db
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMPTY_KEY_PATTERN
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|metadata
decl_stmt|;
specifier|private
name|DocumentStoreStatsCollector
name|stats
decl_stmt|;
specifier|private
name|boolean
name|readOnly
decl_stmt|;
comment|// VERSION column mapping in queries used by RDBVersionGCSupport
specifier|public
specifier|static
name|String
name|VERSIONPROP
init|=
literal|"__version"
decl_stmt|;
comment|// set of supported indexed properties
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|INDEXEDPROPERTIES
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|MODIFIED
block|,
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
block|,
name|NodeDocument
operator|.
name|DELETED_ONCE
block|,
name|NodeDocument
operator|.
name|SD_TYPE
block|,
name|NodeDocument
operator|.
name|SD_MAX_REV_TIME_IN_SECS
block|,
name|VERSIONPROP
block|}
argument_list|)
argument_list|)
decl_stmt|;
comment|// set of required table columns
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|REQUIREDCOLUMNS
init|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"id"
block|,
literal|"dsize"
block|,
literal|"deletedonce"
block|,
literal|"bdata"
block|,
literal|"data"
block|,
literal|"cmodcount"
block|,
literal|"modcount"
block|,
literal|"hasbinary"
block|,
literal|"modified"
block|}
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// set of optional table columns
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|OPTIONALCOLUMNS
init|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"version"
block|,
literal|"sdtype"
block|,
literal|"sdmaxrevtime"
block|}
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// set of properties not serialized to JSON
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|COLUMNPROPERTIES
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|ID
block|,
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
block|,
name|NodeDocument
operator|.
name|DELETED_ONCE
block|,
name|COLLISIONSMODCOUNT
block|,
name|MODIFIED
block|,
name|MODCOUNT
block|}
argument_list|)
argument_list|)
decl_stmt|;
comment|// set of properties not serialized to JSON, schema version 2
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|COLUMNPROPERTIES2
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|ID
block|,
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
block|,
name|NodeDocument
operator|.
name|DELETED_ONCE
block|,
name|COLLISIONSMODCOUNT
block|,
name|MODIFIED
block|,
name|MODCOUNT
block|,
name|NodeDocument
operator|.
name|SD_TYPE
block|,
name|NodeDocument
operator|.
name|SD_MAX_REV_TIME_IN_SECS
block|,
name|VERSIONPROP
block|}
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|RDBDocumentSerializer
name|ser
init|=
operator|new
name|RDBDocumentSerializer
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|private
name|void
name|initialize
parameter_list|(
name|DataSource
name|ds
parameter_list|,
name|DocumentNodeStoreBuilder
argument_list|<
name|?
argument_list|>
name|builder
parameter_list|,
name|RDBOptions
name|options
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|stats
operator|=
name|builder
operator|.
name|getDocumentStoreStatsCollector
argument_list|()
expr_stmt|;
name|this
operator|.
name|callStack
operator|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|?
operator|new
name|Exception
argument_list|(
literal|"call stack of RDBDocumentStore creation"
argument_list|)
else|:
literal|null
expr_stmt|;
name|this
operator|.
name|readOnly
operator|=
name|builder
operator|.
name|getReadOnlyMode
argument_list|()
expr_stmt|;
name|this
operator|.
name|ch
operator|=
operator|new
name|RDBConnectionHandler
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|Connection
name|con
init|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
decl_stmt|;
name|String
name|catalog
init|=
name|con
operator|.
name|getCatalog
argument_list|()
decl_stmt|;
name|DatabaseMetaData
name|md
init|=
name|con
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|catalog
condition|)
block|{
comment|// Oracle
name|catalog
operator|=
name|md
operator|.
name|getUserName
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|tableMeta
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
operator|new
name|RDBTableMetaData
argument_list|(
name|catalog
argument_list|,
name|createTableName
argument_list|(
name|options
operator|.
name|getTablePrefix
argument_list|()
argument_list|,
name|TABLEMAP
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableMeta
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
operator|new
name|RDBTableMetaData
argument_list|(
name|catalog
argument_list|,
name|createTableName
argument_list|(
name|options
operator|.
name|getTablePrefix
argument_list|()
argument_list|,
name|TABLEMAP
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableMeta
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|JOURNAL
argument_list|,
operator|new
name|RDBTableMetaData
argument_list|(
name|catalog
argument_list|,
name|createTableName
argument_list|(
name|options
operator|.
name|getTablePrefix
argument_list|()
argument_list|,
name|TABLEMAP
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|JOURNAL
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableMeta
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|,
operator|new
name|RDBTableMetaData
argument_list|(
name|catalog
argument_list|,
name|createTableName
argument_list|(
name|options
operator|.
name|getTablePrefix
argument_list|()
argument_list|,
name|TABLEMAP
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|locks
operator|=
operator|new
name|StripedNodeDocumentLocks
argument_list|()
expr_stmt|;
name|this
operator|.
name|nodesCache
operator|=
name|builder
operator|.
name|buildNodeDocumentCache
argument_list|(
name|this
argument_list|,
name|locks
argument_list|)
expr_stmt|;
name|int
name|isolation
init|=
name|con
operator|.
name|getTransactionIsolation
argument_list|()
decl_stmt|;
name|String
name|isolationDiags
init|=
name|RDBJDBCTools
operator|.
name|isolationLevelToString
argument_list|(
name|isolation
argument_list|)
decl_stmt|;
if|if
condition|(
name|isolation
operator|!=
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Detected transaction isolation level "
operator|+
name|isolationDiags
operator|+
literal|" is "
operator|+
operator|(
name|isolation
operator|<
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
condition|?
literal|"lower"
else|:
literal|"higher"
operator|)
operator|+
literal|" than expected "
operator|+
name|RDBJDBCTools
operator|.
name|isolationLevelToString
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
operator|+
literal|" - check datasource configuration"
argument_list|)
expr_stmt|;
block|}
name|String
name|dbDesc
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s %s (%d.%d)"
argument_list|,
name|md
operator|.
name|getDatabaseProductName
argument_list|()
argument_list|,
name|md
operator|.
name|getDatabaseProductVersion
argument_list|()
argument_list|,
name|md
operator|.
name|getDatabaseMajorVersion
argument_list|()
argument_list|,
name|md
operator|.
name|getDatabaseMinorVersion
argument_list|()
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"[\r\n\t]"
argument_list|,
literal|" "
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|driverDesc
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s %s (%d.%d)"
argument_list|,
name|md
operator|.
name|getDriverName
argument_list|()
argument_list|,
name|md
operator|.
name|getDriverVersion
argument_list|()
argument_list|,
name|md
operator|.
name|getDriverMajorVersion
argument_list|()
argument_list|,
name|md
operator|.
name|getDriverMinorVersion
argument_list|()
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"[\r\n\t]"
argument_list|,
literal|" "
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|dbUrl
init|=
name|md
operator|.
name|getURL
argument_list|()
decl_stmt|;
name|this
operator|.
name|dbInfo
operator|=
name|RDBDocumentStoreDB
operator|.
name|getValue
argument_list|(
name|md
operator|.
name|getDatabaseProductName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|db
operator|=
operator|new
name|RDBDocumentStoreJDBC
argument_list|(
name|this
operator|.
name|dbInfo
argument_list|,
name|this
operator|.
name|ser
argument_list|,
name|QUERYHITSLIMIT
argument_list|,
name|QUERYTIMELIMIT
argument_list|)
expr_stmt|;
name|this
operator|.
name|metadata
operator|=
name|ImmutableMap
operator|.
expr|<
name|String
operator|,
name|String
operator|>
name|builder
argument_list|()
operator|.
name|put
argument_list|(
literal|"type"
argument_list|,
literal|"rdb"
argument_list|)
operator|.
name|put
argument_list|(
literal|"db"
argument_list|,
name|md
operator|.
name|getDatabaseProductName
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"version"
argument_list|,
name|md
operator|.
name|getDatabaseProductVersion
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"driver"
argument_list|,
name|md
operator|.
name|getDriverName
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"driverVersion"
argument_list|,
name|md
operator|.
name|getDriverVersion
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|String
name|versionDiags
init|=
name|dbInfo
operator|.
name|checkVersion
argument_list|(
name|md
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|versionDiags
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|versionDiags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
literal|""
operator|.
name|equals
argument_list|(
name|dbInfo
operator|.
name|getInitializationStatement
argument_list|()
argument_list|)
condition|)
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
name|dbInfo
operator|.
name|getInitializationStatement
argument_list|()
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|closeStatement
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|tablesCreated
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tablesPresent
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|createTableFor
argument_list|(
name|con
argument_list|,
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|)
argument_list|,
name|tablesCreated
argument_list|,
name|tablesPresent
argument_list|,
name|options
operator|.
name|getInitialSchema
argument_list|()
argument_list|,
name|options
operator|.
name|getUpgradeToSchema
argument_list|()
argument_list|)
expr_stmt|;
name|createTableFor
argument_list|(
name|con
argument_list|,
name|Collection
operator|.
name|NODES
argument_list|,
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|)
argument_list|,
name|tablesCreated
argument_list|,
name|tablesPresent
argument_list|,
name|options
operator|.
name|getInitialSchema
argument_list|()
argument_list|,
name|options
operator|.
name|getUpgradeToSchema
argument_list|()
argument_list|)
expr_stmt|;
name|createTableFor
argument_list|(
name|con
argument_list|,
name|Collection
operator|.
name|SETTINGS
argument_list|,
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|)
argument_list|,
name|tablesCreated
argument_list|,
name|tablesPresent
argument_list|,
name|options
operator|.
name|getInitialSchema
argument_list|()
argument_list|,
name|options
operator|.
name|getUpgradeToSchema
argument_list|()
argument_list|)
expr_stmt|;
name|createTableFor
argument_list|(
name|con
argument_list|,
name|Collection
operator|.
name|JOURNAL
argument_list|,
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|JOURNAL
argument_list|)
argument_list|,
name|tablesCreated
argument_list|,
name|tablesPresent
argument_list|,
name|options
operator|.
name|getInitialSchema
argument_list|()
argument_list|,
name|options
operator|.
name|getUpgradeToSchema
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
name|con
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|StringBuilder
name|tableDiags
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|RDBTableMetaData
name|nodesMeta
init|=
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|)
decl_stmt|;
name|tableDiags
operator|.
name|append
argument_list|(
name|nodesMeta
operator|.
name|getSchemaInfo
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nodesMeta
operator|.
name|getIndexInfo
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|tableDiags
operator|.
name|append
argument_list|(
literal|" /* "
argument_list|)
operator|.
name|append
argument_list|(
name|nodesMeta
operator|.
name|getIndexInfo
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" */"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|.
name|isDropTablesOnClose
argument_list|()
condition|)
block|{
name|tablesToBeDropped
operator|.
name|addAll
argument_list|(
name|tablesCreated
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tableDiags
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|tableDiags
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|String
name|diag
init|=
name|dbInfo
operator|.
name|getAdditionalDiagnostics
argument_list|(
name|this
operator|.
name|ch
argument_list|,
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"RDBDocumentStore ("
operator|+
name|getModuleVersion
argument_list|()
operator|+
literal|") instantiated for database "
operator|+
name|dbDesc
operator|+
literal|", using driver: "
operator|+
name|driverDesc
operator|+
literal|", connecting to: "
operator|+
name|dbUrl
operator|+
operator|(
name|diag
operator|.
name|isEmpty
argument_list|()
condition|?
literal|""
else|:
operator|(
literal|", properties: "
operator|+
name|diag
operator|)
operator|)
operator|+
literal|", transaction isolation level: "
operator|+
name|isolationDiags
operator|+
name|tableDiags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tablesPresent
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Tables present upon startup: "
operator|+
name|tablesPresent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tablesCreated
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Tables created upon startup: "
operator|+
name|tablesCreated
operator|+
operator|(
name|options
operator|.
name|isDropTablesOnClose
argument_list|()
condition|?
literal|" (will be dropped on exit)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isBinaryType
parameter_list|(
name|int
name|sqlType
parameter_list|)
block|{
return|return
name|sqlType
operator|==
name|Types
operator|.
name|VARBINARY
operator|||
name|sqlType
operator|==
name|Types
operator|.
name|BINARY
operator|||
name|sqlType
operator|==
name|Types
operator|.
name|LONGVARBINARY
return|;
block|}
specifier|private
specifier|static
name|void
name|obtainFlagsFromResultSetMeta
parameter_list|(
name|ResultSetMetaData
name|met
parameter_list|,
name|RDBTableMetaData
name|tmd
parameter_list|)
throws|throws
name|SQLException
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|met
operator|.
name|getColumnCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|lcName
init|=
name|met
operator|.
name|getColumnName
argument_list|(
name|i
argument_list|)
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"id"
operator|.
name|equals
argument_list|(
name|lcName
argument_list|)
condition|)
block|{
name|tmd
operator|.
name|setIdIsBinary
argument_list|(
name|isBinaryType
argument_list|(
name|met
operator|.
name|getColumnType
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"data"
operator|.
name|equals
argument_list|(
name|lcName
argument_list|)
condition|)
block|{
name|tmd
operator|.
name|setDataLimitInOctets
argument_list|(
name|met
operator|.
name|getPrecision
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"version"
operator|.
name|equals
argument_list|(
name|lcName
argument_list|)
condition|)
block|{
name|tmd
operator|.
name|setHasVersion
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"sdtype"
operator|.
name|equals
argument_list|(
name|lcName
argument_list|)
condition|)
block|{
name|tmd
operator|.
name|setHasSplitDocs
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|String
name|asQualifiedDbName
parameter_list|(
name|String
name|one
parameter_list|,
name|String
name|two
parameter_list|)
block|{
name|one
operator|=
name|Strings
operator|.
name|nullToEmpty
argument_list|(
name|one
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|two
operator|=
name|Strings
operator|.
name|nullToEmpty
argument_list|(
name|two
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|one
operator|.
name|isEmpty
argument_list|()
operator|&&
name|two
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|one
operator|=
name|Strings
operator|.
name|nullToEmpty
argument_list|(
name|one
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|two
operator|=
name|two
operator|==
literal|null
condition|?
literal|""
else|:
name|two
operator|.
name|trim
argument_list|()
expr_stmt|;
return|return
name|one
operator|.
name|isEmpty
argument_list|()
condition|?
name|two
else|:
name|one
operator|+
literal|"."
operator|+
name|two
return|;
block|}
block|}
specifier|private
specifier|static
name|String
name|indexTypeAsString
parameter_list|(
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DatabaseMetaData
operator|.
name|tableIndexClustered
case|:
return|return
literal|"clustered"
return|;
case|case
name|DatabaseMetaData
operator|.
name|tableIndexHashed
case|:
return|return
literal|"hashed"
return|;
case|case
name|DatabaseMetaData
operator|.
name|tableIndexStatistic
case|:
return|return
literal|"statistic"
return|;
case|case
name|DatabaseMetaData
operator|.
name|tableIndexOther
case|:
return|return
literal|"other"
return|;
default|default:
return|return
literal|"indexType="
operator|+
name|type
return|;
block|}
block|}
specifier|private
specifier|static
name|String
name|dumpIndexData
parameter_list|(
name|DatabaseMetaData
name|met
parameter_list|,
name|ResultSetMetaData
name|rmet
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|indexedColumns
parameter_list|)
block|{
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// if the result set metadata provides a table name, use that (the
comment|// other one
comment|// might be inaccurate due to case insensitivity issues
name|String
name|rmetTableName
init|=
name|Strings
operator|.
name|nullToEmpty
argument_list|(
name|rmet
operator|.
name|getTableName
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|rmetTableName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|tableName
operator|=
name|rmetTableName
expr_stmt|;
block|}
name|String
name|rmetSchemaName
init|=
name|Strings
operator|.
name|nullToEmpty
argument_list|(
name|rmet
operator|.
name|getSchemaName
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|rs
operator|=
name|met
operator|.
name|getIndexInfo
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|indices
init|=
name|getIndexInformation
argument_list|(
name|rs
argument_list|,
name|rmetSchemaName
argument_list|)
decl_stmt|;
if|if
condition|(
name|indices
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|tableName
operator|.
name|equals
argument_list|(
name|tableName
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
argument_list|)
condition|)
block|{
comment|// might have failed due to the DB's handling on ucase/lcase,
comment|// retry ucase
name|rs
operator|=
name|met
operator|.
name|getIndexInfo
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|tableName
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|indices
operator|=
name|getIndexInformation
argument_list|(
name|rs
argument_list|,
name|rmetSchemaName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indexedColumns
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
range|:
name|indices
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|map
operator|.
name|containsKey
argument_list|(
literal|"columns"
argument_list|)
condition|)
block|{
name|indexedColumns
operator|.
name|addAll
argument_list|(
call|(
name|Set
argument_list|<
name|String
argument_list|>
call|)
argument_list|(
name|map
operator|.
name|get
argument_list|(
literal|"columns"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|dumpIndexData
argument_list|(
name|indices
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// well it was best-effort
return|return
name|String
operator|.
name|format
argument_list|(
literal|"/* exception while retrieving index information: %s, code %d, state %s */"
argument_list|,
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|,
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|closeResultSet
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|String
name|dumpIndexData
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|indices
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|index
range|:
name|indices
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|indexName
init|=
name|index
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|info
init|=
name|index
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|boolean
name|nonUnique
init|=
operator|(
operator|(
name|Boolean
operator|)
name|index
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
literal|"nonunique"
argument_list|)
operator|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|fields
init|=
operator|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
operator|)
name|info
operator|.
name|get
argument_list|(
literal|"fields"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%sindex %s on %s ("
argument_list|,
name|nonUnique
condition|?
literal|""
else|:
literal|"unique "
argument_list|,
name|indexName
argument_list|,
name|info
operator|.
name|get
argument_list|(
literal|"tname"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|delim
init|=
literal|""
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
operator|.
name|values
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|delim
argument_list|)
expr_stmt|;
name|delim
operator|=
literal|", "
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|info
operator|.
name|get
argument_list|(
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Object
name|filterCondition
init|=
name|info
operator|.
name|get
argument_list|(
literal|"filterCondition"
argument_list|)
decl_stmt|;
if|if
condition|(
name|filterCondition
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" where "
argument_list|)
operator|.
name|append
argument_list|(
name|filterCondition
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|" (#%s, p%s)"
argument_list|,
name|info
operator|.
name|get
argument_list|(
literal|"cardinality"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|info
operator|.
name|get
argument_list|(
literal|"pages"
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// see https://docs.oracle.com/javase/7/docs/api/java/sql/DatabaseMetaData.html#getIndexInfo(java.lang.String,%20java.lang.String,%20java.lang.String,%20boolean,%20boolean)
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|getIndexInformation
parameter_list|(
name|ResultSet
name|rs
parameter_list|,
name|String
name|rmetSchemaName
parameter_list|)
throws|throws
name|SQLException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|name
init|=
name|asQualifiedDbName
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"INDEX_QUALIFIER"
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|"INDEX_NAME"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|info
init|=
name|result
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|info
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
expr_stmt|;
name|result
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"fields"
argument_list|,
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|put
argument_list|(
literal|"nonunique"
argument_list|,
name|rs
operator|.
name|getBoolean
argument_list|(
literal|"NON_UNIQUE"
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"type"
argument_list|,
name|indexTypeAsString
argument_list|(
name|rs
operator|.
name|getInt
argument_list|(
literal|"TYPE"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|inSchema
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"TABLE_SCHEM"
argument_list|)
decl_stmt|;
name|inSchema
operator|=
name|Strings
operator|.
name|nullToEmpty
argument_list|(
name|inSchema
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|String
name|filterCondition
init|=
name|Strings
operator|.
name|nullToEmpty
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"FILTER_CONDITION"
argument_list|)
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|filterCondition
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|info
operator|.
name|put
argument_list|(
literal|"filterCondition"
argument_list|,
name|filterCondition
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|put
argument_list|(
literal|"cardinality"
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|"CARDINALITY"
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"pages"
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|"PAGES"
argument_list|)
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|columns
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"columns"
argument_list|,
name|columns
argument_list|)
expr_stmt|;
comment|// skip indices on tables in other schemas in case we have that information
if|if
condition|(
name|rmetSchemaName
operator|.
name|isEmpty
argument_list|()
operator|||
name|inSchema
operator|.
name|isEmpty
argument_list|()
operator|||
name|rmetSchemaName
operator|.
name|equals
argument_list|(
name|inSchema
argument_list|)
condition|)
block|{
name|String
name|tname
init|=
name|asQualifiedDbName
argument_list|(
name|inSchema
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|"TABLE_NAME"
argument_list|)
argument_list|)
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"tname"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|String
name|cname
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"COLUMN_NAME"
argument_list|)
decl_stmt|;
if|if
condition|(
name|cname
operator|!=
literal|null
condition|)
block|{
name|columns
operator|.
name|add
argument_list|(
name|cname
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|order
init|=
literal|"A"
operator|.
name|equals
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"ASC_OR_DESC"
argument_list|)
argument_list|)
condition|?
literal|" ASC"
else|:
operator|(
literal|"D"
operator|.
name|equals
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"ASC_OR_DESC"
argument_list|)
argument_list|)
condition|?
literal|" DESC"
else|:
literal|""
operator|)
decl_stmt|;
operator|(
operator|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
operator|)
name|info
operator|.
name|get
argument_list|(
literal|"fields"
argument_list|)
operator|)
operator|.
name|put
argument_list|(
name|rs
operator|.
name|getInt
argument_list|(
literal|"ORDINAL_POSITION"
argument_list|)
argument_list|,
name|cname
operator|+
name|order
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
specifier|private
name|void
name|createTableFor
parameter_list|(
name|Connection
name|con
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
name|col
parameter_list|,
name|RDBTableMetaData
name|tmd
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tablesCreated
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tablesPresent
parameter_list|,
name|int
name|initialSchema
parameter_list|,
name|int
name|upgradeToSchema
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|dbname
init|=
name|this
operator|.
name|dbInfo
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|con
operator|.
name|getMetaData
argument_list|()
operator|.
name|getURL
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dbname
operator|+=
literal|" ("
operator|+
name|con
operator|.
name|getMetaData
argument_list|()
operator|.
name|getURL
argument_list|()
operator|+
literal|")"
expr_stmt|;
block|}
name|String
name|tableName
init|=
name|tmd
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Statement
name|checkStatement
init|=
literal|null
decl_stmt|;
name|ResultSet
name|checkResultSet
init|=
literal|null
decl_stmt|;
name|Statement
name|creatStatement
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// avoid PreparedStatement due to weird DB2 behavior (OAK-6237)
name|checkStatement
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|checkResultSet
operator|=
name|checkStatement
operator|.
name|executeQuery
argument_list|(
literal|"select * from "
operator|+
name|tableName
operator|+
literal|" where ID = '0'"
argument_list|)
expr_stmt|;
comment|// try to discover size of DATA column and binary-ness of ID
name|ResultSetMetaData
name|met
init|=
name|checkResultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|obtainFlagsFromResultSetMeta
argument_list|(
name|met
argument_list|,
name|tmd
argument_list|)
expr_stmt|;
comment|// check that all required columns are present
name|Set
argument_list|<
name|String
argument_list|>
name|requiredColumns
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|REQUIREDCOLUMNS
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|unknownColumns
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|hasVersionColumn
init|=
literal|false
decl_stmt|;
name|boolean
name|hasSDTypeColumn
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|met
operator|.
name|getColumnCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|cname
init|=
name|met
operator|.
name|getColumnName
argument_list|(
name|i
argument_list|)
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|requiredColumns
operator|.
name|remove
argument_list|(
name|cname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|OPTIONALCOLUMNS
operator|.
name|contains
argument_list|(
name|cname
argument_list|)
condition|)
block|{
name|unknownColumns
operator|.
name|add
argument_list|(
name|cname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cname
operator|.
name|equals
argument_list|(
literal|"version"
argument_list|)
condition|)
block|{
name|hasVersionColumn
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|cname
operator|.
name|equals
argument_list|(
literal|"sdtype"
argument_list|)
condition|)
block|{
name|hasSDTypeColumn
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|requiredColumns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Table %s: the following required columns are missing: %s"
argument_list|,
name|tableName
argument_list|,
name|requiredColumns
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|message
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|unknownColumns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Table %s: the following columns are unknown and will not be maintained: %s"
argument_list|,
name|tableName
argument_list|,
name|unknownColumns
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|String
name|tableInfo
init|=
name|RDBJDBCTools
operator|.
name|dumpResultSetMeta
argument_list|(
name|met
argument_list|)
decl_stmt|;
name|tmd
operator|.
name|setSchemaInfo
argument_list|(
name|tableInfo
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|indexOn
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|indexInfo
init|=
name|dumpIndexData
argument_list|(
name|con
operator|.
name|getMetaData
argument_list|()
argument_list|,
name|met
argument_list|,
name|tableName
argument_list|,
name|indexOn
argument_list|)
decl_stmt|;
name|tmd
operator|.
name|setIndexInfo
argument_list|(
name|indexInfo
argument_list|)
expr_stmt|;
name|closeResultSet
argument_list|(
name|checkResultSet
argument_list|)
expr_stmt|;
name|boolean
name|dbWasChanged
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|readOnly
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping table update code because store is initialized in readOnly mode"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|hasVersionColumn
operator|&&
name|upgradeToSchema
operator|>=
literal|1
condition|)
block|{
name|dbWasChanged
operator||=
name|upgradeTable
argument_list|(
name|con
argument_list|,
name|tableName
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasSDTypeColumn
operator|&&
name|upgradeToSchema
operator|>=
literal|2
condition|)
block|{
name|dbWasChanged
operator||=
name|upgradeTable
argument_list|(
name|con
argument_list|,
name|tableName
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|indexOn
operator|.
name|contains
argument_list|(
literal|"MODIFIED"
argument_list|)
operator|&&
name|col
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|dbWasChanged
operator||=
name|addModifiedIndex
argument_list|(
name|con
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
name|tablesPresent
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbWasChanged
condition|)
block|{
name|getTableMetaData
argument_list|(
name|con
argument_list|,
name|col
argument_list|,
name|tmd
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// table does not appear to exist
name|con
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"trying to read from '"
operator|+
name|tableName
operator|+
literal|"'"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|readOnly
condition|)
block|{
throw|throw
operator|new
name|SQLException
argument_list|(
literal|"Would like to create table '"
operator|+
name|tableName
operator|+
literal|"', but RDBDocumentStore has been initialized in 'readonly' mode"
argument_list|)
throw|;
block|}
try|try
block|{
name|creatStatement
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|creatStatement
operator|.
name|execute
argument_list|(
name|this
operator|.
name|dbInfo
operator|.
name|getTableCreationStatement
argument_list|(
name|tableName
argument_list|,
name|initialSchema
argument_list|)
argument_list|)
expr_stmt|;
name|creatStatement
operator|.
name|close
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|ic
range|:
name|this
operator|.
name|dbInfo
operator|.
name|getIndexCreationStatements
argument_list|(
name|tableName
argument_list|,
name|initialSchema
argument_list|)
control|)
block|{
name|creatStatement
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|creatStatement
operator|.
name|execute
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|creatStatement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
name|initialSchema
operator|<
literal|1
operator|&&
name|upgradeToSchema
operator|>=
literal|1
condition|)
block|{
name|upgradeTable
argument_list|(
name|con
argument_list|,
name|tableName
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initialSchema
operator|<
literal|2
operator|&&
name|upgradeToSchema
operator|>=
literal|2
condition|)
block|{
name|upgradeTable
argument_list|(
name|con
argument_list|,
name|tableName
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|tablesCreated
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|getTableMetaData
argument_list|(
name|con
argument_list|,
name|col
argument_list|,
name|tmd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex2
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to create table '"
operator|+
name|tableName
operator|+
literal|"' in '"
operator|+
name|dbname
operator|+
literal|"'"
argument_list|,
name|ex2
argument_list|)
expr_stmt|;
throw|throw
name|ex2
throw|;
block|}
block|}
finally|finally
block|{
name|closeResultSet
argument_list|(
name|checkResultSet
argument_list|)
expr_stmt|;
name|closeStatement
argument_list|(
name|checkStatement
argument_list|)
expr_stmt|;
name|closeStatement
argument_list|(
name|creatStatement
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|upgradeTable
parameter_list|(
name|Connection
name|con
parameter_list|,
name|String
name|tableName
parameter_list|,
name|int
name|level
parameter_list|)
throws|throws
name|SQLException
block|{
name|boolean
name|wasChanged
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|statement
range|:
name|this
operator|.
name|dbInfo
operator|.
name|getTableUpgradeStatements
argument_list|(
name|tableName
argument_list|,
name|level
argument_list|)
control|)
block|{
name|Statement
name|upgradeStatement
init|=
literal|null
decl_stmt|;
try|try
block|{
name|upgradeStatement
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|upgradeStatement
operator|.
name|execute
argument_list|(
name|statement
argument_list|)
expr_stmt|;
name|upgradeStatement
operator|.
name|close
argument_list|()
expr_stmt|;
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Upgraded "
operator|+
name|tableName
operator|+
literal|" to DB level "
operator|+
name|level
operator|+
literal|" using '"
operator|+
name|statement
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|wasChanged
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|exup
parameter_list|)
block|{
name|con
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Attempted to upgrade %s to DB level %d using '%s', but failed with SQLException '%s' (code: %d/state: %s) - will continue without."
argument_list|,
name|tableName
argument_list|,
name|level
argument_list|,
name|statement
argument_list|,
name|exup
operator|.
name|getMessage
argument_list|()
argument_list|,
name|exup
operator|.
name|getErrorCode
argument_list|()
argument_list|,
name|exup
operator|.
name|getSQLState
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|message
argument_list|,
name|exup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|closeStatement
argument_list|(
name|upgradeStatement
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|wasChanged
return|;
block|}
specifier|private
name|boolean
name|addModifiedIndex
parameter_list|(
name|Connection
name|con
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|SQLException
block|{
name|boolean
name|wasChanged
init|=
literal|false
decl_stmt|;
name|String
name|statement
init|=
name|this
operator|.
name|dbInfo
operator|.
name|getModifiedIndexStatement
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|Statement
name|upgradeStatement
init|=
literal|null
decl_stmt|;
try|try
block|{
name|upgradeStatement
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|upgradeStatement
operator|.
name|execute
argument_list|(
name|statement
argument_list|)
expr_stmt|;
name|upgradeStatement
operator|.
name|close
argument_list|()
expr_stmt|;
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added 'modified' index to "
operator|+
name|tableName
operator|+
literal|" using '"
operator|+
name|statement
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|wasChanged
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|exup
parameter_list|)
block|{
name|con
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Attempted to add 'modified' index to %s using '%s', but failed with SQLException '%s' (code: %d/state: %s) - will continue without."
argument_list|,
name|tableName
argument_list|,
name|statement
argument_list|,
name|exup
operator|.
name|getMessage
argument_list|()
argument_list|,
name|exup
operator|.
name|getErrorCode
argument_list|()
argument_list|,
name|exup
operator|.
name|getSQLState
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|message
argument_list|,
name|exup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|closeStatement
argument_list|(
name|upgradeStatement
argument_list|)
expr_stmt|;
block|}
return|return
name|wasChanged
return|;
block|}
specifier|private
specifier|static
name|void
name|getTableMetaData
parameter_list|(
name|Connection
name|con
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
name|col
parameter_list|,
name|RDBTableMetaData
name|tmd
parameter_list|)
throws|throws
name|SQLException
block|{
name|Statement
name|checkStatement
init|=
literal|null
decl_stmt|;
name|ResultSet
name|checkResultSet
init|=
literal|null
decl_stmt|;
try|try
block|{
name|checkStatement
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|checkResultSet
operator|=
name|checkStatement
operator|.
name|executeQuery
argument_list|(
literal|"select * from "
operator|+
name|tmd
operator|.
name|getName
argument_list|()
operator|+
literal|" where ID = '0'"
argument_list|)
expr_stmt|;
comment|// try to discover size of DATA column and binary-ness of ID
name|ResultSetMetaData
name|met
init|=
name|checkResultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|obtainFlagsFromResultSetMeta
argument_list|(
name|met
argument_list|,
name|tmd
argument_list|)
expr_stmt|;
name|String
name|tableInfo
init|=
name|RDBJDBCTools
operator|.
name|dumpResultSetMeta
argument_list|(
name|met
argument_list|)
decl_stmt|;
name|tmd
operator|.
name|setSchemaInfo
argument_list|(
name|tableInfo
argument_list|)
expr_stmt|;
name|String
name|indexInfo
init|=
name|dumpIndexData
argument_list|(
name|con
operator|.
name|getMetaData
argument_list|()
argument_list|,
name|met
argument_list|,
name|tmd
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|tmd
operator|.
name|setIndexInfo
argument_list|(
name|indexInfo
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|closeResultSet
argument_list|(
name|checkResultSet
argument_list|)
expr_stmt|;
name|closeStatement
argument_list|(
name|checkStatement
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
name|readOnly
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|ch
operator|.
name|isClosed
argument_list|()
operator|&&
name|this
operator|.
name|callStack
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"finalizing RDBDocumentStore that was not disposed"
argument_list|,
name|this
operator|.
name|callStack
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|readDocumentCached
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
specifier|final
name|String
name|id
parameter_list|,
name|int
name|maxCacheAge
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|!=
name|Collection
operator|.
name|NODES
condition|)
block|{
return|return
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
name|NodeDocument
name|doc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|maxCacheAge
operator|>
literal|0
condition|)
block|{
comment|// first try without lock
name|doc
operator|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|long
name|lastCheckTime
init|=
name|doc
operator|.
name|getLastCheckTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastCheckTime
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|maxCacheAge
operator|==
name|Integer
operator|.
name|MAX_VALUE
operator|||
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastCheckTime
operator|<
name|maxCacheAge
condition|)
block|{
name|stats
operator|.
name|doneFindCached
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|castAsT
argument_list|(
name|unwrap
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
block|}
try|try
block|{
try|try
init|(
name|CacheLock
name|lock
init|=
name|acquireLockFor
argument_list|(
name|id
argument_list|)
init|)
block|{
comment|// caller really wants the cache to be cleared
if|if
condition|(
name|maxCacheAge
operator|==
literal|0
condition|)
block|{
name|invalidateNodesCache
argument_list|(
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|doc
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|NodeDocument
name|cachedDoc
init|=
name|doc
decl_stmt|;
name|doc
operator|=
name|nodesCache
operator|.
name|get
argument_list|(
name|id
argument_list|,
operator|new
name|Callable
argument_list|<
name|NodeDocument
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|NodeDocument
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|NodeDocument
name|doc
init|=
operator|(
name|NodeDocument
operator|)
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|cachedDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|seal
argument_list|()
expr_stmt|;
block|}
return|return
name|wrap
argument_list|(
name|doc
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// inspect the doc whether it can be used
name|long
name|lastCheckTime
init|=
name|doc
operator|.
name|getLastCheckTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastCheckTime
operator|!=
literal|0
operator|&&
operator|(
name|maxCacheAge
operator|==
literal|0
operator|||
name|maxCacheAge
operator|==
name|Integer
operator|.
name|MAX_VALUE
operator|)
condition|)
block|{
comment|// we either just cleared the cache or the caller does
comment|// not care;
block|}
elseif|else
if|if
condition|(
name|lastCheckTime
operator|!=
literal|0
operator|&&
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastCheckTime
operator|<
name|maxCacheAge
operator|)
condition|)
block|{
comment|// is new enough
block|}
else|else
block|{
comment|// need to at least revalidate
name|NodeDocument
name|ndoc
init|=
operator|(
name|NodeDocument
operator|)
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|cachedDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|ndoc
operator|!=
literal|null
condition|)
block|{
name|ndoc
operator|.
name|seal
argument_list|()
expr_stmt|;
block|}
name|doc
operator|=
name|wrap
argument_list|(
name|ndoc
argument_list|)
expr_stmt|;
name|nodesCache
operator|.
name|put
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|castAsT
argument_list|(
name|unwrap
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Failed to load document with "
operator|+
name|id
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Nullable
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|internalCreate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updates
parameter_list|)
block|{
specifier|final
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|updates
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
try|try
block|{
comment|// try up to CHUNKSIZE ops in one transaction
for|for
control|(
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|chunks
range|:
name|Lists
operator|.
name|partition
argument_list|(
name|updates
argument_list|,
name|CHUNKSIZE
argument_list|)
control|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateOp
name|update
range|:
name|chunks
control|)
block|{
name|ids
operator|.
name|add
argument_list|(
name|update
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|maintainUpdateStats
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|UpdateUtils
operator|.
name|assertUnconditional
argument_list|(
name|update
argument_list|)
expr_stmt|;
name|T
name|doc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|addUpdateCounters
argument_list|(
name|update
argument_list|)
expr_stmt|;
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|doc
argument_list|,
name|update
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|update
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"ID mismatch - UpdateOp: "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|", ID property: "
operator|+
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
name|docs
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|boolean
name|done
init|=
name|insertDocuments
argument_list|(
name|collection
argument_list|,
name|docs
argument_list|)
decl_stmt|;
if|if
condition|(
name|done
condition|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
for|for
control|(
name|T
name|doc
range|:
name|docs
control|)
block|{
name|nodesCache
operator|.
name|putIfAbsent
argument_list|(
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|success
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|success
return|;
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|ex
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|stats
operator|.
name|doneCreate
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|ids
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Nullable
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|internalCreateOrUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|,
name|boolean
name|allowCreate
parameter_list|,
name|boolean
name|checkConditions
parameter_list|,
name|int
name|retries
parameter_list|)
block|{
name|T
name|oldDoc
init|=
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|allowCreate
operator|||
operator|!
name|update
operator|.
name|isNew
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|T
name|doc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|checkConditions
operator|&&
operator|!
name|checkConditions
argument_list|(
name|doc
argument_list|,
name|update
operator|.
name|getConditions
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|addUpdateCounters
argument_list|(
name|update
argument_list|)
expr_stmt|;
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|doc
argument_list|,
name|update
argument_list|)
expr_stmt|;
try|try
block|{
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|insertDocuments
argument_list|(
name|collection
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|doc
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"Can't insert the document: "
operator|+
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|nodesCache
operator|.
name|putIfAbsent
argument_list|(
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|doneFindAndModify
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|oldDoc
return|;
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|ex
parameter_list|)
block|{
comment|// may have failed due to a race condition; try update instead
comment|// this is an edge case, so it's ok to bypass the cache
comment|// (avoiding a race condition where the DB is already updated
comment|// but the cache is not)
name|oldDoc
operator|=
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// something else went wrong
name|LOG
operator|.
name|error
argument_list|(
literal|"insert failed, but document "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|" is not present, aborting"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|ex
operator|)
throw|;
block|}
return|return
name|internalUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
name|oldDoc
argument_list|,
name|checkConditions
argument_list|,
name|retries
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|T
name|result
init|=
name|internalUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
name|oldDoc
argument_list|,
name|checkConditions
argument_list|,
name|retries
argument_list|)
decl_stmt|;
if|if
condition|(
name|allowCreate
operator|&&
name|result
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|retries
operator|>
literal|0
condition|)
block|{
name|result
operator|=
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
name|allowCreate
argument_list|,
name|checkConditions
argument_list|,
name|retries
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"update of "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|" failed, race condition?"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"update of "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|" failed, race condition?"
argument_list|,
literal|null
argument_list|,
name|DocumentStoreException
operator|.
name|Type
operator|.
name|TRANSIENT
argument_list|)
throw|;
block|}
block|}
return|return
name|result
return|;
block|}
block|}
comment|/**      * @return previous version of document or<code>null</code>      */
annotation|@
name|Nullable
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|internalUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|,
name|T
name|oldDoc
parameter_list|,
name|boolean
name|checkConditions
parameter_list|,
name|int
name|maxRetries
parameter_list|)
block|{
if|if
condition|(
name|checkConditions
operator|&&
operator|!
name|UpdateUtils
operator|.
name|checkConditions
argument_list|(
name|oldDoc
argument_list|,
name|update
operator|.
name|getConditions
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|maintainUpdateStats
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|addUpdateCounters
argument_list|(
name|update
argument_list|)
expr_stmt|;
name|T
name|doc
init|=
name|createNewDocument
argument_list|(
name|collection
argument_list|,
name|oldDoc
argument_list|,
name|update
argument_list|)
decl_stmt|;
specifier|final
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|int
name|retries
init|=
name|maxRetries
decl_stmt|;
try|try
init|(
name|CacheLock
name|lock
init|=
name|acquireLockFor
argument_list|(
name|update
operator|.
name|getId
argument_list|()
argument_list|)
init|)
block|{
while|while
condition|(
operator|!
name|success
operator|&&
name|retries
operator|>
literal|0
condition|)
block|{
name|long
name|lastmodcount
init|=
name|modcountOf
argument_list|(
name|oldDoc
argument_list|)
decl_stmt|;
name|success
operator|=
name|updateDocument
argument_list|(
name|collection
argument_list|,
name|doc
argument_list|,
name|update
argument_list|,
name|lastmodcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|retries
operator|-=
literal|1
expr_stmt|;
name|oldDoc
operator|=
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|long
name|newmodcount
init|=
name|modcountOf
argument_list|(
name|oldDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastmodcount
operator|==
name|newmodcount
condition|)
block|{
comment|// cached copy did not change so it probably was
comment|// updated by a different instance, get a fresh one
name|LOG
operator|.
name|debug
argument_list|(
literal|"suspect update from different instance (current modcount: {}), refetching: {}..."
argument_list|,
name|newmodcount
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|nodesCache
operator|.
name|invalidate
argument_list|(
name|update
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|oldDoc
operator|=
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"after refetch: {} is gone"
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"after refetch: modcount for {} is {}"
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
name|modcountOf
argument_list|(
name|oldDoc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// document was there but is now gone
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to apply update because document is gone in the meantime: "
operator|+
name|update
operator|.
name|getId
argument_list|()
argument_list|,
operator|new
name|Exception
argument_list|(
literal|"call stack"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|checkConditions
operator|&&
operator|!
name|UpdateUtils
operator|.
name|checkConditions
argument_list|(
name|oldDoc
argument_list|,
name|update
operator|.
name|getConditions
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|addUpdateCounters
argument_list|(
name|update
argument_list|)
expr_stmt|;
name|doc
operator|=
name|createNewDocument
argument_list|(
name|collection
argument_list|,
name|oldDoc
argument_list|,
name|update
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|nodesCache
operator|.
name|replaceCachedDocument
argument_list|(
operator|(
name|NodeDocument
operator|)
name|oldDoc
argument_list|,
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"failed update of "
operator|+
name|doc
operator|.
name|getId
argument_list|()
operator|+
literal|" (race?) after "
operator|+
name|maxRetries
operator|+
literal|" retries"
argument_list|,
literal|null
argument_list|,
name|DocumentStoreException
operator|.
name|Type
operator|.
name|TRANSIENT
argument_list|)
throw|;
block|}
return|return
name|oldDoc
return|;
block|}
finally|finally
block|{
name|int
name|numOfAttempts
init|=
name|maxRetries
operator|-
name|retries
operator|-
literal|1
decl_stmt|;
name|stats
operator|.
name|doneFindAndModify
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
literal|false
argument_list|,
name|success
argument_list|,
name|numOfAttempts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|NotNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|createNewDocument
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|T
name|oldDoc
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
name|T
name|doc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|oldDoc
operator|.
name|deepCopy
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|doc
argument_list|,
name|update
argument_list|)
expr_stmt|;
name|doc
operator|.
name|seal
argument_list|()
expr_stmt|;
return|return
name|doc
return|;
block|}
specifier|private
specifier|static
name|void
name|addUpdateCounters
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
if|if
condition|(
name|hasChangesToCollisions
argument_list|(
name|update
argument_list|)
condition|)
block|{
name|update
operator|.
name|increment
argument_list|(
name|COLLISIONSMODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|increment
argument_list|(
name|MODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|internalQuery
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|excludeKeyPatterns
parameter_list|,
name|List
argument_list|<
name|QueryCondition
argument_list|>
name|conditions
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
for|for
control|(
name|QueryCondition
name|cond
range|:
name|conditions
control|)
block|{
if|if
condition|(
operator|!
name|INDEXEDPROPERTIES
operator|.
name|contains
argument_list|(
name|cond
operator|.
name|getPropertyName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"indexed property "
operator|+
name|cond
operator|.
name|getPropertyName
argument_list|()
operator|+
literal|" not supported, query was '"
operator|+
name|cond
operator|+
literal|"'; supported properties are "
operator|+
name|INDEXEDPROPERTIES
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
specifier|final
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
name|int
name|resultSize
init|=
literal|0
decl_stmt|;
try|try
init|(
name|CacheChangesTracker
name|tracker
init|=
name|obtainTracker
argument_list|(
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|)
init|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getROConnection
argument_list|()
expr_stmt|;
name|String
name|from
init|=
name|collection
operator|==
name|Collection
operator|.
name|NODES
operator|&&
name|NodeDocument
operator|.
name|MIN_ID_VALUE
operator|.
name|equals
argument_list|(
name|fromKey
argument_list|)
condition|?
literal|null
else|:
name|fromKey
decl_stmt|;
name|String
name|to
init|=
name|collection
operator|==
name|Collection
operator|.
name|NODES
operator|&&
name|NodeDocument
operator|.
name|MAX_ID_VALUE
operator|.
name|equals
argument_list|(
name|toKey
argument_list|)
condition|?
literal|null
else|:
name|toKey
decl_stmt|;
comment|// OAK-6839: only populate the cache with *new* entries if the query
comment|// isn't open-ended (something done by GC processes)
name|boolean
name|populateCache
init|=
name|to
operator|!=
literal|null
decl_stmt|;
name|List
argument_list|<
name|RDBRow
argument_list|>
name|dbresult
init|=
name|db
operator|.
name|query
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|excludeKeyPatterns
argument_list|,
name|conditions
argument_list|,
name|limit
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
name|int
name|size
init|=
name|dbresult
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|(
name|size
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
comment|// free RDBRow as early as possible
name|RDBRow
name|row
init|=
name|dbresult
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|T
name|doc
init|=
name|getIfCached
argument_list|(
name|collection
argument_list|,
name|row
operator|.
name|getId
argument_list|()
argument_list|,
name|row
operator|.
name|getModcount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
comment|// parse DB contents into document if and only if it's not
comment|// already in the cache
name|doc
operator|=
name|convertFromDBObject
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we got a document from the cache, thus collection is NODES
comment|// and a tracker is present
name|long
name|lastmodified
init|=
name|modifiedOf
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastmodified
operator|==
name|row
operator|.
name|getModified
argument_list|()
operator|&&
name|lastmodified
operator|>=
literal|1
condition|)
block|{
try|try
init|(
name|CacheLock
name|lock
init|=
name|acquireLockFor
argument_list|(
name|row
operator|.
name|getId
argument_list|()
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|tracker
operator|.
name|mightBeenAffected
argument_list|(
name|row
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
comment|// otherwise mark it as fresh
operator|(
operator|(
name|NodeDocument
operator|)
name|doc
operator|)
operator|.
name|markUpToDate
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// we need a fresh document instance
name|doc
operator|=
name|convertFromDBObject
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
if|if
condition|(
name|populateCache
condition|)
block|{
name|nodesCache
operator|.
name|putNonConflictingDocs
argument_list|(
name|tracker
argument_list|,
name|castAsNodeDocumentList
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ModificationStamp
argument_list|>
name|invMap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Document
name|doc
range|:
name|result
control|)
block|{
name|invMap
operator|.
name|put
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|,
operator|new
name|ModificationStamp
argument_list|(
name|modcountOf
argument_list|(
name|doc
argument_list|)
argument_list|,
name|modifiedOf
argument_list|(
name|doc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nodesCache
operator|.
name|invalidateOutdated
argument_list|(
name|invMap
argument_list|)
expr_stmt|;
block|}
block|}
name|resultSize
operator|=
name|result
operator|.
name|size
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"SQL exception on query"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|asDocumentStoreException
argument_list|(
name|ex
argument_list|,
literal|"SQL exception on query"
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|stats
operator|.
name|doneQuery
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
operator|!
name|conditions
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|resultSize
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
interface|interface
name|MyCloseableIterable
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Closeable
extends|,
name|Iterable
argument_list|<
name|T
argument_list|>
block|{     }
specifier|protected
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|Iterable
argument_list|<
name|T
argument_list|>
name|queryAsIterable
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|excludeKeyPatterns
parameter_list|,
specifier|final
name|List
argument_list|<
name|QueryCondition
argument_list|>
name|conditions
parameter_list|,
specifier|final
name|int
name|limit
parameter_list|,
specifier|final
name|String
name|sortBy
parameter_list|)
block|{
specifier|final
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|allowedProps
init|=
name|Sets
operator|.
name|intersection
argument_list|(
name|INDEXEDPROPERTIES
argument_list|,
name|tmd
operator|.
name|getColumnProperties
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|QueryCondition
name|cond
range|:
name|conditions
control|)
block|{
if|if
condition|(
operator|!
name|allowedProps
operator|.
name|contains
argument_list|(
name|cond
operator|.
name|getPropertyName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"indexed property "
operator|+
name|cond
operator|.
name|getPropertyName
argument_list|()
operator|+
literal|" not supported, query was '"
operator|+
name|cond
operator|+
literal|"'; supported properties are "
operator|+
name|allowedProps
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|UnsupportedIndexedPropertyException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
specifier|final
name|String
name|from
init|=
name|collection
operator|==
name|Collection
operator|.
name|NODES
operator|&&
name|NodeDocument
operator|.
name|MIN_ID_VALUE
operator|.
name|equals
argument_list|(
name|fromKey
argument_list|)
condition|?
literal|null
else|:
name|fromKey
decl_stmt|;
specifier|final
name|String
name|to
init|=
name|collection
operator|==
name|Collection
operator|.
name|NODES
operator|&&
name|NodeDocument
operator|.
name|MAX_ID_VALUE
operator|.
name|equals
argument_list|(
name|toKey
argument_list|)
condition|?
literal|null
else|:
name|toKey
decl_stmt|;
return|return
operator|new
name|MyCloseableIterable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
name|Set
argument_list|<
name|Iterator
argument_list|<
name|RDBRow
argument_list|>
argument_list|>
name|returned
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
try|try
block|{
name|Iterator
argument_list|<
name|RDBRow
argument_list|>
name|res
init|=
name|db
operator|.
name|queryAsIterator
argument_list|(
name|ch
argument_list|,
name|tmd
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|excludeKeyPatterns
argument_list|,
name|conditions
argument_list|,
name|limit
argument_list|,
name|sortBy
argument_list|)
decl_stmt|;
name|returned
operator|.
name|add
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|T
argument_list|>
name|tmp
init|=
name|Iterators
operator|.
name|transform
argument_list|(
name|res
argument_list|,
operator|new
name|Function
argument_list|<
name|RDBRow
argument_list|,
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|T
name|apply
parameter_list|(
name|RDBRow
name|input
parameter_list|)
block|{
return|return
name|convertFromDBObject
argument_list|(
name|collection
argument_list|,
name|input
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|CloseableIterator
operator|.
name|wrap
argument_list|(
name|tmp
argument_list|,
operator|(
name|Closeable
operator|)
name|res
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Iterator
argument_list|<
name|RDBRow
argument_list|>
name|rdbi
range|:
name|returned
control|)
block|{
if|if
condition|(
name|rdbi
operator|instanceof
name|Closeable
condition|)
block|{
operator|(
operator|(
name|Closeable
operator|)
name|rdbi
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
specifier|protected
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|long
name|queryCount
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|excludeKeyPatterns
parameter_list|,
specifier|final
name|List
argument_list|<
name|QueryCondition
argument_list|>
name|conditions
parameter_list|)
block|{
return|return
name|internalGetAggregate
argument_list|(
name|collection
argument_list|,
literal|"COUNT"
argument_list|,
literal|"*"
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
name|excludeKeyPatterns
argument_list|,
name|conditions
argument_list|)
return|;
block|}
specifier|protected
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|long
name|getMinValue
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|excludeKeyPatterns
parameter_list|,
specifier|final
name|List
argument_list|<
name|QueryCondition
argument_list|>
name|conditions
parameter_list|)
block|{
return|return
name|internalGetAggregate
argument_list|(
name|collection
argument_list|,
literal|"MIN"
argument_list|,
name|field
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
name|excludeKeyPatterns
argument_list|,
name|conditions
argument_list|)
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|long
name|internalGetAggregate
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
specifier|final
name|String
name|aggregrate
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|excludeKeyPatterns
parameter_list|,
specifier|final
name|List
argument_list|<
name|QueryCondition
argument_list|>
name|conditions
parameter_list|)
block|{
specifier|final
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
for|for
control|(
name|QueryCondition
name|cond
range|:
name|conditions
control|)
block|{
if|if
condition|(
operator|!
name|INDEXEDPROPERTIES
operator|.
name|contains
argument_list|(
name|cond
operator|.
name|getPropertyName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"indexed property "
operator|+
name|cond
operator|.
name|getPropertyName
argument_list|()
operator|+
literal|" not supported, query was '"
operator|+
name|cond
operator|+
literal|"'; supported properties are "
operator|+
name|INDEXEDPROPERTIES
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
specifier|final
name|String
name|from
init|=
name|collection
operator|==
name|Collection
operator|.
name|NODES
operator|&&
name|NodeDocument
operator|.
name|MIN_ID_VALUE
operator|.
name|equals
argument_list|(
name|fromKey
argument_list|)
condition|?
literal|null
else|:
name|fromKey
decl_stmt|;
specifier|final
name|String
name|to
init|=
name|collection
operator|==
name|Collection
operator|.
name|NODES
operator|&&
name|NodeDocument
operator|.
name|MAX_ID_VALUE
operator|.
name|equals
argument_list|(
name|toKey
argument_list|)
condition|?
literal|null
else|:
name|toKey
decl_stmt|;
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|ch
operator|.
name|getROConnection
argument_list|()
expr_stmt|;
name|long
name|result
init|=
name|db
operator|.
name|getLong
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|aggregrate
argument_list|,
name|field
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|excludeKeyPatterns
argument_list|,
name|conditions
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"SQL exception on query"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|asDocumentStoreException
argument_list|(
name|ex
argument_list|,
literal|"SQL exception on query"
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|NotNull
specifier|protected
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|RDBTableMetaData
name|getTable
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|)
block|{
name|RDBTableMetaData
name|tmd
init|=
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmd
operator|!=
literal|null
condition|)
block|{
return|return
name|tmd
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown collection: "
operator|+
name|collection
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Nullable
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|readDocumentUncached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|,
name|NodeDocument
name|cachedDoc
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
specifier|final
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
name|boolean
name|docFound
init|=
literal|true
decl_stmt|;
try|try
block|{
name|long
name|lastmodcount
init|=
operator|-
literal|1
decl_stmt|,
name|lastmodified
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|cachedDoc
operator|!=
literal|null
condition|)
block|{
name|lastmodcount
operator|=
name|modcountOf
argument_list|(
name|cachedDoc
argument_list|)
expr_stmt|;
name|lastmodified
operator|=
name|modifiedOf
argument_list|(
name|cachedDoc
argument_list|)
expr_stmt|;
block|}
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getROConnection
argument_list|()
expr_stmt|;
name|RDBRow
name|row
init|=
name|db
operator|.
name|read
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|id
argument_list|,
name|lastmodcount
argument_list|,
name|lastmodified
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
name|docFound
operator|=
literal|false
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
if|if
condition|(
name|lastmodcount
operator|==
name|row
operator|.
name|getModcount
argument_list|()
operator|&&
name|lastmodified
operator|==
name|row
operator|.
name|getModified
argument_list|()
operator|&&
name|lastmodified
operator|>=
literal|1
condition|)
block|{
comment|// we can re-use the cached document
name|cachedDoc
operator|.
name|markUpToDate
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|castAsT
argument_list|(
name|cachedDoc
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|convertFromDBObject
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
name|asDocumentStoreException
argument_list|(
name|ex
argument_list|,
literal|"exception while reading "
operator|+
name|id
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|stats
operator|.
name|doneFindUncached
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|id
argument_list|,
name|docFound
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|delete
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|db
operator|.
name|delete
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
throw|throw
name|handleException
argument_list|(
literal|"removing "
operator|+
name|id
argument_list|,
name|ex
argument_list|,
name|collection
argument_list|,
name|id
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|stats
operator|.
name|doneRemove
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|int
name|delete
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
block|{
name|int
name|numDeleted
init|=
literal|0
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|sublist
range|:
name|Lists
operator|.
name|partition
argument_list|(
name|ids
argument_list|,
literal|64
argument_list|)
control|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|numDeleted
operator|+=
name|db
operator|.
name|delete
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|sublist
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
throw|throw
name|handleException
argument_list|(
literal|"removing "
operator|+
name|ids
argument_list|,
name|ex
argument_list|,
name|collection
argument_list|,
name|ids
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|stats
operator|.
name|doneRemove
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|ids
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|numDeleted
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|int
name|delete
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|toRemove
parameter_list|)
block|{
name|int
name|numDeleted
init|=
literal|0
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|subMap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|it
init|=
name|toRemove
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|entry
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|subMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|subMap
operator|.
name|size
argument_list|()
operator|==
literal|64
operator|||
operator|!
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|num
operator|=
name|db
operator|.
name|delete
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|subMap
argument_list|)
expr_stmt|;
name|numDeleted
operator|+=
name|num
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|ids
init|=
name|subMap
operator|.
name|keySet
argument_list|()
decl_stmt|;
throw|throw
name|handleException
argument_list|(
literal|"deleting "
operator|+
name|ids
argument_list|,
name|ex
argument_list|,
name|collection
argument_list|,
name|ids
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|stats
operator|.
name|doneRemove
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
name|subMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|numDeleted
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|int
name|deleteWithCondition
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|QueryCondition
argument_list|>
name|conditions
parameter_list|)
block|{
name|int
name|numDeleted
init|=
literal|0
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|numDeleted
operator|=
name|db
operator|.
name|deleteWithCondition
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|conditions
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
throw|throw
name|asDocumentStoreException
argument_list|(
name|ex
argument_list|,
literal|"deleting "
operator|+
name|collection
operator|+
literal|": "
operator|+
name|conditions
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|stats
operator|.
name|doneRemove
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|numDeleted
argument_list|)
expr_stmt|;
block|}
return|return
name|numDeleted
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|updateDocument
parameter_list|(
annotation|@
name|NotNull
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
annotation|@
name|NotNull
name|T
name|document
parameter_list|,
annotation|@
name|NotNull
name|UpdateOp
name|update
parameter_list|,
name|Long
name|oldmodcount
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|String
name|data
init|=
literal|null
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|Number
name|hasBinary
init|=
operator|(
name|Number
operator|)
name|document
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
argument_list|)
decl_stmt|;
name|Boolean
name|deletedOnce
init|=
operator|(
name|Boolean
operator|)
name|document
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|DELETED_ONCE
argument_list|)
decl_stmt|;
name|Long
name|modcount
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|MODCOUNT
argument_list|)
decl_stmt|;
name|Long
name|cmodcount
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|COLLISIONSMODCOUNT
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|boolean
name|shouldRetry
init|=
literal|true
decl_stmt|;
comment|// every 16th update is a full rewrite
if|if
condition|(
name|isAppendableUpdate
argument_list|(
name|update
argument_list|)
operator|&&
name|modcount
operator|%
literal|16
operator|!=
literal|0
condition|)
block|{
name|String
name|appendData
init|=
name|ser
operator|.
name|asString
argument_list|(
name|update
argument_list|,
name|tmd
operator|.
name|getColumnOnlyProperties
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|appendData
operator|.
name|length
argument_list|()
operator|<
name|tmd
operator|.
name|getDataLimitInOctets
argument_list|()
operator|/
name|CHAR2OCTETRATIO
condition|)
block|{
try|try
block|{
name|Operation
name|modOperation
init|=
name|update
operator|.
name|getChanges
argument_list|()
operator|.
name|get
argument_list|(
name|MODIFIEDKEY
argument_list|)
decl_stmt|;
name|long
name|modified
init|=
name|getModifiedFromOperation
argument_list|(
name|modOperation
argument_list|)
decl_stmt|;
name|boolean
name|modifiedIsConditional
init|=
name|modOperation
operator|==
literal|null
operator|||
name|modOperation
operator|.
name|type
operator|!=
name|UpdateOp
operator|.
name|Operation
operator|.
name|Type
operator|.
name|SET
decl_stmt|;
name|success
operator|=
name|db
operator|.
name|appendingUpdate
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|modified
argument_list|,
name|modifiedIsConditional
argument_list|,
name|hasBinary
argument_list|,
name|deletedOnce
argument_list|,
name|modcount
argument_list|,
name|cmodcount
argument_list|,
name|oldmodcount
argument_list|,
name|appendData
argument_list|)
expr_stmt|;
comment|// if we get here, a retry is not going to help (the SQL
comment|// operation succeeded but simply did not select a row
comment|// that could be updated, likely because of the check on
comment|// MODCOUNT
name|shouldRetry
operator|=
literal|false
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|continueIfStringOverflow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|success
operator|&&
name|shouldRetry
condition|)
block|{
name|data
operator|=
name|ser
operator|.
name|asString
argument_list|(
name|document
argument_list|,
name|tmd
operator|.
name|getColumnOnlyProperties
argument_list|()
argument_list|)
expr_stmt|;
name|Object
name|m
init|=
name|document
operator|.
name|get
argument_list|(
name|MODIFIED
argument_list|)
decl_stmt|;
name|long
name|modified
init|=
operator|(
name|m
operator|instanceof
name|Long
operator|)
condition|?
operator|(
operator|(
name|Long
operator|)
name|m
operator|)
operator|.
name|longValue
argument_list|()
else|:
literal|0
decl_stmt|;
name|success
operator|=
name|db
operator|.
name|update
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|modified
argument_list|,
name|hasBinary
argument_list|,
name|deletedOnce
argument_list|,
name|modcount
argument_list|,
name|cmodcount
argument_list|,
name|oldmodcount
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|String
name|addDiags
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
operator|&&
name|RDBJDBCTools
operator|.
name|matchesSQLState
argument_list|(
name|ex
argument_list|,
literal|"22"
argument_list|,
literal|"72"
argument_list|)
condition|)
block|{
name|byte
index|[]
name|bytes
init|=
name|asBytes
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|addDiags
operator|=
name|String
operator|.
name|format
argument_list|(
literal|" (DATA size in Java characters: %d, in octets: %d, computed character limit: %d)"
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
name|tmd
operator|.
name|getDataLimitInOctets
argument_list|()
operator|/
name|CHAR2OCTETRATIO
argument_list|)
expr_stmt|;
block|}
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Update for %s failed%s"
argument_list|,
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|addDiags
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|message
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|handleException
argument_list|(
name|message
argument_list|,
name|ex
argument_list|,
name|collection
argument_list|,
name|document
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|continueIfStringOverflow
parameter_list|(
name|SQLException
name|ex
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|state
init|=
name|ex
operator|.
name|getSQLState
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"22001"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
comment|/* everybody */
operator|||
operator|(
literal|"72000"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|&&
literal|1489
operator|==
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|)
comment|/* Oracle */
condition|)
block|{
comment|// ok
block|}
else|else
block|{
throw|throw
operator|(
name|ex
operator|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isAppendableUpdate
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
return|return
name|NOAPPEND
operator|==
literal|false
return|;
block|}
specifier|private
specifier|static
name|long
name|getModifiedFromOperation
parameter_list|(
name|Operation
name|op
parameter_list|)
block|{
return|return
name|op
operator|==
literal|null
condition|?
literal|0L
else|:
name|Long
operator|.
name|parseLong
argument_list|(
name|op
operator|.
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|insertDocuments
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|documents
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|insertedKeys
init|=
name|db
operator|.
name|insert
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|documents
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|insertedKeys
operator|.
name|size
argument_list|()
operator|==
name|documents
operator|.
name|size
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|doc
range|:
name|documents
control|)
block|{
name|ids
operator|.
name|add
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"insert of %s failed"
argument_list|,
name|ids
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|message
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// collect additional exceptions
name|String
name|messages
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|?
name|RDBJDBCTools
operator|.
name|getAdditionalMessages
argument_list|(
name|ex
argument_list|)
else|:
literal|""
decl_stmt|;
comment|// see whether a DATA error was involved
name|boolean
name|dataRelated
init|=
literal|false
decl_stmt|;
name|SQLException
name|walk
init|=
name|ex
decl_stmt|;
while|while
condition|(
name|walk
operator|!=
literal|null
operator|&&
operator|!
name|dataRelated
condition|)
block|{
name|dataRelated
operator|=
name|RDBJDBCTools
operator|.
name|matchesSQLState
argument_list|(
name|walk
argument_list|,
literal|"22"
argument_list|,
literal|"72"
argument_list|)
expr_stmt|;
name|walk
operator|=
name|walk
operator|.
name|getNextException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dataRelated
condition|)
block|{
name|String
name|id
init|=
literal|null
decl_stmt|;
name|int
name|longest
init|=
literal|0
decl_stmt|,
name|longestChars
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Document
name|d
range|:
name|documents
control|)
block|{
name|String
name|data
init|=
name|ser
operator|.
name|asString
argument_list|(
name|d
argument_list|,
name|tmd
operator|.
name|getColumnOnlyProperties
argument_list|()
argument_list|)
decl_stmt|;
name|byte
name|bytes
index|[]
init|=
name|asBytes
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|.
name|length
operator|>
name|longest
condition|)
block|{
name|longest
operator|=
name|bytes
operator|.
name|length
expr_stmt|;
name|longestChars
operator|=
name|data
operator|.
name|length
argument_list|()
expr_stmt|;
name|id
operator|=
name|d
operator|.
name|getId
argument_list|()
expr_stmt|;
block|}
block|}
name|String
name|m
init|=
name|String
operator|.
name|format
argument_list|(
literal|" (potential cause: long data for ID %s - longest octet DATA size in Java characters: %d, in octets: %d, computed character limit: %d)"
argument_list|,
name|id
argument_list|,
name|longest
argument_list|,
name|longestChars
argument_list|,
name|tmd
operator|.
name|getDataLimitInOctets
argument_list|()
operator|/
name|CHAR2OCTETRATIO
argument_list|)
decl_stmt|;
name|messages
operator|+=
name|m
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|messages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"additional diagnostics: "
operator|+
name|messages
argument_list|)
expr_stmt|;
block|}
throw|throw
name|handleException
argument_list|(
name|message
argument_list|,
name|ex
argument_list|,
name|collection
argument_list|,
name|ids
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
comment|// configuration
comment|// Whether to use GZIP compression
specifier|private
specifier|static
specifier|final
name|boolean
name|NOGZIP
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.NOGZIP"
argument_list|)
decl_stmt|;
comment|// Whether to use append operations (string concatenation) in the DATA column
specifier|private
specifier|static
specifier|final
name|boolean
name|NOAPPEND
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.NOAPPEND"
argument_list|)
decl_stmt|;
comment|// Number of documents to insert at once for batch create
specifier|private
specifier|static
specifier|final
name|int
name|CHUNKSIZE
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.CHUNKSIZE"
argument_list|,
literal|64
argument_list|)
decl_stmt|;
comment|// Number of query hits above which a diagnostic warning is generated
specifier|private
specifier|static
specifier|final
name|int
name|QUERYHITSLIMIT
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.QUERYHITSLIMIT"
argument_list|,
literal|4096
argument_list|)
decl_stmt|;
comment|// Number of elapsed ms in a query above which a diagnostic warning is generated
specifier|private
specifier|static
specifier|final
name|int
name|QUERYTIMELIMIT
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.QUERYTIMELIMIT"
argument_list|,
literal|10000
argument_list|)
decl_stmt|;
comment|// Whether to use JDBC batch commands for the createOrUpdate (default: true).
specifier|private
specifier|static
specifier|final
name|boolean
name|BATCHUPDATES
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.BATCHUPDATES"
argument_list|,
literal|"true"
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|byte
index|[]
name|asBytes
parameter_list|(
annotation|@
name|NotNull
name|String
name|data
parameter_list|)
block|{
name|byte
index|[]
name|bytes
decl_stmt|;
try|try
block|{
name|bytes
operator|=
name|data
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"UTF-8 not supported??"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|asDocumentStoreException
argument_list|(
name|ex
argument_list|,
literal|"UTF-8 not supported??"
argument_list|)
throw|;
block|}
if|if
condition|(
name|NOGZIP
condition|)
block|{
return|return
name|bytes
return|;
block|}
else|else
block|{
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|bytes
operator|.
name|length
operator|/
literal|2
argument_list|)
decl_stmt|;
try|try
init|(
name|GZIPOutputStream
name|gos
init|=
name|asGZIPOutputStream
argument_list|(
name|bos
argument_list|,
name|Deflater
operator|.
name|BEST_SPEED
argument_list|)
init|)
block|{
name|gos
operator|.
name|write
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|gos
operator|.
name|close
argument_list|()
expr_stmt|;
name|byte
index|[]
name|compressedBytes
init|=
name|bos
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|long
name|ratio
init|=
operator|(
literal|100L
operator|*
name|compressedBytes
operator|.
name|length
operator|)
operator|/
name|bytes
operator|.
name|length
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Gzipped {} bytes to {} ({}%)"
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
name|compressedBytes
operator|.
name|length
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
block|}
return|return
name|compressedBytes
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while gzipping contents"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|asDocumentStoreException
argument_list|(
name|ex
argument_list|,
literal|"Error while gzipping contents"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
specifier|static
name|GZIPOutputStream
name|asGZIPOutputStream
parameter_list|(
name|OutputStream
name|os
parameter_list|,
specifier|final
name|int
name|level
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|GZIPOutputStream
argument_list|(
name|os
argument_list|)
block|{
block|{
name|this
operator|.
name|def
operator|.
name|setLevel
parameter_list|(
name|level
parameter_list|)
constructor_decl|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setReadWriteMode
parameter_list|(
name|String
name|readWriteMode
parameter_list|)
block|{
comment|// ignored
block|}
specifier|public
name|void
name|setStatsCollector
parameter_list|(
name|DocumentStoreStatsCollector
name|stats
parameter_list|)
block|{
name|this
operator|.
name|stats
operator|=
name|stats
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|castAsT
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
operator|(
name|T
operator|)
name|doc
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|NodeDocument
argument_list|>
name|castAsNodeDocumentList
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
return|return
operator|(
name|List
argument_list|<
name|NodeDocument
argument_list|>
operator|)
name|list
return|;
block|}
specifier|private
name|NodeDocumentCache
name|nodesCache
decl_stmt|;
specifier|private
name|NodeDocumentLocks
name|locks
decl_stmt|;
annotation|@
name|Nullable
specifier|private
specifier|static
name|NodeDocument
name|unwrap
parameter_list|(
annotation|@
name|NotNull
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|==
name|NodeDocument
operator|.
name|NULL
condition|?
literal|null
else|:
name|doc
return|;
block|}
annotation|@
name|NotNull
specifier|private
specifier|static
name|NodeDocument
name|wrap
parameter_list|(
annotation|@
name|Nullable
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|==
literal|null
condition|?
name|NodeDocument
operator|.
name|NULL
else|:
name|doc
return|;
block|}
annotation|@
name|NotNull
specifier|private
specifier|static
name|String
name|idOf
parameter_list|(
annotation|@
name|NotNull
name|Document
name|doc
parameter_list|)
block|{
name|String
name|id
init|=
name|doc
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"non-null ID expected"
argument_list|)
throw|;
block|}
return|return
name|id
return|;
block|}
specifier|private
specifier|static
name|long
name|modcountOf
parameter_list|(
annotation|@
name|NotNull
name|Document
name|doc
parameter_list|)
block|{
name|Long
name|n
init|=
name|doc
operator|.
name|getModCount
argument_list|()
decl_stmt|;
return|return
name|n
operator|!=
literal|null
condition|?
name|n
else|:
operator|-
literal|1
return|;
block|}
specifier|private
specifier|static
name|long
name|modifiedOf
parameter_list|(
annotation|@
name|NotNull
name|Document
name|doc
parameter_list|)
block|{
name|Object
name|l
init|=
name|doc
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|MODIFIED_IN_SECS
argument_list|)
decl_stmt|;
return|return
operator|(
name|l
operator|instanceof
name|Long
operator|)
condition|?
operator|(
operator|(
name|Long
operator|)
name|l
operator|)
operator|.
name|longValue
argument_list|()
else|:
operator|-
literal|1
return|;
block|}
annotation|@
name|NotNull
specifier|protected
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|convertFromDBObject
parameter_list|(
annotation|@
name|NotNull
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
annotation|@
name|NotNull
name|RDBRow
name|row
parameter_list|)
block|{
comment|// this method is present here in order to facilitate unit testing for OAK-3566
return|return
name|ser
operator|.
name|fromRow
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|hasChangesToCollisions
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
if|if
condition|(
operator|!
name|USECMODCOUNT
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|,
name|Operation
argument_list|>
name|e
range|:
name|checkNotNull
argument_list|(
name|update
argument_list|)
operator|.
name|getChanges
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Key
name|k
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Operation
name|op
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|type
operator|==
name|Operation
operator|.
name|Type
operator|.
name|SET_MAP_ENTRY
condition|)
block|{
if|if
condition|(
name|NodeDocument
operator|.
name|COLLISIONS
operator|.
name|equals
argument_list|(
name|k
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|NotNull
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|String
name|dumpKeysAndModcounts
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|docs
parameter_list|)
block|{
if|if
condition|(
name|docs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|"-"
return|;
block|}
else|else
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|e
range|:
name|docs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Long
name|mc
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getModCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s (%s)"
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|mc
operator|==
literal|null
condition|?
literal|""
else|:
name|mc
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|// keeping track of CLUSTER_NODES updates
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|cnUpdates
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|maintainUpdateStats
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|CLUSTER_NODES
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|Long
name|old
init|=
name|cnUpdates
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|old
operator|=
name|old
operator|==
literal|null
condition|?
name|Long
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|)
else|:
name|old
operator|+
literal|1
expr_stmt|;
name|cnUpdates
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|String
name|getCnStats
parameter_list|()
block|{
if|if
condition|(
name|cnUpdates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|""
return|;
block|}
else|else
block|{
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|tmp
init|=
operator|new
name|ArrayList
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|tmp
operator|.
name|addAll
argument_list|(
name|cnUpdates
operator|.
name|entrySet
argument_list|()
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|tmp
argument_list|,
operator|new
name|Comparator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|o1
parameter_list|,
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|getKey
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getKey
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
literal|" (Cluster Node updates: "
operator|+
name|tmp
operator|.
name|toString
argument_list|()
operator|+
literal|")"
return|;
block|}
block|}
specifier|private
name|Stopwatch
name|startWatch
parameter_list|()
block|{
return|return
name|Stopwatch
operator|.
name|createStarted
argument_list|()
return|;
block|}
specifier|protected
name|NodeDocumentCache
name|getNodeDocumentCache
parameter_list|()
block|{
return|return
name|nodesCache
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|DocumentStoreException
name|handleException
parameter_list|(
name|String
name|message
parameter_list|,
name|Exception
name|ex
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|java
operator|.
name|util
operator|.
name|Collection
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|asDocumentStoreException
argument_list|(
name|ex
argument_list|,
name|message
argument_list|)
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|DocumentStoreException
name|handleException
parameter_list|(
name|String
name|message
parameter_list|,
name|Exception
name|ex
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
return|return
name|handleException
argument_list|(
name|message
argument_list|,
name|ex
argument_list|,
name|collection
argument_list|,
name|Collections
operator|.
name|singleton
argument_list|(
name|id
argument_list|)
argument_list|)
return|;
block|}
specifier|protected
class|class
name|UnsupportedIndexedPropertyException
extends|extends
name|DocumentStoreException
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|8392572622365260105L
decl_stmt|;
specifier|public
name|UnsupportedIndexedPropertyException
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|CacheLock
name|acquireLockFor
parameter_list|(
name|String
name|id
parameter_list|)
block|{
return|return
operator|new
name|CacheLock
argument_list|(
name|this
operator|.
name|locks
argument_list|,
name|id
argument_list|)
return|;
block|}
specifier|private
specifier|static
class|class
name|CacheLock
implements|implements
name|AutoCloseable
block|{
specifier|private
specifier|final
name|Lock
name|lock
decl_stmt|;
specifier|public
name|CacheLock
parameter_list|(
name|NodeDocumentLocks
name|locks
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|=
name|locks
operator|.
name|acquire
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// slightly extended query support
specifier|protected
specifier|static
class|class
name|QueryCondition
block|{
specifier|private
specifier|final
name|String
name|propertyName
decl_stmt|,
name|operator
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|operands
decl_stmt|;
specifier|public
name|QueryCondition
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|operator
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|this
operator|.
name|propertyName
operator|=
name|propertyName
expr_stmt|;
name|this
operator|.
name|operator
operator|=
name|operator
expr_stmt|;
name|this
operator|.
name|operands
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
specifier|public
name|QueryCondition
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|operator
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|values
parameter_list|)
block|{
name|this
operator|.
name|propertyName
operator|=
name|propertyName
expr_stmt|;
name|this
operator|.
name|operator
operator|=
name|operator
expr_stmt|;
name|this
operator|.
name|operands
operator|=
name|values
expr_stmt|;
block|}
specifier|public
name|QueryCondition
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|operator
parameter_list|)
block|{
name|this
operator|.
name|propertyName
operator|=
name|propertyName
expr_stmt|;
name|this
operator|.
name|operator
operator|=
name|operator
expr_stmt|;
name|this
operator|.
name|operands
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
specifier|public
name|String
name|getPropertyName
parameter_list|()
block|{
return|return
name|propertyName
return|;
block|}
specifier|public
name|String
name|getOperator
parameter_list|()
block|{
return|return
name|operator
return|;
block|}
specifier|public
name|List
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|getOperands
parameter_list|()
block|{
return|return
name|this
operator|.
name|operands
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|operands
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s %s"
argument_list|,
name|propertyName
argument_list|,
name|operator
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s %s %s"
argument_list|,
name|propertyName
argument_list|,
name|operator
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s %s %s"
argument_list|,
name|propertyName
argument_list|,
name|operator
argument_list|,
name|operands
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
block|}
end_class

end_unit

