begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|AstElementFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|BindVariableValueImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|ColumnImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|ConstraintImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|DynamicOperandImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|JoinConditionImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|JoinType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|LiteralImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|OrderingImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|PropertyExistenceImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|PropertyValueImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|SelectorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|SourceImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|StaticOperandImpl
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_comment
comment|/**  * The SQL2 parser can convert a JCR-SQL2 query to a query.  */
end_comment

begin_class
specifier|public
class|class
name|SQL2Parser
block|{
comment|// Character types, used during the tokenizer phase
specifier|private
specifier|static
specifier|final
name|int
name|CHAR_END
init|=
operator|-
literal|1
decl_stmt|,
name|CHAR_VALUE
init|=
literal|2
decl_stmt|,
name|CHAR_QUOTED
init|=
literal|3
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CHAR_NAME
init|=
literal|4
decl_stmt|,
name|CHAR_SPECIAL_1
init|=
literal|5
decl_stmt|,
name|CHAR_SPECIAL_2
init|=
literal|6
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CHAR_STRING
init|=
literal|7
decl_stmt|,
name|CHAR_DECIMAL
init|=
literal|8
decl_stmt|;
comment|// Token types
specifier|private
specifier|static
specifier|final
name|int
name|KEYWORD
init|=
literal|1
decl_stmt|,
name|IDENTIFIER
init|=
literal|2
decl_stmt|,
name|PARAMETER
init|=
literal|3
decl_stmt|,
name|END
init|=
literal|4
decl_stmt|,
name|VALUE
init|=
literal|5
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MINUS
init|=
literal|12
decl_stmt|,
name|PLUS
init|=
literal|13
decl_stmt|,
name|OPEN
init|=
literal|14
decl_stmt|,
name|CLOSE
init|=
literal|15
decl_stmt|;
comment|// The query as an array of characters and character types
specifier|private
name|String
name|statement
decl_stmt|;
specifier|private
name|char
index|[]
name|statementChars
decl_stmt|;
specifier|private
name|int
index|[]
name|characterTypes
decl_stmt|;
comment|// The current state of the parser
specifier|private
name|int
name|parseIndex
decl_stmt|;
specifier|private
name|int
name|currentTokenType
decl_stmt|;
specifier|private
name|String
name|currentToken
decl_stmt|;
specifier|private
name|boolean
name|currentTokenQuoted
decl_stmt|;
specifier|private
name|CoreValue
name|currentValue
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|String
argument_list|>
name|expected
decl_stmt|;
comment|// The bind variables
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|BindVariableValueImpl
argument_list|>
name|bindVariables
decl_stmt|;
comment|// The list of selectors of this query
specifier|private
name|ArrayList
argument_list|<
name|SelectorImpl
argument_list|>
name|selectors
decl_stmt|;
comment|// SQL injection protection: if disabled, literals are not allowed
specifier|private
name|boolean
name|allowTextLiterals
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|allowNumberLiterals
init|=
literal|true
decl_stmt|;
specifier|private
specifier|final
name|AstElementFactory
name|factory
init|=
operator|new
name|AstElementFactory
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|CoreValueFactory
name|valueFactory
decl_stmt|;
comment|/**      * Create a new parser. A parser can be re-used, but it is not thread safe.      *      * @param valueFactory the value factory      */
specifier|public
name|SQL2Parser
parameter_list|(
name|CoreValueFactory
name|valueFactory
parameter_list|)
block|{
name|this
operator|.
name|valueFactory
operator|=
name|valueFactory
expr_stmt|;
block|}
comment|/**      * Parse the statement and return the query.      *      * @param query the query string      * @return the query      * @throws ParseException if parsing fails      */
specifier|public
name|Query
name|parse
parameter_list|(
name|String
name|query
parameter_list|)
throws|throws
name|ParseException
block|{
name|initialize
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|selectors
operator|=
operator|new
name|ArrayList
argument_list|<
name|SelectorImpl
argument_list|>
argument_list|()
expr_stmt|;
name|expected
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|bindVariables
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BindVariableValueImpl
argument_list|>
argument_list|()
expr_stmt|;
name|read
argument_list|()
expr_stmt|;
name|boolean
name|explain
init|=
name|readIf
argument_list|(
literal|"EXPLAIN"
argument_list|)
decl_stmt|;
name|read
argument_list|(
literal|"SELECT"
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ColumnOrWildcard
argument_list|>
name|list
init|=
name|parseColumns
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|"FROM"
argument_list|)
expr_stmt|;
name|SourceImpl
name|source
init|=
name|parseSource
argument_list|()
decl_stmt|;
name|ColumnImpl
index|[]
name|columnArray
init|=
name|resolveColumns
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|ConstraintImpl
name|constraint
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"WHERE"
argument_list|)
condition|)
block|{
name|constraint
operator|=
name|parseConstraint
argument_list|()
expr_stmt|;
block|}
name|OrderingImpl
index|[]
name|orderings
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"ORDER"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|"BY"
argument_list|)
expr_stmt|;
name|orderings
operator|=
name|parseOrder
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|currentToken
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"<end>"
argument_list|)
throw|;
block|}
name|Query
name|q
init|=
operator|new
name|Query
argument_list|(
name|source
argument_list|,
name|constraint
argument_list|,
name|orderings
argument_list|,
name|columnArray
argument_list|)
decl_stmt|;
name|q
operator|.
name|setExplain
argument_list|(
name|explain
argument_list|)
expr_stmt|;
name|q
operator|.
name|init
argument_list|()
expr_stmt|;
return|return
name|q
return|;
block|}
specifier|private
name|SelectorImpl
name|parseSelector
parameter_list|()
throws|throws
name|ParseException
block|{
name|String
name|nodeTypeName
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"AS"
argument_list|)
condition|)
block|{
name|String
name|selectorName
init|=
name|readName
argument_list|()
decl_stmt|;
return|return
name|factory
operator|.
name|selector
argument_list|(
name|nodeTypeName
argument_list|,
name|selectorName
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|factory
operator|.
name|selector
argument_list|(
name|nodeTypeName
argument_list|,
name|nodeTypeName
argument_list|)
return|;
block|}
block|}
specifier|private
name|String
name|readName
parameter_list|()
throws|throws
name|ParseException
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
if|if
condition|(
name|currentTokenType
operator|==
name|VALUE
condition|)
block|{
name|CoreValue
name|value
init|=
name|readString
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|value
operator|.
name|getString
argument_list|()
return|;
block|}
else|else
block|{
name|int
name|level
init|=
literal|1
decl_stmt|;
name|StringBuilder
name|buff
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|isToken
argument_list|(
literal|"]"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|--
name|level
operator|<=
literal|0
condition|)
block|{
name|read
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|isToken
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
name|level
operator|++
expr_stmt|;
block|}
name|buff
operator|.
name|append
argument_list|(
name|readAny
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|buff
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
else|else
block|{
return|return
name|readAny
argument_list|()
return|;
block|}
block|}
specifier|private
name|SourceImpl
name|parseSource
parameter_list|()
throws|throws
name|ParseException
block|{
name|SelectorImpl
name|selector
init|=
name|parseSelector
argument_list|()
decl_stmt|;
name|selectors
operator|.
name|add
argument_list|(
name|selector
argument_list|)
expr_stmt|;
name|SourceImpl
name|source
init|=
name|selector
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|JoinType
name|joinType
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"RIGHT"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|"OUTER"
argument_list|)
expr_stmt|;
name|joinType
operator|=
name|JoinType
operator|.
name|RIGHT_OUTER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"LEFT"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|"OUTER"
argument_list|)
expr_stmt|;
name|joinType
operator|=
name|JoinType
operator|.
name|LEFT_OUTER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"INNER"
argument_list|)
condition|)
block|{
name|joinType
operator|=
name|JoinType
operator|.
name|INNER
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|read
argument_list|(
literal|"JOIN"
argument_list|)
expr_stmt|;
name|selector
operator|=
name|parseSelector
argument_list|()
expr_stmt|;
name|selectors
operator|.
name|add
argument_list|(
name|selector
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|"ON"
argument_list|)
expr_stmt|;
name|JoinConditionImpl
name|on
init|=
name|parseJoinCondition
argument_list|()
decl_stmt|;
name|source
operator|=
name|factory
operator|.
name|join
argument_list|(
name|source
argument_list|,
name|selector
argument_list|,
name|joinType
argument_list|,
name|on
argument_list|)
expr_stmt|;
block|}
return|return
name|source
return|;
block|}
specifier|private
name|JoinConditionImpl
name|parseJoinCondition
parameter_list|()
throws|throws
name|ParseException
block|{
name|boolean
name|identifier
init|=
name|currentTokenType
operator|==
name|IDENTIFIER
decl_stmt|;
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
name|JoinConditionImpl
name|c
decl_stmt|;
if|if
condition|(
name|identifier
operator|&&
name|readIf
argument_list|(
literal|"("
argument_list|)
condition|)
block|{
if|if
condition|(
literal|"ISSAMENODE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|selector1
init|=
name|readName
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|String
name|selector2
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|sameNodeJoinCondition
argument_list|(
name|selector1
argument_list|,
name|selector2
argument_list|,
name|readPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO verify "." is correct
name|c
operator|=
name|factory
operator|.
name|sameNodeJoinCondition
argument_list|(
name|selector1
argument_list|,
name|selector2
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"ISCHILDNODE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|childSelector
init|=
name|readName
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|childNodeJoinCondition
argument_list|(
name|childSelector
argument_list|,
name|readName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"ISDESCENDANTNODE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|descendantSelector
init|=
name|readName
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|descendantNodeJoinCondition
argument_list|(
name|descendantSelector
argument_list|,
name|readName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"ISSAMENODE, ISCHILDNODE, or ISDESCENDANTNODE"
argument_list|)
throw|;
block|}
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
else|else
block|{
name|String
name|selector1
init|=
name|name
decl_stmt|;
name|read
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|String
name|property1
init|=
name|readName
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|String
name|selector2
init|=
name|readName
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
return|return
name|factory
operator|.
name|equiJoinCondition
argument_list|(
name|selector1
argument_list|,
name|property1
argument_list|,
name|selector2
argument_list|,
name|readName
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|private
name|ConstraintImpl
name|parseConstraint
parameter_list|()
throws|throws
name|ParseException
block|{
name|ConstraintImpl
name|a
init|=
name|parseAnd
argument_list|()
decl_stmt|;
while|while
condition|(
name|readIf
argument_list|(
literal|"OR"
argument_list|)
condition|)
block|{
name|a
operator|=
name|factory
operator|.
name|or
argument_list|(
name|a
argument_list|,
name|parseAnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
specifier|private
name|ConstraintImpl
name|parseAnd
parameter_list|()
throws|throws
name|ParseException
block|{
name|ConstraintImpl
name|a
init|=
name|parseCondition
argument_list|()
decl_stmt|;
while|while
condition|(
name|readIf
argument_list|(
literal|"AND"
argument_list|)
condition|)
block|{
name|a
operator|=
name|factory
operator|.
name|and
argument_list|(
name|a
argument_list|,
name|parseCondition
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
specifier|private
name|ConstraintImpl
name|parseCondition
parameter_list|()
throws|throws
name|ParseException
block|{
name|ConstraintImpl
name|a
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"NOT"
argument_list|)
condition|)
block|{
name|a
operator|=
name|factory
operator|.
name|not
argument_list|(
name|parseConstraint
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"("
argument_list|)
condition|)
block|{
name|a
operator|=
name|parseConstraint
argument_list|()
expr_stmt|;
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentTokenType
operator|==
name|IDENTIFIER
condition|)
block|{
name|String
name|identifier
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"("
argument_list|)
condition|)
block|{
name|a
operator|=
name|parseConditionFunctionIf
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|null
condition|)
block|{
name|DynamicOperandImpl
name|op
init|=
name|parseExpressionFunction
argument_list|(
name|identifier
argument_list|)
decl_stmt|;
name|a
operator|=
name|parseCondition
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|a
operator|=
name|parseCondition
argument_list|(
name|factory
operator|.
name|propertyValue
argument_list|(
name|identifier
argument_list|,
name|readName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|parseCondition
argument_list|(
name|factory
operator|.
name|propertyValue
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"["
operator|.
name|equals
argument_list|(
name|currentToken
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|a
operator|=
name|parseCondition
argument_list|(
name|factory
operator|.
name|propertyValue
argument_list|(
name|name
argument_list|,
name|readName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|parseCondition
argument_list|(
name|factory
operator|.
name|propertyValue
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
return|return
name|a
return|;
block|}
specifier|private
name|ConstraintImpl
name|parseCondition
parameter_list|(
name|DynamicOperandImpl
name|left
parameter_list|)
throws|throws
name|ParseException
block|{
name|ConstraintImpl
name|c
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"="
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|EQUAL
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"<>"
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|NOT_EQUAL
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|LESS_THAN
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|">"
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|GREATER_THAN
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"<="
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|LESS_OR_EQUAL
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|">="
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|GREATER_OR_EQUAL
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"LIKE"
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|LIKE
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"IS"
argument_list|)
condition|)
block|{
name|boolean
name|not
init|=
name|readIf
argument_list|(
literal|"NOT"
argument_list|)
decl_stmt|;
name|read
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|left
operator|instanceof
name|PropertyValueImpl
operator|)
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"propertyName (NOT NULL is only supported for properties)"
argument_list|)
throw|;
block|}
name|PropertyValueImpl
name|p
init|=
operator|(
name|PropertyValueImpl
operator|)
name|left
decl_stmt|;
name|c
operator|=
name|getPropertyExistence
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|not
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|not
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"NOT"
argument_list|)
condition|)
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"IS"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|left
operator|instanceof
name|PropertyValueImpl
operator|)
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Only property values can be tested for NOT IS NULL; got: "
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|parseIndex
argument_list|)
throw|;
block|}
name|PropertyValueImpl
name|pv
init|=
operator|(
name|PropertyValueImpl
operator|)
name|left
decl_stmt|;
name|c
operator|=
name|getPropertyExistence
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|read
argument_list|(
literal|"LIKE"
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|LIKE
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|not
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
return|return
name|c
return|;
block|}
specifier|private
name|PropertyExistenceImpl
name|getPropertyExistence
parameter_list|(
name|PropertyValueImpl
name|p
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
name|factory
operator|.
name|propertyExistence
argument_list|(
name|p
operator|.
name|getSelectorName
argument_list|()
argument_list|,
name|p
operator|.
name|getPropertyName
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|ConstraintImpl
name|parseConditionFunctionIf
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|ParseException
block|{
name|ConstraintImpl
name|c
decl_stmt|;
if|if
condition|(
literal|"CONTAINS"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|fullTextSearch
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|selector
init|=
name|name
decl_stmt|;
name|name
operator|=
name|readName
argument_list|()
expr_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|fullTextSearch
argument_list|(
name|selector
argument_list|,
name|name
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|fullTextSearch
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"ISSAMENODE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|sameNode
argument_list|(
name|name
argument_list|,
name|readPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|factory
operator|.
name|sameNode
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"ISCHILDNODE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|childNode
argument_list|(
name|name
argument_list|,
name|readPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|factory
operator|.
name|childNode
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"ISDESCENDANTNODE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|descendantNode
argument_list|(
name|name
argument_list|,
name|readPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|factory
operator|.
name|descendantNode
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
specifier|private
name|String
name|readPath
parameter_list|()
throws|throws
name|ParseException
block|{
return|return
name|readName
argument_list|()
return|;
block|}
specifier|private
name|DynamicOperandImpl
name|parseDynamicOperand
parameter_list|()
throws|throws
name|ParseException
block|{
name|boolean
name|identifier
init|=
name|currentTokenType
operator|==
name|IDENTIFIER
decl_stmt|;
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|identifier
operator|&&
name|readIf
argument_list|(
literal|"("
argument_list|)
condition|)
block|{
return|return
name|parseExpressionFunction
argument_list|(
name|name
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|parsePropertyValue
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
specifier|private
name|DynamicOperandImpl
name|parseExpressionFunction
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|ParseException
block|{
name|DynamicOperandImpl
name|op
decl_stmt|;
if|if
condition|(
literal|"LENGTH"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|op
operator|=
name|factory
operator|.
name|length
argument_list|(
name|parsePropertyValue
argument_list|(
name|readName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"NAME"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
if|if
condition|(
name|isToken
argument_list|(
literal|")"
argument_list|)
condition|)
block|{
name|op
operator|=
name|factory
operator|.
name|nodeName
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|factory
operator|.
name|nodeName
argument_list|(
name|readName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"LOCALNAME"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
if|if
condition|(
name|isToken
argument_list|(
literal|")"
argument_list|)
condition|)
block|{
name|op
operator|=
name|factory
operator|.
name|nodeLocalName
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|factory
operator|.
name|nodeLocalName
argument_list|(
name|readName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"SCORE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
if|if
condition|(
name|isToken
argument_list|(
literal|")"
argument_list|)
condition|)
block|{
name|op
operator|=
name|factory
operator|.
name|fullTextSearchScore
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|factory
operator|.
name|fullTextSearchScore
argument_list|(
name|readName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"LOWER"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|op
operator|=
name|factory
operator|.
name|lowerCase
argument_list|(
name|parseDynamicOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"UPPER"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|op
operator|=
name|factory
operator|.
name|upperCase
argument_list|(
name|parseDynamicOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"LENGTH, NAME, LOCALNAME, SCORE, LOWER, UPPER, or CAST"
argument_list|)
throw|;
block|}
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
specifier|private
name|PropertyValueImpl
name|parsePropertyValue
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
return|return
name|factory
operator|.
name|propertyValue
argument_list|(
name|name
argument_list|,
name|readName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|factory
operator|.
name|propertyValue
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|)
return|;
block|}
block|}
specifier|private
name|StaticOperandImpl
name|parseStaticOperand
parameter_list|()
throws|throws
name|ParseException
block|{
if|if
condition|(
name|currentTokenType
operator|==
name|PLUS
condition|)
block|{
name|read
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentTokenType
operator|==
name|MINUS
condition|)
block|{
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentTokenType
operator|!=
name|VALUE
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"number"
argument_list|)
throw|;
block|}
name|int
name|valueType
init|=
name|currentValue
operator|.
name|getType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|valueType
condition|)
block|{
case|case
name|CoreValue
operator|.
name|LONG
case|:
name|currentValue
operator|=
name|valueFactory
operator|.
name|createValue
argument_list|(
operator|-
name|currentValue
operator|.
name|getLong
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CoreValue
operator|.
name|DOUBLE
case|:
name|currentValue
operator|=
name|valueFactory
operator|.
name|createValue
argument_list|(
operator|-
name|currentValue
operator|.
name|getDouble
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CoreValue
operator|.
name|BOOLEAN
case|:
name|currentValue
operator|=
name|valueFactory
operator|.
name|createValue
argument_list|(
operator|!
name|currentValue
operator|.
name|getBoolean
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CoreValue
operator|.
name|DECIMAL
case|:
name|currentValue
operator|=
name|valueFactory
operator|.
name|createValue
argument_list|(
name|currentValue
operator|.
name|getDecimal
argument_list|()
operator|.
name|negate
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|getSyntaxError
argument_list|(
literal|"Illegal operation: -"
operator|+
name|currentValue
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|currentTokenType
operator|==
name|VALUE
condition|)
block|{
name|LiteralImpl
name|literal
init|=
name|getUncastLiteral
argument_list|(
name|currentValue
argument_list|)
decl_stmt|;
name|read
argument_list|()
expr_stmt|;
return|return
name|literal
return|;
block|}
elseif|else
if|if
condition|(
name|currentTokenType
operator|==
name|PARAMETER
condition|)
block|{
name|read
argument_list|()
expr_stmt|;
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|":"
argument_list|)
condition|)
block|{
name|name
operator|=
name|name
operator|+
literal|':'
operator|+
name|readName
argument_list|()
expr_stmt|;
block|}
name|BindVariableValueImpl
name|var
init|=
name|bindVariables
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|var
operator|==
literal|null
condition|)
block|{
name|var
operator|=
name|factory
operator|.
name|bindVariable
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|bindVariables
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
return|return
name|var
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"TRUE"
argument_list|)
condition|)
block|{
name|LiteralImpl
name|literal
init|=
name|getUncastLiteral
argument_list|(
name|valueFactory
operator|.
name|createValue
argument_list|(
literal|true
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|literal
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"FALSE"
argument_list|)
condition|)
block|{
name|LiteralImpl
name|literal
init|=
name|getUncastLiteral
argument_list|(
name|valueFactory
operator|.
name|createValue
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|literal
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"CAST"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|StaticOperandImpl
name|op
init|=
name|parseStaticOperand
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|op
operator|instanceof
name|LiteralImpl
operator|)
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"literal"
argument_list|)
throw|;
block|}
name|LiteralImpl
name|literal
init|=
operator|(
name|LiteralImpl
operator|)
name|op
decl_stmt|;
name|CoreValue
name|value
init|=
name|literal
operator|.
name|getLiteralValue
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|"AS"
argument_list|)
expr_stmt|;
name|value
operator|=
name|parseCastAs
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
comment|// CastLiteral
name|literal
operator|=
name|factory
operator|.
name|literal
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|literal
return|;
block|}
else|else
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"static operand"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Create a literal from a parsed value.      *      * @param value the original value      * @return the literal      */
specifier|private
name|LiteralImpl
name|getUncastLiteral
parameter_list|(
name|CoreValue
name|value
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
name|factory
operator|.
name|literal
argument_list|(
name|value
argument_list|)
return|;
block|}
specifier|private
name|CoreValue
name|parseCastAs
parameter_list|(
name|CoreValue
name|value
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"STRING"
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createValue
argument_list|(
name|value
operator|.
name|getString
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"BINARY"
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createValue
argument_list|(
name|value
operator|.
name|getBinary
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"DATE"
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createValue
argument_list|(
name|value
operator|.
name|getDate
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"LONG"
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createValue
argument_list|(
name|value
operator|.
name|getLong
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"DOUBLE"
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createValue
argument_list|(
name|value
operator|.
name|getDouble
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"DECIMAL"
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createValue
argument_list|(
name|value
operator|.
name|getDecimal
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"BOOLEAN"
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createValue
argument_list|(
name|value
operator|.
name|getBoolean
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"NAME"
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createValue
argument_list|(
name|value
operator|.
name|getString
argument_list|()
argument_list|,
name|CoreValue
operator|.
name|NAME
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"PATH"
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createValue
argument_list|(
name|value
operator|.
name|getString
argument_list|()
argument_list|,
name|CoreValue
operator|.
name|PATH
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"REFERENCE"
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createValue
argument_list|(
name|value
operator|.
name|getString
argument_list|()
argument_list|,
name|CoreValue
operator|.
name|REFERENCE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"WEAKREFERENCE"
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createValue
argument_list|(
name|value
operator|.
name|getString
argument_list|()
argument_list|,
name|CoreValue
operator|.
name|WEAKREFERENCE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"URI"
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createValue
argument_list|(
name|value
operator|.
name|getString
argument_list|()
argument_list|,
name|CoreValue
operator|.
name|URI
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"data type (STRING|BINARY|...)"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|OrderingImpl
index|[]
name|parseOrder
parameter_list|()
throws|throws
name|ParseException
block|{
name|ArrayList
argument_list|<
name|OrderingImpl
argument_list|>
name|orderList
init|=
operator|new
name|ArrayList
argument_list|<
name|OrderingImpl
argument_list|>
argument_list|()
decl_stmt|;
do|do
block|{
name|OrderingImpl
name|ordering
decl_stmt|;
name|DynamicOperandImpl
name|op
init|=
name|parseDynamicOperand
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"DESC"
argument_list|)
condition|)
block|{
name|ordering
operator|=
name|factory
operator|.
name|descending
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|readIf
argument_list|(
literal|"ASC"
argument_list|)
expr_stmt|;
name|ordering
operator|=
name|factory
operator|.
name|ascending
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
name|orderList
operator|.
name|add
argument_list|(
name|ordering
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
do|;
name|OrderingImpl
index|[]
name|orderings
init|=
operator|new
name|OrderingImpl
index|[
name|orderList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|orderList
operator|.
name|toArray
argument_list|(
name|orderings
argument_list|)
expr_stmt|;
return|return
name|orderings
return|;
block|}
specifier|private
name|ArrayList
argument_list|<
name|ColumnOrWildcard
argument_list|>
name|parseColumns
parameter_list|()
throws|throws
name|ParseException
block|{
name|ArrayList
argument_list|<
name|ColumnOrWildcard
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnOrWildcard
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
operator|new
name|ColumnOrWildcard
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|ColumnOrWildcard
name|column
init|=
operator|new
name|ColumnOrWildcard
argument_list|()
decl_stmt|;
name|column
operator|.
name|propertyName
operator|=
name|readName
argument_list|()
expr_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|column
operator|.
name|selectorName
operator|=
name|column
operator|.
name|propertyName
expr_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|column
operator|.
name|propertyName
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|column
operator|.
name|propertyName
operator|=
name|readName
argument_list|()
expr_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"AS"
argument_list|)
condition|)
block|{
name|column
operator|.
name|columnName
operator|=
name|readName
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"AS"
argument_list|)
condition|)
block|{
name|column
operator|.
name|columnName
operator|=
name|readName
argument_list|()
expr_stmt|;
block|}
block|}
name|list
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
do|;
block|}
return|return
name|list
return|;
block|}
specifier|private
name|ColumnImpl
index|[]
name|resolveColumns
parameter_list|(
name|ArrayList
argument_list|<
name|ColumnOrWildcard
argument_list|>
name|list
parameter_list|)
throws|throws
name|ParseException
block|{
name|ArrayList
argument_list|<
name|ColumnImpl
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnImpl
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnOrWildcard
name|c
range|:
name|list
control|)
block|{
if|if
condition|(
name|c
operator|.
name|propertyName
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|SelectorImpl
name|selector
range|:
name|selectors
control|)
block|{
if|if
condition|(
name|c
operator|.
name|selectorName
operator|==
literal|null
operator|||
name|c
operator|.
name|selectorName
operator|.
name|equals
argument_list|(
name|selector
operator|.
name|getSelectorName
argument_list|()
argument_list|)
condition|)
block|{
name|ColumnImpl
name|column
init|=
name|factory
operator|.
name|column
argument_list|(
name|selector
operator|.
name|getSelectorName
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|columns
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ColumnImpl
name|column
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|selectorName
operator|!=
literal|null
condition|)
block|{
name|column
operator|=
name|factory
operator|.
name|column
argument_list|(
name|c
operator|.
name|selectorName
argument_list|,
name|c
operator|.
name|propertyName
argument_list|,
name|c
operator|.
name|columnName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|columnName
operator|!=
literal|null
condition|)
block|{
name|column
operator|=
name|factory
operator|.
name|column
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|c
operator|.
name|propertyName
argument_list|,
name|c
operator|.
name|columnName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|column
operator|=
name|factory
operator|.
name|column
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|c
operator|.
name|propertyName
argument_list|,
name|c
operator|.
name|propertyName
argument_list|)
expr_stmt|;
block|}
name|columns
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
block|}
name|ColumnImpl
index|[]
name|array
init|=
operator|new
name|ColumnImpl
index|[
name|columns
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|columns
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
specifier|private
name|boolean
name|readIf
parameter_list|(
name|String
name|token
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|isToken
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|read
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|isToken
parameter_list|(
name|String
name|token
parameter_list|)
block|{
name|boolean
name|result
init|=
name|token
operator|.
name|equalsIgnoreCase
argument_list|(
name|currentToken
argument_list|)
operator|&&
operator|!
name|currentTokenQuoted
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
return|return
literal|true
return|;
block|}
name|addExpected
argument_list|(
name|token
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|read
parameter_list|(
name|String
name|expected
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
operator|!
name|expected
operator|.
name|equalsIgnoreCase
argument_list|(
name|currentToken
argument_list|)
operator|||
name|currentTokenQuoted
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
name|expected
argument_list|)
throw|;
block|}
name|read
argument_list|()
expr_stmt|;
block|}
specifier|private
name|String
name|readAny
parameter_list|()
throws|throws
name|ParseException
block|{
if|if
condition|(
name|currentTokenType
operator|==
name|END
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"a token"
argument_list|)
throw|;
block|}
name|String
name|s
decl_stmt|;
if|if
condition|(
name|currentTokenType
operator|==
name|VALUE
condition|)
block|{
name|s
operator|=
name|currentValue
operator|.
name|getString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|currentToken
expr_stmt|;
block|}
name|read
argument_list|()
expr_stmt|;
return|return
name|s
return|;
block|}
specifier|private
name|CoreValue
name|readString
parameter_list|()
throws|throws
name|ParseException
block|{
if|if
condition|(
name|currentTokenType
operator|!=
name|VALUE
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"string value"
argument_list|)
throw|;
block|}
name|CoreValue
name|value
init|=
name|currentValue
decl_stmt|;
name|read
argument_list|()
expr_stmt|;
return|return
name|value
return|;
block|}
specifier|private
name|void
name|addExpected
parameter_list|(
name|String
name|token
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|!=
literal|null
condition|)
block|{
name|expected
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|initialize
parameter_list|(
name|String
name|query
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|query
operator|==
literal|null
condition|)
block|{
name|query
operator|=
literal|""
expr_stmt|;
block|}
name|statement
operator|=
name|query
expr_stmt|;
name|int
name|len
init|=
name|query
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
name|char
index|[]
name|command
init|=
operator|new
name|char
index|[
name|len
index|]
decl_stmt|;
name|int
index|[]
name|types
init|=
operator|new
name|int
index|[
name|len
index|]
decl_stmt|;
name|len
operator|--
expr_stmt|;
name|query
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|len
argument_list|,
name|command
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|command
index|[
name|len
index|]
operator|=
literal|' '
expr_stmt|;
name|int
name|startLoop
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|command
index|[
name|i
index|]
decl_stmt|;
name|int
name|type
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
case|case
literal|'-'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|'*'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
case|case
literal|'+'
case|:
case|case
literal|'%'
case|:
case|case
literal|'?'
case|:
case|case
literal|'$'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
name|type
operator|=
name|CHAR_SPECIAL_1
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'|'
case|:
case|case
literal|'='
case|:
case|case
literal|':'
case|:
name|type
operator|=
name|CHAR_SPECIAL_2
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|type
operator|=
name|CHAR_DECIMAL
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|type
operator|=
name|CHAR_STRING
expr_stmt|;
name|types
index|[
name|i
index|]
operator|=
name|CHAR_STRING
expr_stmt|;
name|startLoop
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|command
index|[
operator|++
name|i
index|]
operator|!=
literal|'\''
condition|)
block|{
name|checkRunOver
argument_list|(
name|i
argument_list|,
name|len
argument_list|,
name|startLoop
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
name|type
operator|=
name|CHAR_QUOTED
expr_stmt|;
name|types
index|[
name|i
index|]
operator|=
name|CHAR_QUOTED
expr_stmt|;
name|startLoop
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|command
index|[
operator|++
name|i
index|]
operator|!=
literal|'\"'
condition|)
block|{
name|checkRunOver
argument_list|(
name|i
argument_list|,
name|len
argument_list|,
name|startLoop
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'_'
case|:
name|type
operator|=
name|CHAR_NAME
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
block|{
name|type
operator|=
name|CHAR_NAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
block|{
name|type
operator|=
name|CHAR_NAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|type
operator|=
name|CHAR_VALUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|type
operator|=
name|CHAR_NAME
expr_stmt|;
block|}
block|}
block|}
name|types
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|type
expr_stmt|;
block|}
name|statementChars
operator|=
name|command
expr_stmt|;
name|types
index|[
name|len
index|]
operator|=
name|CHAR_END
expr_stmt|;
name|characterTypes
operator|=
name|types
expr_stmt|;
name|parseIndex
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
name|void
name|checkRunOver
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|startLoop
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|i
operator|>=
name|len
condition|)
block|{
name|parseIndex
operator|=
name|startLoop
expr_stmt|;
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
block|}
specifier|private
name|void
name|read
parameter_list|()
throws|throws
name|ParseException
block|{
name|currentTokenQuoted
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|expected
operator|!=
literal|null
condition|)
block|{
name|expected
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|int
index|[]
name|types
init|=
name|characterTypes
decl_stmt|;
name|int
name|i
init|=
name|parseIndex
decl_stmt|;
name|int
name|type
init|=
name|types
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|types
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
name|int
name|start
init|=
name|i
decl_stmt|;
name|char
index|[]
name|chars
init|=
name|statementChars
decl_stmt|;
name|char
name|c
init|=
name|chars
index|[
name|i
operator|++
index|]
decl_stmt|;
name|currentToken
operator|=
literal|""
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CHAR_NAME
case|:
while|while
condition|(
literal|true
condition|)
block|{
name|type
operator|=
name|types
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|CHAR_NAME
operator|&&
name|type
operator|!=
name|CHAR_VALUE
condition|)
block|{
name|c
operator|=
name|chars
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|currentToken
operator|=
name|statement
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentToken
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
name|currentTokenType
operator|=
name|IDENTIFIER
expr_stmt|;
name|parseIndex
operator|=
name|i
expr_stmt|;
return|return;
case|case
name|CHAR_SPECIAL_2
case|:
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
name|CHAR_SPECIAL_2
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
comment|// fall through
case|case
name|CHAR_SPECIAL_1
case|:
name|currentToken
operator|=
name|statement
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'$'
case|:
name|currentTokenType
operator|=
name|PARAMETER
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|currentTokenType
operator|=
name|PLUS
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|currentTokenType
operator|=
name|MINUS
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|currentTokenType
operator|=
name|OPEN
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|currentTokenType
operator|=
name|CLOSE
expr_stmt|;
break|break;
default|default:
name|currentTokenType
operator|=
name|KEYWORD
expr_stmt|;
block|}
name|parseIndex
operator|=
name|i
expr_stmt|;
return|return;
case|case
name|CHAR_VALUE
case|:
name|long
name|number
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|c
operator|=
name|chars
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
argument_list|<
literal|'0'
operator|||
name|c
argument_list|>
literal|'9'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|readDecimal
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'e'
condition|)
block|{
name|readDecimal
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|checkLiterals
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|currentValue
operator|=
name|valueFactory
operator|.
name|createValue
argument_list|(
name|number
argument_list|)
expr_stmt|;
name|currentTokenType
operator|=
name|VALUE
expr_stmt|;
name|currentToken
operator|=
literal|"0"
expr_stmt|;
name|parseIndex
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|number
operator|=
name|number
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|number
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|readDecimal
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return;
case|case
name|CHAR_DECIMAL
case|:
if|if
condition|(
name|types
index|[
name|i
index|]
operator|!=
name|CHAR_VALUE
condition|)
block|{
name|currentTokenType
operator|=
name|KEYWORD
expr_stmt|;
name|currentToken
operator|=
literal|"."
expr_stmt|;
name|parseIndex
operator|=
name|i
expr_stmt|;
return|return;
block|}
name|readDecimal
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
name|CHAR_STRING
case|:
name|readString
argument_list|(
name|i
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
return|return;
case|case
name|CHAR_QUOTED
case|:
name|readString
argument_list|(
name|i
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
return|return;
case|case
name|CHAR_END
case|:
name|currentToken
operator|=
literal|""
expr_stmt|;
name|currentTokenType
operator|=
name|END
expr_stmt|;
name|parseIndex
operator|=
name|i
expr_stmt|;
return|return;
default|default:
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
block|}
specifier|private
name|void
name|readString
parameter_list|(
name|int
name|i
parameter_list|,
name|char
name|end
parameter_list|)
throws|throws
name|ParseException
block|{
name|char
index|[]
name|chars
init|=
name|statementChars
decl_stmt|;
name|String
name|result
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
for|for
control|(
name|int
name|begin
init|=
name|i
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chars
index|[
name|i
index|]
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|statement
operator|.
name|substring
argument_list|(
name|begin
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|+=
name|statement
operator|.
name|substring
argument_list|(
name|begin
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|chars
index|[
operator|++
name|i
index|]
operator|!=
name|end
condition|)
block|{
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|currentToken
operator|=
literal|"'"
expr_stmt|;
name|checkLiterals
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|currentValue
operator|=
name|valueFactory
operator|.
name|createValue
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|parseIndex
operator|=
name|i
expr_stmt|;
name|currentTokenType
operator|=
name|VALUE
expr_stmt|;
block|}
specifier|private
name|void
name|checkLiterals
parameter_list|(
name|boolean
name|text
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|text
operator|&&
operator|!
name|allowTextLiterals
operator|||
operator|!
name|text
operator|&&
operator|!
name|allowNumberLiterals
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"bind variable (literals of this type not allowed)"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|readDecimal
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|i
parameter_list|)
throws|throws
name|ParseException
block|{
name|char
index|[]
name|chars
init|=
name|statementChars
decl_stmt|;
name|int
index|[]
name|types
init|=
name|characterTypes
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|t
init|=
name|types
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|CHAR_DECIMAL
operator|&&
name|t
operator|!=
name|CHAR_VALUE
condition|)
block|{
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chars
index|[
name|i
index|]
operator|==
literal|'E'
operator|||
name|chars
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|chars
index|[
name|i
index|]
operator|==
literal|'+'
operator|||
name|chars
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|types
index|[
name|i
index|]
operator|!=
name|CHAR_VALUE
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
while|while
condition|(
name|types
index|[
operator|++
name|i
index|]
operator|==
name|CHAR_VALUE
condition|)
block|{
comment|// go until the first non-number
block|}
block|}
name|parseIndex
operator|=
name|i
expr_stmt|;
name|String
name|sub
init|=
name|statement
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|BigDecimal
name|bd
decl_stmt|;
try|try
block|{
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Data conversion error converting "
operator|+
name|sub
operator|+
literal|" to BigDecimal: "
operator|+
name|e
argument_list|,
name|parseIndex
argument_list|)
throw|;
block|}
name|checkLiterals
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|currentValue
operator|=
name|valueFactory
operator|.
name|createValue
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|currentTokenType
operator|=
name|VALUE
expr_stmt|;
block|}
specifier|private
name|ParseException
name|getSyntaxError
parameter_list|()
block|{
if|if
condition|(
name|expected
operator|==
literal|null
operator|||
name|expected
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|getSyntaxError
argument_list|(
literal|null
argument_list|)
return|;
block|}
else|else
block|{
name|StringBuilder
name|buff
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|exp
range|:
name|expected
control|)
block|{
if|if
condition|(
name|buff
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|buff
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|buff
operator|.
name|append
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
name|getSyntaxError
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|private
name|ParseException
name|getSyntaxError
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
name|int
name|index
init|=
name|Math
operator|.
name|min
argument_list|(
name|parseIndex
argument_list|,
name|statement
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|String
name|query
init|=
name|statement
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
operator|+
literal|"(*)"
operator|+
name|statement
operator|.
name|substring
argument_list|(
name|index
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|expected
operator|!=
literal|null
condition|)
block|{
name|query
operator|+=
literal|"; expected: "
operator|+
name|expected
expr_stmt|;
block|}
return|return
operator|new
name|ParseException
argument_list|(
literal|"Query:\n"
operator|+
name|query
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/**      * Represents a column or a wildcard in a SQL expression.      * This class is temporarily used during parsing.      */
specifier|static
class|class
name|ColumnOrWildcard
block|{
name|String
name|selectorName
decl_stmt|;
name|String
name|propertyName
decl_stmt|;
name|String
name|columnName
decl_stmt|;
block|}
comment|/**      * Get the selector name if only one selector exists in the query.      * If more than one selector exists, an exception is thrown.      *      * @return the selector name      */
specifier|private
name|String
name|getOnlySelectorName
parameter_list|()
throws|throws
name|ParseException
block|{
if|if
condition|(
name|selectors
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"Need to specify the selector name because the query contains more than one selector."
argument_list|)
throw|;
block|}
return|return
name|selectors
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getSelectorName
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|String
name|escapeStringLiteral
parameter_list|(
name|String
name|value
parameter_list|)
block|{
return|return
literal|'\''
operator|+
name|value
operator|.
name|replace
argument_list|(
literal|"'"
argument_list|,
literal|"''"
argument_list|)
operator|+
literal|'\''
return|;
block|}
specifier|public
name|void
name|setAllowTextLiterals
parameter_list|(
name|boolean
name|allowTextLiterals
parameter_list|)
block|{
name|this
operator|.
name|allowTextLiterals
operator|=
name|allowTextLiterals
expr_stmt|;
block|}
specifier|public
name|void
name|setAllowNumberLiterals
parameter_list|(
name|boolean
name|allowNumberLiterals
parameter_list|)
block|{
name|this
operator|.
name|allowNumberLiterals
operator|=
name|allowNumberLiterals
expr_stmt|;
block|}
block|}
end_class

end_unit

