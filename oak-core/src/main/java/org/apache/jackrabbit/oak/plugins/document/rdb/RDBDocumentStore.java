begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|rdb
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSetMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Deflater
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPOutputStream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|sql
operator|.
name|DataSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|cache
operator|.
name|CacheStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|cache
operator|.
name|CacheValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentMK
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentStoreException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Revision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|StableRevisionComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Key
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Operation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|cache
operator|.
name|CachingDocumentStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|mongo
operator|.
name|MongoDocumentStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|StringValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|Cache
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Striped
import|;
end_import

begin_comment
comment|/**  * Implementation of {@link CachingDocumentStore} for relational databases.  *   *<h3>Supported Databases</h3>  *<p>  * The code is supposed to be sufficiently generic to run with a variety of  * database implementations. However, the tables are created when required to  * simplify testing, and<em>that</em> code specifically supports these  * databases:  *<ul>  *<li>h2</li>  *<li>IBM DB2</li>  *<li>Postgres</li>  *<li>MariaDB (MySQL) (experimental)</li>  *<li>Oracle (experimental)</li>  *</ul>  *   *<h3>Table Layout</h3>  *<p>  * Data for each of the DocumentStore's {@link Collection}s is stored in its own  * database table (with a name matching the collection).  *<p>  * The tables essentially implement key/value storage, where the key usually is  * derived from an Oak path, and the value is a serialization of a  * {@link Document} (or a part of one). Additional fields are used for queries,  * debugging, and concurrency control:  *<table style="text-align: left;">  *<thead>  *<tr>  *<th>Column</th>  *<th>Type</th>  *<th>Description</th>  *</tr>  *</thead><tbody>  *<tr>  *<th>ID</th>  *<td>varchar(512) not null primary key</td>  *<td>the document's key</td>  *</tr>  *<tr>  *<th>MODIFIED</th>  *<td>bigint</td>  *<td>low-resolution timestamp  *</tr>  *<tr>  *<th>HASBINARY</th>  *<td>smallint</td>  *<td>flag indicating whether the document has binary properties  *</tr>  *<tr>  *<th>MODCOUNT</th>  *<td>bigint</td>  *<td>modification counter, used for avoiding overlapping updates</td>  *</tr>  *<tr>  *<th>DSIZE</th>  *<td>bigint</td>  *<td>the approximate  size of the document's JSON serialization (for debugging purposes)</td>  *</tr>  *<tr>  *<th>DATA</th>  *<td>varchar(16384)</td>  *<td>the document's JSON serialization (only used for small document sizes, in  * which case BDATA (below) is not set), or a sequence of JSON serialized update operations  * to be applied against the last full serialization</td>  *</tr>  *<tr>  *<th>BDATA</th>  *<td>blob</td>  *<td>the document's JSON serialization (usually GZIPped, only used for "large"  * documents)</td>  *</tr>  *</tbody>  *</table>  *<p>  * The names of database tables can be prefixed; the purpose is mainly for testing, as  * tables can also be dropped automatically when the store is disposed (this only happens  * for those tables that have been created on demand)  *<p>  *<em>Note that the database needs to be created/configured to support all Unicode  * characters in text fields, and to collate by Unicode code point (in DB2: "identity collation",  * in Postgres: "C").  * THIS IS NOT THE DEFAULT!</em>  *<p>  *<em>For MySQL, the database parameter "max_allowed_packet" needs to be increased to support ~2M blobs.</em>  *   *<h3>Caching</h3>  *<p>  * The cache borrows heavily from the {@link MongoDocumentStore} implementation;  * however it does not support the off-heap mechanism yet.  *   *<h3>Queries</h3>  *<p>  * The implementation currently supports only two indexed properties: "_modified" and  * "_bin". Attempts to use a different indexed property will cause a {@link DocumentStoreException}.  */
end_comment

begin_class
specifier|public
class|class
name|RDBDocumentStore
implements|implements
name|CachingDocumentStore
block|{
comment|/**      * Creates a {@linkplain RDBDocumentStore} instance using the provided      * {@link DataSource}, {@link DocumentMK.Builder}, and {@link RDBOptions}.      */
specifier|public
name|RDBDocumentStore
parameter_list|(
name|DataSource
name|ds
parameter_list|,
name|DocumentMK
operator|.
name|Builder
name|builder
parameter_list|,
name|RDBOptions
name|options
parameter_list|)
block|{
try|try
block|{
name|initialize
argument_list|(
name|ds
argument_list|,
name|builder
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"initializing RDB document store"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates a {@linkplain RDBDocumentStore} instance using the provided      * {@link DataSource}, {@link DocumentMK.Builder}, and default {@link RDBOptions}.      */
specifier|public
name|RDBDocumentStore
parameter_list|(
name|DataSource
name|ds
parameter_list|,
name|DocumentMK
operator|.
name|Builder
name|builder
parameter_list|)
block|{
name|this
argument_list|(
name|ds
argument_list|,
name|builder
argument_list|,
operator|new
name|RDBOptions
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|find
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
return|return
name|find
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|find
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
specifier|final
name|String
name|id
parameter_list|,
name|int
name|maxCacheAge
parameter_list|)
block|{
return|return
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|maxCacheAge
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|query
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|query
argument_list|(
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|query
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|String
name|indexedProperty
parameter_list|,
name|long
name|startValue
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|internalQuery
argument_list|(
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
name|indexedProperty
argument_list|,
name|startValue
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|remove
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|delete
argument_list|(
name|collection
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|remove
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
block|{
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|delete
argument_list|(
name|collection
argument_list|,
name|ids
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|create
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updateOps
parameter_list|)
block|{
return|return
name|internalCreate
argument_list|(
name|collection
argument_list|,
name|updateOps
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|update
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|,
name|UpdateOp
name|updateOp
parameter_list|)
block|{
name|internalUpdate
argument_list|(
name|collection
argument_list|,
name|keys
argument_list|,
name|updateOp
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|createOrUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
return|return
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|findAndUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
return|return
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|invalidateCache
parameter_list|()
block|{
name|nodesCache
operator|.
name|invalidateAll
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|invalidateCache
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|Lock
name|lock
init|=
name|getAndLock
argument_list|(
name|id
argument_list|)
decl_stmt|;
try|try
block|{
name|nodesCache
operator|.
name|invalidate
argument_list|(
operator|new
name|StringValue
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|dispose
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|tablesToBeDropped
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempting to drop: "
operator|+
name|this
operator|.
name|tablesToBeDropped
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|tname
range|:
name|this
operator|.
name|tablesToBeDropped
control|)
block|{
name|Connection
name|con
init|=
literal|null
decl_stmt|;
try|try
block|{
name|con
operator|=
name|getConnection
argument_list|()
expr_stmt|;
try|try
block|{
name|Statement
name|stmt
init|=
name|con
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
literal|"drop table "
operator|+
name|tname
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempting to drop: "
operator|+
name|tname
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempting to drop: "
operator|+
name|tname
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|con
operator|!=
literal|null
condition|)
block|{
name|con
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"on close "
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|this
operator|.
name|ds
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|getIfCached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|!=
name|Collection
operator|.
name|NODES
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|NodeDocument
name|doc
init|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
operator|new
name|StringValue
argument_list|(
name|id
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|castAsT
argument_list|(
name|doc
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|CacheStats
name|getCacheStats
parameter_list|()
block|{
return|return
name|this
operator|.
name|cacheStats
return|;
block|}
comment|// implementation
specifier|private
specifier|static
specifier|final
name|String
name|MODIFIED
init|=
literal|"_modified"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|MODCOUNT
init|=
literal|"_modCount"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ID
init|=
literal|"_id"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RDBDocumentStore
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Comparator
argument_list|<
name|Revision
argument_list|>
name|comparator
init|=
name|StableRevisionComparator
operator|.
name|REVERSE
decl_stmt|;
specifier|private
name|Exception
name|callStack
decl_stmt|;
specifier|private
name|DataSource
name|ds
decl_stmt|;
comment|// from options
specifier|private
name|String
name|tablePrefix
init|=
literal|""
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|tablesToBeDropped
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// ratio between Java characters and UTF-8 encoding
comment|// a) single characters will fit into 3 bytes
comment|// b) a surrogate pair (two Java characters) will fit into 4 bytes
comment|// thus...
specifier|private
specifier|static
name|int
name|CHAR2OCTETRATIO
init|=
literal|3
decl_stmt|;
comment|// capacity of DATA column
specifier|private
name|int
name|dataLimitInOctets
init|=
literal|16384
decl_stmt|;
comment|// number of retries for updates
specifier|private
specifier|static
name|int
name|RETRIES
init|=
literal|10
decl_stmt|;
comment|// for DBs that prefer "concat" over "||"
specifier|private
name|boolean
name|needsConcat
init|=
literal|false
decl_stmt|;
comment|// for DBs that prefer "limit" over "fetch first"
specifier|private
name|boolean
name|needsLimit
init|=
literal|false
decl_stmt|;
comment|// for DBs that do not support CASE in SELECT (currently all)
specifier|private
name|boolean
name|allowsCaseInSelect
init|=
literal|true
decl_stmt|;
comment|// set of supported indexed properties
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|INDEXEDPROPERTIES
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|MODIFIED
block|,
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
block|}
argument_list|)
argument_list|)
decl_stmt|;
comment|// set of properties not serialized to JSON
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|COLUMNPROPERTIES
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|ID
block|,
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
block|,
name|MODIFIED
block|,
name|MODCOUNT
block|}
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
name|RDBDocumentSerializer
name|SR
init|=
operator|new
name|RDBDocumentSerializer
argument_list|(
name|this
argument_list|,
name|COLUMNPROPERTIES
argument_list|)
decl_stmt|;
specifier|private
name|void
name|initialize
parameter_list|(
name|DataSource
name|ds
parameter_list|,
name|DocumentMK
operator|.
name|Builder
name|builder
parameter_list|,
name|RDBOptions
name|options
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|tablePrefix
operator|=
name|options
operator|.
name|getTablePrefix
argument_list|()
expr_stmt|;
if|if
condition|(
name|tablePrefix
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|tablePrefix
operator|.
name|endsWith
argument_list|(
literal|"_"
argument_list|)
condition|)
block|{
name|tablePrefix
operator|+=
literal|"_"
expr_stmt|;
block|}
name|this
operator|.
name|ds
operator|=
name|ds
expr_stmt|;
name|this
operator|.
name|callStack
operator|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|?
operator|new
name|Exception
argument_list|(
literal|"call stack of RDBDocumentStore creation"
argument_list|)
else|:
literal|null
expr_stmt|;
name|this
operator|.
name|nodesCache
operator|=
name|builder
operator|.
name|buildDocumentCache
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|cacheStats
operator|=
operator|new
name|CacheStats
argument_list|(
name|nodesCache
argument_list|,
literal|"Document-Documents"
argument_list|,
name|builder
operator|.
name|getWeigher
argument_list|()
argument_list|,
name|builder
operator|.
name|getDocumentCacheSize
argument_list|()
argument_list|)
expr_stmt|;
name|Connection
name|con
init|=
name|ds
operator|.
name|getConnection
argument_list|()
decl_stmt|;
name|String
name|dbtype
init|=
name|con
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDatabaseProductName
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"Oracle"
operator|.
name|equals
argument_list|(
name|dbtype
argument_list|)
condition|)
block|{
comment|// https://issues.apache.org/jira/browse/OAK-1914
comment|// for some reason, the default for NLS_SORT is incorrect
name|Statement
name|stmt
init|=
name|con
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
literal|"ALTER SESSION SET NLS_SORT='BINARY'"
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"MySQL"
operator|.
name|equals
argument_list|(
name|dbtype
argument_list|)
condition|)
block|{
name|this
operator|.
name|needsConcat
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|needsLimit
operator|=
literal|true
expr_stmt|;
block|}
try|try
block|{
name|con
operator|.
name|setAutoCommit
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|createTableFor
argument_list|(
name|con
argument_list|,
name|dbtype
argument_list|,
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
name|options
operator|.
name|isDropTablesOnClose
argument_list|()
argument_list|)
expr_stmt|;
name|createTableFor
argument_list|(
name|con
argument_list|,
name|dbtype
argument_list|,
name|Collection
operator|.
name|NODES
argument_list|,
name|options
operator|.
name|isDropTablesOnClose
argument_list|()
argument_list|)
expr_stmt|;
name|createTableFor
argument_list|(
name|con
argument_list|,
name|dbtype
argument_list|,
name|Collection
operator|.
name|SETTINGS
argument_list|,
name|options
operator|.
name|isDropTablesOnClose
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|con
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|createTableFor
parameter_list|(
name|Connection
name|con
parameter_list|,
name|String
name|dbtype
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
name|col
parameter_list|,
name|boolean
name|dropTablesOnClose
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|col
argument_list|)
decl_stmt|;
try|try
block|{
name|PreparedStatement
name|stmt
init|=
name|con
operator|.
name|prepareStatement
argument_list|(
literal|"select DATA from "
operator|+
name|tableName
operator|+
literal|" where ID = ?"
argument_list|)
decl_stmt|;
name|stmt
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
literal|"0:/"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|col
operator|.
name|equals
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|)
condition|)
block|{
comment|// try to discover size of DATA column
name|ResultSetMetaData
name|met
init|=
name|rs
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|this
operator|.
name|dataLimitInOctets
operator|=
name|met
operator|.
name|getPrecision
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// table does not appear to exist
name|con
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to create table "
operator|+
name|tableName
operator|+
literal|" in "
operator|+
name|dbtype
argument_list|)
expr_stmt|;
name|Statement
name|stmt
init|=
name|con
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// the code below likely will need to be extended for new
comment|// database types
if|if
condition|(
literal|"PostgreSQL"
operator|.
name|equals
argument_list|(
name|dbtype
argument_list|)
condition|)
block|{
name|stmt
operator|.
name|execute
argument_list|(
literal|"create table "
operator|+
name|tableName
operator|+
literal|" (ID varchar(512) not null primary key, MODIFIED bigint, HASBINARY smallint, MODCOUNT bigint, CMODCOUNT bigint, DSIZE bigint, DATA varchar(16384), BDATA bytea)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"DB2"
operator|.
name|equals
argument_list|(
name|dbtype
argument_list|)
operator|||
operator|(
name|dbtype
operator|!=
literal|null
operator|&&
name|dbtype
operator|.
name|startsWith
argument_list|(
literal|"DB2/"
argument_list|)
operator|)
condition|)
block|{
name|stmt
operator|.
name|execute
argument_list|(
literal|"create table "
operator|+
name|tableName
operator|+
literal|" (ID varchar(512) not null primary key, MODIFIED bigint, HASBINARY smallint, MODCOUNT bigint, CMODCOUNT bigint, DSIZE bigint, DATA varchar(16384), BDATA blob)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"MySQL"
operator|.
name|equals
argument_list|(
name|dbtype
argument_list|)
condition|)
block|{
name|stmt
operator|.
name|execute
argument_list|(
literal|"create table "
operator|+
name|tableName
operator|+
literal|" (ID varchar(512) not null primary key, MODIFIED bigint, HASBINARY smallint, MODCOUNT bigint, CMODCOUNT bigint, DSIZE bigint, DATA varchar(16384), BDATA mediumblob)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"Oracle"
operator|.
name|equals
argument_list|(
name|dbtype
argument_list|)
condition|)
block|{
comment|// see https://issues.apache.org/jira/browse/OAK-1914
name|this
operator|.
name|dataLimitInOctets
operator|=
literal|4000
expr_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
literal|"create table "
operator|+
name|tableName
operator|+
literal|" (ID varchar(512) not null primary key, MODIFIED number, HASBINARY number, MODCOUNT number, CMODCOUNT number, DSIZE number, DATA varchar(4000), BDATA blob)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stmt
operator|.
name|execute
argument_list|(
literal|"create table "
operator|+
name|tableName
operator|+
literal|" (ID varchar(512) not null primary key, MODIFIED bigint, HASBINARY smallint, MODCOUNT bigint, CMODCOUNT bigint, DSIZE bigint, DATA varchar(16384), BDATA blob)"
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
name|dropTablesOnClose
condition|)
block|{
name|tablesToBeDropped
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|finalize
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|ds
operator|!=
literal|null
operator|&&
name|this
operator|.
name|callStack
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"finalizing RDBDocumentStore that was not disposed"
argument_list|,
name|this
operator|.
name|callStack
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|readDocumentCached
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
specifier|final
name|String
name|id
parameter_list|,
name|int
name|maxCacheAge
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|!=
name|Collection
operator|.
name|NODES
condition|)
block|{
return|return
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
name|CacheValue
name|cacheKey
init|=
operator|new
name|StringValue
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|NodeDocument
name|doc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|maxCacheAge
operator|>
literal|0
condition|)
block|{
comment|// first try without lock
name|doc
operator|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|cacheKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|maxCacheAge
operator|==
name|Integer
operator|.
name|MAX_VALUE
operator|||
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|doc
operator|.
name|getLastCheckTime
argument_list|()
operator|<
name|maxCacheAge
condition|)
block|{
return|return
name|castAsT
argument_list|(
name|unwrap
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
try|try
block|{
name|Lock
name|lock
init|=
name|getAndLock
argument_list|(
name|id
argument_list|)
decl_stmt|;
specifier|final
name|NodeDocument
name|cachedDoc
init|=
name|doc
decl_stmt|;
try|try
block|{
if|if
condition|(
name|maxCacheAge
operator|==
literal|0
condition|)
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|doc
operator|=
name|nodesCache
operator|.
name|get
argument_list|(
name|cacheKey
argument_list|,
operator|new
name|Callable
argument_list|<
name|NodeDocument
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|NodeDocument
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|NodeDocument
name|doc
init|=
operator|(
name|NodeDocument
operator|)
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|cachedDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|seal
argument_list|()
expr_stmt|;
block|}
return|return
name|wrap
argument_list|(
name|doc
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxCacheAge
operator|==
literal|0
operator|||
name|maxCacheAge
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|doc
operator|.
name|getLastCheckTime
argument_list|()
operator|<
name|maxCacheAge
condition|)
block|{
break|break;
block|}
comment|// too old: invalidate, try again
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|castAsT
argument_list|(
name|unwrap
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Failed to load document with "
operator|+
name|id
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|internalCreate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updates
parameter_list|)
block|{
try|try
block|{
comment|// try up to CHUNKSIZE ops in one transaction
for|for
control|(
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|chunks
range|:
name|Lists
operator|.
name|partition
argument_list|(
name|updates
argument_list|,
name|CHUNKSIZE
argument_list|)
control|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateOp
name|update
range|:
name|chunks
control|)
block|{
name|T
name|doc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|update
operator|.
name|increment
argument_list|(
name|MODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasChangesToCollisions
argument_list|(
name|update
argument_list|)
condition|)
block|{
name|update
operator|.
name|increment
argument_list|(
name|NodeDocument
operator|.
name|COLLISIONSMODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|doc
argument_list|,
name|update
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|update
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"ID mismatch - UpdateOp: "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|", ID property: "
operator|+
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
name|docs
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|insertDocuments
argument_list|(
name|collection
argument_list|,
name|docs
argument_list|)
expr_stmt|;
for|for
control|(
name|T
name|doc
range|:
name|docs
control|)
block|{
name|addToCache
argument_list|(
name|collection
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|ex
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|internalCreateOrUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|,
name|boolean
name|allowCreate
parameter_list|,
name|boolean
name|checkConditions
parameter_list|)
block|{
name|T
name|oldDoc
init|=
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|allowCreate
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|update
operator|.
name|isNew
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"Document does not exist: "
operator|+
name|update
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
name|T
name|doc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|checkConditions
operator|&&
operator|!
name|UpdateUtils
operator|.
name|checkConditions
argument_list|(
name|doc
argument_list|,
name|update
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|update
operator|.
name|increment
argument_list|(
name|MODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasChangesToCollisions
argument_list|(
name|update
argument_list|)
condition|)
block|{
name|update
operator|.
name|increment
argument_list|(
name|NodeDocument
operator|.
name|COLLISIONSMODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|doc
argument_list|,
name|update
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
try|try
block|{
name|insertDocuments
argument_list|(
name|collection
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|doc
argument_list|)
argument_list|)
expr_stmt|;
name|addToCache
argument_list|(
name|collection
argument_list|,
name|doc
argument_list|)
expr_stmt|;
return|return
name|oldDoc
return|;
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|ex
parameter_list|)
block|{
comment|// may have failed due to a race condition; try update instead
comment|// this is an edge case, so it's ok to bypass the cache
comment|// (avoiding a race condition where the DB is already updated
comment|// but the cache is not)
name|oldDoc
operator|=
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// something else went wrong
name|LOG
operator|.
name|error
argument_list|(
literal|"insert failed, but document "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|" is not present, aborting"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|ex
operator|)
throw|;
block|}
return|return
name|internalUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
name|oldDoc
argument_list|,
name|checkConditions
argument_list|,
name|RETRIES
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|internalUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
name|oldDoc
argument_list|,
name|checkConditions
argument_list|,
name|RETRIES
argument_list|)
return|;
block|}
block|}
comment|/**      * @return previous version of document or<code>null</code>      */
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|internalUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|,
name|T
name|oldDoc
parameter_list|,
name|boolean
name|checkConditions
parameter_list|,
name|int
name|maxRetries
parameter_list|)
block|{
name|T
name|doc
init|=
name|applyChanges
argument_list|(
name|collection
argument_list|,
name|oldDoc
argument_list|,
name|update
argument_list|,
name|checkConditions
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
comment|// conditions not met
return|return
literal|null
return|;
block|}
else|else
block|{
name|Lock
name|l
init|=
name|getAndLock
argument_list|(
name|update
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|int
name|retries
init|=
name|maxRetries
decl_stmt|;
while|while
condition|(
operator|!
name|success
operator|&&
name|retries
operator|>
literal|0
condition|)
block|{
name|long
name|lastmodcount
init|=
operator|(
name|Long
operator|)
name|oldDoc
operator|.
name|get
argument_list|(
name|MODCOUNT
argument_list|)
decl_stmt|;
name|success
operator|=
name|updateDocument
argument_list|(
name|collection
argument_list|,
name|doc
argument_list|,
name|update
argument_list|,
name|lastmodcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|retries
operator|-=
literal|1
expr_stmt|;
name|oldDoc
operator|=
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|long
name|newmodcount
init|=
operator|(
name|Long
operator|)
name|oldDoc
operator|.
name|get
argument_list|(
name|MODCOUNT
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastmodcount
operator|==
name|newmodcount
condition|)
block|{
comment|// cached copy did not change so it probably was updated by
comment|// a different instance, get a fresh one
name|oldDoc
operator|=
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// document was there but is now gone
name|LOG
operator|.
name|error
argument_list|(
literal|"failed to apply update because document is gone in the meantime: "
operator|+
name|update
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|doc
operator|=
name|applyChanges
argument_list|(
name|collection
argument_list|,
name|oldDoc
argument_list|,
name|update
argument_list|,
name|checkConditions
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|applyToCache
argument_list|(
operator|(
name|NodeDocument
operator|)
name|oldDoc
argument_list|,
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"failed update of "
operator|+
name|doc
operator|.
name|getId
argument_list|()
operator|+
literal|" (race?) after "
operator|+
name|maxRetries
operator|+
literal|" retries"
argument_list|)
throw|;
block|}
return|return
name|oldDoc
return|;
block|}
finally|finally
block|{
name|l
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|applyChanges
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|T
name|oldDoc
parameter_list|,
name|UpdateOp
name|update
parameter_list|,
name|boolean
name|checkConditions
parameter_list|)
block|{
name|T
name|doc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|oldDoc
operator|.
name|deepCopy
argument_list|(
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkConditions
operator|&&
operator|!
name|UpdateUtils
operator|.
name|checkConditions
argument_list|(
name|doc
argument_list|,
name|update
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|hasChangesToCollisions
argument_list|(
name|update
argument_list|)
condition|)
block|{
name|update
operator|.
name|increment
argument_list|(
name|NodeDocument
operator|.
name|COLLISIONSMODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|increment
argument_list|(
name|MODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|doc
argument_list|,
name|update
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|doc
operator|.
name|seal
argument_list|()
expr_stmt|;
return|return
name|doc
return|;
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|internalUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
if|if
condition|(
name|isAppendableUpdate
argument_list|(
name|update
argument_list|)
operator|&&
operator|!
name|requiresPreviousState
argument_list|(
name|update
argument_list|)
condition|)
block|{
name|long
name|modified
init|=
name|getModifiedFromUpdate
argument_list|(
name|update
argument_list|)
decl_stmt|;
name|String
name|appendData
init|=
name|SR
operator|.
name|asString
argument_list|(
name|update
argument_list|)
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|chunkedIds
range|:
name|Lists
operator|.
name|partition
argument_list|(
name|ids
argument_list|,
name|CHUNKSIZE
argument_list|)
control|)
block|{
comment|// remember what we already have in the cache
name|Map
argument_list|<
name|String
argument_list|,
name|NodeDocument
argument_list|>
name|cachedDocs
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|cachedDocs
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|NodeDocument
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|key
range|:
name|chunkedIds
control|)
block|{
name|cachedDocs
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
operator|new
name|StringValue
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|getConnection
argument_list|()
expr_stmt|;
name|success
operator|=
name|dbBatchedAppendingUpdate
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|chunkedIds
argument_list|,
name|modified
argument_list|,
name|appendData
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|NodeDocument
argument_list|>
name|entry
range|:
name|cachedDocs
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// make sure concurrently loaded document is invalidated
name|nodesCache
operator|.
name|invalidate
argument_list|(
operator|new
name|StringValue
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|T
name|oldDoc
init|=
call|(
name|T
call|)
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|T
name|newDoc
init|=
name|applyChanges
argument_list|(
name|collection
argument_list|,
call|(
name|T
call|)
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|,
name|update
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|applyToCache
argument_list|(
operator|(
name|NodeDocument
operator|)
name|oldDoc
argument_list|,
operator|(
name|NodeDocument
operator|)
name|newDoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|String
name|id
range|:
name|chunkedIds
control|)
block|{
name|UpdateOp
name|up
init|=
name|update
operator|.
name|copy
argument_list|()
decl_stmt|;
name|up
operator|=
name|up
operator|.
name|shallowCopy
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|up
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
name|UpdateOp
name|up
init|=
name|update
operator|.
name|copy
argument_list|()
decl_stmt|;
name|up
operator|=
name|up
operator|.
name|shallowCopy
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|up
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|internalQuery
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|String
name|indexedProperty
parameter_list|,
name|long
name|startValue
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexedProperty
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|INDEXEDPROPERTIES
operator|.
name|contains
argument_list|(
name|indexedProperty
argument_list|)
operator|)
condition|)
block|{
name|String
name|message
init|=
literal|"indexed property "
operator|+
name|indexedProperty
operator|+
literal|" not supported, query was '>= '"
operator|+
name|startValue
operator|+
literal|"'; supported properties are "
operator|+
name|INDEXEDPROPERTIES
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|message
argument_list|)
throw|;
block|}
try|try
block|{
name|connection
operator|=
name|getConnection
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RDBRow
argument_list|>
name|dbresult
init|=
name|dbQuery
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
name|indexedProperty
argument_list|,
name|startValue
argument_list|,
name|limit
argument_list|)
decl_stmt|;
for|for
control|(
name|RDBRow
name|r
range|:
name|dbresult
control|)
block|{
name|T
name|doc
init|=
name|runThroughCache
argument_list|(
name|collection
argument_list|,
name|r
argument_list|,
name|now
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"SQL exception on query"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|String
name|getTable
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|CLUSTER_NODES
condition|)
block|{
return|return
name|this
operator|.
name|tablePrefix
operator|+
literal|"CLUSTERNODES"
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
return|return
name|this
operator|.
name|tablePrefix
operator|+
literal|"NODES"
return|;
block|}
elseif|else
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|SETTINGS
condition|)
block|{
return|return
name|this
operator|.
name|tablePrefix
operator|+
literal|"SETTINGS"
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown collection: "
operator|+
name|collection
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|readDocumentUncached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|,
name|NodeDocument
name|cachedDoc
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|long
name|lastmodcount
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|cachedDoc
operator|!=
literal|null
operator|&&
name|cachedDoc
operator|.
name|getModCount
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|lastmodcount
operator|=
name|cachedDoc
operator|.
name|getModCount
argument_list|()
operator|.
name|longValue
argument_list|()
expr_stmt|;
block|}
name|connection
operator|=
name|getConnection
argument_list|()
expr_stmt|;
name|RDBRow
name|row
init|=
name|dbRead
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|id
argument_list|,
name|lastmodcount
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
if|if
condition|(
name|lastmodcount
operator|==
name|row
operator|.
name|getModcount
argument_list|()
condition|)
block|{
comment|// we can re-use the cached document
name|cachedDoc
operator|.
name|markUpToDate
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|T
operator|)
name|cachedDoc
return|;
block|}
else|else
block|{
return|return
name|SR
operator|.
name|fromRow
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|delete
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|getConnection
argument_list|()
expr_stmt|;
name|dbDelete
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|delete
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
block|{
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|sublist
range|:
name|Lists
operator|.
name|partition
argument_list|(
name|ids
argument_list|,
literal|64
argument_list|)
control|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|getConnection
argument_list|()
expr_stmt|;
name|dbDelete
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|sublist
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|updateDocument
parameter_list|(
annotation|@
name|Nonnull
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
annotation|@
name|Nonnull
name|T
name|document
parameter_list|,
annotation|@
name|Nonnull
name|UpdateOp
name|update
parameter_list|,
name|Long
name|oldmodcount
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|getConnection
argument_list|()
expr_stmt|;
name|Long
name|modified
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|MODIFIED
argument_list|)
decl_stmt|;
name|Number
name|flag
init|=
operator|(
name|Number
operator|)
name|document
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
argument_list|)
decl_stmt|;
name|Boolean
name|hasBinary
init|=
name|flag
operator|==
literal|null
condition|?
literal|false
else|:
name|flag
operator|.
name|intValue
argument_list|()
operator|==
name|NodeDocument
operator|.
name|HAS_BINARY_VAL
decl_stmt|;
name|Long
name|modcount
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|MODCOUNT
argument_list|)
decl_stmt|;
name|Long
name|cmodcount
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|COLLISIONSMODCOUNT
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
comment|// every 16th update is a full rewrite
if|if
condition|(
name|isAppendableUpdate
argument_list|(
name|update
argument_list|)
operator|&&
name|modcount
operator|%
literal|16
operator|!=
literal|0
condition|)
block|{
name|String
name|appendData
init|=
name|SR
operator|.
name|asString
argument_list|(
name|update
argument_list|)
decl_stmt|;
if|if
condition|(
name|appendData
operator|.
name|length
argument_list|()
operator|<
name|this
operator|.
name|dataLimitInOctets
operator|/
name|CHAR2OCTETRATIO
condition|)
block|{
try|try
block|{
name|success
operator|=
name|dbAppendingUpdate
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|modified
argument_list|,
name|hasBinary
argument_list|,
name|modcount
argument_list|,
name|cmodcount
argument_list|,
name|oldmodcount
argument_list|,
name|appendData
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|continueIfStringOverflow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|connection
operator|.
name|rollback
argument_list|()
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|String
name|data
init|=
name|SR
operator|.
name|asString
argument_list|(
name|document
argument_list|)
decl_stmt|;
name|success
operator|=
name|dbUpdate
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|modified
argument_list|,
name|hasBinary
argument_list|,
name|modcount
argument_list|,
name|cmodcount
argument_list|,
name|oldmodcount
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
name|connection
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
comment|// TODO
block|}
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|continueIfStringOverflow
parameter_list|(
name|SQLException
name|ex
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|state
init|=
name|ex
operator|.
name|getSQLState
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"22001"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
comment|/* everybody */
operator|||
operator|(
literal|"72000"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|&&
literal|1489
operator|==
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|)
comment|/* Oracle */
condition|)
block|{
comment|// ok
block|}
else|else
block|{
throw|throw
operator|(
name|ex
operator|)
throw|;
block|}
block|}
comment|/* currently we use append for all updates, but this might change in the future */
specifier|private
specifier|static
name|boolean
name|isAppendableUpdate
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
comment|/* check whether this update operation requires knowledge about the previous state */
specifier|private
specifier|static
name|boolean
name|requiresPreviousState
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Key
argument_list|,
name|Operation
argument_list|>
name|change
range|:
name|update
operator|.
name|getChanges
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Operation
name|op
init|=
name|change
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|type
operator|==
name|UpdateOp
operator|.
name|Operation
operator|.
name|Type
operator|.
name|CONTAINS_MAP_ENTRY
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
name|long
name|getModifiedFromUpdate
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Key
argument_list|,
name|Operation
argument_list|>
name|change
range|:
name|update
operator|.
name|getChanges
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Operation
name|op
init|=
name|change
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|type
operator|==
name|UpdateOp
operator|.
name|Operation
operator|.
name|Type
operator|.
name|MAX
operator|||
name|op
operator|.
name|type
operator|==
name|UpdateOp
operator|.
name|Operation
operator|.
name|Type
operator|.
name|SET
condition|)
block|{
if|if
condition|(
name|MODIFIED
operator|.
name|equals
argument_list|(
name|change
operator|.
name|getKey
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|op
operator|.
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|0L
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|insertDocuments
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|documents
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|String
name|tableName
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|getConnection
argument_list|()
expr_stmt|;
for|for
control|(
name|T
name|document
range|:
name|documents
control|)
block|{
name|String
name|data
init|=
name|SR
operator|.
name|asString
argument_list|(
name|document
argument_list|)
decl_stmt|;
name|Long
name|modified
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|MODIFIED
argument_list|)
decl_stmt|;
name|Number
name|flag
init|=
operator|(
name|Number
operator|)
name|document
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
argument_list|)
decl_stmt|;
name|Boolean
name|hasBinary
init|=
name|flag
operator|==
literal|null
condition|?
literal|false
else|:
name|flag
operator|.
name|intValue
argument_list|()
operator|==
name|NodeDocument
operator|.
name|HAS_BINARY_VAL
decl_stmt|;
name|Long
name|modcount
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|MODCOUNT
argument_list|)
decl_stmt|;
name|Long
name|cmodcount
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|COLLISIONSMODCOUNT
argument_list|)
decl_stmt|;
name|dbInsert
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|modified
argument_list|,
name|hasBinary
argument_list|,
name|modcount
argument_list|,
name|cmodcount
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"insert of "
operator|+
name|ids
operator|+
literal|" failed"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
name|connection
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
comment|// TODO
block|}
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
comment|// configuration
comment|// Whether to use GZIP compression
specifier|private
specifier|static
name|boolean
name|NOGZIP
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.NOGZIP"
argument_list|)
decl_stmt|;
comment|// Number of documents to insert at once for batch create
specifier|private
specifier|static
name|int
name|CHUNKSIZE
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.CHUNKSIZE"
argument_list|,
literal|64
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
name|asBytes
parameter_list|(
name|String
name|data
parameter_list|)
block|{
name|byte
index|[]
name|bytes
decl_stmt|;
try|try
block|{
name|bytes
operator|=
name|data
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"UTF-8 not supported??"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
if|if
condition|(
name|NOGZIP
condition|)
block|{
return|return
name|bytes
return|;
block|}
else|else
block|{
try|try
block|{
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|data
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|GZIPOutputStream
name|gos
init|=
operator|new
name|GZIPOutputStream
argument_list|(
name|bos
argument_list|)
block|{
block|{
comment|// TODO: make this configurable
name|this
operator|.
name|def
operator|.
name|setLevel
parameter_list|(
name|Deflater
operator|.
name|BEST_SPEED
parameter_list|)
constructor_decl|;
block|}
block|}
decl_stmt|;
name|gos
operator|.
name|write
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|gos
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|bos
operator|.
name|toByteArray
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while gzipping contents"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
name|RDBRow
name|dbRead
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|id
parameter_list|,
name|long
name|lastmodcount
parameter_list|)
throws|throws
name|SQLException
block|{
name|PreparedStatement
name|stmt
decl_stmt|;
name|boolean
name|useCaseStatement
init|=
name|lastmodcount
operator|!=
operator|-
literal|1
operator|&&
name|allowsCaseInSelect
decl_stmt|;
if|if
condition|(
name|useCaseStatement
condition|)
block|{
comment|// either we don't have a previous version of the document
comment|// or the database does not support CASE in SELECT
name|stmt
operator|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"select MODIFIED, MODCOUNT, HASBINARY, DATA, BDATA from "
operator|+
name|tableName
operator|+
literal|" where ID = ?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the case statement causes the actual row data not to be
comment|// sent in case we already have it
name|stmt
operator|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"select MODIFIED, MODCOUNT, HASBINARY, case MODCOUNT when ? then null else DATA end as DATA, "
operator|+
literal|"case MODCOUNT when ? then null else BDATA end as BDATA from "
operator|+
name|tableName
operator|+
literal|" where ID = ?"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|useCaseStatement
condition|)
block|{
name|stmt
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stmt
operator|.
name|setLong
argument_list|(
literal|1
argument_list|,
name|lastmodcount
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setLong
argument_list|(
literal|2
argument_list|,
name|lastmodcount
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setString
argument_list|(
literal|3
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|long
name|modified
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|long
name|modcount
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|long
name|hasBinary
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|String
name|data
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bdata
init|=
name|rs
operator|.
name|getBytes
argument_list|(
literal|5
argument_list|)
decl_stmt|;
return|return
operator|new
name|RDBRow
argument_list|(
name|id
argument_list|,
name|hasBinary
operator|==
literal|1
argument_list|,
name|modified
argument_list|,
name|modcount
argument_list|,
name|data
argument_list|,
name|bdata
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"attempting to read "
operator|+
name|id
operator|+
literal|" (id length is "
operator|+
name|id
operator|.
name|length
argument_list|()
operator|+
literal|")"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// DB2 throws an SQLException for invalid keys; handle this more
comment|// gracefully
if|if
condition|(
literal|"22001"
operator|.
name|equals
argument_list|(
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
condition|)
block|{
name|connection
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
throw|throw
operator|(
name|ex
operator|)
throw|;
block|}
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|RDBRow
argument_list|>
name|dbQuery
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|minId
parameter_list|,
name|String
name|maxId
parameter_list|,
name|String
name|indexedProperty
parameter_list|,
name|long
name|startValue
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|t
init|=
literal|"select ID, MODIFIED, MODCOUNT, HASBINARY, DATA, BDATA from "
operator|+
name|tableName
operator|+
literal|" where ID> ? and ID< ?"
decl_stmt|;
if|if
condition|(
name|indexedProperty
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|MODIFIED
operator|.
name|equals
argument_list|(
name|indexedProperty
argument_list|)
condition|)
block|{
name|t
operator|+=
literal|" and MODIFIED>= ?"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
operator|.
name|equals
argument_list|(
name|indexedProperty
argument_list|)
condition|)
block|{
if|if
condition|(
name|startValue
operator|!=
name|NodeDocument
operator|.
name|HAS_BINARY_VAL
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"unsupported value for property "
operator|+
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
argument_list|)
throw|;
block|}
name|t
operator|+=
literal|" and HASBINARY = 1"
expr_stmt|;
block|}
block|}
name|t
operator|+=
literal|" order by ID"
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|t
operator|+=
name|this
operator|.
name|needsLimit
condition|?
operator|(
literal|" LIMIT "
operator|+
name|limit
operator|)
else|:
operator|(
literal|" FETCH FIRST "
operator|+
name|limit
operator|+
literal|" ROWS ONLY"
operator|)
expr_stmt|;
block|}
name|PreparedStatement
name|stmt
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RDBRow
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|RDBRow
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|si
init|=
literal|1
decl_stmt|;
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
name|minId
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
name|maxId
argument_list|)
expr_stmt|;
if|if
condition|(
name|MODIFIED
operator|.
name|equals
argument_list|(
name|indexedProperty
argument_list|)
condition|)
block|{
name|stmt
operator|.
name|setLong
argument_list|(
name|si
operator|++
argument_list|,
name|startValue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|!=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|stmt
operator|.
name|setFetchSize
argument_list|(
name|limit
argument_list|)
expr_stmt|;
block|}
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
operator|&&
name|result
operator|.
name|size
argument_list|()
operator|<
name|limit
condition|)
block|{
name|String
name|id
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|.
name|compareTo
argument_list|(
name|minId
argument_list|)
operator|<
literal|0
operator|||
name|id
operator|.
name|compareTo
argument_list|(
name|maxId
argument_list|)
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"unexpected query result: '"
operator|+
name|minId
operator|+
literal|"'< '"
operator|+
name|id
operator|+
literal|"'< '"
operator|+
name|maxId
operator|+
literal|"' - broken DB collation?"
argument_list|)
throw|;
block|}
name|long
name|modified
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|long
name|modcount
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|long
name|hasBinary
init|=
name|rs
operator|.
name|getLong
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|String
name|data
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bdata
init|=
name|rs
operator|.
name|getBytes
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|RDBRow
argument_list|(
name|id
argument_list|,
name|hasBinary
operator|==
literal|1
argument_list|,
name|modified
argument_list|,
name|modcount
argument_list|,
name|data
argument_list|,
name|bdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|boolean
name|dbUpdate
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|id
parameter_list|,
name|Long
name|modified
parameter_list|,
name|Boolean
name|hasBinary
parameter_list|,
name|Long
name|modcount
parameter_list|,
name|Long
name|cmodcount
parameter_list|,
name|Long
name|oldmodcount
parameter_list|,
name|String
name|data
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|t
init|=
literal|"update "
operator|+
name|tableName
operator|+
literal|" set MODIFIED = ?, HASBINARY = ?, MODCOUNT = ?, CMODCOUNT = ?, DSIZE = ?, DATA = ?, BDATA = ? where ID = ?"
decl_stmt|;
if|if
condition|(
name|oldmodcount
operator|!=
literal|null
condition|)
block|{
name|t
operator|+=
literal|" and MODCOUNT = ?"
expr_stmt|;
block|}
name|PreparedStatement
name|stmt
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|t
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|si
init|=
literal|1
decl_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modified
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|hasBinary
condition|?
literal|1
else|:
literal|0
argument_list|,
name|Types
operator|.
name|SMALLINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|cmodcount
operator|==
literal|null
condition|?
literal|0
else|:
name|cmodcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|length
argument_list|()
operator|<
name|this
operator|.
name|dataLimitInOctets
operator|/
name|CHAR2OCTETRATIO
condition|)
block|{
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setBinaryStream
argument_list|(
name|si
operator|++
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
literal|"\"blob\""
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bytes
init|=
name|asBytes
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|stmt
operator|.
name|setBytes
argument_list|(
name|si
operator|++
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmodcount
operator|!=
literal|null
condition|)
block|{
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|oldmodcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
block|}
name|int
name|result
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DB update failed for "
operator|+
name|tableName
operator|+
literal|"/"
operator|+
name|id
operator|+
literal|" with oldmodcount="
operator|+
name|oldmodcount
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|==
literal|1
return|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|dbAppendingUpdate
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|id
parameter_list|,
name|Long
name|modified
parameter_list|,
name|Boolean
name|hasBinary
parameter_list|,
name|Long
name|modcount
parameter_list|,
name|Long
name|cmodcount
parameter_list|,
name|Long
name|oldmodcount
parameter_list|,
name|String
name|appendData
parameter_list|)
throws|throws
name|SQLException
block|{
name|StringBuilder
name|t
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|t
operator|.
name|append
argument_list|(
literal|"update "
operator|+
name|tableName
operator|+
literal|" set MODIFIED = GREATEST(MODIFIED, ?), HASBINARY = ?, MODCOUNT = ?, CMODCOUNT = ?, DSIZE = DSIZE + ?, "
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
name|this
operator|.
name|needsConcat
condition|?
literal|"DATA = CONCAT(DATA, ?) "
else|:
literal|"DATA = DATA || CAST(? AS varchar("
operator|+
name|this
operator|.
name|dataLimitInOctets
operator|+
literal|")) "
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
literal|"where ID = ?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmodcount
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|append
argument_list|(
literal|" and MODCOUNT = ?"
argument_list|)
expr_stmt|;
block|}
name|PreparedStatement
name|stmt
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|si
init|=
literal|1
decl_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modified
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|hasBinary
condition|?
literal|1
else|:
literal|0
argument_list|,
name|Types
operator|.
name|SMALLINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|cmodcount
operator|==
literal|null
condition|?
literal|0
else|:
name|cmodcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
literal|1
operator|+
name|appendData
operator|.
name|length
argument_list|()
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
literal|","
operator|+
name|appendData
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmodcount
operator|!=
literal|null
condition|)
block|{
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|oldmodcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
block|}
name|int
name|result
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DB append update failed for "
operator|+
name|tableName
operator|+
literal|"/"
operator|+
name|id
operator|+
literal|" with oldmodcount="
operator|+
name|oldmodcount
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|==
literal|1
return|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|dbBatchedAppendingUpdate
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|,
name|Long
name|modified
parameter_list|,
name|String
name|appendData
parameter_list|)
throws|throws
name|SQLException
block|{
name|StringBuilder
name|t
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|t
operator|.
name|append
argument_list|(
literal|"update "
operator|+
name|tableName
operator|+
literal|" set MODIFIED = GREATEST(MODIFIED, ?), MODCOUNT = MODCOUNT + 1, DSIZE = DSIZE + ?, "
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
name|this
operator|.
name|needsConcat
condition|?
literal|"DATA = CONCAT(DATA, ?) "
else|:
literal|"DATA = DATA || CAST(? AS varchar("
operator|+
name|this
operator|.
name|dataLimitInOctets
operator|+
literal|")) "
argument_list|)
expr_stmt|;
name|t
operator|.
name|append
argument_list|(
literal|"where ID in ("
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ids
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|t
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|append
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|PreparedStatement
name|stmt
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|si
init|=
literal|1
decl_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modified
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
literal|1
operator|+
name|appendData
operator|.
name|length
argument_list|()
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
literal|","
operator|+
name|appendData
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|int
name|result
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|ids
operator|.
name|size
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DB update failed: only "
operator|+
name|result
operator|+
literal|" of "
operator|+
name|ids
operator|.
name|size
argument_list|()
operator|+
literal|" updated. Table: "
operator|+
name|tableName
operator|+
literal|", IDs:"
operator|+
name|ids
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|==
name|ids
operator|.
name|size
argument_list|()
return|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|dbInsert
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|id
parameter_list|,
name|Long
name|modified
parameter_list|,
name|Boolean
name|hasBinary
parameter_list|,
name|Long
name|modcount
parameter_list|,
name|Long
name|cmodcount
parameter_list|,
name|String
name|data
parameter_list|)
throws|throws
name|SQLException
block|{
name|PreparedStatement
name|stmt
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"insert into "
operator|+
name|tableName
operator|+
literal|"(ID, MODIFIED, HASBINARY, MODCOUNT, CMODCOUNT, DSIZE, DATA, BDATA) values (?, ?, ?, ?, ?, ?, ?, ?)"
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|si
init|=
literal|1
decl_stmt|;
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modified
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|hasBinary
condition|?
literal|1
else|:
literal|0
argument_list|,
name|Types
operator|.
name|SMALLINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|modcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|cmodcount
operator|==
literal|null
condition|?
literal|0
else|:
name|cmodcount
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setObject
argument_list|(
name|si
operator|++
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|length
argument_list|()
operator|<
name|this
operator|.
name|dataLimitInOctets
operator|/
name|CHAR2OCTETRATIO
condition|)
block|{
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|setBinaryStream
argument_list|(
name|si
operator|++
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stmt
operator|.
name|setString
argument_list|(
name|si
operator|++
argument_list|,
literal|"\"blob\""
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bytes
init|=
name|asBytes
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|stmt
operator|.
name|setBytes
argument_list|(
name|si
operator|++
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
name|int
name|result
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DB insert failed for "
operator|+
name|tableName
operator|+
literal|"/"
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|==
literal|1
return|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|dbDelete
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
throws|throws
name|SQLException
block|{
name|PreparedStatement
name|stmt
decl_stmt|;
name|int
name|cnt
init|=
name|ids
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|1
condition|)
block|{
name|stmt
operator|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"delete from "
operator|+
name|tableName
operator|+
literal|" where ID=?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|StringBuilder
name|inClause
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|inClause
operator|.
name|append
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|cnt
operator|-
literal|1
condition|)
block|{
name|inClause
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
name|stmt
operator|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"delete from "
operator|+
name|tableName
operator|+
literal|" where ID in ("
operator|+
name|inClause
operator|.
name|toString
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|stmt
operator|.
name|setString
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|ids
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|result
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|cnt
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DB delete failed for "
operator|+
name|tableName
operator|+
literal|"/"
operator|+
name|ids
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setReadWriteMode
parameter_list|(
name|String
name|readWriteMode
parameter_list|)
block|{
comment|// ignored
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|castAsT
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
operator|(
name|T
operator|)
name|doc
return|;
block|}
comment|// Memory Cache
specifier|private
name|Cache
argument_list|<
name|CacheValue
argument_list|,
name|NodeDocument
argument_list|>
name|nodesCache
decl_stmt|;
specifier|private
name|CacheStats
name|cacheStats
decl_stmt|;
specifier|private
specifier|final
name|Striped
argument_list|<
name|Lock
argument_list|>
name|locks
init|=
name|Striped
operator|.
name|lock
argument_list|(
literal|64
argument_list|)
decl_stmt|;
specifier|private
name|Lock
name|getAndLock
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|Lock
name|l
init|=
name|locks
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|l
operator|.
name|lock
argument_list|()
expr_stmt|;
return|return
name|l
return|;
block|}
annotation|@
name|CheckForNull
specifier|private
specifier|static
name|NodeDocument
name|unwrap
parameter_list|(
annotation|@
name|Nonnull
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|==
name|NodeDocument
operator|.
name|NULL
condition|?
literal|null
else|:
name|doc
return|;
block|}
annotation|@
name|Nonnull
specifier|private
specifier|static
name|NodeDocument
name|wrap
parameter_list|(
annotation|@
name|CheckForNull
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|==
literal|null
condition|?
name|NodeDocument
operator|.
name|NULL
else|:
name|doc
return|;
block|}
comment|/**      * Adds a document to the {@link #nodesCache} iff there is no document in      * the cache with the document key. This method does not acquire a lock from      * {@link #locks}! The caller must ensure a lock is held for the given      * document.      *       * @param doc      *            the document to add to the cache.      * @return either the given<code>doc</code> or the document already present      *         in the cache.      */
annotation|@
name|Nonnull
specifier|private
name|NodeDocument
name|addToCache
parameter_list|(
annotation|@
name|Nonnull
specifier|final
name|NodeDocument
name|doc
parameter_list|)
block|{
if|if
condition|(
name|doc
operator|==
name|NodeDocument
operator|.
name|NULL
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"doc must not be NULL document"
argument_list|)
throw|;
block|}
name|doc
operator|.
name|seal
argument_list|()
expr_stmt|;
comment|// make sure we only cache the document if it wasn't
comment|// changed and cached by some other thread in the
comment|// meantime. That is, use get() with a Callable,
comment|// which is only used when the document isn't there
try|try
block|{
name|CacheValue
name|key
init|=
operator|new
name|StringValue
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|NodeDocument
name|cached
init|=
name|nodesCache
operator|.
name|get
argument_list|(
name|key
argument_list|,
operator|new
name|Callable
argument_list|<
name|NodeDocument
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|NodeDocument
name|call
parameter_list|()
block|{
return|return
name|doc
return|;
block|}
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
name|NodeDocument
operator|.
name|NULL
condition|)
block|{
return|return
name|cached
return|;
block|}
else|else
block|{
name|nodesCache
operator|.
name|invalidate
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
comment|// will never happen because call() just returns
comment|// the already available doc
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Nonnull
specifier|private
name|void
name|applyToCache
parameter_list|(
annotation|@
name|Nonnull
specifier|final
name|NodeDocument
name|oldDoc
parameter_list|,
annotation|@
name|Nonnull
specifier|final
name|NodeDocument
name|newDoc
parameter_list|)
block|{
name|NodeDocument
name|cached
init|=
name|addToCache
argument_list|(
name|newDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|==
name|newDoc
condition|)
block|{
comment|// successful
return|return;
block|}
elseif|else
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// this is an insert and some other thread was quicker
comment|// loading it into the cache -> return now
return|return;
block|}
else|else
block|{
name|CacheValue
name|key
init|=
operator|new
name|StringValue
argument_list|(
name|newDoc
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
comment|// this is an update (oldDoc != null)
if|if
condition|(
name|Objects
operator|.
name|equal
argument_list|(
name|cached
operator|.
name|getModCount
argument_list|()
argument_list|,
name|oldDoc
operator|.
name|getModCount
argument_list|()
argument_list|)
condition|)
block|{
name|nodesCache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|newDoc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the cache entry was modified by some other thread in
comment|// the meantime. the updated cache entry may or may not
comment|// include this update. we cannot just apply our update
comment|// on top of the cached entry.
comment|// therefore we must invalidate the cache entry
name|nodesCache
operator|.
name|invalidate
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|addToCache
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|T
name|doc
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|Lock
name|lock
init|=
name|getAndLock
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|addToCache
argument_list|(
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|runThroughCache
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|RDBRow
name|row
parameter_list|,
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|!=
name|Collection
operator|.
name|NODES
condition|)
block|{
comment|// not in the cache anyway
return|return
name|SR
operator|.
name|fromRow
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
return|;
block|}
name|String
name|id
init|=
name|row
operator|.
name|getId
argument_list|()
decl_stmt|;
name|CacheValue
name|cacheKey
init|=
operator|new
name|StringValue
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|NodeDocument
name|inCache
init|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|cacheKey
argument_list|)
decl_stmt|;
name|Number
name|modCount
init|=
name|row
operator|.
name|getModcount
argument_list|()
decl_stmt|;
comment|// do not overwrite document in cache if the
comment|// existing one in the cache is newer
if|if
condition|(
name|inCache
operator|!=
literal|null
operator|&&
name|inCache
operator|!=
name|NodeDocument
operator|.
name|NULL
condition|)
block|{
comment|// check mod count
name|Number
name|cachedModCount
init|=
name|inCache
operator|.
name|getModCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|cachedModCount
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Missing "
operator|+
name|Document
operator|.
name|MOD_COUNT
argument_list|)
throw|;
block|}
if|if
condition|(
name|modCount
operator|.
name|longValue
argument_list|()
operator|<=
name|cachedModCount
operator|.
name|longValue
argument_list|()
condition|)
block|{
comment|// we can use the cached document
name|inCache
operator|.
name|markUpToDate
argument_list|(
name|now
argument_list|)
expr_stmt|;
return|return
operator|(
name|T
operator|)
name|inCache
return|;
block|}
block|}
name|NodeDocument
name|fresh
init|=
operator|(
name|NodeDocument
operator|)
name|SR
operator|.
name|fromRow
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
decl_stmt|;
name|fresh
operator|.
name|seal
argument_list|()
expr_stmt|;
name|Lock
name|lock
init|=
name|getAndLock
argument_list|(
name|id
argument_list|)
decl_stmt|;
try|try
block|{
name|inCache
operator|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|cacheKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|inCache
operator|!=
literal|null
operator|&&
name|inCache
operator|!=
name|NodeDocument
operator|.
name|NULL
condition|)
block|{
comment|// check mod count
name|Number
name|cachedModCount
init|=
name|inCache
operator|.
name|getModCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|cachedModCount
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Missing "
operator|+
name|Document
operator|.
name|MOD_COUNT
argument_list|)
throw|;
block|}
if|if
condition|(
name|modCount
operator|.
name|longValue
argument_list|()
operator|>
name|cachedModCount
operator|.
name|longValue
argument_list|()
condition|)
block|{
name|nodesCache
operator|.
name|put
argument_list|(
name|cacheKey
argument_list|,
name|fresh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fresh
operator|=
name|inCache
expr_stmt|;
block|}
block|}
else|else
block|{
name|nodesCache
operator|.
name|put
argument_list|(
name|cacheKey
argument_list|,
name|fresh
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|T
operator|)
name|fresh
return|;
block|}
specifier|private
name|Connection
name|getConnection
parameter_list|()
throws|throws
name|SQLException
block|{
name|Connection
name|c
init|=
name|this
operator|.
name|ds
operator|.
name|getConnection
argument_list|()
decl_stmt|;
name|c
operator|.
name|setAutoCommit
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
specifier|private
name|void
name|closeConnection
parameter_list|(
name|Connection
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|c
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// log me
block|}
block|}
block|}
specifier|private
name|boolean
name|hasChangesToCollisions
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|,
name|Operation
argument_list|>
name|e
range|:
name|checkNotNull
argument_list|(
name|update
argument_list|)
operator|.
name|getChanges
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Key
name|k
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Operation
name|op
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|type
operator|==
name|Operation
operator|.
name|Type
operator|.
name|SET_MAP_ENTRY
condition|)
block|{
if|if
condition|(
name|NodeDocument
operator|.
name|COLLISIONS
operator|.
name|equals
argument_list|(
name|k
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

