begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkState
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|fill
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|IOUtils
operator|.
name|closeQuietly
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|CacheWeights
operator|.
name|OBJECT_HEADER_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|RecordNumbers
operator|.
name|EMPTY_RECORD_NUMBERS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|SegmentId
operator|.
name|isDataSegmentId
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|SegmentStream
operator|.
name|BLOCK_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|SegmentVersion
operator|.
name|LATEST_VERSION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|SegmentVersion
operator|.
name|isValid
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|data
operator|.
name|SegmentData
operator|.
name|newRawSegmentData
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|data
operator|.
name|SegmentData
operator|.
name|newSegmentData
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|file
operator|.
name|tar
operator|.
name|GCGeneration
operator|.
name|newGCGeneration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|AbstractIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|HexDump
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|output
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|output
operator|.
name|WriterOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|PropertyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|PropertyStates
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|RecordNumbers
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|data
operator|.
name|RecordIdData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|data
operator|.
name|SegmentData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|data
operator|.
name|StringData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|segment
operator|.
name|file
operator|.
name|tar
operator|.
name|GCGeneration
import|;
end_import

begin_comment
comment|/**  * A list of records.  *<p>  * Record data is not kept in memory, but some entries are cached (templates,  * all strings in the segment).  *<p>  * This class includes method to read records from the raw bytes.  */
end_comment

begin_class
specifier|public
class|class
name|Segment
block|{
specifier|static
specifier|final
name|int
name|HEADER_SIZE
init|=
literal|32
decl_stmt|;
comment|/**      * Size of a line in the table of references to external segments.      */
specifier|static
specifier|final
name|int
name|SEGMENT_REFERENCE_SIZE
init|=
literal|16
decl_stmt|;
comment|/**      * Size of a line in the table mapping record numbers to their type and      * offset.      */
specifier|static
specifier|final
name|int
name|RECORD_SIZE
init|=
literal|9
decl_stmt|;
comment|/**      * Number of bytes used for storing a record identifier. Two bytes      * are used for identifying the segment and four for the record offset      * within that segment.      */
specifier|static
specifier|final
name|int
name|RECORD_ID_BYTES
init|=
literal|2
operator|+
literal|4
decl_stmt|;
comment|/**      * The number of bytes (or bits of address space) to use for the      * alignment boundary of segment records.      */
specifier|static
specifier|final
name|int
name|RECORD_ALIGN_BITS
init|=
literal|2
decl_stmt|;
comment|// align at the four-byte boundary
comment|/**      * Maximum segment size      */
specifier|static
specifier|final
name|int
name|MAX_SEGMENT_SIZE
init|=
literal|1
operator|<<
literal|18
decl_stmt|;
comment|// 256kB
comment|/**      * The size limit for small values. The variable length of small values      * is encoded as a single byte with the high bit as zero, which gives us      * seven bits for encoding the length of the value.      */
specifier|static
specifier|final
name|int
name|SMALL_LIMIT
init|=
literal|1
operator|<<
literal|7
decl_stmt|;
comment|/**      * The size limit for medium values. The variable length of medium values      * is encoded as two bytes with the highest bits of the first byte set to      * one and zero, which gives us 14 bits for encoding the length of the      * value. And since small values are never stored as medium ones, we can      * extend the size range to cover that many longer values.      */
specifier|static
specifier|final
name|int
name|MEDIUM_LIMIT
init|=
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|2
operator|)
operator|)
operator|+
name|SMALL_LIMIT
decl_stmt|;
comment|/**      * Maximum size of small blob IDs. A small blob ID is stored in a value      * record whose length field contains the pattern "1110" in its most      * significant bits. Since two bytes are used to store both the bit pattern      * and the actual length of the blob ID, a maximum of 2^12 values can be      * stored in the length field.      */
specifier|static
specifier|final
name|int
name|BLOB_ID_SMALL_LIMIT
init|=
literal|1
operator|<<
literal|12
decl_stmt|;
specifier|static
specifier|final
name|int
name|GC_FULL_GENERATION_OFFSET
init|=
literal|4
decl_stmt|;
specifier|static
specifier|final
name|int
name|GC_GENERATION_OFFSET
init|=
literal|10
decl_stmt|;
specifier|static
specifier|final
name|int
name|REFERENCED_SEGMENT_ID_COUNT_OFFSET
init|=
literal|14
decl_stmt|;
specifier|static
specifier|final
name|int
name|RECORD_NUMBER_COUNT_OFFSET
init|=
literal|18
decl_stmt|;
annotation|@
name|Nonnull
specifier|private
specifier|final
name|SegmentReader
name|reader
decl_stmt|;
annotation|@
name|Nonnull
specifier|private
specifier|final
name|SegmentId
name|id
decl_stmt|;
specifier|private
specifier|final
name|SegmentData
name|data
decl_stmt|;
comment|/**      * Version of the segment storage format.      */
annotation|@
name|Nonnull
specifier|private
specifier|final
name|SegmentVersion
name|version
decl_stmt|;
comment|/**      * The table translating record numbers to offsets.      */
specifier|private
specifier|final
name|RecordNumbers
name|recordNumbers
decl_stmt|;
comment|/**      * The table translating references to segment IDs.      */
specifier|private
specifier|final
name|SegmentReferences
name|segmentReferences
decl_stmt|;
comment|/**      * Align an {@code address} on the given {@code boundary}      *      * @param address     address to align      * @param boundary    boundary to align to      * @return  {@code n = address + a} such that {@code n % boundary == 0} and      *          {@code 0<= a< boundary}.      */
specifier|static
name|int
name|align
parameter_list|(
name|int
name|address
parameter_list|,
name|int
name|boundary
parameter_list|)
block|{
return|return
operator|(
name|address
operator|+
name|boundary
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
return|;
block|}
name|Segment
parameter_list|(
annotation|@
name|Nonnull
name|SegmentId
name|id
parameter_list|,
annotation|@
name|Nonnull
name|SegmentReader
name|reader
parameter_list|,
annotation|@
name|Nonnull
name|byte
index|[]
name|buffer
parameter_list|,
annotation|@
name|Nonnull
name|RecordNumbers
name|recordNumbers
parameter_list|,
annotation|@
name|Nonnull
name|SegmentReferences
name|segmentReferences
parameter_list|,
annotation|@
name|Nonnull
name|String
name|info
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|checkNotNull
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|this
operator|.
name|reader
operator|=
name|checkNotNull
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|this
operator|.
name|info
operator|=
name|checkNotNull
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|.
name|isDataSegmentId
argument_list|()
condition|)
block|{
name|this
operator|.
name|data
operator|=
name|newSegmentData
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|data
operator|=
name|newRawSegmentData
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|version
operator|=
name|SegmentVersion
operator|.
name|fromByte
argument_list|(
name|buffer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|this
operator|.
name|recordNumbers
operator|=
name|recordNumbers
expr_stmt|;
name|this
operator|.
name|segmentReferences
operator|=
name|segmentReferences
expr_stmt|;
name|id
operator|.
name|loaded
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Segment
parameter_list|(
annotation|@
name|Nonnull
name|SegmentIdProvider
name|idProvider
parameter_list|,
annotation|@
name|Nonnull
name|SegmentReader
name|reader
parameter_list|,
annotation|@
name|Nonnull
specifier|final
name|SegmentId
name|id
parameter_list|,
annotation|@
name|Nonnull
specifier|final
name|ByteBuffer
name|data
parameter_list|)
block|{
name|this
operator|.
name|reader
operator|=
name|checkNotNull
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|checkNotNull
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|.
name|isDataSegmentId
argument_list|()
condition|)
block|{
name|this
operator|.
name|data
operator|=
name|newSegmentData
argument_list|(
name|checkNotNull
argument_list|(
name|data
argument_list|)
operator|.
name|slice
argument_list|()
argument_list|)
expr_stmt|;
name|byte
name|segmentVersion
init|=
name|this
operator|.
name|data
operator|.
name|getVersion
argument_list|()
decl_stmt|;
name|checkState
argument_list|(
name|this
operator|.
name|data
operator|.
name|getSignature
argument_list|()
operator|.
name|equals
argument_list|(
literal|"0aK"
argument_list|)
operator|&&
name|isValid
argument_list|(
name|segmentVersion
argument_list|)
argument_list|,
operator|new
name|Object
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"Invalid segment format. Dumping segment %s\n%s"
argument_list|,
name|id
argument_list|,
name|toHex
argument_list|(
name|data
operator|.
name|array
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|SegmentVersion
operator|.
name|fromByte
argument_list|(
name|segmentVersion
argument_list|)
expr_stmt|;
name|this
operator|.
name|recordNumbers
operator|=
name|readRecordNumberOffsets
argument_list|()
expr_stmt|;
name|this
operator|.
name|segmentReferences
operator|=
name|readReferencedSegments
argument_list|(
name|idProvider
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|data
operator|=
name|newRawSegmentData
argument_list|(
name|checkNotNull
argument_list|(
name|data
argument_list|)
operator|.
name|slice
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|LATEST_VERSION
expr_stmt|;
name|this
operator|.
name|recordNumbers
operator|=
operator|new
name|IdentityRecordNumbers
argument_list|()
expr_stmt|;
name|this
operator|.
name|segmentReferences
operator|=
operator|new
name|IllegalSegmentReferences
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|String
name|toHex
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|ByteArrayOutputStream
name|out
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
try|try
block|{
name|HexDump
operator|.
name|dump
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|out
operator|.
name|toString
argument_list|(
name|Charsets
operator|.
name|UTF_8
operator|.
name|name
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|"Error dumping segment: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
return|;
block|}
finally|finally
block|{
name|closeQuietly
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Read the serialized table mapping record numbers to offsets.      *      * @return An instance of {@link RecordNumbers}, never {@code null}.      */
specifier|private
name|RecordNumbers
name|readRecordNumberOffsets
parameter_list|()
block|{
name|int
name|recordNumberCount
init|=
name|data
operator|.
name|getRecordReferencesCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|recordNumberCount
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_RECORD_NUMBERS
return|;
block|}
name|int
name|maxIndex
init|=
name|data
operator|.
name|getRecordReferenceNumber
argument_list|(
name|recordNumberCount
operator|-
literal|1
argument_list|)
decl_stmt|;
name|byte
index|[]
name|types
init|=
operator|new
name|byte
index|[
name|maxIndex
operator|+
literal|1
index|]
decl_stmt|;
name|int
index|[]
name|offsets
init|=
operator|new
name|int
index|[
name|maxIndex
operator|+
literal|1
index|]
decl_stmt|;
name|fill
argument_list|(
name|offsets
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|recordNumberCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|recordNumber
init|=
name|data
operator|.
name|getRecordReferenceNumber
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|types
index|[
name|recordNumber
index|]
operator|=
name|data
operator|.
name|getRecordReferenceType
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|offsets
index|[
name|recordNumber
index|]
operator|=
name|data
operator|.
name|getRecordReferenceOffset
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ImmutableRecordNumbers
argument_list|(
name|offsets
argument_list|,
name|types
argument_list|)
return|;
block|}
specifier|private
name|SegmentReferences
name|readReferencedSegments
parameter_list|(
specifier|final
name|SegmentIdProvider
name|idProvider
parameter_list|)
block|{
name|checkState
argument_list|(
name|getReferencedSegmentIdCount
argument_list|()
operator|+
literal|1
operator|<
literal|0xffff
argument_list|,
literal|"Segment cannot have more than 0xffff references"
argument_list|)
expr_stmt|;
specifier|final
name|int
name|referencedSegmentIdCount
init|=
name|getReferencedSegmentIdCount
argument_list|()
decl_stmt|;
comment|// We need to keep SegmentId references (as opposed to e.g. UUIDs)
comment|// here as frequently resolving the segment ids via the segment id
comment|// tables is prohibitively expensive.
comment|// These SegmentId references are not a problem wrt. heap usage as
comment|// their individual memoised references to their underlying segment
comment|// is managed via the SegmentCache. It is the size of that cache that
comment|// keeps overall heap usage by Segment instances bounded.
comment|// See OAK-6106.
specifier|final
name|SegmentId
index|[]
name|refIds
init|=
operator|new
name|SegmentId
index|[
name|referencedSegmentIdCount
index|]
decl_stmt|;
return|return
operator|new
name|SegmentReferences
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SegmentId
name|getSegmentId
parameter_list|(
name|int
name|reference
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|reference
operator|<=
name|referencedSegmentIdCount
argument_list|,
literal|"Segment reference out of bounds"
argument_list|)
expr_stmt|;
name|SegmentId
name|id
init|=
name|refIds
index|[
name|reference
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|refIds
init|)
block|{
name|id
operator|=
name|refIds
index|[
name|reference
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
name|long
name|msb
init|=
name|data
operator|.
name|getSegmentReferenceMsb
argument_list|(
name|reference
operator|-
literal|1
argument_list|)
decl_stmt|;
name|long
name|lsb
init|=
name|data
operator|.
name|getSegmentReferenceLsb
argument_list|(
name|reference
operator|-
literal|1
argument_list|)
decl_stmt|;
name|id
operator|=
name|idProvider
operator|.
name|newSegmentId
argument_list|(
name|msb
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|refIds
index|[
name|reference
operator|-
literal|1
index|]
operator|=
name|id
expr_stmt|;
block|}
block|}
block|}
return|return
name|id
return|;
block|}
annotation|@
name|Nonnull
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|SegmentId
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractIterator
argument_list|<
name|SegmentId
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|reference
init|=
literal|1
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|SegmentId
name|computeNext
parameter_list|()
block|{
if|if
condition|(
name|reference
operator|<=
name|referencedSegmentIdCount
condition|)
block|{
return|return
name|getSegmentId
argument_list|(
name|reference
operator|++
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|endOfData
argument_list|()
return|;
block|}
block|}
block|}
return|;
block|}
block|}
return|;
block|}
specifier|public
name|SegmentVersion
name|getSegmentVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
specifier|public
name|SegmentId
name|getSegmentId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
specifier|public
name|int
name|getReferencedSegmentIdCount
parameter_list|()
block|{
return|return
name|data
operator|.
name|getSegmentReferencesCount
argument_list|()
return|;
block|}
specifier|private
name|int
name|getRecordNumberCount
parameter_list|()
block|{
return|return
name|data
operator|.
name|getRecordReferencesCount
argument_list|()
return|;
block|}
specifier|public
name|UUID
name|getReferencedSegmentId
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|segmentReferences
operator|.
name|getSegmentId
argument_list|(
name|index
operator|+
literal|1
argument_list|)
operator|.
name|asUUID
argument_list|()
return|;
block|}
comment|/**      * Determine the gc generation a segment from its data. Note that bulk      * segments don't have generations (i.e. stay at 0).      *      * @param data      the data of the segment      * @param segmentId the id of the segment      * @return the gc generation of this segment or {@link GCGeneration#NULL} if      * this is bulk segment.      */
specifier|public
specifier|static
name|GCGeneration
name|getGcGeneration
parameter_list|(
name|SegmentData
name|data
parameter_list|,
name|UUID
name|segmentId
parameter_list|)
block|{
if|if
condition|(
name|isDataSegmentId
argument_list|(
name|segmentId
operator|.
name|getLeastSignificantBits
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|newGCGeneration
argument_list|(
name|data
operator|.
name|getGeneration
argument_list|()
argument_list|,
name|data
operator|.
name|getFullGeneration
argument_list|()
argument_list|,
name|data
operator|.
name|isCompacted
argument_list|()
argument_list|)
return|;
block|}
return|return
name|GCGeneration
operator|.
name|NULL
return|;
block|}
comment|/**      * Determine the gc generation of this segment. Note that bulk segments don't have      * generations (i.e. stay at 0).      * @return  the gc generation of this segment or 0 if this is bulk segment.      */
annotation|@
name|Nonnull
specifier|public
name|GCGeneration
name|getGcGeneration
parameter_list|()
block|{
return|return
name|getGcGeneration
argument_list|(
name|data
argument_list|,
name|id
operator|.
name|asUUID
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|volatile
name|String
name|info
decl_stmt|;
comment|/**      * Returns the segment meta data of this segment or {@code null} if none is present.      *<p>      * The segment meta data is a string of the format {@code "{wid=W,sno=S,gc=G,t=T}"}      * where:      *<ul>      *<li>{@code W} is the writer id {@code wid},</li>      *<li>{@code S} is a unique, increasing sequence number corresponding to the allocation order      * of the segments in this store,</li>      *<li>{@code G} is the garbage collection generation (i.e. the number of compaction cycles      * that have been run),</li>      *<li>{@code T} is a time stamp according to {@link System#currentTimeMillis()}.</li>      *</ul>      * @return the segment meta data      */
annotation|@
name|CheckForNull
name|String
name|getSegmentInfo
parameter_list|()
block|{
if|if
condition|(
name|info
operator|==
literal|null
operator|&&
name|id
operator|.
name|isDataSegmentId
argument_list|()
condition|)
block|{
name|info
operator|=
name|readString
argument_list|(
name|recordNumbers
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getRecordNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|data
operator|.
name|size
argument_list|()
return|;
block|}
name|byte
name|readByte
parameter_list|(
name|int
name|recordNumber
parameter_list|)
block|{
return|return
name|data
operator|.
name|readByte
argument_list|(
name|recordNumbers
operator|.
name|getOffset
argument_list|(
name|recordNumber
argument_list|)
argument_list|)
return|;
block|}
name|byte
name|readByte
parameter_list|(
name|int
name|recordNumber
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
name|data
operator|.
name|readByte
argument_list|(
name|recordNumbers
operator|.
name|getOffset
argument_list|(
name|recordNumber
argument_list|)
operator|+
name|offset
argument_list|)
return|;
block|}
name|short
name|readShort
parameter_list|(
name|int
name|recordNumber
parameter_list|)
block|{
return|return
name|data
operator|.
name|readShort
argument_list|(
name|recordNumbers
operator|.
name|getOffset
argument_list|(
name|recordNumber
argument_list|)
argument_list|)
return|;
block|}
name|int
name|readInt
parameter_list|(
name|int
name|recordNumber
parameter_list|)
block|{
return|return
name|data
operator|.
name|readInt
argument_list|(
name|recordNumbers
operator|.
name|getOffset
argument_list|(
name|recordNumber
argument_list|)
argument_list|)
return|;
block|}
name|int
name|readInt
parameter_list|(
name|int
name|recordNumber
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
name|data
operator|.
name|readInt
argument_list|(
name|recordNumbers
operator|.
name|getOffset
argument_list|(
name|recordNumber
argument_list|)
operator|+
name|offset
argument_list|)
return|;
block|}
name|long
name|readLong
parameter_list|(
name|int
name|recordNumber
parameter_list|)
block|{
return|return
name|data
operator|.
name|readLong
argument_list|(
name|recordNumbers
operator|.
name|getOffset
argument_list|(
name|recordNumber
argument_list|)
argument_list|)
return|;
block|}
name|void
name|readBytes
parameter_list|(
name|int
name|recordNumber
parameter_list|,
name|int
name|position
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|readBytes
argument_list|(
name|recordNumber
argument_list|,
name|position
argument_list|,
name|length
argument_list|)
operator|.
name|get
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|ByteBuffer
name|readBytes
parameter_list|(
name|int
name|recordNumber
parameter_list|,
name|int
name|position
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|data
operator|.
name|readBytes
argument_list|(
name|recordNumbers
operator|.
name|getOffset
argument_list|(
name|recordNumber
argument_list|)
operator|+
name|position
argument_list|,
name|length
argument_list|)
return|;
block|}
annotation|@
name|Nonnull
name|RecordId
name|readRecordId
parameter_list|(
name|int
name|recordNumber
parameter_list|,
name|int
name|rawOffset
parameter_list|,
name|int
name|recordIdOffset
parameter_list|)
block|{
name|int
name|offset
init|=
name|recordNumbers
operator|.
name|getOffset
argument_list|(
name|recordNumber
argument_list|)
operator|+
name|rawOffset
operator|+
name|recordIdOffset
operator|*
name|RecordIdData
operator|.
name|BYTES
decl_stmt|;
name|RecordIdData
name|recordIdData
init|=
name|data
operator|.
name|readRecordId
argument_list|(
name|offset
argument_list|)
decl_stmt|;
return|return
operator|new
name|RecordId
argument_list|(
name|dereferenceSegmentId
argument_list|(
name|recordIdData
operator|.
name|getSegmentReference
argument_list|()
argument_list|)
argument_list|,
name|recordIdData
operator|.
name|getRecordNumber
argument_list|()
argument_list|)
return|;
block|}
name|RecordId
name|readRecordId
parameter_list|(
name|int
name|recordNumber
parameter_list|,
name|int
name|rawOffset
parameter_list|)
block|{
return|return
name|readRecordId
argument_list|(
name|recordNumber
argument_list|,
name|rawOffset
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|RecordId
name|readRecordId
parameter_list|(
name|int
name|recordNumber
parameter_list|)
block|{
return|return
name|readRecordId
argument_list|(
name|recordNumber
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
annotation|@
name|Nonnull
specifier|private
name|SegmentId
name|dereferenceSegmentId
parameter_list|(
name|int
name|reference
parameter_list|)
block|{
if|if
condition|(
name|reference
operator|==
literal|0
condition|)
block|{
return|return
name|id
return|;
block|}
name|SegmentId
name|id
init|=
name|segmentReferences
operator|.
name|getSegmentId
argument_list|(
name|reference
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Referenced segment not found"
argument_list|)
throw|;
block|}
return|return
name|id
return|;
block|}
annotation|@
name|Nonnull
name|String
name|readString
parameter_list|(
name|int
name|recordNumber
parameter_list|)
block|{
name|StringData
name|data
init|=
name|this
operator|.
name|data
operator|.
name|readString
argument_list|(
name|recordNumbers
operator|.
name|getOffset
argument_list|(
name|recordNumber
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|isString
argument_list|()
condition|)
block|{
return|return
name|data
operator|.
name|getString
argument_list|()
return|;
block|}
if|if
condition|(
name|data
operator|.
name|isRecordId
argument_list|()
condition|)
block|{
name|SegmentId
name|segmentId
init|=
name|dereferenceSegmentId
argument_list|(
name|data
operator|.
name|getRecordId
argument_list|()
operator|.
name|getSegmentReference
argument_list|()
argument_list|)
decl_stmt|;
name|RecordId
name|recordId
init|=
operator|new
name|RecordId
argument_list|(
name|segmentId
argument_list|,
name|data
operator|.
name|getRecordId
argument_list|()
operator|.
name|getRecordNumber
argument_list|()
argument_list|)
decl_stmt|;
name|ListRecord
name|list
init|=
operator|new
name|ListRecord
argument_list|(
name|recordId
argument_list|,
operator|(
name|data
operator|.
name|getLength
argument_list|()
operator|+
name|BLOCK_SIZE
operator|-
literal|1
operator|)
operator|/
name|BLOCK_SIZE
argument_list|)
decl_stmt|;
try|try
init|(
name|SegmentStream
name|stream
init|=
operator|new
name|SegmentStream
argument_list|(
operator|new
name|RecordId
argument_list|(
name|id
argument_list|,
name|recordNumber
argument_list|)
argument_list|,
name|list
argument_list|,
name|data
operator|.
name|getLength
argument_list|()
argument_list|)
init|)
block|{
return|return
name|stream
operator|.
name|getString
argument_list|()
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid return value"
argument_list|)
throw|;
block|}
annotation|@
name|Nonnull
name|Template
name|readTemplate
parameter_list|(
name|int
name|recordNumber
parameter_list|)
block|{
name|int
name|head
init|=
name|readInt
argument_list|(
name|recordNumber
argument_list|)
decl_stmt|;
name|boolean
name|hasPrimaryType
init|=
operator|(
name|head
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|hasMixinTypes
init|=
operator|(
name|head
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|zeroChildNodes
init|=
operator|(
name|head
operator|&
operator|(
literal|1
operator|<<
literal|29
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|boolean
name|manyChildNodes
init|=
operator|(
name|head
operator|&
operator|(
literal|1
operator|<<
literal|28
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|mixinCount
init|=
operator|(
name|head
operator|>>
literal|18
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|propertyCount
init|=
name|head
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|18
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|offset
init|=
literal|4
decl_stmt|;
name|PropertyState
name|primaryType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|hasPrimaryType
condition|)
block|{
name|RecordId
name|primaryId
init|=
name|readRecordId
argument_list|(
name|recordNumber
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|primaryType
operator|=
name|PropertyStates
operator|.
name|createProperty
argument_list|(
literal|"jcr:primaryType"
argument_list|,
name|reader
operator|.
name|readString
argument_list|(
name|primaryId
argument_list|)
argument_list|,
name|Type
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|RECORD_ID_BYTES
expr_stmt|;
block|}
name|PropertyState
name|mixinTypes
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|hasMixinTypes
condition|)
block|{
name|String
index|[]
name|mixins
init|=
operator|new
name|String
index|[
name|mixinCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mixins
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RecordId
name|mixinId
init|=
name|readRecordId
argument_list|(
name|recordNumber
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|mixins
index|[
name|i
index|]
operator|=
name|reader
operator|.
name|readString
argument_list|(
name|mixinId
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|RECORD_ID_BYTES
expr_stmt|;
block|}
name|mixinTypes
operator|=
name|PropertyStates
operator|.
name|createProperty
argument_list|(
literal|"jcr:mixinTypes"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|mixins
argument_list|)
argument_list|,
name|Type
operator|.
name|NAMES
argument_list|)
expr_stmt|;
block|}
name|String
name|childName
init|=
name|Template
operator|.
name|ZERO_CHILD_NODES
decl_stmt|;
if|if
condition|(
name|manyChildNodes
condition|)
block|{
name|childName
operator|=
name|Template
operator|.
name|MANY_CHILD_NODES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zeroChildNodes
condition|)
block|{
name|RecordId
name|childNameId
init|=
name|readRecordId
argument_list|(
name|recordNumber
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|childName
operator|=
name|reader
operator|.
name|readString
argument_list|(
name|childNameId
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|RECORD_ID_BYTES
expr_stmt|;
block|}
name|PropertyTemplate
index|[]
name|properties
decl_stmt|;
name|properties
operator|=
name|readProps
argument_list|(
name|propertyCount
argument_list|,
name|recordNumber
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|new
name|Template
argument_list|(
name|reader
argument_list|,
name|primaryType
argument_list|,
name|mixinTypes
argument_list|,
name|properties
argument_list|,
name|childName
argument_list|)
return|;
block|}
specifier|private
name|PropertyTemplate
index|[]
name|readProps
parameter_list|(
name|int
name|propertyCount
parameter_list|,
name|int
name|recordNumber
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|PropertyTemplate
index|[]
name|properties
init|=
operator|new
name|PropertyTemplate
index|[
name|propertyCount
index|]
decl_stmt|;
if|if
condition|(
name|propertyCount
operator|>
literal|0
condition|)
block|{
name|RecordId
name|id
init|=
name|readRecordId
argument_list|(
name|recordNumber
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|ListRecord
name|propertyNames
init|=
operator|new
name|ListRecord
argument_list|(
name|id
argument_list|,
name|properties
operator|.
name|length
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|RECORD_ID_BYTES
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|propertyCount
condition|;
name|i
operator|++
control|)
block|{
name|byte
name|type
init|=
name|readByte
argument_list|(
name|recordNumber
argument_list|,
name|offset
operator|++
argument_list|)
decl_stmt|;
name|properties
index|[
name|i
index|]
operator|=
operator|new
name|PropertyTemplate
argument_list|(
name|i
argument_list|,
name|reader
operator|.
name|readString
argument_list|(
name|propertyNames
operator|.
name|getEntry
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|Type
operator|.
name|fromTag
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
operator|<
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|properties
return|;
block|}
specifier|static
name|long
name|readLength
parameter_list|(
name|RecordId
name|id
parameter_list|)
block|{
return|return
name|id
operator|.
name|getSegment
argument_list|()
operator|.
name|readLength
argument_list|(
name|id
operator|.
name|getRecordNumber
argument_list|()
argument_list|)
return|;
block|}
name|long
name|readLength
parameter_list|(
name|int
name|recordNumber
parameter_list|)
block|{
return|return
name|data
operator|.
name|readLength
argument_list|(
name|recordNumbers
operator|.
name|getOffset
argument_list|(
name|recordNumber
argument_list|)
argument_list|)
return|;
block|}
comment|//------------------------------------------------------------< Object>--
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringWriter
name|string
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
try|try
init|(
name|PrintWriter
name|writer
init|=
operator|new
name|PrintWriter
argument_list|(
name|string
argument_list|)
init|)
block|{
name|writer
operator|.
name|format
argument_list|(
literal|"Segment %s (%d bytes)%n"
argument_list|,
name|id
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|segmentInfo
init|=
name|getSegmentInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|segmentInfo
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|format
argument_list|(
literal|"Info: %s, Generation: %s%n"
argument_list|,
name|segmentInfo
argument_list|,
name|getGcGeneration
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|.
name|isDataSegmentId
argument_list|()
condition|)
block|{
name|writer
operator|.
name|println
argument_list|(
literal|"--------------------------------------------------------------------------"
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|SegmentId
name|segmentId
range|:
name|segmentReferences
control|)
block|{
name|writer
operator|.
name|format
argument_list|(
literal|"reference %02x: %s%n"
argument_list|,
name|i
operator|++
argument_list|,
name|segmentId
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
name|entry
range|:
name|recordNumbers
control|)
block|{
name|writer
operator|.
name|format
argument_list|(
literal|"%10s record %08x: %08x%n"
argument_list|,
name|entry
operator|.
name|getType
argument_list|()
argument_list|,
name|entry
operator|.
name|getRecordNumber
argument_list|()
argument_list|,
name|entry
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|writer
operator|.
name|println
argument_list|(
literal|"--------------------------------------------------------------------------"
argument_list|)
expr_stmt|;
try|try
block|{
name|data
operator|.
name|hexDump
argument_list|(
operator|new
name|WriterOutputStream
argument_list|(
name|writer
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|writer
operator|.
name|println
argument_list|(
literal|"--------------------------------------------------------------------------"
argument_list|)
expr_stmt|;
block|}
return|return
name|string
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|void
name|writeTo
parameter_list|(
name|OutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|binDump
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/**      * A consumer of record data.      */
specifier|public
interface|interface
name|RecordConsumer
block|{
comment|/**          * Consume data about a record.          *          * @param number the record number.          * @param type   the record type.          * @param offset the offset where the record is stored.          */
name|void
name|consume
parameter_list|(
name|int
name|number
parameter_list|,
name|RecordType
name|type
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
block|}
comment|/**      * Iterate over the records contained in this segment.      *      * @param consumer an instance of {@link RecordConsumer}.      */
specifier|public
name|void
name|forEachRecord
parameter_list|(
name|RecordConsumer
name|consumer
parameter_list|)
block|{
for|for
control|(
name|Entry
name|entry
range|:
name|recordNumbers
control|)
block|{
name|consumer
operator|.
name|consume
argument_list|(
name|entry
operator|.
name|getRecordNumber
argument_list|()
argument_list|,
name|entry
operator|.
name|getType
argument_list|()
argument_list|,
name|entry
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Estimate of how much memory this instance would occupy in the segment      * cache.      */
name|int
name|estimateMemoryUsage
parameter_list|()
block|{
name|int
name|size
init|=
name|OBJECT_HEADER_SIZE
operator|+
literal|76
decl_stmt|;
name|size
operator|+=
literal|56
expr_stmt|;
comment|// 7 refs x 8 bytes
if|if
condition|(
name|id
operator|.
name|isDataSegmentId
argument_list|()
condition|)
block|{
name|int
name|recordNumberCount
init|=
name|getRecordNumberCount
argument_list|()
decl_stmt|;
name|size
operator|+=
literal|5
operator|*
name|recordNumberCount
expr_stmt|;
name|int
name|referencedSegmentIdCount
init|=
name|getReferencedSegmentIdCount
argument_list|()
decl_stmt|;
name|size
operator|+=
literal|8
operator|*
name|referencedSegmentIdCount
expr_stmt|;
name|size
operator|+=
name|StringUtils
operator|.
name|estimateMemoryUsage
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|size
operator|+=
name|data
operator|.
name|estimateMemoryUsage
argument_list|()
expr_stmt|;
name|size
operator|+=
name|id
operator|.
name|estimateMemoryUsage
argument_list|()
expr_stmt|;
return|return
name|size
return|;
block|}
block|}
end_class

end_unit

