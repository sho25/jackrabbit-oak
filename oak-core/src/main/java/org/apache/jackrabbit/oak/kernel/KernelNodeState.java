begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|kernel
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptyList
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|EmptyNodeState
operator|.
name|EMPTY_NODE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|EmptyNodeState
operator|.
name|MISSING_NODE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|PropertyStates
operator|.
name|createProperty
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|PropertyType
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheLoader
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LoadingCache
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|api
operator|.
name|MicroKernel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|api
operator|.
name|MicroKernelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|cache
operator|.
name|StringCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|json
operator|.
name|JsopReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|json
operator|.
name|JsopTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|PropertyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|json
operator|.
name|TypeCodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|BinaryPropertyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|BooleanPropertyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|DoublePropertyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|EmptyNodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|LongPropertyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|MemoryNodeBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|PropertyStates
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|StringPropertyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|value
operator|.
name|Conversions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|AbstractChildNodeEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|AbstractNodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|ChildNodeEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeStateDiff
import|;
end_import

begin_comment
comment|/**  * Basic {@link NodeState} implementation based on the {@link MicroKernel}  * interface. This class makes an attempt to load data lazily.  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|KernelNodeState
extends|extends
name|AbstractNodeState
block|{
comment|/**      * Maximum number of child nodes kept in memory.      */
specifier|public
specifier|static
specifier|final
name|int
name|MAX_CHILD_NAMES
init|=
literal|100
decl_stmt|;
comment|/**      * Number of child nodes beyond which {@link MicroKernel#diff(String, String, String, int)}      * is used for diffing.      */
specifier|public
specifier|static
specifier|final
name|int
name|LOCAL_DIFF_THRESHOLD
init|=
literal|10
decl_stmt|;
comment|/**      * Dummy cache instance for static {@link #NULL} kernel node state.      */
specifier|private
specifier|static
specifier|final
name|LoadingCache
argument_list|<
name|String
argument_list|,
name|KernelNodeState
argument_list|>
name|DUMMY_CACHE
init|=
name|CacheBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|(
operator|new
name|CacheLoader
argument_list|<
name|String
argument_list|,
name|KernelNodeState
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|KernelNodeState
name|load
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|Exception
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|/**      * This {@code NULL} kernel node state is used as a value in the      * {@link #cache} to indicate that there is no node state at the given      * path and revision. This object is only used internally and never leaves      * this {@link KernelNodeState}.      */
specifier|private
specifier|static
specifier|final
name|KernelNodeState
name|NULL
init|=
operator|new
name|KernelNodeState
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|KernelNodeStore
name|store
decl_stmt|;
specifier|private
specifier|final
name|MicroKernel
name|kernel
decl_stmt|;
specifier|private
specifier|final
name|String
name|path
decl_stmt|;
specifier|private
name|String
name|revision
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|PropertyState
argument_list|>
name|properties
decl_stmt|;
specifier|private
name|long
name|childNodeCount
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|long
name|childNodeCountMin
decl_stmt|;
specifier|private
name|String
name|hash
decl_stmt|;
specifier|private
name|String
name|id
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|childNames
decl_stmt|;
comment|/**      * {@code true} is this is a node state from a branch. {@code false}      * otherwise.      *<p>      * FIXME: this is a workaround to avoid creating branches from a branch      * until this is supported by the MicroKernel. See {@link KernelNodeState#builder()}.      */
specifier|private
name|boolean
name|isBranch
decl_stmt|;
specifier|private
specifier|final
name|LoadingCache
argument_list|<
name|String
argument_list|,
name|KernelNodeState
argument_list|>
name|cache
decl_stmt|;
comment|/**      * Create a new instance of this class representing the node at the      * given {@code path} and {@code revision}. It is an error if the      * underlying Microkernel does not contain such a node.      *      * @param store the underlying KernelNodeStore      * @param path the path of this KernelNodeState      * @param revision the revision of the node to read from the kernel.      * @param cache the KernelNodeState cache      */
specifier|public
name|KernelNodeState
parameter_list|(
name|KernelNodeStore
name|store
parameter_list|,
name|String
name|path
parameter_list|,
name|String
name|revision
parameter_list|,
name|LoadingCache
argument_list|<
name|String
argument_list|,
name|KernelNodeState
argument_list|>
name|cache
parameter_list|)
block|{
name|this
operator|.
name|store
operator|=
name|store
expr_stmt|;
name|this
operator|.
name|kernel
operator|=
name|store
operator|.
name|getKernel
argument_list|()
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|checkNotNull
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|this
operator|.
name|revision
operator|=
name|checkNotNull
argument_list|(
name|revision
argument_list|)
expr_stmt|;
name|this
operator|.
name|cache
operator|=
name|checkNotNull
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
specifier|private
name|KernelNodeState
parameter_list|()
block|{
name|this
operator|.
name|store
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|kernel
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|path
operator|=
literal|"null"
expr_stmt|;
name|this
operator|.
name|revision
operator|=
literal|"null"
expr_stmt|;
name|this
operator|.
name|cache
operator|=
name|DUMMY_CACHE
expr_stmt|;
block|}
specifier|private
name|void
name|init
parameter_list|()
block|{
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|properties
operator|==
literal|null
condition|)
block|{
name|String
name|json
init|=
name|kernel
operator|.
name|getNodes
argument_list|(
name|path
argument_list|,
name|revision
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MAX_CHILD_NAMES
argument_list|,
literal|"{\"properties\":[\"*\",\":hash\",\":id\"]}"
argument_list|)
decl_stmt|;
name|checkNotNull
argument_list|(
name|json
argument_list|,
literal|"No node found at path [%s] for revision [%s]"
argument_list|,
name|path
argument_list|,
name|revision
argument_list|)
expr_stmt|;
name|JsopReader
name|reader
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|json
argument_list|)
decl_stmt|;
name|reader
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|properties
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|PropertyState
argument_list|>
argument_list|()
expr_stmt|;
name|childNames
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
do|do
block|{
name|String
name|name
init|=
name|StringCache
operator|.
name|get
argument_list|(
name|reader
operator|.
name|readString
argument_list|()
argument_list|)
decl_stmt|;
name|reader
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
literal|":childNodeCount"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|childNodeCount
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|reader
operator|.
name|read
argument_list|(
name|JsopReader
operator|.
name|NUMBER
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|":hash"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|hash
operator|=
operator|new
name|String
argument_list|(
name|reader
operator|.
name|read
argument_list|(
name|JsopReader
operator|.
name|STRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|// save some memory
name|hash
operator|=
name|id
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|":id"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|id
operator|=
operator|new
name|String
argument_list|(
name|reader
operator|.
name|read
argument_list|(
name|JsopReader
operator|.
name|STRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|.
name|equals
argument_list|(
name|hash
argument_list|)
condition|)
block|{
comment|// save some memory
name|id
operator|=
name|hash
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|matches
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
name|reader
operator|.
name|read
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|childNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|matches
argument_list|(
literal|'['
argument_list|)
condition|)
block|{
name|properties
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|readArrayProperty
argument_list|(
name|name
argument_list|,
name|reader
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|properties
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|readProperty
argument_list|(
name|name
argument_list|,
name|reader
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|reader
operator|.
name|matches
argument_list|(
literal|','
argument_list|)
condition|)
do|;
name|reader
operator|.
name|read
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|reader
operator|.
name|read
argument_list|(
name|JsopReader
operator|.
name|END
argument_list|)
expr_stmt|;
comment|// optimize for empty childNodes
if|if
condition|(
name|childNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|childNames
operator|=
name|Collections
operator|.
name|emptySet
argument_list|()
expr_stmt|;
block|}
name|initialized
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|initialized
condition|)
block|{
comment|// refresh cache to force re-calculation of weight (OAK-643)
name|cache
operator|.
name|refresh
argument_list|(
name|revision
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initialized
operator|&&
operator|!
name|PathUtils
operator|.
name|denotesRoot
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|// OAK-591: check if we can re-use a previous revision
comment|// by looking up the node state by hash or id (if available)
comment|// introducing this secondary lookup basically means we point
comment|// back to a subtree in an older revision, in case it didn't change
name|String
name|hashOrId
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|hash
operator|!=
literal|null
condition|)
block|{
comment|// hash takes precedence
name|hashOrId
operator|=
name|hash
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|!=
literal|null
condition|)
block|{
name|hashOrId
operator|=
name|id
expr_stmt|;
block|}
if|if
condition|(
name|hashOrId
operator|!=
literal|null
condition|)
block|{
name|KernelNodeState
name|cached
init|=
name|cache
operator|.
name|getIfPresent
argument_list|(
name|hashOrId
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
operator|&&
name|cached
operator|.
name|path
operator|.
name|equals
argument_list|(
name|this
operator|.
name|path
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|this
operator|.
name|revision
operator|=
name|cached
operator|.
name|revision
expr_stmt|;
name|this
operator|.
name|childNames
operator|=
name|cached
operator|.
name|childNames
expr_stmt|;
name|this
operator|.
name|properties
operator|=
name|cached
operator|.
name|properties
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// store under secondary key
name|cache
operator|.
name|put
argument_list|(
name|hashOrId
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|exists
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getPropertyCount
parameter_list|()
block|{
name|init
argument_list|()
expr_stmt|;
return|return
name|properties
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasProperty
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|init
argument_list|()
expr_stmt|;
return|return
name|properties
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|PropertyState
name|getProperty
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|init
argument_list|()
expr_stmt|;
return|return
name|properties
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterable
argument_list|<
name|?
extends|extends
name|PropertyState
argument_list|>
name|getProperties
parameter_list|()
block|{
name|init
argument_list|()
expr_stmt|;
return|return
name|properties
operator|.
name|values
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getChildNodeCount
parameter_list|(
name|long
name|max
parameter_list|)
block|{
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|childNodeCount
operator|==
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
if|if
condition|(
name|childNodeCountMin
operator|>
name|max
condition|)
block|{
comment|// getChildNodeCount(max) was already called,
comment|// and we know the value is higher than max
return|return
name|childNodeCountMin
return|;
block|}
comment|// count the entries
name|Iterator
argument_list|<
name|?
extends|extends
name|ChildNodeEntry
argument_list|>
name|iterator
init|=
name|getChildNodeEntries
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|long
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|<=
name|max
condition|)
block|{
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// we know the exact number now
name|childNodeCount
operator|=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
comment|// remember we have at least this number of entries
name|childNodeCountMin
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|max
condition|)
block|{
comment|// we didn't count all entries
return|return
name|max
return|;
block|}
block|}
return|return
name|childNodeCount
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasChildNode
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|childNames
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// the named child node exits for sure
block|}
elseif|else
if|if
condition|(
name|getChildNodeCount
argument_list|(
name|MAX_CHILD_NAMES
argument_list|)
operator|<=
name|MAX_CHILD_NAMES
condition|)
block|{
return|return
literal|false
return|;
comment|// all child node names are cached, and none match
block|}
else|else
block|{
return|return
name|isValidName
argument_list|(
name|name
argument_list|)
operator|&&
name|getChildNode
argument_list|(
name|name
argument_list|)
operator|.
name|exists
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|NodeState
name|getChildNode
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|init
argument_list|()
expr_stmt|;
name|String
name|childPath
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|childNames
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|childPath
operator|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|path
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isValidName
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid name: "
operator|+
name|name
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|getChildNodeCount
argument_list|(
name|MAX_CHILD_NAMES
argument_list|)
operator|<=
name|MAX_CHILD_NAMES
condition|)
block|{
return|return
name|MISSING_NODE
return|;
block|}
else|else
block|{
name|childPath
operator|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|path
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|// OAK-506: Avoid the nodeExists() call when already cached
name|NodeState
name|state
init|=
name|cache
operator|.
name|getIfPresent
argument_list|(
name|revision
operator|+
name|childPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
block|{
return|return
name|MISSING_NODE
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
return|return
name|state
return|;
block|}
comment|// not able to tell from cache if node exists
comment|// need to ask MicroKernel
if|if
condition|(
operator|!
name|kernel
operator|.
name|nodeExists
argument_list|(
name|childPath
argument_list|,
name|revision
argument_list|)
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
name|revision
operator|+
name|childPath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|MISSING_NODE
return|;
block|}
block|}
try|try
block|{
return|return
name|cache
operator|.
name|get
argument_list|(
name|revision
operator|+
name|childPath
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MicroKernelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Iterable
argument_list|<
name|?
extends|extends
name|ChildNodeEntry
argument_list|>
name|getChildNodeEntries
parameter_list|()
block|{
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|childNodeCount
operator|<=
name|MAX_CHILD_NAMES
operator|&&
name|childNodeCount
operator|<=
name|childNames
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|iterable
argument_list|(
name|childNames
argument_list|)
return|;
block|}
name|List
argument_list|<
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
argument_list|>
name|iterables
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|iterables
operator|.
name|add
argument_list|(
name|iterable
argument_list|(
name|childNames
argument_list|)
argument_list|)
expr_stmt|;
name|iterables
operator|.
name|add
argument_list|(
name|getChildNodeEntries
argument_list|(
name|childNames
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Iterables
operator|.
name|concat
argument_list|(
name|iterables
argument_list|)
return|;
block|}
specifier|private
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
name|getChildNodeEntries
parameter_list|(
specifier|final
name|long
name|offset
parameter_list|)
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|ChildNodeEntry
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|ChildNodeEntry
argument_list|>
argument_list|()
block|{
specifier|private
name|long
name|currentOffset
init|=
name|offset
decl_stmt|;
specifier|private
name|Iterator
argument_list|<
name|ChildNodeEntry
argument_list|>
name|current
decl_stmt|;
block|{
name|fetchEntries
parameter_list|()
constructor_decl|;
block|}
specifier|private
name|void
name|fetchEntries
parameter_list|()
block|{
name|List
argument_list|<
name|ChildNodeEntry
argument_list|>
name|entries
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|MAX_CHILD_NAMES
argument_list|)
decl_stmt|;
name|String
name|json
init|=
name|kernel
operator|.
name|getNodes
argument_list|(
name|path
argument_list|,
name|revision
argument_list|,
literal|0
argument_list|,
name|currentOffset
argument_list|,
name|MAX_CHILD_NAMES
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|JsopReader
name|reader
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|json
argument_list|)
decl_stmt|;
name|reader
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
do|do
block|{
name|String
name|name
init|=
name|StringCache
operator|.
name|get
argument_list|(
name|reader
operator|.
name|readString
argument_list|()
argument_list|)
decl_stmt|;
name|reader
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|reader
operator|.
name|matches
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
name|reader
operator|.
name|read
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|entries
operator|.
name|add
argument_list|(
operator|new
name|KernelChildNodeEntry
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|matches
argument_list|(
literal|'['
argument_list|)
condition|)
block|{
while|while
condition|(
name|reader
operator|.
name|read
argument_list|()
operator|!=
literal|']'
condition|)
block|{
comment|// skip
block|}
block|}
else|else
block|{
name|reader
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|reader
operator|.
name|matches
argument_list|(
literal|','
argument_list|)
condition|)
do|;
name|reader
operator|.
name|read
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|reader
operator|.
name|read
argument_list|(
name|JsopReader
operator|.
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|current
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|currentOffset
operator|+=
name|entries
operator|.
name|size
argument_list|()
expr_stmt|;
name|current
operator|=
name|entries
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|current
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|fetchEntries
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ChildNodeEntry
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Reading past the end"
argument_list|)
throw|;
block|}
return|return
name|current
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**      * This implementation returns a {@link KernelNodeBuilder} unless this is not      * a root node or {@link #isBranch} is {@code true} in which case a      * {@link MemoryNodeBuilder} is returned.      *<p>      * TODO: this is a workaround to avoid creating branches from a branch      * until this is supported by the MicroKernel.      */
annotation|@
name|Override
specifier|public
name|NodeBuilder
name|builder
parameter_list|()
block|{
if|if
condition|(
name|isBranch
condition|)
block|{
return|return
operator|new
name|MemoryNodeBuilder
argument_list|(
name|this
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
literal|"/"
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
return|return
operator|new
name|KernelRootBuilder
argument_list|(
name|this
argument_list|,
name|store
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|MemoryNodeBuilder
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**      * Optimised comparison method that can avoid traversing all properties      * and child nodes if both this and the given base node state come from      * the same MicroKernel and either have the same content hash (when      * available) or are located at the same path in different revisions.      *      * @see<a href="https://issues.apache.org/jira/browse/OAK-175">OAK-175</a>      */
annotation|@
name|Override
specifier|public
name|boolean
name|compareAgainstBaseState
parameter_list|(
name|NodeState
name|base
parameter_list|,
name|NodeStateDiff
name|diff
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|base
condition|)
block|{
return|return
literal|true
return|;
comment|// no differences
block|}
elseif|else
if|if
condition|(
name|base
operator|==
name|EMPTY_NODE
operator|||
operator|!
name|base
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// special case
return|return
name|EmptyNodeState
operator|.
name|compareAgainstEmptyState
argument_list|(
name|this
argument_list|,
name|diff
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|base
operator|instanceof
name|KernelNodeState
condition|)
block|{
name|KernelNodeState
name|kbase
init|=
operator|(
name|KernelNodeState
operator|)
name|base
decl_stmt|;
if|if
condition|(
name|kernel
operator|.
name|equals
argument_list|(
name|kbase
operator|.
name|kernel
argument_list|)
condition|)
block|{
if|if
condition|(
name|revision
operator|.
name|equals
argument_list|(
name|kbase
operator|.
name|revision
argument_list|)
operator|&&
name|path
operator|.
name|equals
argument_list|(
name|kbase
operator|.
name|path
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// no differences
block|}
else|else
block|{
name|init
argument_list|()
expr_stmt|;
name|kbase
operator|.
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|hash
operator|!=
literal|null
operator|&&
name|hash
operator|.
name|equals
argument_list|(
name|kbase
operator|.
name|hash
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// no differences
block|}
elseif|else
if|if
condition|(
name|id
operator|!=
literal|null
operator|&&
name|id
operator|.
name|equals
argument_list|(
name|kbase
operator|.
name|id
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// no differences
block|}
elseif|else
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
name|kbase
operator|.
name|path
argument_list|)
operator|&&
name|getChildNodeCount
argument_list|(
name|LOCAL_DIFF_THRESHOLD
argument_list|)
operator|>
name|LOCAL_DIFF_THRESHOLD
condition|)
block|{
comment|// use MK.diff() when there are 'many' child nodes
name|String
name|jsonDiff
init|=
name|kernel
operator|.
name|diff
argument_list|(
name|kbase
operator|.
name|getRevision
argument_list|()
argument_list|,
name|revision
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|processJsonDiff
argument_list|(
name|jsonDiff
argument_list|,
name|kbase
argument_list|,
name|diff
argument_list|)
return|;
block|}
block|}
block|}
block|}
comment|// fall back to the generic node state diff algorithm
return|return
name|super
operator|.
name|compareAgainstBaseState
argument_list|(
name|base
argument_list|,
name|diff
argument_list|)
return|;
block|}
comment|//------------------------------------------------------------< Object>--
comment|/**      * Optimised equality check that can avoid a full tree comparison if      * both instances come from the same MicroKernel and have either      * the same revision and path or the same content hash (when available).      * Otherwise we fall back to the default tree comparison algorithm.      *      * @see<a href="https://issues.apache.org/jira/browse/OAK-172">OAK-172</a>      */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|object
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|object
operator|instanceof
name|KernelNodeState
condition|)
block|{
name|KernelNodeState
name|that
init|=
operator|(
name|KernelNodeState
operator|)
name|object
decl_stmt|;
if|if
condition|(
name|kernel
operator|.
name|equals
argument_list|(
name|that
operator|.
name|kernel
argument_list|)
condition|)
block|{
if|if
condition|(
name|revision
operator|.
name|equals
argument_list|(
name|that
operator|.
name|revision
argument_list|)
operator|&&
name|path
operator|.
name|equals
argument_list|(
name|that
operator|.
name|path
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|this
operator|.
name|init
argument_list|()
expr_stmt|;
name|that
operator|.
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|hash
operator|!=
literal|null
operator|&&
name|that
operator|.
name|hash
operator|!=
literal|null
condition|)
block|{
return|return
name|hash
operator|.
name|equals
argument_list|(
name|that
operator|.
name|hash
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|id
operator|!=
literal|null
operator|&&
name|id
operator|.
name|equals
argument_list|(
name|that
operator|.
name|id
argument_list|)
condition|)
block|{
comment|// only return result of equals if ids are equal
comment|// different ids doesn't mean the node states are
comment|// definitively different.
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
name|that
operator|.
name|path
argument_list|)
operator|&&
operator|!
name|path
operator|.
name|equals
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|String
name|r1
init|=
name|revision
decl_stmt|,
name|r2
init|=
name|that
operator|.
name|getRevision
argument_list|()
decl_stmt|;
if|if
condition|(
name|r1
operator|.
name|compareTo
argument_list|(
name|r2
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|// sort the revisions, to allow the MicroKernel to cache the result
name|String
name|temp
init|=
name|r1
decl_stmt|;
name|r1
operator|=
name|r2
expr_stmt|;
name|r2
operator|=
name|temp
expr_stmt|;
block|}
name|String
name|jsonDiff
init|=
name|kernel
operator|.
name|diff
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
operator|!
name|hasChanges
argument_list|(
name|jsonDiff
argument_list|)
return|;
block|}
block|}
block|}
block|}
comment|// fall back to the generic tree equality comparison algorithm
return|return
name|super
operator|.
name|equals
argument_list|(
name|object
argument_list|)
return|;
block|}
comment|//------------------------------------------------------------< internal>---
annotation|@
name|Nonnull
name|String
name|getRevision
parameter_list|()
block|{
return|return
name|revision
return|;
block|}
comment|/**      * Mark this instance as from being on branch.      *<p>      * TODO this is a workaround to avoid creating branches from a branch      * until this is supported by the MicroKernel. See {@link KernelNodeState#builder()}.      * @return {@code this}      */
name|KernelNodeState
name|setBranch
parameter_list|()
block|{
name|isBranch
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * @return  {@code true} if this instance has been marked as being on a branch by a call      * to {@link #setBranch()}      */
name|boolean
name|isBranch
parameter_list|()
block|{
return|return
name|isBranch
return|;
block|}
comment|/**      * @return the approximate memory usage of this node state.      */
specifier|synchronized
name|int
name|getMemory
parameter_list|()
block|{
comment|// base memory footprint is roughly 64 bytes
name|int
name|memory
init|=
literal|64
decl_stmt|;
comment|// path String
name|memory
operator|+=
literal|48
operator|+
name|path
operator|.
name|length
argument_list|()
operator|*
literal|2
expr_stmt|;
comment|// revision String
name|memory
operator|+=
literal|48
operator|+
name|revision
operator|.
name|length
argument_list|()
operator|*
literal|2
expr_stmt|;
comment|// optional hash String
if|if
condition|(
name|hash
operator|!=
literal|null
condition|)
block|{
name|memory
operator|+=
literal|48
operator|+
name|hash
operator|.
name|length
argument_list|()
operator|*
literal|2
expr_stmt|;
block|}
comment|// optional id String
if|if
condition|(
name|id
operator|!=
literal|null
operator|&&
operator|!
name|id
operator|.
name|equals
argument_list|(
name|hash
argument_list|)
condition|)
block|{
name|memory
operator|+=
literal|48
operator|+
name|id
operator|.
name|length
argument_list|()
operator|*
literal|2
expr_stmt|;
block|}
comment|// rough approximation for properties
if|if
condition|(
name|properties
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|PropertyState
argument_list|>
name|entry
range|:
name|properties
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// name
name|memory
operator|+=
literal|48
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|length
argument_list|()
operator|*
literal|2
expr_stmt|;
name|PropertyState
name|propState
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|propState
operator|.
name|getType
argument_list|()
operator|!=
name|Type
operator|.
name|BINARY
operator|&&
name|propState
operator|.
name|getType
argument_list|()
operator|!=
name|Type
operator|.
name|BINARIES
condition|)
block|{
comment|// assume binaries go into blob store
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|propState
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// size() returns length of string
comment|// overhead:
comment|// - 8 bytes per reference in values list
comment|// - 48 bytes per string
name|memory
operator|+=
literal|56
operator|+
name|propState
operator|.
name|size
argument_list|(
name|i
argument_list|)
operator|*
literal|2
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// rough approximation for child nodes
if|if
condition|(
name|childNames
operator|!=
literal|null
condition|)
block|{
name|memory
operator|+=
name|childNames
operator|.
name|size
argument_list|()
operator|*
literal|150
expr_stmt|;
block|}
return|return
name|memory
return|;
block|}
comment|//------------------------------------------------------------< private>---
specifier|private
specifier|static
name|boolean
name|hasChanges
parameter_list|(
name|String
name|journal
parameter_list|)
block|{
return|return
operator|!
name|journal
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**      * Process the given JSON diff, which is the diff of of the {@code base}      * node state to this node state.      *      * @param jsonDiff the JSON diff.      * @param base the base node state.      * @param diff where diffs are reported to.      * @return {@code true} to continue the comparison, {@code false} to stop      */
specifier|private
name|boolean
name|processJsonDiff
parameter_list|(
name|String
name|jsonDiff
parameter_list|,
name|KernelNodeState
name|base
parameter_list|,
name|NodeStateDiff
name|diff
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasChanges
argument_list|(
name|jsonDiff
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|AbstractNodeState
operator|.
name|comparePropertiesAgainstBaseState
argument_list|(
name|this
argument_list|,
name|base
argument_list|,
name|diff
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|jsonDiff
argument_list|)
decl_stmt|;
name|boolean
name|continueComparison
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|continueComparison
condition|)
block|{
name|int
name|r
init|=
name|t
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|JsopReader
operator|.
name|END
condition|)
block|{
break|break;
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|'+'
case|:
block|{
name|String
name|path
init|=
name|t
operator|.
name|readString
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|.
name|read
argument_list|()
operator|!=
literal|'}'
condition|)
block|{
comment|// skip properties
block|}
name|String
name|name
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|continueComparison
operator|=
name|diff
operator|.
name|childNodeAdded
argument_list|(
name|name
argument_list|,
name|getChildNode
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'-'
case|:
block|{
name|String
name|path
init|=
name|t
operator|.
name|readString
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|continueComparison
operator|=
name|diff
operator|.
name|childNodeDeleted
argument_list|(
name|name
argument_list|,
name|base
operator|.
name|getChildNode
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'^'
case|:
block|{
name|String
name|path
init|=
name|t
operator|.
name|readString
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
name|t
operator|.
name|read
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|continueComparison
operator|=
name|diff
operator|.
name|childNodeChanged
argument_list|(
name|name
argument_list|,
name|base
operator|.
name|getChildNode
argument_list|(
name|name
argument_list|)
argument_list|,
name|getChildNode
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|'['
argument_list|)
condition|)
block|{
comment|// ignore multi valued property
while|while
condition|(
name|t
operator|.
name|read
argument_list|()
operator|!=
literal|']'
condition|)
block|{
comment|// skip values
block|}
block|}
else|else
block|{
comment|// ignore single valued property
name|t
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'>'
case|:
block|{
name|String
name|from
init|=
name|t
operator|.
name|readString
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|String
name|to
init|=
name|t
operator|.
name|readString
argument_list|()
decl_stmt|;
name|String
name|fromName
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|continueComparison
operator|=
name|diff
operator|.
name|childNodeDeleted
argument_list|(
name|fromName
argument_list|,
name|base
operator|.
name|getChildNode
argument_list|(
name|fromName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|continueComparison
condition|)
block|{
break|break;
block|}
name|String
name|toName
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|continueComparison
operator|=
name|diff
operator|.
name|childNodeAdded
argument_list|(
name|toName
argument_list|,
name|getChildNode
argument_list|(
name|toName
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"jsonDiff: illegal token '"
operator|+
name|t
operator|.
name|getToken
argument_list|()
operator|+
literal|"' at pos: "
operator|+
name|t
operator|.
name|getLastPos
argument_list|()
operator|+
literal|' '
operator|+
name|jsonDiff
argument_list|)
throw|;
block|}
block|}
return|return
name|continueComparison
return|;
block|}
specifier|private
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
name|iterable
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|transform
argument_list|(
name|names
argument_list|,
operator|new
name|Function
argument_list|<
name|String
argument_list|,
name|ChildNodeEntry
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ChildNodeEntry
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
operator|new
name|KernelChildNodeEntry
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|private
class|class
name|KernelChildNodeEntry
extends|extends
name|AbstractChildNodeEntry
block|{
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
comment|/**          * Creates a child node entry with the given name.          *          * @param name child node name          */
specifier|public
name|KernelChildNodeEntry
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|checkNotNull
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
annotation|@
name|Override
specifier|public
name|NodeState
name|getNodeState
parameter_list|()
block|{
try|try
block|{
return|return
name|cache
operator|.
name|get
argument_list|(
name|revision
operator|+
name|PathUtils
operator|.
name|concat
argument_list|(
name|path
argument_list|,
name|name
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MicroKernelException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Read a {@code PropertyState} from a {@link JsopReader}      * @param name  The name of the property state      * @param reader  The reader      * @return new property state      */
specifier|private
name|PropertyState
name|readProperty
parameter_list|(
name|String
name|name
parameter_list|,
name|JsopReader
name|reader
parameter_list|)
block|{
if|if
condition|(
name|reader
operator|.
name|matches
argument_list|(
name|JsopReader
operator|.
name|NUMBER
argument_list|)
condition|)
block|{
name|String
name|number
init|=
name|reader
operator|.
name|getToken
argument_list|()
decl_stmt|;
try|try
block|{
return|return
operator|new
name|LongPropertyState
argument_list|(
name|name
argument_list|,
name|Long
operator|.
name|parseLong
argument_list|(
name|number
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
return|return
operator|new
name|DoublePropertyState
argument_list|(
name|name
argument_list|,
name|Double
operator|.
name|parseDouble
argument_list|(
name|number
argument_list|)
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|matches
argument_list|(
name|JsopReader
operator|.
name|TRUE
argument_list|)
condition|)
block|{
return|return
name|BooleanPropertyState
operator|.
name|booleanProperty
argument_list|(
name|name
argument_list|,
literal|true
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|matches
argument_list|(
name|JsopReader
operator|.
name|FALSE
argument_list|)
condition|)
block|{
return|return
name|BooleanPropertyState
operator|.
name|booleanProperty
argument_list|(
name|name
argument_list|,
literal|false
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|matches
argument_list|(
name|JsopReader
operator|.
name|STRING
argument_list|)
condition|)
block|{
name|String
name|jsonString
init|=
name|reader
operator|.
name|getToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|jsonString
operator|.
name|startsWith
argument_list|(
name|TypeCodes
operator|.
name|EMPTY_ARRAY
argument_list|)
condition|)
block|{
name|int
name|type
init|=
name|PropertyType
operator|.
name|valueFromName
argument_list|(
name|jsonString
operator|.
name|substring
argument_list|(
name|TypeCodes
operator|.
name|EMPTY_ARRAY
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|PropertyStates
operator|.
name|createProperty
argument_list|(
name|name
argument_list|,
name|emptyList
argument_list|()
argument_list|,
name|Type
operator|.
name|fromTag
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
name|int
name|split
init|=
name|TypeCodes
operator|.
name|split
argument_list|(
name|jsonString
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|type
init|=
name|TypeCodes
operator|.
name|decodeType
argument_list|(
name|split
argument_list|,
name|jsonString
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|TypeCodes
operator|.
name|decodeName
argument_list|(
name|split
argument_list|,
name|jsonString
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|PropertyType
operator|.
name|BINARY
condition|)
block|{
return|return
name|BinaryPropertyState
operator|.
name|binaryProperty
argument_list|(
name|name
argument_list|,
operator|new
name|KernelBlob
argument_list|(
operator|new
name|String
argument_list|(
name|value
argument_list|)
argument_list|,
name|kernel
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|createProperty
argument_list|(
name|name
argument_list|,
name|StringCache
operator|.
name|get
argument_list|(
name|value
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|StringPropertyState
operator|.
name|stringProperty
argument_list|(
name|name
argument_list|,
name|StringCache
operator|.
name|get
argument_list|(
name|jsonString
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected token: "
operator|+
name|reader
operator|.
name|getToken
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Read a multi valued {@code PropertyState} from a {@link JsopReader}      * @param name  The name of the property state      * @param reader  The reader      * @return new property state      */
specifier|private
name|PropertyState
name|readArrayProperty
parameter_list|(
name|String
name|name
parameter_list|,
name|JsopReader
name|reader
parameter_list|)
block|{
name|int
name|type
init|=
name|PropertyType
operator|.
name|STRING
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|values
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|reader
operator|.
name|matches
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
if|if
condition|(
name|reader
operator|.
name|matches
argument_list|(
name|JsopReader
operator|.
name|NUMBER
argument_list|)
condition|)
block|{
name|String
name|number
init|=
name|reader
operator|.
name|getToken
argument_list|()
decl_stmt|;
try|try
block|{
name|type
operator|=
name|PropertyType
operator|.
name|LONG
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|number
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|type
operator|=
name|PropertyType
operator|.
name|DOUBLE
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
name|Double
operator|.
name|parseDouble
argument_list|(
name|number
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|matches
argument_list|(
name|JsopReader
operator|.
name|TRUE
argument_list|)
condition|)
block|{
name|type
operator|=
name|PropertyType
operator|.
name|BOOLEAN
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|matches
argument_list|(
name|JsopReader
operator|.
name|FALSE
argument_list|)
condition|)
block|{
name|type
operator|=
name|PropertyType
operator|.
name|BOOLEAN
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|matches
argument_list|(
name|JsopReader
operator|.
name|STRING
argument_list|)
condition|)
block|{
name|String
name|jsonString
init|=
name|reader
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|int
name|split
init|=
name|TypeCodes
operator|.
name|split
argument_list|(
name|jsonString
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|!=
operator|-
literal|1
condition|)
block|{
name|type
operator|=
name|TypeCodes
operator|.
name|decodeType
argument_list|(
name|split
argument_list|,
name|jsonString
argument_list|)
expr_stmt|;
name|String
name|value
init|=
name|TypeCodes
operator|.
name|decodeName
argument_list|(
name|split
argument_list|,
name|jsonString
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|PropertyType
operator|.
name|BINARY
condition|)
block|{
name|values
operator|.
name|add
argument_list|(
operator|new
name|KernelBlob
argument_list|(
operator|new
name|String
argument_list|(
name|value
argument_list|)
argument_list|,
name|kernel
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|PropertyType
operator|.
name|DOUBLE
condition|)
block|{
name|values
operator|.
name|add
argument_list|(
name|Conversions
operator|.
name|convert
argument_list|(
name|value
argument_list|)
operator|.
name|toDouble
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|PropertyType
operator|.
name|DECIMAL
condition|)
block|{
name|values
operator|.
name|add
argument_list|(
name|Conversions
operator|.
name|convert
argument_list|(
name|value
argument_list|)
operator|.
name|toDecimal
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|values
operator|.
name|add
argument_list|(
name|StringCache
operator|.
name|get
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|type
operator|=
name|PropertyType
operator|.
name|STRING
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
name|StringCache
operator|.
name|get
argument_list|(
name|jsonString
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected token: "
operator|+
name|reader
operator|.
name|getToken
argument_list|()
argument_list|)
throw|;
block|}
name|reader
operator|.
name|matches
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
return|return
name|createProperty
argument_list|(
name|name
argument_list|,
name|values
argument_list|,
name|Type
operator|.
name|fromTag
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|path
argument_list|)
operator|.
name|append
argument_list|(
literal|'@'
argument_list|)
operator|.
name|append
argument_list|(
name|revision
argument_list|)
expr_stmt|;
if|if
condition|(
name|childNodeCount
operator|>=
literal|0
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|" children: "
argument_list|)
operator|.
name|append
argument_list|(
name|childNodeCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|" hash: "
argument_list|)
operator|.
name|append
argument_list|(
name|hash
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|" id: "
argument_list|)
operator|.
name|append
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|properties
operator|==
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|" /* props not initialized */"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|PropertyState
name|property
range|:
name|getProperties
argument_list|()
control|)
block|{
if|if
condition|(
name|count
operator|++
operator|>
literal|0
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
operator|.
name|append
argument_list|(
name|property
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|childNames
operator|==
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|" /* child node names not initialized */"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|String
name|s
range|:
name|childNames
control|)
block|{
if|if
condition|(
name|count
operator|++
operator|>
literal|0
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|builder
operator|.
name|append
argument_list|(
literal|" }"
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

