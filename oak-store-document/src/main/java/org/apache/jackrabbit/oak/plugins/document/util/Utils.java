begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|AbstractIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|OakVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|ClusterNodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|ClusterNodeInfoDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentStoreException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Revision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|RevisionVector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|StableRevisionComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|stats
operator|.
name|Clock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|NotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|transform
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|isDeletedEntry
import|;
end_import

begin_comment
comment|/**  * Utility methods.  */
end_comment

begin_class
specifier|public
class|class
name|Utils
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Utils
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|String
name|MODULE_VERSION
init|=
literal|null
decl_stmt|;
comment|/**      * Approximate length of a Revision string.      */
specifier|private
specifier|static
specifier|final
name|int
name|REVISION_LENGTH
init|=
operator|new
name|Revision
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|length
argument_list|()
decl_stmt|;
comment|/**      * The length of path (in characters), whose UTF-8 representation can not      * possibly be too large to be used for the primary key for the document      * store.      */
specifier|public
specifier|static
specifier|final
name|int
name|PATH_SHORT
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"oak.pathShort"
argument_list|,
literal|165
argument_list|)
decl_stmt|;
comment|/**      * The maximum length of the parent path, in bytes. If the parent path is      * longer, then the id of a document is no longer the path, but the hash of      * the parent, and then the node name.      */
specifier|public
specifier|static
specifier|final
name|int
name|PATH_LONG
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"oak.pathLong"
argument_list|,
literal|350
argument_list|)
decl_stmt|;
comment|/**      * The maximum size a node name, in bytes. This is only a problem for long path.      */
specifier|public
specifier|static
specifier|final
name|int
name|NODE_NAME_LIMIT
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"oak.nodeNameLimit"
argument_list|,
literal|150
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|UTF_8
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|HEX_DIGITS
init|=
literal|"0123456789abcdef"
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
comment|/**      * A predicate for property and _deleted names.      */
specifier|public
specifier|static
specifier|final
name|Predicate
argument_list|<
name|String
argument_list|>
name|PROPERTY_OR_DELETED
init|=
operator|new
name|Predicate
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
annotation|@
name|Nullable
name|String
name|input
parameter_list|)
block|{
return|return
name|Utils
operator|.
name|isPropertyName
argument_list|(
name|input
argument_list|)
operator|||
name|isDeletedEntry
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|public
specifier|static
name|int
name|pathDepth
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|depth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|path
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|path
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'/'
condition|)
block|{
name|depth
operator|++
expr_stmt|;
block|}
block|}
return|return
name|depth
return|;
block|}
comment|/**      * Calculates the depth prefix of the id for the given {@code path}. The is      * the same as {@link #pathDepth(String)}, but takes a {@link Path}      * argument.      *      * @param path a path.      * @return the id depth prefix for the given {@code path}.      */
specifier|public
specifier|static
name|int
name|getIdDepth
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|int
name|depth
init|=
name|path
operator|.
name|getDepth
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|depth
operator|--
expr_stmt|;
block|}
return|return
name|depth
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
name|int
name|estimateMemoryUsage
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|Object
argument_list|>
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|?
argument_list|,
name|Object
argument_list|>
name|e
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getKey
argument_list|()
operator|instanceof
name|Revision
condition|)
block|{
name|size
operator|+=
literal|32
expr_stmt|;
block|}
else|else
block|{
name|size
operator|+=
name|StringUtils
operator|.
name|estimateMemoryUsage
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Object
name|o
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|String
condition|)
block|{
name|size
operator|+=
name|StringUtils
operator|.
name|estimateMemoryUsage
argument_list|(
operator|(
name|String
operator|)
name|o
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Long
condition|)
block|{
name|size
operator|+=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Boolean
condition|)
block|{
name|size
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Integer
condition|)
block|{
name|size
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Map
condition|)
block|{
name|size
operator|+=
literal|8
operator|+
operator|(
name|long
operator|)
name|estimateMemoryUsage
argument_list|(
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|o
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
comment|// zero
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't estimate memory usage of "
operator|+
name|o
argument_list|)
throw|;
block|}
block|}
comment|// overhead for map object
comment|// TreeMap (80) + unmodifiable wrapper (32)
name|size
operator|+=
literal|112
expr_stmt|;
comment|// 64 bytes per entry
name|size
operator|+=
operator|(
name|long
operator|)
name|map
operator|.
name|size
argument_list|()
operator|*
literal|64
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Estimated memory footprint larger than Integer.MAX_VALUE: {}."
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|size
return|;
block|}
specifier|public
specifier|static
name|String
name|escapePropertyName
parameter_list|(
name|String
name|propertyName
parameter_list|)
block|{
name|int
name|len
init|=
name|propertyName
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|"_"
return|;
block|}
comment|// avoid creating a buffer if escaping is not needed
name|StringBuilder
name|buff
init|=
literal|null
decl_stmt|;
name|char
name|c
init|=
name|propertyName
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
name|buff
operator|=
operator|new
name|StringBuilder
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buff
operator|.
name|append
argument_list|(
literal|'_'
argument_list|)
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|propertyName
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|char
name|rep
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'.'
case|:
name|rep
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|rep
operator|=
literal|'\\'
expr_stmt|;
break|break;
default|default:
name|rep
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|buff
operator|==
literal|null
condition|)
block|{
name|buff
operator|=
operator|new
name|StringBuilder
argument_list|(
name|propertyName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buff
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
operator|.
name|append
argument_list|(
name|rep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buff
operator|!=
literal|null
condition|)
block|{
name|buff
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buff
operator|==
literal|null
condition|?
name|propertyName
else|:
name|buff
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|String
name|unescapePropertyName
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|int
name|len
init|=
name|key
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|startsWith
argument_list|(
literal|"_"
argument_list|)
operator|&&
operator|(
name|key
operator|.
name|startsWith
argument_list|(
literal|"__"
argument_list|)
operator|||
name|key
operator|.
name|startsWith
argument_list|(
literal|"_$"
argument_list|)
operator|||
name|len
operator|==
literal|1
operator|)
condition|)
block|{
name|key
operator|=
name|key
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
comment|// avoid creating a buffer if escaping is not needed
name|StringBuilder
name|buff
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|key
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|buff
operator|==
literal|null
condition|)
block|{
name|buff
operator|=
operator|new
name|StringBuilder
argument_list|(
name|key
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|key
operator|.
name|charAt
argument_list|(
operator|++
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|// ok
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
name|c
operator|=
literal|'.'
expr_stmt|;
block|}
name|buff
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buff
operator|!=
literal|null
condition|)
block|{
name|buff
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buff
operator|==
literal|null
condition|?
name|key
else|:
name|buff
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isPropertyName
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
operator|!
name|key
operator|.
name|startsWith
argument_list|(
literal|"_"
argument_list|)
operator|||
name|key
operator|.
name|startsWith
argument_list|(
literal|"__"
argument_list|)
operator|||
name|key
operator|.
name|startsWith
argument_list|(
literal|"_$"
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|getIdFromPath
parameter_list|(
annotation|@
name|NotNull
name|String
name|path
parameter_list|)
block|{
name|int
name|depth
init|=
name|Utils
operator|.
name|pathDepth
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|isLongPath
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|String
name|parent
init|=
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|byte
index|[]
name|hash
init|=
name|createSHA256Digest
argument_list|(
name|parent
argument_list|)
decl_stmt|;
return|return
name|createHashedId
argument_list|(
name|depth
argument_list|,
name|hash
argument_list|,
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
return|return
name|depth
operator|+
literal|":"
operator|+
name|path
return|;
block|}
specifier|public
specifier|static
name|String
name|getIdFromPath
parameter_list|(
annotation|@
name|NotNull
name|Path
name|path
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|int
name|depth
init|=
name|getIdDepth
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Path
name|parent
init|=
name|path
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
operator|&&
name|isLongPath
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|byte
index|[]
name|hash
init|=
name|createSHA256Digest
argument_list|(
name|parent
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|createHashedId
argument_list|(
name|depth
argument_list|,
name|hash
argument_list|,
name|path
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
return|return
name|depth
operator|+
literal|":"
operator|+
name|path
return|;
block|}
specifier|private
specifier|static
name|String
name|createHashedId
parameter_list|(
name|int
name|depth
parameter_list|,
name|byte
index|[]
name|hash
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|hash
operator|.
name|length
operator|*
literal|2
operator|+
name|name
operator|.
name|length
argument_list|()
operator|+
literal|6
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|depth
argument_list|)
operator|.
name|append
argument_list|(
literal|":h"
argument_list|)
expr_stmt|;
name|encodeHexString
argument_list|(
name|hash
argument_list|,
name|sb
argument_list|)
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|byte
index|[]
name|createSHA256Digest
parameter_list|(
name|String
name|input
parameter_list|)
block|{
try|try
block|{
return|return
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"SHA-256"
argument_list|)
operator|.
name|digest
argument_list|(
name|input
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Encodes the given data as hexadecimal string representation and appends      * it to the {@code StringBuilder}. The hex digits are in lower case.      *      * @param data the bytes to encode.      * @param sb the hexadecimal string representation is appended to this      *           {@code StringBuilder}.      * @return the {@code StringBuilder} passed to this method.      */
specifier|public
specifier|static
name|StringBuilder
name|encodeHexString
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
block|{
for|for
control|(
name|byte
name|b
range|:
name|data
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|HEX_DIGITS
index|[
operator|(
name|b
operator|>>
literal|4
operator|)
operator|&
literal|0xF
index|]
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|HEX_DIGITS
index|[
operator|(
name|b
operator|&
literal|0xF
operator|)
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
return|;
block|}
comment|/**      * Returns the parent id for given id if possible      *      *<p>It would return null in following cases      *<ul>      *<li>If id is from long path</li>      *<li>If id is for root path</li>      *<li>If id is for an invalid path</li>      *</ul>      * @param id id for which parent id needs to be determined      * @return parent id. null if parent id cannot be determined      */
annotation|@
name|Nullable
specifier|public
specifier|static
name|String
name|getParentId
parameter_list|(
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|Utils
operator|.
name|isIdFromLongPath
argument_list|(
name|id
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|path
init|=
name|Utils
operator|.
name|getPathFromId
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|PathUtils
operator|.
name|isValid
argument_list|(
name|path
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|PathUtils
operator|.
name|denotesRoot
argument_list|(
name|path
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|parentPath
init|=
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
name|Utils
operator|.
name|getIdFromPath
argument_list|(
name|parentPath
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isLongPath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
comment|// the most common case: a short path
comment|// avoid calculating the parent path
if|if
condition|(
name|path
operator|.
name|length
argument_list|()
operator|<
name|PATH_SHORT
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check if the parent path is long
name|byte
index|[]
name|parent
init|=
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|path
argument_list|)
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|.
name|length
operator|<
name|PATH_LONG
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|name
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
operator|.
name|length
operator|>
name|NODE_NAME_LIMIT
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Node name is too long: "
operator|+
name|path
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isLongPath
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
comment|// the most common case: a short path
comment|// avoid calculating the parent path
if|if
condition|(
name|path
operator|.
name|length
argument_list|()
operator|<
name|PATH_SHORT
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check if the parent path is long
name|Path
name|parent
init|=
name|path
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|parent
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
operator|.
name|length
operator|<
name|PATH_LONG
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|path
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
operator|.
name|length
operator|>
name|NODE_NAME_LIMIT
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Node name is too long: "
operator|+
name|path
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isIdFromLongPath
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|int
name|index
init|=
name|id
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
return|return
name|index
operator|!=
operator|-
literal|1
operator|&&
name|index
operator|<
name|id
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|&&
name|id
operator|.
name|charAt
argument_list|(
name|index
operator|+
literal|1
argument_list|)
operator|==
literal|'h'
return|;
block|}
comment|// TODO deprecate?
specifier|public
specifier|static
name|String
name|getPathFromId
parameter_list|(
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|isIdFromLongPath
argument_list|(
name|id
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Id is hashed: "
operator|+
name|id
argument_list|)
throw|;
block|}
name|int
name|index
init|=
name|id
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
return|return
name|id
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|getDepthFromId
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
try|try
block|{
name|int
name|index
init|=
name|id
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|id
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|// ignore and throw IllegalArgumentException
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid id: "
operator|+
name|id
argument_list|)
throw|;
block|}
specifier|public
specifier|static
name|Path
name|getPreviousPathFor
parameter_list|(
name|Path
name|path
parameter_list|,
name|Revision
name|r
parameter_list|,
name|int
name|height
parameter_list|)
block|{
if|if
condition|(
operator|!
name|path
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"path must be absolute: "
operator|+
name|path
argument_list|)
throw|;
block|}
name|Path
name|prev
init|=
operator|new
name|Path
argument_list|(
literal|"p"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|path
operator|.
name|elements
argument_list|()
control|)
block|{
name|prev
operator|=
operator|new
name|Path
argument_list|(
name|prev
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
operator|new
name|Path
argument_list|(
name|prev
argument_list|,
name|r
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|prev
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|height
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|getPreviousIdFor
parameter_list|(
name|Path
name|path
parameter_list|,
name|Revision
name|r
parameter_list|,
name|int
name|height
parameter_list|)
block|{
return|return
name|getIdFromPath
argument_list|(
name|getPreviousPathFor
argument_list|(
name|path
argument_list|,
name|r
argument_list|,
name|height
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Determines if the passed id belongs to a previous doc      *      * @param id id to check      * @return true if the id belongs to a previous doc      */
specifier|public
specifier|static
name|boolean
name|isPreviousDocId
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|int
name|indexOfColon
init|=
name|id
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexOfColon
operator|>
literal|0
operator|&&
name|indexOfColon
operator|<
name|id
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
return|return
name|id
operator|.
name|charAt
argument_list|(
name|indexOfColon
operator|+
literal|1
argument_list|)
operator|==
literal|'p'
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Determines if the passed id belongs to a leaf level previous doc      *      * @param id id to check      * @return true if the id belongs to a leaf level previous doc      */
specifier|public
specifier|static
name|boolean
name|isLeafPreviousDocId
parameter_list|(
name|String
name|id
parameter_list|)
block|{
return|return
name|isPreviousDocId
argument_list|(
name|id
argument_list|)
operator|&&
name|id
operator|.
name|endsWith
argument_list|(
literal|"/0"
argument_list|)
return|;
block|}
comment|/**      * Deep copy of a map that may contain map values.      *      * @param source the source map      * @param target the target map      * @param<K> the type of the map key      */
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|>
name|void
name|deepCopyMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|Object
argument_list|>
name|source
parameter_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|Object
argument_list|>
name|target
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|Object
argument_list|>
name|e
range|:
name|source
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|value
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Comparator
argument_list|<
name|?
super|super
name|K
argument_list|>
name|comparator
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|SortedMap
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|(
name|SortedMap
argument_list|<
name|K
argument_list|,
name|Object
argument_list|>
operator|)
name|value
decl_stmt|;
name|comparator
operator|=
name|map
operator|.
name|comparator
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
argument_list|<
name|K
argument_list|,
name|Object
argument_list|>
name|old
init|=
operator|(
name|Map
argument_list|<
name|K
argument_list|,
name|Object
argument_list|>
operator|)
name|value
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|Object
argument_list|>
name|c
init|=
operator|new
name|TreeMap
argument_list|<
name|K
argument_list|,
name|Object
argument_list|>
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|deepCopyMap
argument_list|(
name|old
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|value
operator|=
name|c
expr_stmt|;
block|}
name|target
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the lower key limit to retrieve the children of the given      *<code>path</code>.      *      * @param path a path.      * @return the lower key limit.      */
specifier|public
specifier|static
name|String
name|getKeyLowerLimit
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|String
name|from
init|=
name|getIdFromPath
argument_list|(
operator|new
name|Path
argument_list|(
name|path
argument_list|,
literal|"a"
argument_list|)
argument_list|)
decl_stmt|;
name|from
operator|=
name|from
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|from
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|from
return|;
block|}
comment|/**      * Returns the upper key limit to retrieve the children of the given      *<code>path</code>.      *      * @param path a path.      * @return the upper key limit.      */
specifier|public
specifier|static
name|String
name|getKeyUpperLimit
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|String
name|to
init|=
name|getIdFromPath
argument_list|(
operator|new
name|Path
argument_list|(
name|path
argument_list|,
literal|"z"
argument_list|)
argument_list|)
decl_stmt|;
name|to
operator|=
name|to
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|to
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
operator|+
literal|"0"
expr_stmt|;
return|return
name|to
return|;
block|}
comment|/**      * Returns parentId extracted from the fromKey. fromKey is usually constructed      * using Utils#getKeyLowerLimit      *      * @param fromKey key used as start key in queries      * @return parentId if possible.      */
annotation|@
name|Nullable
specifier|public
specifier|static
name|String
name|getParentIdFromLowerLimit
parameter_list|(
name|String
name|fromKey
parameter_list|)
block|{
comment|//If key just ends with slash 2:/foo/ then append a fake
comment|//name to create a proper id
if|if
condition|(
name|fromKey
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|fromKey
operator|=
name|fromKey
operator|+
literal|"a"
expr_stmt|;
block|}
return|return
name|getParentId
argument_list|(
name|fromKey
argument_list|)
return|;
block|}
comment|/**      * Returns<code>true</code> if a revision tagged with the given revision      * should be considered committed,<code>false</code> otherwise. Committed      * revisions have a tag, which equals 'c' or starts with 'c-'.      *      * @param tag the tag (may be<code>null</code>).      * @return<code>true</code> if committed;<code>false</code> otherwise.      */
specifier|public
specifier|static
name|boolean
name|isCommitted
parameter_list|(
annotation|@
name|Nullable
name|String
name|tag
parameter_list|)
block|{
return|return
name|tag
operator|!=
literal|null
operator|&&
operator|(
name|tag
operator|.
name|equals
argument_list|(
literal|"c"
argument_list|)
operator|||
name|tag
operator|.
name|startsWith
argument_list|(
literal|"c-"
argument_list|)
operator|)
return|;
block|}
comment|/**      * Resolve the commit revision for the given revision<code>rev</code> and      * the associated commit tag.      *      * @param rev a revision.      * @param tag the associated commit tag.      * @return the actual commit revision for<code>rev</code>.      */
annotation|@
name|NotNull
specifier|public
specifier|static
name|Revision
name|resolveCommitRevision
parameter_list|(
annotation|@
name|NotNull
name|Revision
name|rev
parameter_list|,
annotation|@
name|NotNull
name|String
name|tag
parameter_list|)
block|{
return|return
name|checkNotNull
argument_list|(
name|tag
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"c-"
argument_list|)
condition|?
name|Revision
operator|.
name|fromString
argument_list|(
name|tag
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
argument_list|)
else|:
name|rev
return|;
block|}
comment|/**      * Closes the obj its of type {@link java.io.Closeable}. It is mostly      * used to close Iterator/Iterables which are backed by say DBCursor      *      * @param obj object to close      */
specifier|public
specifier|static
name|void
name|closeIfCloseable
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|Closeable
condition|)
block|{
try|try
block|{
operator|(
operator|(
name|Closeable
operator|)
name|obj
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error occurred while closing {}"
argument_list|,
name|obj
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Provides a readable string for given timestamp      */
specifier|public
specifier|static
name|String
name|timestampToString
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
return|return
operator|(
operator|new
name|Timestamp
argument_list|(
name|timestamp
argument_list|)
operator|+
literal|"00"
operator|)
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|23
argument_list|)
return|;
block|}
comment|/**      * Returns the revision with the newer timestamp or {@code null} if both      * revisions are {@code null}. The implementation will return the first      * revision if both have the same timestamp.      *      * @param a the first revision (or {@code null}).      * @param b the second revision (or {@code null}).      * @return the revision with the newer timestamp.      */
annotation|@
name|Nullable
specifier|public
specifier|static
name|Revision
name|max
parameter_list|(
annotation|@
name|Nullable
name|Revision
name|a
parameter_list|,
annotation|@
name|Nullable
name|Revision
name|b
parameter_list|)
block|{
return|return
name|max
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|StableRevisionComparator
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
comment|/**      * Returns the revision which is considered more recent or {@code null} if      * both revisions are {@code null}. The implementation will return the first      * revision if both are considered equal. The comparison is done using the      * provided comparator.      *      * @param a the first revision (or {@code null}).      * @param b the second revision (or {@code null}).      * @param c the comparator.      * @return the revision considered more recent.      */
annotation|@
name|Nullable
specifier|public
specifier|static
name|Revision
name|max
parameter_list|(
annotation|@
name|Nullable
name|Revision
name|a
parameter_list|,
annotation|@
name|Nullable
name|Revision
name|b
parameter_list|,
annotation|@
name|NotNull
name|Comparator
argument_list|<
name|Revision
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|null
condition|)
block|{
return|return
name|b
return|;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
name|a
return|;
block|}
return|return
name|c
operator|.
name|compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|>=
literal|0
condition|?
name|a
else|:
name|b
return|;
block|}
comment|/**      * Returns the revision with the older timestamp or {@code null} if both      * revisions are {@code null}. The implementation will return the first      * revision if both have the same timestamp.      *      * @param a the first revision (or {@code null}).      * @param b the second revision (or {@code null}).      * @return the revision with the older timestamp.      */
annotation|@
name|Nullable
specifier|public
specifier|static
name|Revision
name|min
parameter_list|(
annotation|@
name|Nullable
name|Revision
name|a
parameter_list|,
annotation|@
name|Nullable
name|Revision
name|b
parameter_list|)
block|{
return|return
name|min
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|StableRevisionComparator
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
comment|/**      * Returns the revision which is considered older or {@code null} if      * both revisions are {@code null}. The implementation will return the first      * revision if both are considered equal. The comparison is done using the      * provided comparator.      *      * @param a the first revision (or {@code null}).      * @param b the second revision (or {@code null}).      * @param c the comparator.      * @return the revision considered more recent.      */
annotation|@
name|Nullable
specifier|public
specifier|static
name|Revision
name|min
parameter_list|(
annotation|@
name|Nullable
name|Revision
name|a
parameter_list|,
annotation|@
name|Nullable
name|Revision
name|b
parameter_list|,
annotation|@
name|NotNull
name|Comparator
argument_list|<
name|Revision
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|null
condition|)
block|{
return|return
name|b
return|;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
name|a
return|;
block|}
return|return
name|c
operator|.
name|compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|<=
literal|0
condition|?
name|a
else|:
name|b
return|;
block|}
comment|// default batch size for paging through a document store
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_BATCH_SIZE
init|=
literal|100
decl_stmt|;
comment|/**      * Returns an {@link Iterable} over all {@link NodeDocument}s in the given      * store. The returned {@linkplain Iterable} does not guarantee a consistent      * view on the store. it may return documents that have been added to the      * store after this method had been called.      *      * @param store      *            a {@link DocumentStore}.      * @return an {@link Iterable} over all documents in the store.      */
specifier|public
specifier|static
name|Iterable
argument_list|<
name|NodeDocument
argument_list|>
name|getAllDocuments
parameter_list|(
specifier|final
name|DocumentStore
name|store
parameter_list|)
block|{
return|return
name|internalGetSelectedDocuments
argument_list|(
name|store
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
name|DEFAULT_BATCH_SIZE
argument_list|)
return|;
block|}
comment|/**      * Returns the root node document of the given document store. The returned      * document is retrieved from the document store via      * {@link DocumentStore#find(Collection, String)}, which means the      * implementation is allowed to return a cached version of the document.      * The document is therefore not guaranteed to be up-to-date.      *      * @param store a document store.      * @return the root document.      * @throws IllegalStateException if there is no root document.      */
annotation|@
name|NotNull
specifier|public
specifier|static
name|NodeDocument
name|getRootDocument
parameter_list|(
annotation|@
name|NotNull
name|DocumentStore
name|store
parameter_list|)
block|{
name|String
name|rootId
init|=
name|Utils
operator|.
name|getIdFromPath
argument_list|(
name|Path
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|NodeDocument
name|root
init|=
name|store
operator|.
name|find
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
name|rootId
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"missing root document"
argument_list|)
throw|;
block|}
return|return
name|root
return|;
block|}
comment|/**      * Returns an {@link Iterable} over all {@link NodeDocument}s in the given      * store matching a condition on an<em>indexed property</em>. The returned      * {@link Iterable} does not guarantee a consistent view on the store.      * it may return documents that have been added to the store after this      * method had been called.      *      * @param store      *            a {@link DocumentStore}.      * @param indexedProperty the name of the indexed property.      * @param startValue the lower bound value for the indexed property      *                   (inclusive).      * @param batchSize number of documents to fetch at once      * @return an {@link Iterable} over all documents in the store matching the      *         condition      */
specifier|public
specifier|static
name|Iterable
argument_list|<
name|NodeDocument
argument_list|>
name|getSelectedDocuments
parameter_list|(
name|DocumentStore
name|store
parameter_list|,
name|String
name|indexedProperty
parameter_list|,
name|long
name|startValue
parameter_list|,
name|int
name|batchSize
parameter_list|)
block|{
return|return
name|internalGetSelectedDocuments
argument_list|(
name|store
argument_list|,
name|indexedProperty
argument_list|,
name|startValue
argument_list|,
name|batchSize
argument_list|)
return|;
block|}
comment|/**      * Like {@link #getSelectedDocuments(DocumentStore, String, long, int)} with      * a default {@code batchSize}.      */
specifier|public
specifier|static
name|Iterable
argument_list|<
name|NodeDocument
argument_list|>
name|getSelectedDocuments
parameter_list|(
name|DocumentStore
name|store
parameter_list|,
name|String
name|indexedProperty
parameter_list|,
name|long
name|startValue
parameter_list|)
block|{
return|return
name|internalGetSelectedDocuments
argument_list|(
name|store
argument_list|,
name|indexedProperty
argument_list|,
name|startValue
argument_list|,
name|DEFAULT_BATCH_SIZE
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Iterable
argument_list|<
name|NodeDocument
argument_list|>
name|internalGetSelectedDocuments
parameter_list|(
specifier|final
name|DocumentStore
name|store
parameter_list|,
specifier|final
name|String
name|indexedProperty
parameter_list|,
specifier|final
name|long
name|startValue
parameter_list|,
specifier|final
name|int
name|batchSize
parameter_list|)
block|{
if|if
condition|(
name|batchSize
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"batchSize must be> 1"
argument_list|)
throw|;
block|}
return|return
operator|new
name|Iterable
argument_list|<
name|NodeDocument
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|NodeDocument
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractIterator
argument_list|<
name|NodeDocument
argument_list|>
argument_list|()
block|{
specifier|private
name|String
name|startId
init|=
name|NodeDocument
operator|.
name|MIN_ID_VALUE
decl_stmt|;
specifier|private
name|Iterator
argument_list|<
name|NodeDocument
argument_list|>
name|batch
init|=
name|nextBatch
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|NodeDocument
name|computeNext
parameter_list|()
block|{
comment|// read next batch if necessary
if|if
condition|(
operator|!
name|batch
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|batch
operator|=
name|nextBatch
argument_list|()
expr_stmt|;
block|}
name|NodeDocument
name|doc
decl_stmt|;
if|if
condition|(
name|batch
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|doc
operator|=
name|batch
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// remember current id
name|startId
operator|=
name|doc
operator|.
name|getId
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|=
name|endOfData
argument_list|()
expr_stmt|;
block|}
return|return
name|doc
return|;
block|}
specifier|private
name|Iterator
argument_list|<
name|NodeDocument
argument_list|>
name|nextBatch
parameter_list|()
block|{
name|List
argument_list|<
name|NodeDocument
argument_list|>
name|result
init|=
name|indexedProperty
operator|==
literal|null
condition|?
name|store
operator|.
name|query
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
name|startId
argument_list|,
name|NodeDocument
operator|.
name|MAX_ID_VALUE
argument_list|,
name|batchSize
argument_list|)
else|:
name|store
operator|.
name|query
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
name|startId
argument_list|,
name|NodeDocument
operator|.
name|MAX_ID_VALUE
argument_list|,
name|indexedProperty
argument_list|,
name|startValue
argument_list|,
name|batchSize
argument_list|)
decl_stmt|;
return|return
name|result
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**      * @return if {@code path} represent oak's internal path. That is, a path      *          element start with a colon.      */
specifier|public
specifier|static
name|boolean
name|isHiddenPath
parameter_list|(
annotation|@
name|NotNull
name|String
name|path
parameter_list|)
block|{
return|return
name|path
operator|.
name|contains
argument_list|(
literal|"/:"
argument_list|)
return|;
block|}
comment|/**      * Transforms the given {@link Iterable} from {@link String} to      * {@link StringValue} elements. The {@link Iterable} must no have      * {@code null} values.      */
specifier|public
specifier|static
name|Iterable
argument_list|<
name|StringValue
argument_list|>
name|asStringValueIterable
parameter_list|(
annotation|@
name|NotNull
name|Iterable
argument_list|<
name|String
argument_list|>
name|values
parameter_list|)
block|{
return|return
name|transform
argument_list|(
name|values
argument_list|,
operator|new
name|Function
argument_list|<
name|String
argument_list|,
name|StringValue
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|StringValue
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
operator|new
name|StringValue
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**      * Transforms the given paths into ids using {@link #getIdFromPath(String)}.      */
specifier|public
specifier|static
name|Iterable
argument_list|<
name|String
argument_list|>
name|pathToId
parameter_list|(
annotation|@
name|NotNull
name|Iterable
argument_list|<
name|String
argument_list|>
name|paths
parameter_list|)
block|{
return|return
name|transform
argument_list|(
name|paths
argument_list|,
operator|new
name|Function
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
name|getIdFromPath
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**      * Returns the highest timestamp of all the passed external revisions.      * A revision is considered external if the clusterId is different from the      * passed {@code localClusterId}.      *      * @param revisions the revisions to consider.      * @param localClusterId the id of the local cluster node.      * @return the highest timestamp or {@link Long#MIN_VALUE} if none of the      *          revisions is external.      */
specifier|public
specifier|static
name|long
name|getMaxExternalTimestamp
parameter_list|(
name|Iterable
argument_list|<
name|Revision
argument_list|>
name|revisions
parameter_list|,
name|int
name|localClusterId
parameter_list|)
block|{
name|long
name|maxTime
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
for|for
control|(
name|Revision
name|r
range|:
name|revisions
control|)
block|{
if|if
condition|(
name|r
operator|.
name|getClusterId
argument_list|()
operator|==
name|localClusterId
condition|)
block|{
continue|continue;
block|}
name|maxTime
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxTime
argument_list|,
name|r
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|maxTime
return|;
block|}
comment|/**      * Returns the given number instance as a {@code Long}.      *      * @param n a number or {@code null}.      * @return the number converted to a {@code Long} or {@code null}      *      if {@code n} is {@code null}.      */
specifier|public
specifier|static
name|Long
name|asLong
parameter_list|(
annotation|@
name|Nullable
name|Number
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|Long
operator|)
name|n
return|;
block|}
else|else
block|{
return|return
name|n
operator|.
name|longValue
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns a revision vector that contains a revision for each of the passed      * cluster nodes with a revision timestamp that corresponds to the last      * known time when the cluster node was started.      *      * @param clusterNodes the cluster node information.      * @return revision vector representing the last known time when the cluster      *      nodes were started.      */
annotation|@
name|NotNull
specifier|public
specifier|static
name|RevisionVector
name|getStartRevisions
parameter_list|(
annotation|@
name|NotNull
name|Iterable
argument_list|<
name|ClusterNodeInfoDocument
argument_list|>
name|clusterNodes
parameter_list|)
block|{
name|List
argument_list|<
name|Revision
argument_list|>
name|revs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ClusterNodeInfoDocument
name|doc
range|:
name|clusterNodes
control|)
block|{
name|revs
operator|.
name|add
argument_list|(
operator|new
name|Revision
argument_list|(
name|doc
operator|.
name|getStartTime
argument_list|()
argument_list|,
literal|0
argument_list|,
name|doc
operator|.
name|getClusterId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RevisionVector
argument_list|(
name|revs
argument_list|)
return|;
block|}
comment|/**      * Returns the minimum timestamp to use for a query for child documents that      * have been modified between {@code fromRev} and {@code toRev}.      *      * @param fromRev the from revision.      * @param toRev the to revision.      * @param minRevisions the minimum revisions of foreign cluster nodes. These      *                     are derived from the startTime of a cluster node.      * @return the minimum timestamp.      */
specifier|public
specifier|static
name|long
name|getMinTimestampForDiff
parameter_list|(
annotation|@
name|NotNull
name|RevisionVector
name|fromRev
parameter_list|,
annotation|@
name|NotNull
name|RevisionVector
name|toRev
parameter_list|,
annotation|@
name|NotNull
name|RevisionVector
name|minRevisions
parameter_list|)
block|{
comment|// make sure we have minimum revisions for all known cluster nodes
name|fromRev
operator|=
name|fromRev
operator|.
name|pmax
argument_list|(
name|minRevisions
argument_list|)
expr_stmt|;
name|toRev
operator|=
name|toRev
operator|.
name|pmax
argument_list|(
name|minRevisions
argument_list|)
expr_stmt|;
comment|// keep only revision entries that changed
name|RevisionVector
name|from
init|=
name|fromRev
operator|.
name|difference
argument_list|(
name|toRev
argument_list|)
decl_stmt|;
name|RevisionVector
name|to
init|=
name|toRev
operator|.
name|difference
argument_list|(
name|fromRev
argument_list|)
decl_stmt|;
comment|// now calculate minimum timestamp
name|long
name|min
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|Revision
name|r
range|:
name|from
control|)
block|{
name|min
operator|=
name|Math
operator|.
name|min
argument_list|(
name|r
operator|.
name|getTimestamp
argument_list|()
argument_list|,
name|min
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Revision
name|r
range|:
name|to
control|)
block|{
name|min
operator|=
name|Math
operator|.
name|min
argument_list|(
name|r
operator|.
name|getTimestamp
argument_list|()
argument_list|,
name|min
argument_list|)
expr_stmt|;
block|}
return|return
name|min
return|;
block|}
comment|/**      * Returns true if all the revisions in the {@code a} greater or equals      * to their counterparts in {@code b}. If {@code b} contains revisions      * for cluster nodes that are not present in {@code a}, return false.      *      * @param a      * @param b      * @return true if all the revisions in the {@code a} are at least      * as recent as their counterparts in the {@code b}      */
specifier|public
specifier|static
name|boolean
name|isGreaterOrEquals
parameter_list|(
annotation|@
name|NotNull
name|RevisionVector
name|a
parameter_list|,
annotation|@
name|NotNull
name|RevisionVector
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|pmax
argument_list|(
name|b
argument_list|)
operator|.
name|equals
argument_list|(
name|a
argument_list|)
return|;
block|}
comment|/**      * Returns {@code true} if changes identified by the {@code from} and      * {@code to} {@code RevisionVector} are considered local changes. That is      * the only difference between the two revision vectors are for the given      * (local) {@code clusterId}.      *      * @param from the from revision vector.      * @param to the to revision vector.      * @param clusterId the local clusterId.      * @return whether the changes are considered local.      */
specifier|public
specifier|static
name|boolean
name|isLocalChange
parameter_list|(
annotation|@
name|NotNull
name|RevisionVector
name|from
parameter_list|,
annotation|@
name|NotNull
name|RevisionVector
name|to
parameter_list|,
name|int
name|clusterId
parameter_list|)
block|{
name|RevisionVector
name|diff
init|=
name|to
operator|.
name|difference
argument_list|(
name|from
argument_list|)
decl_stmt|;
return|return
name|diff
operator|.
name|getDimensions
argument_list|()
operator|==
literal|1
operator|&&
name|diff
operator|.
name|getRevision
argument_list|(
name|clusterId
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * Wraps the given iterable and aborts iteration over elements when the      * predicate on an element evaluates to {@code false}. Calling      * {@code close()} on the returned iterable will close the passed iterable      * if it is {@link Closeable}.      *      * @param iterable the iterable to wrap.      * @param p the predicate.      * @return the aborting iterable.      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|CloseableIterable
argument_list|<
name|T
argument_list|>
name|abortingIterable
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|Predicate
argument_list|<
name|T
argument_list|>
name|p
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|iterable
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|new
name|CloseableIterable
argument_list|<
name|T
argument_list|>
argument_list|(
parameter_list|()
lambda|->
block|{
specifier|final
name|Iterator
argument_list|<
name|T
argument_list|>
name|it
init|=
name|iterable
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|AbstractIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|T
name|computeNext
parameter_list|()
block|{
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|next
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|apply
argument_list|(
name|next
argument_list|)
condition|)
block|{
return|return
name|next
return|;
block|}
block|}
return|return
name|endOfData
argument_list|()
return|;
block|}
block|}
return|;
block|}
argument_list|,
parameter_list|()
lambda|->
name|closeIfCloseable
argument_list|(
name|iterable
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Makes sure the current time is after the most recent external revision      * timestamp in the _lastRev map of the given root document. If necessary      * the current thread waits until {@code clock} is after the external      * revision timestamp.      *      * @param rootDoc the root document.      * @param clock the clock.      * @param clusterId the local clusterId.      * @throws InterruptedException if the current thread is interrupted while      *          waiting. The interrupted status on the current thread is cleared      *          when this exception is thrown.      */
specifier|public
specifier|static
name|void
name|alignWithExternalRevisions
parameter_list|(
annotation|@
name|NotNull
name|NodeDocument
name|rootDoc
parameter_list|,
annotation|@
name|NotNull
name|Clock
name|clock
parameter_list|,
name|int
name|clusterId
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|Revision
argument_list|>
name|lastRevMap
init|=
name|checkNotNull
argument_list|(
name|rootDoc
argument_list|)
operator|.
name|getLastRev
argument_list|()
decl_stmt|;
name|long
name|externalTime
init|=
name|Utils
operator|.
name|getMaxExternalTimestamp
argument_list|(
name|lastRevMap
operator|.
name|values
argument_list|()
argument_list|,
name|clusterId
argument_list|)
decl_stmt|;
name|long
name|localTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|localTime
operator|<
name|externalTime
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Detected clock differences. Local time is '{}', "
operator|+
literal|"while most recent external time is '{}'. "
operator|+
literal|"Current _lastRev entries: {}"
argument_list|,
operator|new
name|Date
argument_list|(
name|localTime
argument_list|)
argument_list|,
operator|new
name|Date
argument_list|(
name|externalTime
argument_list|)
argument_list|,
name|lastRevMap
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|double
name|delay
init|=
operator|(
operator|(
name|double
operator|)
name|externalTime
operator|-
name|localTime
operator|)
operator|/
literal|1000d
decl_stmt|;
name|String
name|fmt
init|=
literal|"Background read will be delayed by %.1f seconds. "
operator|+
literal|"Please check system time on cluster nodes."
decl_stmt|;
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
name|fmt
argument_list|,
name|delay
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
while|while
condition|(
name|localTime
operator|+
literal|60000
operator|<
name|externalTime
condition|)
block|{
name|clock
operator|.
name|waitUntil
argument_list|(
name|localTime
operator|+
literal|60000
argument_list|)
expr_stmt|;
name|localTime
operator|=
name|clock
operator|.
name|getTime
argument_list|()
expr_stmt|;
name|delay
operator|=
operator|(
operator|(
name|double
operator|)
name|externalTime
operator|-
name|localTime
operator|)
operator|/
literal|1000d
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|fmt
argument_list|,
name|delay
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clock
operator|.
name|waitUntil
argument_list|(
name|externalTime
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|localTime
operator|==
name|externalTime
condition|)
block|{
comment|// make sure local time is past external time
comment|// but only log at debug
name|LOG
operator|.
name|debug
argument_list|(
literal|"Local and external time are equal. Waiting until local"
operator|+
literal|"time is more recent than external reported time."
argument_list|)
expr_stmt|;
name|clock
operator|.
name|waitUntil
argument_list|(
name|externalTime
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Calls {@link Thread#join()} on each of the passed threads and catches      * any potentially thrown {@link InterruptedException}.      *      * @param threads the threads to join.      */
specifier|public
specifier|static
name|void
name|joinQuietly
parameter_list|(
name|Thread
modifier|...
name|threads
parameter_list|)
block|{
for|for
control|(
name|Thread
name|t
range|:
name|threads
control|)
block|{
try|try
block|{
name|t
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
comment|/**      * Returns the version of the module that contains the DocumentNodeStore.      *      * @return the module version or "SNAPSHOT" if unknown.      */
specifier|public
specifier|static
name|String
name|getModuleVersion
parameter_list|()
block|{
name|String
name|v
init|=
name|MODULE_VERSION
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
name|v
operator|=
name|OakVersion
operator|.
name|getVersion
argument_list|(
literal|"oak-store-document"
argument_list|,
name|Utils
operator|.
name|class
argument_list|)
expr_stmt|;
name|MODULE_VERSION
operator|=
name|v
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
comment|/**      * Check the revision age on the root document for the given cluster node      * info. The check will fail with a {@link DocumentStoreException} if the      * {@code _lastRev} timestamp for the cluster node is newer then the current      * {@code clock} time. The check will not fail if the root document does      * not exist or does not have a {@code _lastRev} entry for the cluster node.      *      * @param store the document store from where to read the root document.      * @param info the cluster node info with the clusterId.      * @param clock the clock to get the current time.      * @throws DocumentStoreException if the check fails.      */
specifier|public
specifier|static
name|void
name|checkRevisionAge
parameter_list|(
name|DocumentStore
name|store
parameter_list|,
name|ClusterNodeInfo
name|info
parameter_list|,
name|Clock
name|clock
parameter_list|)
throws|throws
name|DocumentStoreException
block|{
name|NodeDocument
name|root
init|=
name|store
operator|.
name|find
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
name|getIdFromPath
argument_list|(
name|Path
operator|.
name|ROOT
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|int
name|clusterId
init|=
name|info
operator|.
name|getId
argument_list|()
decl_stmt|;
name|Revision
name|rev
init|=
name|root
operator|.
name|getLastRev
argument_list|()
operator|.
name|get
argument_list|(
name|clusterId
argument_list|)
decl_stmt|;
if|if
condition|(
name|rev
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|long
name|now
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|rev
operator|.
name|getTimestamp
argument_list|()
operator|>
name|now
condition|)
block|{
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Cluster id %d has a _lastRev %s (%s) "
operator|+
literal|"newer than current time %s. Please check system time on "
operator|+
literal|"cluster nodes."
argument_list|,
name|clusterId
argument_list|,
name|rev
operator|.
name|toString
argument_list|()
argument_list|,
name|timestampToString
argument_list|(
name|rev
operator|.
name|getTimestamp
argument_list|()
argument_list|)
argument_list|,
name|timestampToString
argument_list|(
name|now
argument_list|)
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

