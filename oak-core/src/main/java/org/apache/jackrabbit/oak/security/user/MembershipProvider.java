begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|security
operator|.
name|user
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|RepositoryException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterators
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|commons
operator|.
name|iterator
operator|.
name|AbstractLazyIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|PropertyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Root
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|PropertyValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|security
operator|.
name|ConfigurationParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|security
operator|.
name|user
operator|.
name|AuthorizableType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|NotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * {@code MembershipProvider} implementation storing group membership information  * with the {@code Tree} associated with a given {@link org.apache.jackrabbit.api.security.user.Group}.  *  * As of Oak the {@code MembershipProvider} automatically chooses an appropriate storage structure  * depending on the number of group members. If the number of members is low they are stored as  * {@link javax.jcr.PropertyType#WEAKREFERENCE} in the {@link #REP_MEMBERS} multi value property. This is similar to  * Jackrabbit 2.x.  *  * If the number of members is high the {@code MembershipProvider} will create an intermediate node list to reduce the  * size of the multi value properties below a {@link #REP_MEMBERS_LIST} node. The provider will maintain a number of  * sub nodes of type {@link #NT_REP_MEMBER_REFERENCES} that again store the member references in a {@link #REP_MEMBERS}  * property.  *  * Note that the writing of the members is done in {@link MembershipWriter} so that the logic can be re-used by the  * migration code.  *  * The current implementation uses a fixed threshold value of {@link MembershipWriter#DEFAULT_MEMBERSHIP_THRESHOLD} before creating  * {@link #NT_REP_MEMBER_REFERENCES} sub nodes.  *  * Example Group with few members (irrelevant properties excluded):  *<xmp>      {          "jcr:primaryType": "rep:Group",          "rep:principalName": "contributor",          "rep:members": [              "429bbd5b-46a6-3c3d-808b-5fd4219d5c4d",              "ca58c408-fe06-357e-953c-2d23ffe1e096",              "3ebb1c04-76dd-317e-a9ee-5164182bc390",              "d3c827d3-4db2-30cc-9c41-0ed8117dbaff",              "f5777a0b-a933-3b4d-9405-613d8bc39cc7",              "fdd1547a-b19a-3154-90da-1eae8c2c3504",              "65c3084e-abfc-3719-8223-72c6cb9a3d6f"          ]      }  *</xmp>  *  * Example Group with many members (irrelevant properties excluded):  *<xmp>      {          "jcr:primaryType": "rep:Group",          "rep:principalName": "employees",          "rep:membersList": {              "jcr:primaryType": "rep:MemberReferencesList",              "0": {                  "jcr:primaryType": "rep:MemberReferences",                  "rep:members": [                      "429bbd5b-46a6-3c3d-808b-5fd4219d5c4d",                      "ca58c408-fe06-357e-953c-2d23ffe1e096",                      ...                  ]              },              ...              "341": {                  "jcr:primaryType": "rep:MemberReferences",                  "rep:members": [                      "fdd1547a-b19a-3154-90da-1eae8c2c3504",                      "65c3084e-abfc-3719-8223-72c6cb9a3d6f",                      ...                  ]              }          }      }  *</xmp>  */
end_comment

begin_class
class|class
name|MembershipProvider
extends|extends
name|AuthorizableBaseProvider
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MembershipProvider
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|MembershipWriter
name|writer
init|=
operator|new
name|MembershipWriter
argument_list|()
decl_stmt|;
comment|/**      * Creates a new membership provider      * @param root the current root      * @param config the security configuration      */
name|MembershipProvider
parameter_list|(
annotation|@
name|NotNull
name|Root
name|root
parameter_list|,
annotation|@
name|NotNull
name|ConfigurationParameters
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|root
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the size of the membership property threshold. This is currently only useful for testing.      * @param membershipSizeThreshold the size of the membership property threshold      */
name|void
name|setMembershipSizeThreshold
parameter_list|(
name|int
name|membershipSizeThreshold
parameter_list|)
block|{
name|writer
operator|.
name|setMembershipSizeThreshold
argument_list|(
name|membershipSizeThreshold
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns an iterator over all membership paths of the given authorizable.      *      * @param authorizableTree the authorizable tree      * @param includeInherited {@code true} to include inherited memberships      * @return an iterator over all membership paths.      */
annotation|@
name|NotNull
name|Iterator
argument_list|<
name|String
argument_list|>
name|getMembership
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|authorizableTree
parameter_list|,
specifier|final
name|boolean
name|includeInherited
parameter_list|)
block|{
return|return
name|getMembership
argument_list|(
name|authorizableTree
argument_list|,
name|includeInherited
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns an iterator over all membership paths of the given authorizable.      *      * @param authorizableTree the authorizable tree      * @param includeInherited {@code true} to include inherited memberships      * @param processedPaths helper set that contains the processed paths      * @return an iterator over all membership paths.      */
annotation|@
name|NotNull
specifier|private
name|Iterator
argument_list|<
name|String
argument_list|>
name|getMembership
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|authorizableTree
parameter_list|,
specifier|final
name|boolean
name|includeInherited
parameter_list|,
annotation|@
name|NotNull
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|processedPaths
parameter_list|)
block|{
specifier|final
name|Iterable
argument_list|<
name|String
argument_list|>
name|refPaths
init|=
name|identifierManager
operator|.
name|getReferences
argument_list|(
name|authorizableTree
argument_list|,
name|REP_MEMBERS
argument_list|,
name|NT_REP_MEMBER_REFERENCES
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|AbstractMemberIterator
argument_list|(
name|refPaths
operator|.
name|iterator
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|String
name|internalGetNext
parameter_list|(
annotation|@
name|NotNull
name|String
name|propPath
parameter_list|)
block|{
name|String
name|next
init|=
literal|null
decl_stmt|;
name|String
name|groupPath
init|=
name|getGroupPath
argument_list|(
name|propPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|groupPath
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|processedPaths
operator|.
name|add
argument_list|(
name|groupPath
argument_list|)
condition|)
block|{
comment|// we didn't see this path before, so continue
name|next
operator|=
name|groupPath
expr_stmt|;
if|if
condition|(
name|includeInherited
condition|)
block|{
comment|// inject a parent iterator if inherited memberships is requested
name|Tree
name|group
init|=
name|getByPath
argument_list|(
name|groupPath
argument_list|,
name|AuthorizableType
operator|.
name|GROUP
argument_list|)
decl_stmt|;
if|if
condition|(
name|group
operator|!=
literal|null
condition|)
block|{
name|remember
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Not a membership reference property "
operator|+
name|propPath
argument_list|)
expr_stmt|;
block|}
return|return
name|next
return|;
block|}
annotation|@
name|NotNull
annotation|@
name|Override
specifier|protected
name|Iterator
argument_list|<
name|String
argument_list|>
name|getNextIterator
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|)
block|{
return|return
name|getMembership
argument_list|(
name|groupTree
argument_list|,
literal|true
argument_list|,
name|processedPaths
argument_list|)
return|;
block|}
annotation|@
name|Nullable
specifier|private
name|String
name|getGroupPath
parameter_list|(
annotation|@
name|NotNull
name|String
name|membersPropPath
parameter_list|)
block|{
name|int
name|index
init|=
name|membersPropPath
operator|.
name|indexOf
argument_list|(
literal|'/'
operator|+
name|REP_MEMBERS_LIST
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|index
operator|=
name|membersPropPath
operator|.
name|indexOf
argument_list|(
literal|'/'
operator|+
name|REP_MEMBERS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|>
literal|0
condition|)
block|{
return|return
name|membersPropPath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
return|;
block|}
comment|/**      * Tests if the membership of the specified {@code authorizableTree}      * contains the given target group as defined by {@code groupTree}.      *      * @param authorizableTree The tree of the authorizable for which to resolve the membership.      * @param groupPath The path of the group which needs to be tested.      * @return {@code true} if the group is contained in the membership of the specified authorizable.      */
specifier|private
name|boolean
name|hasMembership
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|authorizableTree
parameter_list|,
annotation|@
name|NotNull
name|String
name|groupPath
parameter_list|)
block|{
return|return
name|Iterators
operator|.
name|contains
argument_list|(
name|getMembership
argument_list|(
name|authorizableTree
argument_list|,
literal|true
argument_list|)
argument_list|,
name|groupPath
argument_list|)
return|;
block|}
comment|/**      * Returns an iterator over all member paths of the given group.      *      * @param groupTree the group tree      * @param includeInherited {@code true} to include inherited members      * @return an iterator over all member paths      */
annotation|@
name|NotNull
name|Iterator
argument_list|<
name|String
argument_list|>
name|getMembers
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|,
name|boolean
name|includeInherited
parameter_list|)
block|{
return|return
name|getMembers
argument_list|(
name|groupTree
argument_list|,
name|getContentID
argument_list|(
name|groupTree
argument_list|)
argument_list|,
name|includeInherited
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|NotNull
name|Iterator
argument_list|<
name|String
argument_list|>
name|getDeclaredMemberContentIDs
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|)
block|{
return|return
name|getDeclaredMemberReferenceIterator
argument_list|(
name|groupTree
argument_list|)
return|;
block|}
comment|/**      * Returns an iterator over all member paths of the given group.      *      * @param groupTree the group tree      * @param includeInherited {@code true} to include inherited members      * @param processedRefs helper set that contains the references that are already processed.      * @return an iterator over all member paths      */
annotation|@
name|NotNull
specifier|private
name|Iterator
argument_list|<
name|String
argument_list|>
name|getMembers
parameter_list|(
annotation|@
name|NotNull
specifier|final
name|Tree
name|groupTree
parameter_list|,
annotation|@
name|NotNull
specifier|final
name|String
name|groupContentId
parameter_list|,
specifier|final
name|boolean
name|includeInherited
parameter_list|,
annotation|@
name|NotNull
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|processedRefs
parameter_list|)
block|{
name|MemberReferenceIterator
name|mrit
init|=
operator|new
name|MemberReferenceIterator
argument_list|(
name|groupTree
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|hasProcessedReference
parameter_list|(
annotation|@
name|NotNull
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|groupContentId
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Cyclic group membership detected for contentId "
operator|+
name|groupContentId
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|processedRefs
operator|.
name|add
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|AbstractMemberIterator
argument_list|(
name|mrit
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|String
name|internalGetNext
parameter_list|(
annotation|@
name|NotNull
name|String
name|value
parameter_list|)
block|{
name|String
name|next
init|=
name|identifierManager
operator|.
name|getPath
argument_list|(
name|PropertyValues
operator|.
name|newWeakReference
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
comment|// eventually remember groups for including inherited members
if|if
condition|(
name|next
operator|!=
literal|null
operator|&&
name|includeInherited
condition|)
block|{
name|Tree
name|gr
init|=
name|getByPath
argument_list|(
name|next
argument_list|,
name|AuthorizableType
operator|.
name|GROUP
argument_list|)
decl_stmt|;
if|if
condition|(
name|gr
operator|!=
literal|null
condition|)
block|{
name|remember
argument_list|(
name|gr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|next
return|;
block|}
annotation|@
name|NotNull
annotation|@
name|Override
specifier|protected
name|Iterator
argument_list|<
name|String
argument_list|>
name|getNextIterator
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|)
block|{
return|return
name|getMembers
argument_list|(
name|groupTree
argument_list|,
name|groupContentId
argument_list|,
literal|true
argument_list|,
name|processedRefs
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**      * Returns {@code true} if the given {@code groupTree} contains a member with the given {@code authorizableTree}      *      * @param groupTree  The new member to be tested for cyclic membership.      * @param authorizableTree The authorizable to check      *      * @return true if the group has given member.      */
name|boolean
name|isMember
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|,
annotation|@
name|NotNull
name|Tree
name|authorizableTree
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasMembers
argument_list|(
name|groupTree
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|pendingChanges
argument_list|(
name|groupTree
argument_list|)
condition|)
block|{
return|return
name|Iterators
operator|.
name|contains
argument_list|(
name|getMembers
argument_list|(
name|groupTree
argument_list|,
literal|true
argument_list|)
argument_list|,
name|authorizableTree
operator|.
name|getPath
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|hasMembership
argument_list|(
name|authorizableTree
argument_list|,
name|groupTree
operator|.
name|getPath
argument_list|()
argument_list|)
return|;
block|}
block|}
name|boolean
name|isDeclaredMember
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|,
annotation|@
name|NotNull
name|Tree
name|authorizableTree
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasMembers
argument_list|(
name|groupTree
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|contentId
init|=
name|getContentID
argument_list|(
name|authorizableTree
argument_list|)
decl_stmt|;
name|MemberReferenceIterator
name|refs
init|=
name|getDeclaredMemberReferenceIterator
argument_list|(
name|groupTree
argument_list|)
decl_stmt|;
return|return
name|Iterators
operator|.
name|contains
argument_list|(
name|refs
argument_list|,
name|contentId
argument_list|)
return|;
block|}
comment|/**      * Utility to determine if a given group has any members.      *      * @param groupTree The tree of the target group.      * @return {@code true} if the group has any members i.e. if it has a rep:members      * property or a rep:membersList child node.      */
specifier|private
specifier|static
name|boolean
name|hasMembers
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|)
block|{
return|return
name|groupTree
operator|.
name|getPropertyStatus
argument_list|(
name|REP_MEMBERS
argument_list|)
operator|!=
literal|null
operator|||
name|groupTree
operator|.
name|hasChild
argument_list|(
name|REP_MEMBERS_LIST
argument_list|)
return|;
block|}
comment|/**      * Determine if the group has (potentially) been modified in which case the      * query can't be used:      * - rep:members property has been modified      * - any potential modification in the member-ref-list subtree, which is not      * easy to detect => relying on pending changes on the root object      *      * @param groupTree The tree of the target group.      * @return {@code true} if the specified group tree has an unmodified rep:members      * property or if the root has pending changes.      */
specifier|private
name|boolean
name|pendingChanges
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|)
block|{
name|Tree
operator|.
name|Status
name|memberPropStatus
init|=
name|groupTree
operator|.
name|getPropertyStatus
argument_list|(
name|REP_MEMBERS
argument_list|)
decl_stmt|;
comment|// rep:members is new or has been modified or root has pending changes
return|return
name|Tree
operator|.
name|Status
operator|.
name|UNCHANGED
operator|!=
name|memberPropStatus
operator|||
name|root
operator|.
name|hasPendingChanges
argument_list|()
return|;
block|}
comment|/**      * Adds a new member to the given {@code groupTree}.      * @param groupTree the group to add the member to      * @param newMemberTree the tree of the new member      * @return {@code true} if the member was added      * @throws RepositoryException if an error occurs      */
name|boolean
name|addMember
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|,
annotation|@
name|NotNull
name|Tree
name|newMemberTree
parameter_list|)
block|{
return|return
name|writer
operator|.
name|addMember
argument_list|(
name|groupTree
argument_list|,
name|getContentID
argument_list|(
name|newMemberTree
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Add the members from the given group.      *      * @param groupTree group to add the new members      * @param memberIds Map of 'contentId':'memberId' of all members to be added.      * @return the set of member IDs that was not successfully processed.      */
name|Set
argument_list|<
name|String
argument_list|>
name|addMembers
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|,
annotation|@
name|NotNull
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|memberIds
parameter_list|)
block|{
return|return
name|writer
operator|.
name|addMembers
argument_list|(
name|groupTree
argument_list|,
name|memberIds
argument_list|)
return|;
block|}
comment|/**      * Removes the member from the given group.      *      * @param groupTree group to remove the member from      * @param memberTree member to remove      * @return {@code true} if the member was removed.      */
name|boolean
name|removeMember
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|,
annotation|@
name|NotNull
name|Tree
name|memberTree
parameter_list|)
block|{
if|if
condition|(
name|writer
operator|.
name|removeMember
argument_list|(
name|groupTree
argument_list|,
name|getContentID
argument_list|(
name|memberTree
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Authorizable {} was not member of {}"
argument_list|,
name|memberTree
operator|.
name|getName
argument_list|()
argument_list|,
name|groupTree
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Removes the members from the given group.      *      * @param groupTree group to remove the member from      * @param memberIds Map of 'contentId':'memberId' of all members that need to be removed.      * @return the set of member IDs that was not successfully processed.      */
name|Set
argument_list|<
name|String
argument_list|>
name|removeMembers
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|,
annotation|@
name|NotNull
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|memberIds
parameter_list|)
block|{
return|return
name|writer
operator|.
name|removeMembers
argument_list|(
name|groupTree
argument_list|,
name|memberIds
argument_list|)
return|;
block|}
specifier|private
name|MemberReferenceIterator
name|getDeclaredMemberReferenceIterator
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|)
block|{
return|return
operator|new
name|MemberReferenceIterator
argument_list|(
name|groupTree
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|hasProcessedReference
parameter_list|(
annotation|@
name|NotNull
name|String
name|value
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|;
block|}
comment|/**      * Iterator that provides member references based on the rep:members properties of a underlying tree iterator.      */
specifier|private
specifier|abstract
class|class
name|MemberReferenceIterator
extends|extends
name|AbstractLazyIterator
argument_list|<
name|String
argument_list|>
block|{
specifier|private
specifier|final
name|Iterator
argument_list|<
name|Tree
argument_list|>
name|trees
decl_stmt|;
specifier|private
name|Iterator
argument_list|<
name|String
argument_list|>
name|propertyValues
decl_stmt|;
specifier|private
name|MemberReferenceIterator
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|)
block|{
name|this
operator|.
name|trees
operator|=
name|Iterators
operator|.
name|concat
argument_list|(
name|Iterators
operator|.
name|singletonIterator
argument_list|(
name|groupTree
argument_list|)
argument_list|,
name|groupTree
operator|.
name|getChild
argument_list|(
name|REP_MEMBERS_LIST
argument_list|)
operator|.
name|getChildren
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getNext
parameter_list|()
block|{
name|String
name|next
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|next
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|propertyValues
operator|==
literal|null
condition|)
block|{
comment|// check if there are more trees that can provide a rep:members property
if|if
condition|(
operator|!
name|trees
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// if not, we're done
break|break;
block|}
name|PropertyState
name|property
init|=
name|trees
operator|.
name|next
argument_list|()
operator|.
name|getProperty
argument_list|(
name|REP_MEMBERS
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
block|{
name|propertyValues
operator|=
name|property
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|STRINGS
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|propertyValues
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// if there are no more values left, reset the iterator
name|propertyValues
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|String
name|value
init|=
name|propertyValues
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasProcessedReference
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|next
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
return|return
name|next
return|;
block|}
specifier|protected
specifier|abstract
name|boolean
name|hasProcessedReference
parameter_list|(
annotation|@
name|NotNull
name|String
name|value
parameter_list|)
function_decl|;
block|}
specifier|private
specifier|abstract
class|class
name|AbstractMemberIterator
extends|extends
name|AbstractLazyIterator
argument_list|<
name|String
argument_list|>
block|{
specifier|private
name|Iterator
argument_list|<
name|String
argument_list|>
name|references
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Tree
argument_list|>
name|groupTrees
decl_stmt|;
specifier|private
name|Iterator
argument_list|<
name|String
argument_list|>
name|parent
decl_stmt|;
name|AbstractMemberIterator
parameter_list|(
annotation|@
name|NotNull
name|Iterator
argument_list|<
name|String
argument_list|>
name|references
parameter_list|)
block|{
name|this
operator|.
name|references
operator|=
name|references
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getNext
parameter_list|()
block|{
name|String
name|next
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|next
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|references
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|next
operator|=
name|internalGetNext
argument_list|(
name|references
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|parent
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|next
operator|=
name|parent
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// force retrieval of next parent iterator
name|parent
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// try to retrieve the next 'parent' iterator for the first
comment|// group tree remembered in the list.
if|if
condition|(
name|groupTrees
operator|==
literal|null
operator|||
name|groupTrees
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// no more parents to process => reset the iterator.
break|break;
block|}
else|else
block|{
name|parent
operator|=
name|getNextIterator
argument_list|(
name|groupTrees
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|next
return|;
block|}
comment|/**          * Remember a group that needs to be search for references ('parent')          * once all 'references' have been processed.          *          * @param groupTree A tree associated with a group          * @see #getNextIterator(Tree)          */
name|void
name|remember
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|)
block|{
if|if
condition|(
name|groupTrees
operator|==
literal|null
condition|)
block|{
name|groupTrees
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|groupTrees
operator|.
name|add
argument_list|(
name|groupTree
argument_list|)
expr_stmt|;
block|}
comment|/**          * Abstract method to obtain the next authorizable path from the given          * reference value.          *          * @param nextReference The next reference as obtained from the iterator.          * @return The path of the authorizable identified by {@code nextReference}          * or {@code null} if it cannot be resolved.          */
annotation|@
name|Nullable
specifier|protected
specifier|abstract
name|String
name|internalGetNext
parameter_list|(
annotation|@
name|NotNull
name|String
name|nextReference
parameter_list|)
function_decl|;
comment|/**          * Abstract method to retrieve the next member iterator for the given          * {@code groupTree}.          *          * @param groupTree Tree referring to a group.          * @return The next member reference 'parent' iterator to be processed.          */
annotation|@
name|NotNull
specifier|protected
specifier|abstract
name|Iterator
argument_list|<
name|String
argument_list|>
name|getNextIterator
parameter_list|(
annotation|@
name|NotNull
name|Tree
name|groupTree
parameter_list|)
function_decl|;
block|}
block|}
end_class

end_unit

