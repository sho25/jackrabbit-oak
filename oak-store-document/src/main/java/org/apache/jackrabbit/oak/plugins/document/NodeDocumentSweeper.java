begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|NotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|filter
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|partition
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|transform
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|immutableEntry
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|newHashMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|isDeletedEntry
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|removeCommitRoot
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|removeRevision
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|setDeletedOnce
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|Utils
operator|.
name|PROPERTY_OR_DELETED
import|;
end_import

begin_comment
comment|/**  * The {@code NodeDocumentSweeper} is responsible for removing uncommitted  * changes from {@code NodeDocument}s for a given clusterId.  *<p>  * This class is not thread-safe.  */
end_comment

begin_class
specifier|final
class|class
name|NodeDocumentSweeper
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|NodeDocumentSweeper
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|INVALIDATE_BATCH_SIZE
init|=
literal|100
decl_stmt|;
specifier|private
specifier|final
name|RevisionContext
name|context
decl_stmt|;
specifier|private
specifier|final
name|int
name|clusterId
decl_stmt|;
specifier|private
specifier|final
name|RevisionVector
name|headRevision
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|sweepNewerThanHead
decl_stmt|;
specifier|private
name|Revision
name|head
decl_stmt|;
specifier|private
name|long
name|documentCount
decl_stmt|;
comment|/**      * Creates a new sweeper for the given context. The sweeper is initialized      * in the constructor with the head revision provided by the revision      * context. This is the head revision used later when the documents are      * check for uncommitted changes in      * {@link #sweep(Iterable, NodeDocumentSweepListener)}.      *<p>      * In combination with {@code sweepNewerThanHead == false}, the revision      * context may return a head revision that is not up-to-date, as long as it      * is consistent with documents passed to the {@code sweep()} method. That      * is, the documents must reflect all changes visible from the provided head      * revision. The sweeper will then only revert uncommitted changes up to the      * head revision. With {@code sweepNewerThanHead == true}, the sweeper will      * also revert uncommitted changes that are newer than the head revision.      * This is usually only useful during recovery of a cluster node, when it is      * guaranteed that there are no in-progress commits newer than the current      * head revision.      *      * @param context the revision context.      * @param sweepNewerThanHead whether uncommitted changes newer than the head      *                 revision should be reverted.      */
name|NodeDocumentSweeper
parameter_list|(
name|RevisionContext
name|context
parameter_list|,
name|boolean
name|sweepNewerThanHead
parameter_list|)
block|{
name|this
operator|.
name|context
operator|=
name|checkNotNull
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterId
operator|=
name|context
operator|.
name|getClusterId
argument_list|()
expr_stmt|;
name|this
operator|.
name|headRevision
operator|=
name|context
operator|.
name|getHeadRevision
argument_list|()
expr_stmt|;
name|this
operator|.
name|sweepNewerThanHead
operator|=
name|sweepNewerThanHead
expr_stmt|;
block|}
comment|/**      * Performs a sweep and reports the required updates to the given sweep      * listener. The returned revision is the new sweep revision for the      * clusterId associated with the revision context used to create this      * sweeper. The caller is responsible for storing the returned sweep      * revision on the root document. This method returns {@code null} if no      * update was possible.      *      * @param documents the documents to sweep      * @param listener the listener to receive required sweep update operations.      * @return the new sweep revision or {@code null} if no updates were done.      * @throws DocumentStoreException if reading from the store or writing to      *          the store failed.      */
annotation|@
name|Nullable
name|Revision
name|sweep
parameter_list|(
annotation|@
name|NotNull
name|Iterable
argument_list|<
name|NodeDocument
argument_list|>
name|documents
parameter_list|,
annotation|@
name|NotNull
name|NodeDocumentSweepListener
name|listener
parameter_list|)
throws|throws
name|DocumentStoreException
block|{
return|return
name|performSweep
argument_list|(
name|documents
argument_list|,
name|checkNotNull
argument_list|(
name|listener
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * @return the head revision vector in use by this sweeper.      */
name|RevisionVector
name|getHeadRevision
parameter_list|()
block|{
return|return
name|headRevision
return|;
block|}
comment|//----------------------------< internal>----------------------------------
annotation|@
name|Nullable
specifier|private
name|Revision
name|performSweep
parameter_list|(
name|Iterable
argument_list|<
name|NodeDocument
argument_list|>
name|documents
parameter_list|,
name|NodeDocumentSweepListener
name|listener
parameter_list|)
throws|throws
name|DocumentStoreException
block|{
name|head
operator|=
name|headRevision
operator|.
name|getRevision
argument_list|(
name|clusterId
argument_list|)
expr_stmt|;
name|documentCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|head
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Head revision does not have an entry for "
operator|+
literal|"clusterId {}. Sweeping of documents is skipped."
argument_list|,
name|clusterId
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Iterable
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|UpdateOp
argument_list|>
argument_list|>
name|ops
init|=
name|sweepOperations
argument_list|(
name|documents
argument_list|)
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|UpdateOp
argument_list|>
argument_list|>
name|batch
range|:
name|partition
argument_list|(
name|ops
argument_list|,
name|INVALIDATE_BATCH_SIZE
argument_list|)
control|)
block|{
name|Map
argument_list|<
name|Path
argument_list|,
name|UpdateOp
argument_list|>
name|updates
init|=
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|UpdateOp
argument_list|>
name|entry
range|:
name|batch
control|)
block|{
name|updates
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|listener
operator|.
name|sweepUpdate
argument_list|(
name|updates
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Document sweep finished"
argument_list|)
expr_stmt|;
return|return
name|head
return|;
block|}
specifier|private
name|Iterable
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|UpdateOp
argument_list|>
argument_list|>
name|sweepOperations
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|NodeDocument
argument_list|>
name|docs
parameter_list|)
block|{
return|return
name|filter
argument_list|(
name|transform
argument_list|(
name|docs
argument_list|,
operator|new
name|Function
argument_list|<
name|NodeDocument
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|UpdateOp
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|UpdateOp
argument_list|>
name|apply
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
name|immutableEntry
argument_list|(
name|doc
operator|.
name|getPath
argument_list|()
argument_list|,
name|sweepOne
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
argument_list|,
operator|new
name|Predicate
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|UpdateOp
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|UpdateOp
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|private
name|UpdateOp
name|sweepOne
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
throws|throws
name|DocumentStoreException
block|{
name|UpdateOp
name|op
init|=
name|createUpdateOp
argument_list|(
name|doc
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|property
range|:
name|filter
argument_list|(
name|doc
operator|.
name|keySet
argument_list|()
argument_list|,
name|PROPERTY_OR_DELETED
argument_list|)
control|)
block|{
name|Map
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|valueMap
init|=
name|doc
operator|.
name|getLocalMap
argument_list|(
name|property
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|valueMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Revision
name|rev
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// only consider change for this cluster node
if|if
condition|(
name|rev
operator|.
name|getClusterId
argument_list|()
operator|!=
name|clusterId
condition|)
block|{
continue|continue;
block|}
name|Revision
name|cRev
init|=
name|getCommitRevision
argument_list|(
name|doc
argument_list|,
name|rev
argument_list|)
decl_stmt|;
if|if
condition|(
name|cRev
operator|==
literal|null
condition|)
block|{
name|uncommitted
argument_list|(
name|doc
argument_list|,
name|property
argument_list|,
name|rev
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cRev
operator|.
name|equals
argument_list|(
name|rev
argument_list|)
condition|)
block|{
name|committed
argument_list|(
name|property
argument_list|,
name|rev
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|committedBranch
argument_list|(
name|doc
argument_list|,
name|property
argument_list|,
name|rev
argument_list|,
name|cRev
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|++
name|documentCount
operator|%
literal|100000
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Checked {} documents so far"
argument_list|,
name|documentCount
argument_list|)
expr_stmt|;
block|}
return|return
name|op
operator|.
name|hasChanges
argument_list|()
condition|?
name|op
else|:
literal|null
return|;
block|}
specifier|private
name|void
name|uncommitted
parameter_list|(
name|NodeDocument
name|doc
parameter_list|,
name|String
name|property
parameter_list|,
name|Revision
name|rev
parameter_list|,
name|UpdateOp
name|op
parameter_list|)
block|{
if|if
condition|(
name|head
operator|.
name|compareRevisionTime
argument_list|(
name|rev
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|sweepNewerThanHead
condition|)
block|{
comment|// ignore changes that happen after the
comment|// head we are currently looking at
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Uncommitted change on {}, {} @ {} newer than head {} "
argument_list|,
name|op
operator|.
name|getId
argument_list|()
argument_list|,
name|property
argument_list|,
name|rev
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|isV18BranchCommit
argument_list|(
name|rev
argument_list|,
name|doc
argument_list|)
condition|)
block|{
comment|// this is a not yet merged branch commit
comment|// -> do nothing
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unmerged branch commit on {}, {} @ {}"
argument_list|,
name|op
operator|.
name|getId
argument_list|()
argument_list|,
name|property
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// this may be a not yet merged branch commit, but since it
comment|// wasn't created by this Oak version, it must be a left over
comment|// from an old branch which cannot be merged anyway.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Uncommitted change on {}, {} @ {}"
argument_list|,
name|op
operator|.
name|getId
argument_list|()
argument_list|,
name|property
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
name|op
operator|.
name|removeMapEntry
argument_list|(
name|property
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|.
name|getLocalCommitRoot
argument_list|()
operator|.
name|containsKey
argument_list|(
name|rev
argument_list|)
condition|)
block|{
name|removeCommitRoot
argument_list|(
name|op
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removeRevision
argument_list|(
name|op
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
comment|// set _deletedOnce if uncommitted change is a failed create
comment|// node operation and doc does not have _deletedOnce yet
if|if
condition|(
name|isDeletedEntry
argument_list|(
name|property
argument_list|)
operator|&&
operator|!
name|doc
operator|.
name|wasDeletedOnce
argument_list|()
operator|&&
literal|"false"
operator|.
name|equals
argument_list|(
name|doc
operator|.
name|getLocalDeleted
argument_list|()
operator|.
name|get
argument_list|(
name|rev
argument_list|)
argument_list|)
condition|)
block|{
name|setDeletedOnce
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Returns {@code true} if the given revision is marked as a branch commit      * on the document. This method only checks local branch commit information      * available on the document ({@link NodeDocument#getLocalBranchCommits()}).      * If the given revision is related to a branch commit that was created      * prior to Oak 1.8, the method will return {@code false}.      *      * @param rev a revision.      * @param doc the document to check.      * @return {@code true} if the revision is marked as a branch commit;      *          {@code false} otherwise.      */
specifier|private
name|boolean
name|isV18BranchCommit
parameter_list|(
name|Revision
name|rev
parameter_list|,
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|.
name|getLocalBranchCommits
argument_list|()
operator|.
name|contains
argument_list|(
name|rev
argument_list|)
return|;
block|}
specifier|private
name|void
name|committed
parameter_list|(
name|String
name|property
parameter_list|,
name|Revision
name|rev
parameter_list|,
name|UpdateOp
name|op
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Committed change on {}, {} @ {}"
argument_list|,
name|op
operator|.
name|getId
argument_list|()
argument_list|,
name|property
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|committedBranch
parameter_list|(
name|NodeDocument
name|doc
parameter_list|,
name|String
name|property
parameter_list|,
name|Revision
name|rev
parameter_list|,
name|Revision
name|cRev
parameter_list|,
name|UpdateOp
name|op
parameter_list|)
block|{
name|boolean
name|newerThanHead
init|=
name|cRev
operator|.
name|compareRevisionTime
argument_list|(
name|head
argument_list|)
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
name|newerThanHead
condition|?
literal|" (newer than head)"
else|:
literal|""
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Committed branch change on {}, {} @ {}/{}{}"
argument_list|,
name|op
operator|.
name|getId
argument_list|()
argument_list|,
name|property
argument_list|,
name|rev
argument_list|,
name|cRev
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isV18BranchCommit
argument_list|(
name|rev
argument_list|,
name|doc
argument_list|)
condition|)
block|{
name|NodeDocument
operator|.
name|setBranchCommit
argument_list|(
name|op
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|UpdateOp
name|createUpdateOp
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
operator|new
name|UpdateOp
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Nullable
specifier|private
name|Revision
name|getCommitRevision
parameter_list|(
specifier|final
name|NodeDocument
name|doc
parameter_list|,
specifier|final
name|Revision
name|rev
parameter_list|)
throws|throws
name|DocumentStoreException
block|{
name|String
name|cv
init|=
name|context
operator|.
name|getCommitValue
argument_list|(
name|rev
argument_list|,
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|Utils
operator|.
name|resolveCommitRevision
argument_list|(
name|rev
argument_list|,
name|cv
argument_list|)
return|;
block|}
block|}
end_class

end_unit

