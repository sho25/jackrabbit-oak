begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|CloseableIterable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|filter
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|partition
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|transform
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|immutableEntry
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|newHashMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|getModifiedInSecs
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|isDeletedEntry
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|removeCommitRoot
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|removeRevision
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|setDeletedOnce
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|Utils
operator|.
name|PROPERTY_OR_DELETED
import|;
end_import

begin_comment
comment|/**  * The {@code NodeDocumentSweeper} is responsible for removing uncommitted  * changes from {@code NodeDocument}s for a given clusterId. The sweeper scans  * through documents modified after a given timestamp. This timestamp is derived  * from the sweep revisions available on the root document  * ({@link NodeDocument#getSweepRevisions()}). If no sweep revision is present  * for the current clusterId, the sweeper scans through the entire nodes  * collection. This is usually a one-time operation when the repository is  * upgraded from a version older than 1.8.  *<p>  * The sweeper can read from an eventually consistent store and does not require  * that it sees the most up-to-date state of the store. That is, running it off  * a MongoDB Secondary is fine and even recommended.  *<p>  * This class is not thread-safe.  */
end_comment

begin_class
specifier|abstract
class|class
name|NodeDocumentSweeper
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|NodeDocumentSweeper
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|INVALIDATE_BATCH_SIZE
init|=
literal|100
decl_stmt|;
specifier|private
specifier|final
name|RevisionContext
name|context
decl_stmt|;
specifier|private
specifier|final
name|int
name|clusterId
decl_stmt|;
specifier|private
name|Revision
name|headRevision
decl_stmt|;
comment|/**      * Creates a new sweeper for the given context.      *      *  @param context the revision context.      *      */
name|NodeDocumentSweeper
parameter_list|(
name|RevisionContext
name|context
parameter_list|)
block|{
name|this
operator|.
name|context
operator|=
name|checkNotNull
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterId
operator|=
name|context
operator|.
name|getClusterId
argument_list|()
expr_stmt|;
block|}
comment|/**      * Must be implemented by sub-class and return the current root document      * in the nodes collection. An implementation is permitted to return a root      * document that is not up-to-date, as long as it is consistency with      * {@link #getDocuments(long)}.      *      * @return the root document.      * @throws DocumentStoreException if an exception occurs reading the      *          document.      */
annotation|@
name|Nonnull
specifier|protected
specifier|abstract
name|NodeDocument
name|getRoot
parameter_list|()
throws|throws
name|DocumentStoreException
function_decl|;
comment|/**      * Returns all documents that have a {@link NodeDocument#MODIFIED_IN_SECS}      * field equal or greater than {@code modifiedInSecs}. An implementation is      * permitted to return documents that are not up-to-date, as long as they      * are consistent with {@link #getRoot()}.      *<p>      * See also {@link NodeDocument#getModifiedInSecs(long)}.      *      * @param modifiedInSecs a timestamp in seconds.      * @return matching documents.      * @throws DocumentStoreException if an exception occurs reading documents.      */
annotation|@
name|Nonnull
specifier|protected
specifier|abstract
name|Iterable
argument_list|<
name|NodeDocument
argument_list|>
name|getDocuments
parameter_list|(
name|long
name|modifiedInSecs
parameter_list|)
throws|throws
name|DocumentStoreException
function_decl|;
comment|/**      * Performs a sweep and reports the required updates to the given sweep      * listener. The returned revision is the new sweep revision for the      * clusterId associated with the revision context used to create this      * sweeper. The caller is responsible for storing the returned sweep      * revision on the root document. This method returns {@code null} if no      * update was needed or possible.      *      * @param listener the listener to receive required sweep update operations.      * @return the new sweep revision or {@code null} if no updates were done.      * @throws DocumentStoreException if reading from the store or writing to      *          the store failed.      */
annotation|@
name|CheckForNull
name|Revision
name|sweep
parameter_list|(
name|NodeDocumentSweepListener
name|listener
parameter_list|)
throws|throws
name|DocumentStoreException
block|{
return|return
name|performSweep
argument_list|(
name|listener
argument_list|)
return|;
block|}
comment|//----------------------------< internal>----------------------------------
annotation|@
name|CheckForNull
specifier|private
name|Revision
name|performSweep
parameter_list|(
name|NodeDocumentSweepListener
name|listener
parameter_list|)
throws|throws
name|DocumentStoreException
block|{
name|NodeDocument
name|rootDoc
init|=
name|getRoot
argument_list|()
decl_stmt|;
name|RevisionVector
name|head
init|=
name|getHeadRevision
argument_list|(
name|rootDoc
argument_list|)
decl_stmt|;
name|headRevision
operator|=
name|head
operator|.
name|getRevision
argument_list|(
name|clusterId
argument_list|)
expr_stmt|;
if|if
condition|(
name|headRevision
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Head revision {} does not have an entry for "
operator|+
literal|"clusterId {}. Sweeping of documents is skipped."
argument_list|,
name|head
argument_list|,
name|clusterId
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|RevisionVector
name|sweepRevs
init|=
name|rootDoc
operator|.
name|getSweepRevisions
argument_list|()
decl_stmt|;
name|Revision
name|lastSweepHead
init|=
name|sweepRevs
operator|.
name|getRevision
argument_list|(
name|clusterId
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastSweepHead
operator|==
literal|null
condition|)
block|{
comment|// sweep all
name|lastSweepHead
operator|=
operator|new
name|Revision
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|clusterId
argument_list|)
expr_stmt|;
block|}
comment|// only sweep documents when the _modified time changed
name|long
name|lastSweepTick
init|=
name|getModifiedInSecs
argument_list|(
name|lastSweepHead
operator|.
name|getTimestamp
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|currentTick
init|=
name|getModifiedInSecs
argument_list|(
name|context
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastSweepTick
operator|==
name|currentTick
condition|)
block|{
return|return
literal|null
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting document sweep. Head: {}, starting at {}"
argument_list|,
name|headRevision
argument_list|,
name|lastSweepHead
argument_list|)
expr_stmt|;
name|CloseableIterable
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
argument_list|>
name|ops
init|=
name|sweepOperations
argument_list|(
name|lastSweepTick
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
argument_list|>
name|batch
range|:
name|partition
argument_list|(
name|ops
argument_list|,
name|INVALIDATE_BATCH_SIZE
argument_list|)
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
name|updates
init|=
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
name|entry
range|:
name|batch
control|)
block|{
name|updates
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|listener
operator|.
name|sweepUpdate
argument_list|(
name|updates
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
try|try
block|{
name|ops
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close sweep operations"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Document sweep finished"
argument_list|)
expr_stmt|;
return|return
name|headRevision
return|;
block|}
specifier|private
name|CloseableIterable
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
argument_list|>
name|sweepOperations
parameter_list|(
name|long
name|modifiedInSecs
parameter_list|)
block|{
specifier|final
name|Iterable
argument_list|<
name|NodeDocument
argument_list|>
name|docs
init|=
name|getDocuments
argument_list|(
name|modifiedInSecs
argument_list|)
decl_stmt|;
return|return
name|CloseableIterable
operator|.
name|wrap
argument_list|(
name|filter
argument_list|(
name|transform
argument_list|(
name|docs
argument_list|,
operator|new
name|Function
argument_list|<
name|NodeDocument
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
name|apply
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
name|immutableEntry
argument_list|(
name|doc
operator|.
name|getPath
argument_list|()
argument_list|,
name|sweepOne
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
argument_list|,
operator|new
name|Predicate
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
return|;
block|}
block|}
argument_list|)
argument_list|,
operator|new
name|Closeable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|Utils
operator|.
name|closeIfCloseable
argument_list|(
name|docs
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Nonnull
specifier|private
name|RevisionVector
name|getHeadRevision
parameter_list|(
name|NodeDocument
name|rootDoc
parameter_list|)
block|{
return|return
operator|new
name|RevisionVector
argument_list|(
name|rootDoc
operator|.
name|getLastRev
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|UpdateOp
name|sweepOne
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
throws|throws
name|DocumentStoreException
block|{
name|UpdateOp
name|op
init|=
name|createUpdateOp
argument_list|(
name|doc
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|property
range|:
name|filter
argument_list|(
name|doc
operator|.
name|keySet
argument_list|()
argument_list|,
name|PROPERTY_OR_DELETED
argument_list|)
control|)
block|{
name|Map
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|valueMap
init|=
name|doc
operator|.
name|getLocalMap
argument_list|(
name|property
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|valueMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Revision
name|rev
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// only consider change for this cluster node
if|if
condition|(
name|rev
operator|.
name|getClusterId
argument_list|()
operator|!=
name|clusterId
condition|)
block|{
continue|continue;
block|}
name|Revision
name|cRev
init|=
name|getCommitRevision
argument_list|(
name|doc
argument_list|,
name|rev
argument_list|)
decl_stmt|;
if|if
condition|(
name|cRev
operator|==
literal|null
condition|)
block|{
name|uncommitted
argument_list|(
name|doc
argument_list|,
name|property
argument_list|,
name|rev
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cRev
operator|.
name|equals
argument_list|(
name|rev
argument_list|)
condition|)
block|{
name|committed
argument_list|(
name|property
argument_list|,
name|rev
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|committedBranch
argument_list|(
name|property
argument_list|,
name|rev
argument_list|,
name|cRev
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|op
operator|.
name|hasChanges
argument_list|()
condition|?
name|op
else|:
literal|null
return|;
block|}
specifier|private
name|void
name|uncommitted
parameter_list|(
name|NodeDocument
name|doc
parameter_list|,
name|String
name|property
parameter_list|,
name|Revision
name|rev
parameter_list|,
name|UpdateOp
name|op
parameter_list|)
block|{
if|if
condition|(
name|headRevision
operator|.
name|compareRevisionTime
argument_list|(
name|rev
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// ignore changes that happen after the
comment|// head we are currently looking at
return|return;
block|}
if|if
condition|(
name|isV18BranchCommit
argument_list|(
name|rev
argument_list|,
name|doc
argument_list|)
condition|)
block|{
comment|// this is a not yet merged branch commit
comment|// -> do nothing
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unmerged branch commit on {}, {} @ {}"
argument_list|,
name|op
operator|.
name|getId
argument_list|()
argument_list|,
name|property
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// this may be a not yet merged branch commit, but since it
comment|// wasn't created by this Oak version, it must be a left over
comment|// from an old branch which cannot be merged anyway.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Uncommitted change on {}, {} @ {}"
argument_list|,
name|op
operator|.
name|getId
argument_list|()
argument_list|,
name|property
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
name|op
operator|.
name|removeMapEntry
argument_list|(
name|property
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|.
name|getLocalCommitRoot
argument_list|()
operator|.
name|containsKey
argument_list|(
name|rev
argument_list|)
condition|)
block|{
name|removeCommitRoot
argument_list|(
name|op
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removeRevision
argument_list|(
name|op
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
comment|// set _deletedOnce if uncommitted change is a failed create
comment|// node operation and doc does not have _deletedOnce yet
if|if
condition|(
name|isDeletedEntry
argument_list|(
name|property
argument_list|)
operator|&&
operator|!
name|doc
operator|.
name|wasDeletedOnce
argument_list|()
operator|&&
literal|"false"
operator|.
name|equals
argument_list|(
name|doc
operator|.
name|getLocalDeleted
argument_list|()
operator|.
name|get
argument_list|(
name|rev
argument_list|)
argument_list|)
condition|)
block|{
name|setDeletedOnce
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Returns {@code true} if the given revision is marked as a branch commit      * on the document. This method only checks local branch commit information      * available on the document ({@link NodeDocument#getLocalBranchCommits()}).      * If the given revision is related to a branch commit that was created      * prior to Oak 1.8, the method will return {@code false}.      *      * @param rev a revision.      * @param doc the document to check.      * @return {@code true} if the revision is marked as a branch commit;      *          {@code false} otherwise.      */
specifier|private
name|boolean
name|isV18BranchCommit
parameter_list|(
name|Revision
name|rev
parameter_list|,
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|.
name|getLocalBranchCommits
argument_list|()
operator|.
name|contains
argument_list|(
name|rev
argument_list|)
return|;
block|}
specifier|private
name|void
name|committed
parameter_list|(
name|String
name|property
parameter_list|,
name|Revision
name|rev
parameter_list|,
name|UpdateOp
name|op
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Committed change on {}, {} @ {}"
argument_list|,
name|op
operator|.
name|getId
argument_list|()
argument_list|,
name|property
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|committedBranch
parameter_list|(
name|String
name|property
parameter_list|,
name|Revision
name|rev
parameter_list|,
name|Revision
name|cRev
parameter_list|,
name|UpdateOp
name|op
parameter_list|)
block|{
name|boolean
name|newerThanHead
init|=
name|cRev
operator|.
name|compareRevisionTime
argument_list|(
name|headRevision
argument_list|)
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
name|newerThanHead
condition|?
literal|" (newer than head)"
else|:
literal|""
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Committed branch change on {}, {} @ {}/{}{}"
argument_list|,
name|op
operator|.
name|getId
argument_list|()
argument_list|,
name|property
argument_list|,
name|rev
argument_list|,
name|cRev
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|UpdateOp
name|createUpdateOp
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
operator|new
name|UpdateOp
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|CheckForNull
specifier|private
name|Revision
name|getCommitRevision
parameter_list|(
specifier|final
name|NodeDocument
name|doc
parameter_list|,
specifier|final
name|Revision
name|rev
parameter_list|)
throws|throws
name|DocumentStoreException
block|{
name|String
name|cv
init|=
name|context
operator|.
name|getCommitValue
argument_list|(
name|rev
argument_list|,
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|Utils
operator|.
name|resolveCommitRevision
argument_list|(
name|rev
argument_list|,
name|cv
argument_list|)
return|;
block|}
block|}
end_class

end_unit

