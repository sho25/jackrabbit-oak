begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|nodetype
package|;
end_package

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|PropertyType
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|nodetype
operator|.
name|ItemDefinition
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|nodetype
operator|.
name|NodeDefinition
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|nodetype
operator|.
name|NodeTypeDefinition
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|nodetype
operator|.
name|PropertyDefinition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_comment
comment|/**  * A<code>NodeTypeDefDiff</code> represents the result of the comparison of  * two node type definitions.  *<p>  * The result of the comparison can be categorized as one of the following types:  *<p>  *<b><code>NONE</code></b> indicates that there is no modification at all.  *<p>  * A<b><code>TRIVIAL</code></b> modification has no impact on the consistency  * of existing content. The following modifications are considered  *<code>TRIVIAL</code>:  *<ul>  *<li>changing node type<code>orderableChildNodes</code> flag  *<li>changing node type<code>primaryItemName</code> value  *<li>adding non-<code>mandatory</code> property/child node  *<li>changing property/child node<code>protected</code> flag  *<li>changing property/child node<code>onParentVersion</code> value  *<li>changing property/child node<code>mandatory</code> flag to<code>false</code>  *<li>changing property/child node<code>autoCreated</code> flag  *<li>changing specific property/child node<code>name</code> to<code>*</code>  *<li>changing child node<code>defaultPrimaryType</code>  *<li>changing child node<code>sameNameSiblings</code> flag to<code>true</code>  *<li>weaken child node<code>requiredPrimaryTypes</code> (e.g. by removing)  *<li>weaken property<code>valueConstraints</code> (e.g. by removing a constraint  * or by making a specific constraint less restrictive)  *<li>changing property<code>defaultValues</code>  *<li>changing specific property<code>requiredType</code> to<code>undefined</code>  *<li>changing property<code>multiple</code> flag to<code>true</code>  *</ul>  *<p>  * A<b><code>MAJOR</code></b> modification potentially<i>affects</i> the  * consistency of existing content.  *  * All modifications that are not<b><code>TRIVIAL</code></b> are considered  *<b><code>MAJOR</code></b>.  *  *<p>  *<em>This class duplicates code from org.apache.jackrabbit.spi.commons.nodetype.NodeTypeDefDiff; both should be update in sync,  * see<a href="https://issues.apache.org/jira/browse/OAK-2802">OAK-2802</a></em>  */
end_comment

begin_class
specifier|public
class|class
name|NodeTypeDefDiff
block|{
comment|/**      * no modification      */
specifier|public
specifier|static
specifier|final
name|int
name|NONE
init|=
literal|0
decl_stmt|;
comment|/**      * trivial modification: does not affect consistency of existing content      */
specifier|public
specifier|static
specifier|final
name|int
name|TRIVIAL
init|=
literal|1
decl_stmt|;
comment|/**      * major modification:<i>does</i> affect consistency of existing content      */
specifier|public
specifier|static
specifier|final
name|int
name|MAJOR
init|=
literal|2
decl_stmt|;
specifier|private
specifier|final
name|NodeTypeDefinition
name|oldDef
decl_stmt|;
specifier|private
specifier|final
name|NodeTypeDefinition
name|newDef
decl_stmt|;
specifier|private
name|int
name|type
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|PropDefDiff
argument_list|>
name|propDefDiffs
init|=
operator|new
name|ArrayList
argument_list|<
name|PropDefDiff
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|ChildNodeDefDiff
argument_list|>
name|childNodeDefDiffs
init|=
operator|new
name|ArrayList
argument_list|<
name|ChildNodeDefDiff
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Constructor      * @param oldDef old definition      * @param newDef new definition      */
specifier|private
name|NodeTypeDefDiff
parameter_list|(
name|NodeTypeDefinition
name|oldDef
parameter_list|,
name|NodeTypeDefinition
name|newDef
parameter_list|)
block|{
name|this
operator|.
name|oldDef
operator|=
name|oldDef
expr_stmt|;
name|this
operator|.
name|newDef
operator|=
name|newDef
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
block|}
comment|/**      *      */
specifier|private
name|void
name|init
parameter_list|()
block|{
if|if
condition|(
name|oldDef
operator|.
name|equals
argument_list|(
name|newDef
argument_list|)
condition|)
block|{
comment|// definitions are identical
name|type
operator|=
name|NONE
expr_stmt|;
block|}
else|else
block|{
comment|// definitions are not identical, determine type of modification
comment|// assume TRIVIAL change by default
name|type
operator|=
name|TRIVIAL
expr_stmt|;
comment|// check supertypes
name|int
name|tmpType
init|=
name|supertypesDiff
argument_list|()
decl_stmt|;
if|if
condition|(
name|tmpType
operator|>
name|type
condition|)
block|{
name|type
operator|=
name|tmpType
expr_stmt|;
block|}
comment|// check mixin flag (MAJOR modification)
name|tmpType
operator|=
name|mixinFlagDiff
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmpType
operator|>
name|type
condition|)
block|{
name|type
operator|=
name|tmpType
expr_stmt|;
block|}
comment|// check abstract flag (MAJOR modification)
name|tmpType
operator|=
name|abstractFlagDiff
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmpType
operator|>
name|type
condition|)
block|{
name|type
operator|=
name|tmpType
expr_stmt|;
block|}
comment|// no need to check orderableChildNodes flag (TRIVIAL modification)
comment|// no need to check queryable flag (TRIVIAL modification)
comment|// check property definitions
name|tmpType
operator|=
name|buildPropDefDiffs
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmpType
operator|>
name|type
condition|)
block|{
name|type
operator|=
name|tmpType
expr_stmt|;
block|}
comment|// check child node definitions
name|tmpType
operator|=
name|buildChildNodeDefDiffs
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmpType
operator|>
name|type
condition|)
block|{
name|type
operator|=
name|tmpType
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @param oldDef old definition      * @param newDef new definition      * @return the diff      */
specifier|public
specifier|static
name|NodeTypeDefDiff
name|create
parameter_list|(
name|NodeTypeDefinition
name|oldDef
parameter_list|,
name|NodeTypeDefinition
name|newDef
parameter_list|)
block|{
if|if
condition|(
name|oldDef
operator|==
literal|null
operator|||
name|newDef
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"arguments can not be null"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|oldDef
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|newDef
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"at least node type names must be matching"
argument_list|)
throw|;
block|}
return|return
operator|new
name|NodeTypeDefDiff
argument_list|(
name|oldDef
argument_list|,
name|newDef
argument_list|)
return|;
block|}
comment|/**      * @return<code>true</code> if modified      */
specifier|public
name|boolean
name|isModified
parameter_list|()
block|{
return|return
name|type
operator|!=
name|NONE
return|;
block|}
comment|/**      * @return<code>true</code> if trivial      */
specifier|public
name|boolean
name|isTrivial
parameter_list|()
block|{
return|return
name|type
operator|==
name|TRIVIAL
return|;
block|}
comment|/**      * @return<code>true</code> if major      */
specifier|public
name|boolean
name|isMajor
parameter_list|()
block|{
return|return
name|type
operator|==
name|MAJOR
return|;
block|}
comment|/**      * Returns the type of modification as expressed by the following constants:      *<ul>      *<li><b><code>NONE</code></b>: no modification at all      *<li><b><code>TRIVIAL</code></b>: does not affect consistency of      * existing content      *<li><b><code>MAJOR</code></b>:<i>does</i> affect consistency of existing      * content      *</ul>      *      * @return the type of modification      */
specifier|public
name|int
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
comment|/**      * @return<code>true</code> if mixin flag diff      */
specifier|public
name|int
name|mixinFlagDiff
parameter_list|()
block|{
return|return
name|oldDef
operator|.
name|isMixin
argument_list|()
operator|!=
name|newDef
operator|.
name|isMixin
argument_list|()
condition|?
name|MAJOR
else|:
name|NONE
return|;
block|}
comment|/**      * @return<code>true</code> if abstract flag diff      */
specifier|public
name|int
name|abstractFlagDiff
parameter_list|()
block|{
return|return
name|oldDef
operator|.
name|isAbstract
argument_list|()
operator|&&
operator|!
name|newDef
operator|.
name|isAbstract
argument_list|()
condition|?
name|MAJOR
else|:
name|NONE
return|;
block|}
comment|/**      * @return<code>true</code> if supertypes diff      */
specifier|public
name|int
name|supertypesDiff
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set1
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|oldDef
operator|.
name|getDeclaredSupertypeNames
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|set2
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|newDef
operator|.
name|getDeclaredSupertypeNames
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|!
name|set1
operator|.
name|equals
argument_list|(
name|set2
argument_list|)
condition|?
name|MAJOR
else|:
name|NONE
return|;
block|}
comment|/**      * @return diff type      */
specifier|private
name|int
name|buildPropDefDiffs
parameter_list|()
block|{
name|int
name|maxType
init|=
name|NONE
decl_stmt|;
name|Map
argument_list|<
name|PropertyDefinitionId
argument_list|,
name|PropertyDefinition
argument_list|>
name|oldDefs
init|=
operator|new
name|HashMap
argument_list|<
name|PropertyDefinitionId
argument_list|,
name|PropertyDefinition
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|PropertyDefinition
name|def
range|:
name|oldDef
operator|.
name|getDeclaredPropertyDefinitions
argument_list|()
control|)
block|{
name|oldDefs
operator|.
name|put
argument_list|(
operator|new
name|PropertyDefinitionId
argument_list|(
name|def
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|PropertyDefinitionId
argument_list|,
name|PropertyDefinition
argument_list|>
name|newDefs
init|=
operator|new
name|HashMap
argument_list|<
name|PropertyDefinitionId
argument_list|,
name|PropertyDefinition
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|PropertyDefinition
name|def
range|:
name|newDef
operator|.
name|getDeclaredPropertyDefinitions
argument_list|()
control|)
block|{
name|newDefs
operator|.
name|put
argument_list|(
operator|new
name|PropertyDefinitionId
argument_list|(
name|def
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
comment|/**          * walk through defs1 and process all entries found in          * both defs1& defs2 and those found only in defs1          */
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|PropertyDefinitionId
argument_list|,
name|PropertyDefinition
argument_list|>
name|entry
range|:
name|oldDefs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|PropertyDefinitionId
name|id
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|PropertyDefinition
name|def1
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|PropertyDefinition
name|def2
init|=
name|newDefs
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|PropDefDiff
name|diff
init|=
operator|new
name|PropDefDiff
argument_list|(
name|def1
argument_list|,
name|def2
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|.
name|getType
argument_list|()
operator|>
name|maxType
condition|)
block|{
name|maxType
operator|=
name|diff
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
name|propDefDiffs
operator|.
name|add
argument_list|(
name|diff
argument_list|)
expr_stmt|;
name|newDefs
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
comment|/**          * defs2 by now only contains entries found in defs2 only;          * walk through defs2 and process all remaining entries          */
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|PropertyDefinitionId
argument_list|,
name|PropertyDefinition
argument_list|>
name|entry
range|:
name|newDefs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|PropertyDefinition
name|def
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|PropDefDiff
name|diff
init|=
operator|new
name|PropDefDiff
argument_list|(
literal|null
argument_list|,
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|.
name|getType
argument_list|()
operator|>
name|maxType
condition|)
block|{
name|maxType
operator|=
name|diff
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
name|propDefDiffs
operator|.
name|add
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
return|return
name|maxType
return|;
block|}
comment|/**      * @return diff type      */
specifier|private
name|int
name|buildChildNodeDefDiffs
parameter_list|()
block|{
name|int
name|maxType
init|=
name|NONE
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|NodeDefinitionId
argument_list|,
name|List
argument_list|<
name|NodeDefinition
argument_list|>
argument_list|>
name|oldDefs
init|=
name|collectChildNodeDefs
argument_list|(
name|oldDef
operator|.
name|getDeclaredChildNodeDefinitions
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|NodeDefinitionId
argument_list|,
name|List
argument_list|<
name|NodeDefinition
argument_list|>
argument_list|>
name|newDefs
init|=
name|collectChildNodeDefs
argument_list|(
name|newDef
operator|.
name|getDeclaredChildNodeDefinitions
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|NodeDefinitionId
name|defId
range|:
name|oldDefs
operator|.
name|keySet
argument_list|()
control|)
block|{
specifier|final
name|ChildNodeDefDiffs
name|childNodeDefDiffs
init|=
operator|new
name|ChildNodeDefDiffs
argument_list|(
name|oldDefs
operator|.
name|get
argument_list|(
name|defId
argument_list|)
argument_list|,
name|newDefs
operator|.
name|get
argument_list|(
name|defId
argument_list|)
argument_list|)
decl_stmt|;
name|this
operator|.
name|childNodeDefDiffs
operator|.
name|addAll
argument_list|(
name|childNodeDefDiffs
operator|.
name|getChildNodeDefDiffs
argument_list|()
argument_list|)
expr_stmt|;
name|newDefs
operator|.
name|remove
argument_list|(
name|defId
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|NodeDefinitionId
name|defId
range|:
name|newDefs
operator|.
name|keySet
argument_list|()
control|)
block|{
specifier|final
name|ChildNodeDefDiffs
name|childNodeDefDiffs
init|=
operator|new
name|ChildNodeDefDiffs
argument_list|(
literal|null
argument_list|,
name|newDefs
operator|.
name|get
argument_list|(
name|defId
argument_list|)
argument_list|)
decl_stmt|;
name|this
operator|.
name|childNodeDefDiffs
operator|.
name|addAll
argument_list|(
name|childNodeDefDiffs
operator|.
name|getChildNodeDefDiffs
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ChildNodeDefDiff
name|diff
range|:
name|childNodeDefDiffs
control|)
block|{
if|if
condition|(
name|diff
operator|.
name|getType
argument_list|()
operator|>
name|maxType
condition|)
block|{
name|maxType
operator|=
name|diff
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|maxType
return|;
block|}
specifier|private
name|Map
argument_list|<
name|NodeDefinitionId
argument_list|,
name|List
argument_list|<
name|NodeDefinition
argument_list|>
argument_list|>
name|collectChildNodeDefs
parameter_list|(
specifier|final
name|NodeDefinition
index|[]
name|cnda1
parameter_list|)
block|{
name|Map
argument_list|<
name|NodeDefinitionId
argument_list|,
name|List
argument_list|<
name|NodeDefinition
argument_list|>
argument_list|>
name|defs1
init|=
operator|new
name|HashMap
argument_list|<
name|NodeDefinitionId
argument_list|,
name|List
argument_list|<
name|NodeDefinition
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|NodeDefinition
name|def1
range|:
name|cnda1
control|)
block|{
specifier|final
name|NodeDefinitionId
name|def1Id
init|=
operator|new
name|NodeDefinitionId
argument_list|(
name|def1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|NodeDefinition
argument_list|>
name|list
init|=
name|defs1
operator|.
name|get
argument_list|(
name|def1Id
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|list
operator|=
operator|new
name|ArrayList
argument_list|<
name|NodeDefinition
argument_list|>
argument_list|()
expr_stmt|;
name|defs1
operator|.
name|put
argument_list|(
name|def1Id
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|def1
argument_list|)
expr_stmt|;
block|}
return|return
name|defs1
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|result
init|=
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"[\n\tnodeTypeName="
operator|+
name|oldDef
operator|.
name|getName
argument_list|()
decl_stmt|;
name|result
operator|+=
literal|",\n\tmixinFlagDiff="
operator|+
name|modificationTypeToString
argument_list|(
name|mixinFlagDiff
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|+=
literal|",\n\tsupertypesDiff="
operator|+
name|modificationTypeToString
argument_list|(
name|supertypesDiff
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|+=
literal|",\n\tpropertyDifferences=[\n"
expr_stmt|;
name|result
operator|+=
name|toString
argument_list|(
name|propDefDiffs
argument_list|)
expr_stmt|;
name|result
operator|+=
literal|"\t]"
expr_stmt|;
name|result
operator|+=
literal|",\n\tchildNodeDifferences=[\n"
expr_stmt|;
name|result
operator|+=
name|toString
argument_list|(
name|childNodeDefDiffs
argument_list|)
expr_stmt|;
name|result
operator|+=
literal|"\t]\n"
expr_stmt|;
name|result
operator|+=
literal|"]\n"
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|String
name|toString
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|ChildItemDefDiff
argument_list|>
name|childItemDefDiffs
parameter_list|)
block|{
name|String
name|result
init|=
literal|""
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
extends|extends
name|ChildItemDefDiff
argument_list|>
name|iter
init|=
name|childItemDefDiffs
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ChildItemDefDiff
name|propDefDiff
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|result
operator|+=
literal|"\t\t"
operator|+
name|propDefDiff
expr_stmt|;
if|if
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|result
operator|+=
literal|","
expr_stmt|;
block|}
name|result
operator|+=
literal|"\n"
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|String
name|modificationTypeToString
parameter_list|(
name|int
name|modificationType
parameter_list|)
block|{
name|String
name|typeString
init|=
literal|"unknown"
decl_stmt|;
switch|switch
condition|(
name|modificationType
condition|)
block|{
case|case
name|NONE
case|:
name|typeString
operator|=
literal|"NONE"
expr_stmt|;
break|break;
case|case
name|TRIVIAL
case|:
name|typeString
operator|=
literal|"TRIVIAL"
expr_stmt|;
break|break;
case|case
name|MAJOR
case|:
name|typeString
operator|=
literal|"MAJOR"
expr_stmt|;
break|break;
block|}
return|return
name|typeString
return|;
block|}
comment|//--------------------------------------------------------< inner classes>
specifier|abstract
class|class
name|ChildItemDefDiff
block|{
specifier|protected
specifier|final
name|ItemDefinition
name|oldDef
decl_stmt|;
specifier|protected
specifier|final
name|ItemDefinition
name|newDef
decl_stmt|;
specifier|protected
name|int
name|type
decl_stmt|;
name|ChildItemDefDiff
parameter_list|(
name|ItemDefinition
name|oldDef
parameter_list|,
name|ItemDefinition
name|newDef
parameter_list|)
block|{
name|this
operator|.
name|oldDef
operator|=
name|oldDef
expr_stmt|;
name|this
operator|.
name|newDef
operator|=
name|newDef
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|void
name|init
parameter_list|()
block|{
comment|// determine type of modification
if|if
condition|(
name|isAdded
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|newDef
operator|.
name|isMandatory
argument_list|()
condition|)
block|{
comment|// adding a non-mandatory child item is a TRIVIAL change
name|type
operator|=
name|TRIVIAL
expr_stmt|;
block|}
else|else
block|{
comment|// adding a mandatory child item is a MAJOR change
name|type
operator|=
name|MAJOR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isRemoved
argument_list|()
condition|)
block|{
comment|// removing a child item is a MAJOR change
name|type
operator|=
name|MAJOR
expr_stmt|;
block|}
else|else
block|{
comment|/**                  * neither added nor removed => has to be either identical                  * or modified                  */
if|if
condition|(
name|oldDef
operator|.
name|equals
argument_list|(
name|newDef
argument_list|)
condition|)
block|{
comment|// identical
name|type
operator|=
name|NONE
expr_stmt|;
block|}
else|else
block|{
comment|// modified
if|if
condition|(
name|oldDef
operator|.
name|isMandatory
argument_list|()
operator|!=
name|newDef
operator|.
name|isMandatory
argument_list|()
operator|&&
name|newDef
operator|.
name|isMandatory
argument_list|()
condition|)
block|{
comment|// making a child item mandatory is a MAJOR change
name|type
operator|=
name|MAJOR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
literal|"*"
operator|.
name|equals
argument_list|(
name|oldDef
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
literal|"*"
operator|.
name|equals
argument_list|(
name|newDef
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// just making a child item residual is a TRIVIAL change
name|type
operator|=
name|TRIVIAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|oldDef
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|newDef
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// changing the name of a child item is a MAJOR change
name|type
operator|=
name|MAJOR
expr_stmt|;
block|}
else|else
block|{
comment|// all other changes are TRIVIAL
name|type
operator|=
name|TRIVIAL
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
specifier|public
name|int
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
specifier|public
name|boolean
name|isAdded
parameter_list|()
block|{
return|return
name|oldDef
operator|==
literal|null
operator|&&
name|newDef
operator|!=
literal|null
return|;
block|}
specifier|public
name|boolean
name|isRemoved
parameter_list|()
block|{
return|return
name|oldDef
operator|!=
literal|null
operator|&&
name|newDef
operator|==
literal|null
return|;
block|}
specifier|public
name|boolean
name|isModified
parameter_list|()
block|{
return|return
name|oldDef
operator|!=
literal|null
operator|&&
name|newDef
operator|!=
literal|null
operator|&&
operator|!
name|oldDef
operator|.
name|equals
argument_list|(
name|newDef
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|typeString
init|=
name|modificationTypeToString
argument_list|(
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|operationString
decl_stmt|;
if|if
condition|(
name|isAdded
argument_list|()
condition|)
block|{
name|operationString
operator|=
literal|"ADDED"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isModified
argument_list|()
condition|)
block|{
name|operationString
operator|=
literal|"MODIFIED"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isRemoved
argument_list|()
condition|)
block|{
name|operationString
operator|=
literal|"REMOVED"
expr_stmt|;
block|}
else|else
block|{
name|operationString
operator|=
literal|"NONE"
expr_stmt|;
block|}
name|ItemDefinition
name|itemDefinition
init|=
operator|(
name|oldDef
operator|!=
literal|null
operator|)
condition|?
name|oldDef
else|:
name|newDef
decl_stmt|;
return|return
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"[itemName="
operator|+
name|itemDefinition
operator|.
name|getName
argument_list|()
operator|+
literal|", type="
operator|+
name|typeString
operator|+
literal|", operation="
operator|+
name|operationString
operator|+
literal|"]"
return|;
block|}
block|}
specifier|public
class|class
name|PropDefDiff
extends|extends
name|ChildItemDefDiff
block|{
name|PropDefDiff
parameter_list|(
name|PropertyDefinition
name|oldDef
parameter_list|,
name|PropertyDefinition
name|newDef
parameter_list|)
block|{
name|super
argument_list|(
name|oldDef
argument_list|,
name|newDef
argument_list|)
expr_stmt|;
block|}
specifier|public
name|PropertyDefinition
name|getOldDef
parameter_list|()
block|{
return|return
operator|(
name|PropertyDefinition
operator|)
name|oldDef
return|;
block|}
specifier|public
name|PropertyDefinition
name|getNewDef
parameter_list|()
block|{
return|return
operator|(
name|PropertyDefinition
operator|)
name|newDef
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|init
parameter_list|()
block|{
name|super
operator|.
name|init
argument_list|()
expr_stmt|;
comment|/**              * only need to do comparison if base class implementation              * detected a non-MAJOR (i.e. TRIVIAL) modification;              * no need to check for additions or removals as this is already              * handled in base class implementation.              */
if|if
condition|(
name|isModified
argument_list|()
operator|&&
name|type
operator|==
name|TRIVIAL
condition|)
block|{
comment|// check if valueConstraints were made more restrictive
name|String
index|[]
name|vca1
init|=
name|getOldDef
argument_list|()
operator|.
name|getValueConstraints
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|set1
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|aVca1
range|:
name|vca1
control|)
block|{
name|set1
operator|.
name|add
argument_list|(
name|aVca1
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|vca2
init|=
name|getNewDef
argument_list|()
operator|.
name|getValueConstraints
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|set2
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|aVca2
range|:
name|vca2
control|)
block|{
name|set2
operator|.
name|add
argument_list|(
name|aVca2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|set1
operator|.
name|equals
argument_list|(
name|set2
argument_list|)
condition|)
block|{
comment|// valueConstraints have been modified
if|if
condition|(
name|set2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// all existing constraints have been cleared
comment|// => TRIVIAL change
name|type
operator|=
name|TRIVIAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// constraints have been set on a previously unconstrained property
comment|// => MAJOR change
name|type
operator|=
name|MAJOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set2
operator|.
name|containsAll
argument_list|(
name|set1
argument_list|)
condition|)
block|{
comment|// new set is a superset of old set,
comment|// i.e. constraints have been weakened
comment|// (since constraints are OR'ed)
comment|// => TRIVIAL change
name|type
operator|=
name|TRIVIAL
expr_stmt|;
block|}
else|else
block|{
comment|// constraint have been removed/modified (MAJOR change);
comment|// since we're unable to semantically compare
comment|// value constraints (e.g. regular expressions), all
comment|// such modifications are considered a MAJOR change.
name|type
operator|=
name|MAJOR
expr_stmt|;
block|}
block|}
comment|// no need to check defaultValues (TRIVIAL change)
comment|// no need to check availableQueryOperators (TRIVIAL change)
comment|// no need to check queryOrderable (TRIVIAL change)
if|if
condition|(
name|type
operator|==
name|TRIVIAL
condition|)
block|{
name|int
name|t1
init|=
name|getOldDef
argument_list|()
operator|.
name|getRequiredType
argument_list|()
decl_stmt|;
name|int
name|t2
init|=
name|getNewDef
argument_list|()
operator|.
name|getRequiredType
argument_list|()
decl_stmt|;
if|if
condition|(
name|t1
operator|!=
name|t2
condition|)
block|{
if|if
condition|(
name|t2
operator|==
name|PropertyType
operator|.
name|UNDEFINED
condition|)
block|{
comment|// changed getRequiredType to UNDEFINED (TRIVIAL change)
name|type
operator|=
name|TRIVIAL
expr_stmt|;
block|}
else|else
block|{
comment|// changed getRequiredType to specific type (MAJOR change)
name|type
operator|=
name|MAJOR
expr_stmt|;
block|}
block|}
name|boolean
name|b1
init|=
name|getOldDef
argument_list|()
operator|.
name|isMultiple
argument_list|()
decl_stmt|;
name|boolean
name|b2
init|=
name|getNewDef
argument_list|()
operator|.
name|isMultiple
argument_list|()
decl_stmt|;
if|if
condition|(
name|b1
operator|!=
name|b2
condition|)
block|{
if|if
condition|(
name|b2
condition|)
block|{
comment|// changed multiple flag to true (TRIVIAL change)
name|type
operator|=
name|TRIVIAL
expr_stmt|;
block|}
else|else
block|{
comment|// changed multiple flag to false (MAJOR change)
name|type
operator|=
name|MAJOR
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
specifier|public
class|class
name|ChildNodeDefDiff
extends|extends
name|ChildItemDefDiff
block|{
name|ChildNodeDefDiff
parameter_list|(
name|NodeDefinition
name|oldDef
parameter_list|,
name|NodeDefinition
name|newDef
parameter_list|)
block|{
name|super
argument_list|(
name|oldDef
argument_list|,
name|newDef
argument_list|)
expr_stmt|;
block|}
specifier|public
name|NodeDefinition
name|getOldDef
parameter_list|()
block|{
return|return
operator|(
name|NodeDefinition
operator|)
name|oldDef
return|;
block|}
specifier|public
name|NodeDefinition
name|getNewDef
parameter_list|()
block|{
return|return
operator|(
name|NodeDefinition
operator|)
name|newDef
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|init
parameter_list|()
block|{
name|super
operator|.
name|init
argument_list|()
expr_stmt|;
comment|/**              * only need to do comparison if base class implementation              * detected a non-MAJOR (i.e. TRIVIAL) modification;              * no need to check for additions or removals as this is already              * handled in base class implementation.              */
if|if
condition|(
name|isModified
argument_list|()
operator|&&
name|type
operator|==
name|TRIVIAL
condition|)
block|{
name|boolean
name|b1
init|=
name|getOldDef
argument_list|()
operator|.
name|allowsSameNameSiblings
argument_list|()
decl_stmt|;
name|boolean
name|b2
init|=
name|getNewDef
argument_list|()
operator|.
name|allowsSameNameSiblings
argument_list|()
decl_stmt|;
if|if
condition|(
name|b1
operator|!=
name|b2
operator|&&
operator|!
name|b2
condition|)
block|{
comment|// changed sameNameSiblings flag to false (MAJOR change)
name|type
operator|=
name|MAJOR
expr_stmt|;
block|}
comment|// no need to check defaultPrimaryType (TRIVIAL change)
if|if
condition|(
name|type
operator|==
name|TRIVIAL
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|s1
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|getOldDef
argument_list|()
operator|.
name|getRequiredPrimaryTypeNames
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|s2
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|getNewDef
argument_list|()
operator|.
name|getRequiredPrimaryTypeNames
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// normalize sets by removing nt:base (adding/removing nt:base is irrelevant for the diff)
name|s1
operator|.
name|remove
argument_list|(
literal|"nt:base"
argument_list|)
expr_stmt|;
name|s2
operator|.
name|remove
argument_list|(
literal|"nt:base"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s1
operator|.
name|equals
argument_list|(
name|s2
argument_list|)
condition|)
block|{
comment|// requiredPrimaryTypes have been modified
if|if
condition|(
name|s1
operator|.
name|containsAll
argument_list|(
name|s2
argument_list|)
condition|)
block|{
comment|// old list is a superset of new list
comment|// => removed requiredPrimaryType (TRIVIAL change)
name|type
operator|=
name|TRIVIAL
expr_stmt|;
block|}
else|else
block|{
comment|// added/modified requiredPrimaryType (MAJOR change)
comment|// todo check whether aggregate of old requiredTypes would include aggregate of new requiredTypes => trivial change
name|type
operator|=
name|MAJOR
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**      * Identifier used to identify corresponding property definitions      */
specifier|static
class|class
name|PropertyDefinitionId
block|{
name|String
name|declaringNodeType
decl_stmt|;
name|String
name|name
decl_stmt|;
name|boolean
name|definesResidual
decl_stmt|;
name|PropertyDefinitionId
parameter_list|(
name|PropertyDefinition
name|def
parameter_list|)
block|{
name|declaringNodeType
operator|=
name|def
operator|.
name|getDeclaringNodeType
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|name
operator|=
name|def
operator|.
name|getName
argument_list|()
expr_stmt|;
name|definesResidual
operator|=
literal|"*"
operator|.
name|equals
argument_list|(
name|def
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//---------------------------------------< java.lang.Object overrides>
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|instanceof
name|PropertyDefinitionId
condition|)
block|{
name|PropertyDefinitionId
name|other
init|=
operator|(
name|PropertyDefinitionId
operator|)
name|obj
decl_stmt|;
return|return
name|declaringNodeType
operator|.
name|equals
argument_list|(
name|other
operator|.
name|declaringNodeType
argument_list|)
operator|&&
name|name
operator|.
name|equals
argument_list|(
name|other
operator|.
name|name
argument_list|)
operator|&&
name|definesResidual
operator|==
name|other
operator|.
name|definesResidual
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
literal|17
decl_stmt|;
name|h
operator|=
literal|37
operator|*
name|h
operator|+
name|declaringNodeType
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|h
operator|=
literal|37
operator|*
name|h
operator|+
name|name
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|h
operator|=
literal|37
operator|*
name|h
operator|+
operator|(
name|definesResidual
condition|?
literal|11
else|:
literal|43
operator|)
expr_stmt|;
return|return
name|h
return|;
block|}
block|}
comment|/**      * Identifier used to identify corresponding node definitions      */
specifier|static
class|class
name|NodeDefinitionId
block|{
name|String
name|declaringNodeType
decl_stmt|;
name|String
name|name
decl_stmt|;
name|NodeDefinitionId
parameter_list|(
name|NodeDefinition
name|def
parameter_list|)
block|{
name|declaringNodeType
operator|=
name|def
operator|.
name|getDeclaringNodeType
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|name
operator|=
name|def
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
comment|//---------------------------------------< java.lang.Object overrides>
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|instanceof
name|NodeDefinitionId
condition|)
block|{
name|NodeDefinitionId
name|other
init|=
operator|(
name|NodeDefinitionId
operator|)
name|obj
decl_stmt|;
return|return
name|declaringNodeType
operator|.
name|equals
argument_list|(
name|other
operator|.
name|declaringNodeType
argument_list|)
operator|&&
name|name
operator|.
name|equals
argument_list|(
name|other
operator|.
name|name
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
literal|17
decl_stmt|;
name|h
operator|=
literal|37
operator|*
name|h
operator|+
name|declaringNodeType
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|h
operator|=
literal|37
operator|*
name|h
operator|+
name|name
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|h
return|;
block|}
block|}
specifier|private
class|class
name|ChildNodeDefDiffs
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|NodeDefinition
argument_list|>
name|defs1
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|NodeDefinition
argument_list|>
name|defs2
decl_stmt|;
specifier|private
name|ChildNodeDefDiffs
parameter_list|(
specifier|final
name|List
argument_list|<
name|NodeDefinition
argument_list|>
name|defs1
parameter_list|,
specifier|final
name|List
argument_list|<
name|NodeDefinition
argument_list|>
name|defs2
parameter_list|)
block|{
name|this
operator|.
name|defs1
operator|=
name|defs1
operator|!=
literal|null
condition|?
name|defs1
else|:
name|Collections
operator|.
expr|<
name|NodeDefinition
operator|>
name|emptyList
argument_list|()
expr_stmt|;
name|this
operator|.
name|defs2
operator|=
name|defs2
operator|!=
literal|null
condition|?
name|defs2
else|:
name|Collections
operator|.
expr|<
name|NodeDefinition
operator|>
name|emptyList
argument_list|()
expr_stmt|;
block|}
specifier|private
name|Collection
argument_list|<
name|ChildNodeDefDiff
argument_list|>
name|getChildNodeDefDiffs
parameter_list|()
block|{
comment|// gather all possible combinations of diffs
specifier|final
name|List
argument_list|<
name|ChildNodeDefDiff
argument_list|>
name|diffs
init|=
operator|new
name|ArrayList
argument_list|<
name|ChildNodeDefDiff
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|NodeDefinition
name|def1
range|:
name|defs1
control|)
block|{
for|for
control|(
name|NodeDefinition
name|def2
range|:
name|defs2
control|)
block|{
name|diffs
operator|.
name|add
argument_list|(
operator|new
name|ChildNodeDefDiff
argument_list|(
name|def1
argument_list|,
name|def2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|defs2
operator|.
name|size
argument_list|()
operator|<
name|defs1
operator|.
name|size
argument_list|()
condition|)
block|{
for|for
control|(
name|NodeDefinition
name|def1
range|:
name|defs1
control|)
block|{
name|diffs
operator|.
name|add
argument_list|(
operator|new
name|ChildNodeDefDiff
argument_list|(
name|def1
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|defs1
operator|.
name|size
argument_list|()
operator|<
name|defs2
operator|.
name|size
argument_list|()
condition|)
block|{
for|for
control|(
name|NodeDefinition
name|def2
range|:
name|defs2
control|)
block|{
name|diffs
operator|.
name|add
argument_list|(
operator|new
name|ChildNodeDefDiff
argument_list|(
literal|null
argument_list|,
name|def2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// sort them according to decreasing compatibility
name|Collections
operator|.
name|sort
argument_list|(
name|diffs
argument_list|,
operator|new
name|Comparator
argument_list|<
name|ChildNodeDefDiff
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
specifier|final
name|ChildNodeDefDiff
name|o1
parameter_list|,
specifier|final
name|ChildNodeDefDiff
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|getType
argument_list|()
operator|-
name|o2
operator|.
name|getType
argument_list|()
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// select the most compatible ones
specifier|final
name|int
name|size
init|=
name|defs1
operator|.
name|size
argument_list|()
operator|>
name|defs2
operator|.
name|size
argument_list|()
condition|?
name|defs1
operator|.
name|size
argument_list|()
else|:
name|defs2
operator|.
name|size
argument_list|()
decl_stmt|;
name|AtomicInteger
name|allowedNewNull
init|=
operator|new
name|AtomicInteger
argument_list|(
name|defs1
operator|.
name|size
argument_list|()
operator|-
name|defs2
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|AtomicInteger
name|allowedOldNull
init|=
operator|new
name|AtomicInteger
argument_list|(
name|defs2
operator|.
name|size
argument_list|()
operator|-
name|defs1
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ChildNodeDefDiff
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|ChildNodeDefDiff
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ChildNodeDefDiff
name|diff
range|:
name|diffs
control|)
block|{
if|if
condition|(
operator|!
name|alreadyMatched
argument_list|(
name|results
argument_list|,
name|diff
operator|.
name|getNewDef
argument_list|()
argument_list|,
name|diff
operator|.
name|getOldDef
argument_list|()
argument_list|,
name|allowedNewNull
argument_list|,
name|allowedOldNull
argument_list|)
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|.
name|getNewDef
argument_list|()
operator|==
literal|null
condition|)
block|{
name|allowedNewNull
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|diff
operator|.
name|getOldDef
argument_list|()
operator|==
literal|null
condition|)
block|{
name|allowedOldNull
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|results
operator|.
name|size
argument_list|()
operator|==
name|size
condition|)
block|{
break|break;
block|}
block|}
return|return
name|results
return|;
block|}
specifier|private
name|boolean
name|alreadyMatched
parameter_list|(
specifier|final
name|List
argument_list|<
name|ChildNodeDefDiff
argument_list|>
name|result
parameter_list|,
specifier|final
name|NodeDefinition
name|newDef
parameter_list|,
specifier|final
name|NodeDefinition
name|oldDef
parameter_list|,
specifier|final
name|AtomicInteger
name|allowedNewNull
parameter_list|,
specifier|final
name|AtomicInteger
name|allowedOldNull
parameter_list|)
block|{
name|boolean
name|containsNewDef
init|=
literal|false
decl_stmt|,
name|containsOldDef
init|=
literal|false
decl_stmt|;
for|for
control|(
name|ChildNodeDefDiff
name|d
range|:
name|result
control|)
block|{
if|if
condition|(
name|d
operator|.
name|getNewDef
argument_list|()
operator|!=
literal|null
operator|&&
name|d
operator|.
name|getNewDef
argument_list|()
operator|.
name|equals
argument_list|(
name|newDef
argument_list|)
condition|)
block|{
name|containsNewDef
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|d
operator|.
name|getOldDef
argument_list|()
operator|!=
literal|null
operator|&&
name|d
operator|.
name|getOldDef
argument_list|()
operator|.
name|equals
argument_list|(
name|oldDef
argument_list|)
condition|)
block|{
name|containsOldDef
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|oldDef
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|allowedOldNull
operator|.
name|get
argument_list|()
operator|<
literal|1
condition|)
block|{
name|containsOldDef
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newDef
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|allowedNewNull
operator|.
name|get
argument_list|()
operator|<
literal|1
condition|)
block|{
name|containsNewDef
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|containsNewDef
operator|||
name|containsOldDef
return|;
block|}
block|}
block|}
end_class

end_unit

