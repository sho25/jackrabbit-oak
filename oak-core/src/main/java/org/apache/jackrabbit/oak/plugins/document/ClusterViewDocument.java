begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
package|;
end_package

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|json
operator|.
name|JsopBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Represents the document stored in the settings collection containing a  * 'cluster view'.  *<p>  * A 'cluster view' is the state of the membership of instances that are or have  * all been connected to the same oak repository. The 'cluster view' is  * maintained by all instances in the cluster concurrently - the faster one  * wins. Its information is derived from the clusterNodes collection. From there  * the following three states are derived and instances are grouped into these:  *<ul>  *<li>Active: an instance is active and has no recoveryLock is currently  * acquired. The lease timeout is ignored. When the lease times out, this is  * noticed by one of the instances at some point and a recovery is started, at  * which point the instance transitions from 'Active' to 'Recovering'.</li>  *<li>Recovering: an instance that was active but currently has the  * recoveryLock acquired by one of the instances.</li>  *<li>Inactive: an instance is not set to active (in which case the  * recoveryLock is never set)</li>  *</ul>  *<p>  * Note that the states managed in this ClusterViewDocument differs from the one  * from ClusterView - since ClusterView also manages the fact that after a  * recovery of a crashed instance there could be a 'backlog' of changes which it  * doesn't yet see until a background read is performed.  */
end_comment

begin_class
class|class
name|ClusterViewDocument
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ClusterViewDocument
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** the id of this document is always 'clusterView' **/
specifier|private
specifier|static
specifier|final
name|String
name|CLUSTERVIEW_DOC_ID
init|=
literal|"clusterView"
decl_stmt|;
comment|// keys that we store in the root document - and in the history
comment|/**      * document key that stores the stable id of the cluster (will never change)      * (Note: a better term would have been just clusterId - but that one is      * already occupied with what should actually be called clusterNodeId or      * just nodeId)      **/
specifier|static
specifier|final
name|String
name|CLUSTER_VIEW_ID_KEY
init|=
literal|"clusterViewId"
decl_stmt|;
comment|/**      * document key that stores the monotonically incrementing sequence number      * of the cluster view. Any update will increase this by 1      **/
specifier|static
specifier|final
name|String
name|VIEW_SEQ_NUM_KEY
init|=
literal|"seqNum"
decl_stmt|;
comment|/**      * document key that stores the comma-separated list of active instance ids      **/
specifier|static
specifier|final
name|String
name|ACTIVE_KEY
init|=
literal|"active"
decl_stmt|;
comment|/**      * document key that stores the comma-separated list of inactive instance      * ids (they might still have a backlog, that is handled in ClusterView      * though, never persisted      */
specifier|static
specifier|final
name|String
name|INACTIVE_KEY
init|=
literal|"inactive"
decl_stmt|;
comment|/**      * document key that stores the comma-separated list of recovering instance      * ids      **/
specifier|static
specifier|final
name|String
name|RECOVERING_KEY
init|=
literal|"recovering"
decl_stmt|;
comment|/**      * document key that stores the date and time when this view was created -      * for debugging purpose only      **/
specifier|private
specifier|static
specifier|final
name|String
name|CREATED_KEY
init|=
literal|"created"
decl_stmt|;
comment|/**      * document key that stores the id of the instance that created this view -      * for debugging purpose only      **/
specifier|private
specifier|static
specifier|final
name|String
name|CREATOR_KEY
init|=
literal|"creator"
decl_stmt|;
comment|/**      * document key that stores the date and time when this was was retired -      * for debugging purpose only      **/
specifier|private
specifier|static
specifier|final
name|String
name|RETIRED_KEY
init|=
literal|"retired"
decl_stmt|;
comment|/**      * document key that stores the id of the instance that retired this view -      * for debugging purpose only      **/
specifier|private
specifier|static
specifier|final
name|String
name|RETIRER_KEY
init|=
literal|"retirer"
decl_stmt|;
comment|/**      * document key that stores a short, limited history of previous cluster      * views - for debugging purpose only      **/
specifier|private
specifier|static
specifier|final
name|String
name|CLUSTER_VIEW_HISTORY_KEY
init|=
literal|"clusterViewHistory"
decl_stmt|;
comment|/** the format used when storing date+time **/
specifier|private
specifier|static
specifier|final
name|DateFormat
name|standardDateFormat
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd'T'HH:mm:ss.SSSZ"
argument_list|)
decl_stmt|;
comment|/** number of elements kept in the CLUSTERVIEW_HISTORY_KEY field **/
specifier|private
specifier|static
specifier|final
name|int
name|HISTORY_LIMIT
init|=
literal|10
decl_stmt|;
comment|/** the monotonically incrementing sequence number of this cluster view **/
specifier|private
specifier|final
name|long
name|viewSeqNum
decl_stmt|;
comment|/** the stable id of this cluster **/
specifier|private
specifier|final
name|String
name|clusterViewId
decl_stmt|;
comment|/** the ids of instances that are active at this moment **/
specifier|private
specifier|final
name|Integer
index|[]
name|activeIds
decl_stmt|;
comment|/**      * the ids of instances that are recovering (lastRev-recovery) at this      * moment      **/
specifier|private
specifier|final
name|Integer
index|[]
name|recoveringIds
decl_stmt|;
comment|/** the ids of instances that are inactive at this moment **/
specifier|private
specifier|final
name|Integer
index|[]
name|inactiveIds
decl_stmt|;
comment|/**      * the short, limited history of previous cluster views, for debugging only      **/
specifier|private
specifier|final
name|Map
argument_list|<
name|Object
argument_list|,
name|String
argument_list|>
name|viewHistory
decl_stmt|;
comment|/** the date+time at which this view was created, for debugging only **/
specifier|private
specifier|final
name|String
name|createdAt
decl_stmt|;
comment|/** the id of the instance that created this view, for debugging only **/
specifier|private
specifier|final
name|Long
name|createdBy
decl_stmt|;
comment|/**      * Main method by which the ClusterViewDocument is updated in the settings      * collection      *       * @return the resulting ClusterViewDocument as just updated in the settings      *         collection - or null if another instance was updating the      *         clusterview concurrently (in which case the caller should re-read      *         first and possibly re-update if needed)      */
specifier|static
name|ClusterViewDocument
name|readOrUpdate
parameter_list|(
name|DocumentNodeStore
name|documentNodeStore
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|activeIds
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|recoveringIds
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|inactiveIds
parameter_list|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"readOrUpdate: expected: activeIds: {}, recoveringIds: {}, inactiveIds: {}"
argument_list|,
name|activeIds
argument_list|,
name|recoveringIds
argument_list|,
name|inactiveIds
argument_list|)
expr_stmt|;
if|if
condition|(
name|activeIds
operator|==
literal|null
operator|||
name|activeIds
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"readOrUpdate: activeIds must not be null or empty"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"activeIds must not be null or empty"
argument_list|)
throw|;
block|}
name|int
name|localClusterId
init|=
name|documentNodeStore
operator|.
name|getClusterId
argument_list|()
decl_stmt|;
specifier|final
name|ClusterViewDocument
name|previousView
init|=
name|doRead
argument_list|(
name|documentNodeStore
argument_list|)
decl_stmt|;
if|if
condition|(
name|previousView
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|previousView
operator|.
name|matches
argument_list|(
name|activeIds
argument_list|,
name|recoveringIds
argument_list|,
name|inactiveIds
argument_list|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"readOrUpdate: view unchanged, returning: {}"
argument_list|,
name|previousView
argument_list|)
expr_stmt|;
return|return
name|previousView
return|;
block|}
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"readOrUpdate: view change detected, going to update from {} to activeIds: {}, recoveringIds: {}, inactiveIds: {}"
argument_list|,
name|previousView
argument_list|,
name|activeIds
argument_list|,
name|recoveringIds
argument_list|,
name|inactiveIds
argument_list|)
expr_stmt|;
name|UpdateOp
name|updateOp
init|=
operator|new
name|UpdateOp
argument_list|(
name|CLUSTERVIEW_DOC_ID
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Date
name|now
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
name|updateOp
operator|.
name|set
argument_list|(
name|ACTIVE_KEY
argument_list|,
name|setToCsv
argument_list|(
name|activeIds
argument_list|)
argument_list|)
expr_stmt|;
name|updateOp
operator|.
name|set
argument_list|(
name|RECOVERING_KEY
argument_list|,
name|setToCsv
argument_list|(
name|recoveringIds
argument_list|)
argument_list|)
expr_stmt|;
name|updateOp
operator|.
name|set
argument_list|(
name|INACTIVE_KEY
argument_list|,
name|setToCsv
argument_list|(
name|inactiveIds
argument_list|)
argument_list|)
expr_stmt|;
name|updateOp
operator|.
name|set
argument_list|(
name|CREATED_KEY
argument_list|,
name|standardDateFormat
operator|.
name|format
argument_list|(
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|updateOp
operator|.
name|set
argument_list|(
name|CREATOR_KEY
argument_list|,
operator|(
name|long
operator|)
name|localClusterId
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|String
argument_list|>
name|historyMap
init|=
operator|new
name|HashMap
argument_list|<
name|Object
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|previousView
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|Object
argument_list|,
name|String
argument_list|>
name|previousHistory
init|=
name|previousView
operator|.
name|getHistory
argument_list|()
decl_stmt|;
if|if
condition|(
name|previousHistory
operator|!=
literal|null
condition|)
block|{
name|historyMap
operator|.
name|putAll
argument_list|(
name|previousHistory
argument_list|)
expr_stmt|;
block|}
name|historyMap
operator|.
name|put
argument_list|(
name|Revision
operator|.
name|newRevision
argument_list|(
name|localClusterId
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|asHistoryEntry
argument_list|(
name|previousView
argument_list|,
name|localClusterId
argument_list|,
name|now
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|applyHistoryLimit
argument_list|(
name|historyMap
argument_list|)
expr_stmt|;
name|updateOp
operator|.
name|set
argument_list|(
name|CLUSTER_VIEW_HISTORY_KEY
argument_list|,
name|historyMap
argument_list|)
expr_stmt|;
specifier|final
name|Long
name|newViewSeqNum
decl_stmt|;
if|if
condition|(
name|previousView
operator|==
literal|null
condition|)
block|{
comment|// we are the first ever, looks like, that the clusterview is
comment|// defined
comment|// so we can use viewId==1 and we make sure no other cluster node
comment|// tries to create this first one simultaneously - so we use
comment|// 'create'
comment|// going via 'create' requires ID to be set again (not only in new
comment|// UpdateOp(id,isNew)):
name|updateOp
operator|.
name|set
argument_list|(
name|Document
operator|.
name|ID
argument_list|,
name|CLUSTERVIEW_DOC_ID
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|UpdateOp
argument_list|>
name|updateOps
init|=
operator|new
name|ArrayList
argument_list|<
name|UpdateOp
argument_list|>
argument_list|()
decl_stmt|;
name|newViewSeqNum
operator|=
literal|1L
expr_stmt|;
name|updateOp
operator|.
name|setNew
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// paranoia as that's already set above
name|updateOp
operator|.
name|set
argument_list|(
name|VIEW_SEQ_NUM_KEY
argument_list|,
name|newViewSeqNum
argument_list|)
expr_stmt|;
comment|// first view ever => choose a new unique clusterViewId
name|String
name|clusterViewId
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|updateOp
operator|.
name|set
argument_list|(
name|CLUSTER_VIEW_ID_KEY
argument_list|,
name|clusterViewId
argument_list|)
expr_stmt|;
name|updateOps
operator|.
name|add
argument_list|(
name|updateOp
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"updateAndRead: trying to create the first ever clusterView - hence {}={} and {}={}"
argument_list|,
name|VIEW_SEQ_NUM_KEY
argument_list|,
name|newViewSeqNum
argument_list|,
name|CLUSTER_VIEW_ID_KEY
argument_list|,
name|clusterViewId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|documentNodeStore
operator|.
name|getDocumentStore
argument_list|()
operator|.
name|create
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|,
name|updateOps
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"updateAndRead: someone else just created the first view ever while I tried - reread that one later"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
comment|// there were earlier clusterViews (the normal case) - thus we
comment|// use 'findAndUpdate' with the condition that
comment|// the view id is still at the previousview one
name|Long
name|previousViewSeqNum
init|=
name|previousView
operator|.
name|getViewSeqNum
argument_list|()
decl_stmt|;
name|updateOp
operator|.
name|setNew
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// change to false from true above
name|updateOp
operator|.
name|equals
argument_list|(
name|VIEW_SEQ_NUM_KEY
argument_list|,
literal|null
argument_list|,
name|previousViewSeqNum
argument_list|)
expr_stmt|;
name|newViewSeqNum
operator|=
name|previousViewSeqNum
operator|+
literal|1
expr_stmt|;
name|updateOp
operator|.
name|set
argument_list|(
name|VIEW_SEQ_NUM_KEY
argument_list|,
name|newViewSeqNum
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"updateAndRead: trying to update the clusterView to {}={} "
argument_list|,
name|VIEW_SEQ_NUM_KEY
argument_list|,
name|newViewSeqNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|documentNodeStore
operator|.
name|getDocumentStore
argument_list|()
operator|.
name|findAndUpdate
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|,
name|updateOp
argument_list|)
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"updateAndRead: someone else just updated the view which I wanted to do as well - reread that one later"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|// whatever the outcome of the above - we don't care -
comment|// re-reading will in any case definitely show what has been persisted
comment|// and if the re-read view contains the same id, it is what we have
comment|// written
comment|// - otherwise someone else came in between and we have to step back and
comment|// retry
name|ClusterViewDocument
name|readResult
init|=
name|doRead
argument_list|(
name|documentNodeStore
argument_list|)
decl_stmt|;
if|if
condition|(
name|readResult
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"updateAndRead: got null from read - whatever the exact reason, we must retry in a moment."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|newViewSeqNum
operator|.
name|equals
argument_list|(
name|readResult
operator|.
name|getViewSeqNum
argument_list|()
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"updateAndRead: matching view - no change"
argument_list|)
expr_stmt|;
return|return
name|readResult
return|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"updateAndRead: someone else in the cluster was updating right after I also succeeded - re-read in a bit"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Pruning method that makes sure the history never gets larger than      * HISTORY_LIMIT      *       * @param historyMap      *            the pruning is done directly on this map      */
specifier|private
specifier|static
name|void
name|applyHistoryLimit
parameter_list|(
name|Map
argument_list|<
name|Object
argument_list|,
name|String
argument_list|>
name|historyMap
parameter_list|)
block|{
while|while
condition|(
name|historyMap
operator|.
name|size
argument_list|()
operator|>
name|HISTORY_LIMIT
condition|)
block|{
comment|// remove the oldest
name|String
name|oldestRevision
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|it
init|=
name|historyMap
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|obj
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// obj can be a String or a Revision
comment|// in case of it being a Revision the toString() will
comment|// be appropriate, hence:
name|String
name|r
init|=
name|obj
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldestRevision
operator|==
literal|null
condition|)
block|{
name|oldestRevision
operator|=
name|r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Revision
operator|.
name|getTimestampDifference
argument_list|(
name|Revision
operator|.
name|fromString
argument_list|(
name|r
argument_list|)
argument_list|,
name|Revision
operator|.
name|fromString
argument_list|(
name|oldestRevision
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oldestRevision
operator|=
name|r
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldestRevision
operator|==
literal|null
condition|)
block|{
break|break;
block|}
else|else
block|{
if|if
condition|(
name|historyMap
operator|.
name|remove
argument_list|(
name|oldestRevision
argument_list|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|historyMap
operator|.
name|remove
argument_list|(
name|Revision
operator|.
name|fromString
argument_list|(
name|oldestRevision
argument_list|)
argument_list|)
operator|==
literal|null
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/** Converts a previous clusterView document into a history 'string' **/
specifier|private
specifier|static
name|String
name|asHistoryEntry
parameter_list|(
specifier|final
name|ClusterViewDocument
name|previousView
parameter_list|,
name|int
name|retiringClusterNodeId
parameter_list|,
name|Date
name|retireTime
parameter_list|)
block|{
name|String
name|h
decl_stmt|;
name|JsopBuilder
name|b
init|=
operator|new
name|JsopBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|object
argument_list|()
expr_stmt|;
name|b
operator|.
name|key
argument_list|(
name|VIEW_SEQ_NUM_KEY
argument_list|)
expr_stmt|;
name|b
operator|.
name|value
argument_list|(
name|previousView
operator|.
name|getViewSeqNum
argument_list|()
argument_list|)
expr_stmt|;
name|b
operator|.
name|key
argument_list|(
name|CREATED_KEY
argument_list|)
expr_stmt|;
name|b
operator|.
name|value
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|previousView
operator|.
name|getCreatedAt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|key
argument_list|(
name|CREATOR_KEY
argument_list|)
expr_stmt|;
name|b
operator|.
name|value
argument_list|(
name|previousView
operator|.
name|getCreatedBy
argument_list|()
argument_list|)
expr_stmt|;
name|b
operator|.
name|key
argument_list|(
name|RETIRED_KEY
argument_list|)
expr_stmt|;
name|b
operator|.
name|value
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|standardDateFormat
operator|.
name|format
argument_list|(
name|retireTime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|key
argument_list|(
name|RETIRER_KEY
argument_list|)
expr_stmt|;
name|b
operator|.
name|value
argument_list|(
name|retiringClusterNodeId
argument_list|)
expr_stmt|;
name|b
operator|.
name|key
argument_list|(
name|ACTIVE_KEY
argument_list|)
expr_stmt|;
name|b
operator|.
name|value
argument_list|(
name|setToCsv
argument_list|(
name|previousView
operator|.
name|getActiveIds
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|key
argument_list|(
name|RECOVERING_KEY
argument_list|)
expr_stmt|;
name|b
operator|.
name|value
argument_list|(
name|setToCsv
argument_list|(
name|previousView
operator|.
name|getRecoveringIds
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|key
argument_list|(
name|INACTIVE_KEY
argument_list|)
expr_stmt|;
name|b
operator|.
name|value
argument_list|(
name|setToCsv
argument_list|(
name|previousView
operator|.
name|getInactiveIds
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|endObject
argument_list|()
expr_stmt|;
name|h
operator|=
name|b
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|h
return|;
block|}
comment|/**      * helper method to convert a set to a comma-separated string (without using      * toString() for safety)      *       * @return null if set is null or empty, comma-separated string (no spaces)      *         otherwise      */
specifier|private
specifier|static
name|String
name|setToCsv
parameter_list|(
name|Set
argument_list|<
name|Integer
argument_list|>
name|ids
parameter_list|)
block|{
if|if
condition|(
name|ids
operator|==
literal|null
operator|||
name|ids
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|id
range|:
name|ids
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * helper method to convert an array to a comma-separated string      *       * @return null if array is null or empty, comman-separated string (no      *         spaces) otherwise      */
specifier|static
name|String
name|arrayToCsv
parameter_list|(
name|Integer
index|[]
name|arr
parameter_list|)
block|{
if|if
condition|(
name|arr
operator|==
literal|null
operator|||
name|arr
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|a
range|:
name|arr
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * inverse helper method which converts a comma-separated string into an      * integer array      **/
specifier|static
name|Integer
index|[]
name|csvToIntegerArray
parameter_list|(
name|String
name|csv
parameter_list|)
block|{
if|if
condition|(
name|csv
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
index|[]
name|split
init|=
name|csv
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|Integer
index|[]
name|result
init|=
operator|new
name|Integer
index|[
name|split
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|split
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|split
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * internal reader of an existing clusterView document from the settings      * collection      **/
specifier|private
specifier|static
name|ClusterViewDocument
name|doRead
parameter_list|(
name|DocumentNodeStore
name|documentNodeStore
parameter_list|)
block|{
name|DocumentStore
name|documentStore
init|=
name|documentNodeStore
operator|.
name|getDocumentStore
argument_list|()
decl_stmt|;
name|Document
name|doc
init|=
name|documentStore
operator|.
name|find
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|,
literal|"clusterView"
argument_list|,
operator|-
literal|1
comment|/* -1; avoid caching */
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|ClusterViewDocument
name|clusterView
init|=
operator|new
name|ClusterViewDocument
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
name|clusterView
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
name|clusterView
return|;
block|}
else|else
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"read: clusterView document is not valid: "
operator|+
name|doc
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
comment|/** comparison helper that compares an integer array with a set **/
specifier|static
name|boolean
name|matches
parameter_list|(
name|Integer
index|[]
name|expected
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|actual
parameter_list|)
block|{
name|boolean
name|expectedIsEmpty
init|=
name|expected
operator|==
literal|null
operator|||
name|expected
operator|.
name|length
operator|==
literal|0
decl_stmt|;
name|boolean
name|actualIsEmpty
init|=
name|actual
operator|==
literal|null
operator|||
name|actual
operator|.
name|size
argument_list|()
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|expectedIsEmpty
operator|&&
name|actualIsEmpty
condition|)
block|{
comment|// if both are null or empty, they match
return|return
literal|true
return|;
block|}
if|if
condition|(
name|expectedIsEmpty
operator|!=
name|actualIsEmpty
condition|)
block|{
comment|// if one of them is only empty, but the other not, then they don't
comment|// match
return|return
literal|false
return|;
block|}
if|if
condition|(
name|expected
operator|.
name|length
operator|!=
name|actual
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// different size
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expected
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Integer
name|aMemberId
init|=
name|expected
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|actual
operator|.
name|contains
argument_list|(
name|aMemberId
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ClusterViewDocument
parameter_list|(
name|Document
name|doc
parameter_list|)
block|{
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"doc must not be null"
argument_list|)
throw|;
block|}
name|this
operator|.
name|clusterViewId
operator|=
operator|(
name|String
operator|)
name|doc
operator|.
name|get
argument_list|(
name|CLUSTER_VIEW_ID_KEY
argument_list|)
expr_stmt|;
name|this
operator|.
name|viewSeqNum
operator|=
operator|(
name|Long
operator|)
name|doc
operator|.
name|get
argument_list|(
name|VIEW_SEQ_NUM_KEY
argument_list|)
expr_stmt|;
name|this
operator|.
name|createdAt
operator|=
operator|(
name|String
operator|)
name|doc
operator|.
name|get
argument_list|(
name|CREATED_KEY
argument_list|)
expr_stmt|;
name|Object
name|creatorId
init|=
name|doc
operator|.
name|get
argument_list|(
name|CREATOR_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|creatorId
operator|instanceof
name|Long
condition|)
block|{
name|this
operator|.
name|createdBy
operator|=
operator|(
name|Long
operator|)
name|creatorId
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|creatorId
operator|instanceof
name|Integer
condition|)
block|{
name|this
operator|.
name|createdBy
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
name|Integer
operator|)
name|creatorId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unsupported type of creator: "
operator|+
name|creatorId
argument_list|)
throw|;
block|}
name|Object
name|obj
init|=
name|doc
operator|.
name|get
argument_list|(
name|ACTIVE_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj
operator|==
literal|null
operator|||
operator|!
operator|(
name|obj
operator|instanceof
name|String
operator|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"<init>: {} : {}"
argument_list|,
name|ACTIVE_KEY
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|this
operator|.
name|activeIds
operator|=
operator|new
name|Integer
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|activeIds
operator|=
name|csvToIntegerArray
argument_list|(
operator|(
name|String
operator|)
name|obj
argument_list|)
expr_stmt|;
block|}
name|Object
name|obj2
init|=
name|doc
operator|.
name|get
argument_list|(
name|RECOVERING_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj2
operator|==
literal|null
operator|||
operator|!
operator|(
name|obj2
operator|instanceof
name|String
operator|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"<init>: {} : {}"
argument_list|,
name|RECOVERING_KEY
argument_list|,
name|obj2
argument_list|)
expr_stmt|;
name|this
operator|.
name|recoveringIds
operator|=
operator|new
name|Integer
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|recoveringIds
operator|=
name|csvToIntegerArray
argument_list|(
operator|(
name|String
operator|)
name|obj2
argument_list|)
expr_stmt|;
block|}
name|Object
name|obj3
init|=
name|doc
operator|.
name|get
argument_list|(
name|INACTIVE_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj3
operator|==
literal|null
operator|||
operator|!
operator|(
name|obj3
operator|instanceof
name|String
operator|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"<init>: {} : {}"
argument_list|,
name|INACTIVE_KEY
argument_list|,
name|obj3
argument_list|)
expr_stmt|;
name|this
operator|.
name|inactiveIds
operator|=
operator|new
name|Integer
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|inactiveIds
operator|=
name|csvToIntegerArray
argument_list|(
operator|(
name|String
operator|)
name|obj3
argument_list|)
expr_stmt|;
block|}
name|Object
name|obj4
init|=
name|doc
operator|.
name|get
argument_list|(
name|CLUSTER_VIEW_HISTORY_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj4
operator|==
literal|null
operator|||
operator|!
operator|(
name|obj4
operator|instanceof
name|Map
operator|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"<init> viewHistory is null"
argument_list|)
expr_stmt|;
name|this
operator|.
name|viewHistory
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|viewHistory
operator|=
operator|(
operator|(
name|Map
argument_list|<
name|Object
argument_list|,
name|String
argument_list|>
operator|)
name|obj4
operator|)
expr_stmt|;
block|}
block|}
comment|/** Returns the set of active ids of this cluster view **/
name|Set
argument_list|<
name|Integer
argument_list|>
name|getActiveIds
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|activeIds
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns the set of recovering ids of this cluster view **/
name|Set
argument_list|<
name|Integer
argument_list|>
name|getRecoveringIds
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|recoveringIds
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns the set of inactive ids of this cluster view **/
name|Set
argument_list|<
name|Integer
argument_list|>
name|getInactiveIds
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|inactiveIds
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns the history map **/
specifier|private
name|Map
argument_list|<
name|Object
argument_list|,
name|String
argument_list|>
name|getHistory
parameter_list|()
block|{
return|return
name|viewHistory
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"a ClusterView[valid="
operator|+
name|isValid
argument_list|()
operator|+
literal|", viewSeqNum="
operator|+
name|viewSeqNum
operator|+
literal|", clusterViewId="
operator|+
name|clusterViewId
operator|+
literal|", activeIds="
operator|+
name|arrayToCsv
argument_list|(
name|activeIds
argument_list|)
operator|+
literal|", recoveringIds="
operator|+
name|arrayToCsv
argument_list|(
name|recoveringIds
argument_list|)
operator|+
literal|", inactiveIds="
operator|+
name|arrayToCsv
argument_list|(
name|inactiveIds
argument_list|)
operator|+
literal|"]"
return|;
block|}
name|boolean
name|isValid
parameter_list|()
block|{
return|return
name|viewSeqNum
operator|>=
literal|0
operator|&&
name|activeIds
operator|!=
literal|null
operator|&&
name|activeIds
operator|.
name|length
operator|>
literal|0
return|;
block|}
comment|/**      * Returns the date+time when this view was created, for debugging purpose      * only      **/
name|String
name|getCreatedAt
parameter_list|()
block|{
return|return
name|createdAt
return|;
block|}
comment|/**      * Returns the id of the instance that created this view, for debugging      * purpose only      **/
name|long
name|getCreatedBy
parameter_list|()
block|{
return|return
name|createdBy
return|;
block|}
comment|/** Returns the monotonically incrementing sequenece number of this view **/
name|long
name|getViewSeqNum
parameter_list|()
block|{
return|return
name|viewSeqNum
return|;
block|}
comment|/**      * Returns a UUID representing this cluster - will never change, propagates      * from view to view      **/
name|String
name|getClusterViewId
parameter_list|()
block|{
return|return
name|clusterViewId
return|;
block|}
specifier|private
name|boolean
name|matches
parameter_list|(
name|Set
argument_list|<
name|Integer
argument_list|>
name|activeIds
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|recoveringIds
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|inactiveIds
parameter_list|)
block|{
if|if
condition|(
operator|!
name|matches
argument_list|(
name|this
operator|.
name|activeIds
argument_list|,
name|activeIds
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|matches
argument_list|(
name|this
operator|.
name|recoveringIds
argument_list|,
name|recoveringIds
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|matches
argument_list|(
name|this
operator|.
name|inactiveIds
argument_list|,
name|inactiveIds
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_class

end_unit

