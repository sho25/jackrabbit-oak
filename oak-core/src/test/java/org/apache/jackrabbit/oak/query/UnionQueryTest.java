begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|JcrConstants
operator|.
name|JCR_PRIMARYTYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Type
operator|.
name|NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|IndexConstants
operator|.
name|INDEX_DEFINITIONS_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|IndexConstants
operator|.
name|INDEX_DEFINITIONS_NODE_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|IndexConstants
operator|.
name|TYPE_PROPERTY_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|InitialContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|Oak
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|ContentRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|QueryEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|ResultRow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|namepath
operator|.
name|NamePathMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|namepath
operator|.
name|impl
operator|.
name|GlobalNameMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|namepath
operator|.
name|impl
operator|.
name|NamePathMapperImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|MemoryNodeStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|ColumnImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|ConstraintImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|DescendantNodeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|NodeTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|NodeTypeInfoProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|OrderingImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|PropertyValueImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|SelectorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|SourceImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|stats
operator|.
name|QueryStatsData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|security
operator|.
name|OpenSecurityProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_class
specifier|public
class|class
name|UnionQueryTest
extends|extends
name|AbstractQueryTest
block|{
name|MemoryNodeStore
name|store
decl_stmt|;
name|QueryEngineSettings
name|qeSettings
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|ContentRepository
name|createRepository
parameter_list|()
block|{
name|store
operator|=
operator|new
name|MemoryNodeStore
argument_list|()
expr_stmt|;
name|qeSettings
operator|=
operator|new
name|QueryEngineSettings
argument_list|()
expr_stmt|;
return|return
operator|new
name|Oak
argument_list|(
name|store
argument_list|)
operator|.
name|with
argument_list|(
operator|new
name|OpenSecurityProvider
argument_list|()
argument_list|)
operator|.
name|with
argument_list|(
operator|new
name|InitialContent
argument_list|()
argument_list|)
operator|.
name|with
argument_list|(
name|qeSettings
argument_list|)
operator|.
name|createContentRepository
argument_list|()
return|;
block|}
annotation|@
name|Before
annotation|@
name|Override
specifier|public
name|void
name|before
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|before
argument_list|()
expr_stmt|;
comment|// Create tree for this test
name|Tree
name|t
init|=
name|root
operator|.
name|getTree
argument_list|(
literal|"/"
argument_list|)
operator|.
name|addChild
argument_list|(
literal|"UnionQueryTest"
argument_list|)
decl_stmt|;
comment|// Create tree /a/b/c/d/e
name|t
operator|=
name|t
operator|.
name|addChild
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|.
name|addChild
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|.
name|addChild
argument_list|(
literal|"c"
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|.
name|addChild
argument_list|(
literal|"d"
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|.
name|addChild
argument_list|(
literal|"e"
argument_list|)
expr_stmt|;
name|Tree
name|t2
init|=
name|root
operator|.
name|getTree
argument_list|(
literal|"/"
argument_list|)
operator|.
name|addChild
argument_list|(
literal|"UnionQueryTest2"
argument_list|)
decl_stmt|;
name|Tree
name|t3
init|=
name|t2
operator|.
name|addChild
argument_list|(
literal|"a"
argument_list|)
decl_stmt|;
name|root
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
annotation|@
name|After
specifier|public
name|void
name|after
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Remove test tree
name|root
operator|.
name|getTree
argument_list|(
literal|"/UnionQueryTest"
argument_list|)
operator|.
name|remove
argument_list|()
expr_stmt|;
name|root
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMergeSortedVsConcat
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|left
init|=
literal|"SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest2')"
decl_stmt|;
name|String
name|right
init|=
literal|"SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest/a')"
decl_stmt|;
name|String
name|order
init|=
literal|"ORDER BY [jcr:path]"
decl_stmt|;
name|String
name|union
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s UNION %s %s"
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|order
argument_list|)
decl_stmt|;
specifier|final
name|int
name|limit
init|=
literal|10
decl_stmt|;
specifier|final
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|// Execute query with ORDER BY clause - This should use mergeSorted and the final result should be sorted across both the subqueries.
name|String
index|[]
name|expected
init|=
block|{
literal|"/UnionQueryTest/a/b"
block|,
literal|"/UnionQueryTest/a/b/c"
block|,
literal|"/UnionQueryTest/a/b/c/d"
block|,
literal|"/UnionQueryTest/a/b/c/d/e"
block|,
literal|"/UnionQueryTest2/a"
block|}
decl_stmt|;
name|Result
name|result
init|=
name|qe
operator|.
name|executeQuery
argument_list|(
name|union
argument_list|,
name|QueryEngineImpl
operator|.
name|SQL2
argument_list|,
name|limit
argument_list|,
name|offset
argument_list|,
name|QueryEngine
operator|.
name|NO_BINDINGS
argument_list|,
name|QueryEngine
operator|.
name|NO_MAPPINGS
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ResultRow
name|rr
range|:
name|result
operator|.
name|getRows
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|rr
operator|.
name|getPath
argument_list|()
argument_list|,
name|expected
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Now we execute the same union query without the order by clause. Expectation is the subqueries results should simply be concatenated without
comment|// sorting of the overall result
name|String
index|[]
name|expected2
init|=
block|{
literal|"/UnionQueryTest2/a"
block|,
literal|"/UnionQueryTest/a/b"
block|,
literal|"/UnionQueryTest/a/b/c"
block|,
literal|"/UnionQueryTest/a/b/c/d"
block|,
literal|"/UnionQueryTest/a/b/c/d/e"
block|}
decl_stmt|;
name|union
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"%s UNION %s"
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|result
operator|=
name|qe
operator|.
name|executeQuery
argument_list|(
name|union
argument_list|,
name|QueryEngineImpl
operator|.
name|SQL2
argument_list|,
name|limit
argument_list|,
name|offset
argument_list|,
name|QueryEngine
operator|.
name|NO_BINDINGS
argument_list|,
name|QueryEngine
operator|.
name|NO_MAPPINGS
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ResultRow
name|rr
range|:
name|result
operator|.
name|getRows
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|rr
operator|.
name|getPath
argument_list|()
argument_list|,
name|expected2
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO - Write a similar test that might fail with guava's merge sort on some conditions
annotation|@
name|Test
specifier|public
name|void
name|testSortWithOneSubquerySortedByIndexAndOtherNot
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|left
init|=
literal|"SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest2')"
decl_stmt|;
name|String
name|right
init|=
literal|"SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest/a')"
decl_stmt|;
name|NodeTypeInfoProvider
name|nodeTypes
init|=
operator|new
name|NodeStateNodeTypeInfoProvider
argument_list|(
name|store
operator|.
name|getRoot
argument_list|()
argument_list|)
decl_stmt|;
name|NodeTypeInfo
name|type
init|=
name|nodeTypes
operator|.
name|getNodeTypeInfo
argument_list|(
literal|"nt:base"
argument_list|)
decl_stmt|;
name|SourceImpl
name|sImpl
init|=
operator|new
name|SelectorImpl
argument_list|(
name|type
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|SourceImpl
name|sImpl2
init|=
operator|new
name|SelectorImpl
argument_list|(
name|type
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|SourceImpl
name|sImpl3
init|=
operator|new
name|SelectorImpl
argument_list|(
name|type
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|QueryImpl
name|qImplLeft
init|=
name|createQuery
argument_list|(
name|left
argument_list|,
operator|new
name|DescendantNodeImpl
argument_list|(
literal|"a"
argument_list|,
literal|"/UnionQueryTest2"
argument_list|)
argument_list|,
name|sImpl
argument_list|)
decl_stmt|;
name|qImplLeft
operator|.
name|setExecutionContext
argument_list|(
operator|(
operator|(
name|QueryEngineImpl
operator|)
name|root
operator|.
name|getQueryEngine
argument_list|()
operator|)
operator|.
name|getExecutionContext
argument_list|()
argument_list|)
expr_stmt|;
name|QueryImpl
name|qImplRight
init|=
name|createQuery
argument_list|(
name|right
argument_list|,
operator|new
name|DescendantNodeImpl
argument_list|(
literal|"a"
argument_list|,
literal|"/UnionQueryTest/a"
argument_list|)
argument_list|,
name|sImpl2
argument_list|)
decl_stmt|;
name|qImplRight
operator|.
name|setExecutionContext
argument_list|(
operator|(
operator|(
name|QueryEngineImpl
operator|)
name|root
operator|.
name|getQueryEngine
argument_list|()
operator|)
operator|.
name|getExecutionContext
argument_list|()
argument_list|)
expr_stmt|;
name|PropertyValueImpl
name|propValImpl
init|=
operator|new
name|PropertyValueImpl
argument_list|(
literal|"a"
argument_list|,
literal|"jcr:path"
argument_list|)
decl_stmt|;
name|propValImpl
operator|.
name|bindSelector
argument_list|(
name|sImpl
argument_list|)
expr_stmt|;
name|PropertyValueImpl
name|propValImpl2
init|=
operator|new
name|PropertyValueImpl
argument_list|(
literal|"a"
argument_list|,
literal|"jcr:path"
argument_list|)
decl_stmt|;
name|propValImpl2
operator|.
name|bindSelector
argument_list|(
name|sImpl2
argument_list|)
expr_stmt|;
name|PropertyValueImpl
name|propValImpl3
init|=
operator|new
name|PropertyValueImpl
argument_list|(
literal|"a"
argument_list|,
literal|"jcr:path"
argument_list|)
decl_stmt|;
name|propValImpl2
operator|.
name|bindSelector
argument_list|(
name|sImpl3
argument_list|)
expr_stmt|;
comment|/// One subquery sorted by index and the other not and orderBY != null in UnionQueryImpl
name|QueryImpl
name|spyLeft
init|=
name|Mockito
operator|.
name|spy
argument_list|(
name|qImplLeft
argument_list|)
decl_stmt|;
name|QueryImpl
name|spyRight
init|=
name|Mockito
operator|.
name|spy
argument_list|(
name|qImplRight
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|spyLeft
argument_list|)
operator|.
name|isSortedByIndex
argument_list|()
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
literal|false
argument_list|)
operator|.
name|when
argument_list|(
name|spyRight
argument_list|)
operator|.
name|isSortedByIndex
argument_list|()
expr_stmt|;
name|spyLeft
operator|.
name|setOrderings
argument_list|(
operator|new
name|OrderingImpl
index|[]
block|{
operator|new
name|OrderingImpl
argument_list|(
name|propValImpl
argument_list|,
name|Order
operator|.
name|DESCENDING
argument_list|)
block|}
argument_list|)
expr_stmt|;
name|spyRight
operator|.
name|setOrderings
argument_list|(
operator|new
name|OrderingImpl
index|[]
block|{
operator|new
name|OrderingImpl
argument_list|(
name|propValImpl2
argument_list|,
name|Order
operator|.
name|DESCENDING
argument_list|)
block|}
argument_list|)
expr_stmt|;
name|UnionQueryImpl
name|unionImpl
init|=
operator|new
name|UnionQueryImpl
argument_list|(
literal|true
argument_list|,
name|spyLeft
argument_list|,
name|spyRight
argument_list|,
operator|new
name|QueryEngineSettings
argument_list|()
argument_list|)
decl_stmt|;
name|unionImpl
operator|.
name|setOrderings
argument_list|(
operator|new
name|OrderingImpl
index|[]
block|{
operator|new
name|OrderingImpl
argument_list|(
name|propValImpl3
argument_list|,
name|Order
operator|.
name|ASCENDING
argument_list|)
block|}
argument_list|)
expr_stmt|;
name|unionImpl
operator|.
name|init
argument_list|()
expr_stmt|;
comment|// Execute query with ORDER BY clause - This should use mergeSorted and the final result should be sorted across both the subqueries.
name|String
index|[]
name|expected
init|=
block|{
literal|"/UnionQueryTest/a/b"
block|,
literal|"/UnionQueryTest/a/b/c"
block|,
literal|"/UnionQueryTest/a/b/c/d"
block|,
literal|"/UnionQueryTest/a/b/c/d/e"
block|,
literal|"/UnionQueryTest2/a"
block|}
decl_stmt|;
name|Result
name|result
init|=
name|unionImpl
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ResultRow
name|rr
range|:
name|result
operator|.
name|getRows
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|expected
index|[
name|i
operator|++
index|]
argument_list|,
name|rr
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrderLimitOffset
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|left
init|=
literal|"SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest')"
decl_stmt|;
name|String
name|right
init|=
literal|"SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest')"
decl_stmt|;
name|String
name|order
init|=
literal|"ORDER BY [jcr:path]"
decl_stmt|;
name|String
name|union
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s UNION %s %s"
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|order
argument_list|)
decl_stmt|;
specifier|final
name|int
name|limit
init|=
literal|3
decl_stmt|;
specifier|final
name|int
name|offset
init|=
literal|2
decl_stmt|;
name|String
index|[]
name|expected
init|=
block|{
literal|"/UnionQueryTest/a/b/c"
block|,
literal|"/UnionQueryTest/a/b/c/d"
block|,
literal|"/UnionQueryTest/a/b/c/d/e"
block|}
decl_stmt|;
name|Result
name|result
init|=
name|qe
operator|.
name|executeQuery
argument_list|(
name|union
argument_list|,
name|QueryEngineImpl
operator|.
name|SQL2
argument_list|,
name|limit
argument_list|,
name|offset
argument_list|,
name|QueryEngine
operator|.
name|NO_BINDINGS
argument_list|,
name|QueryEngine
operator|.
name|NO_MAPPINGS
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ResultRow
argument_list|>
name|rows
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|result
operator|.
name|getRows
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|length
argument_list|,
name|rows
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ResultRow
name|rr
range|:
name|result
operator|.
name|getRows
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|rr
operator|.
name|getPath
argument_list|()
argument_list|,
name|expected
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExplainStatement
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|left
init|=
literal|"SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest')"
decl_stmt|;
specifier|final
name|String
name|right
init|=
literal|"SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest')"
decl_stmt|;
specifier|final
name|String
name|order
init|=
literal|"ORDER BY [jcr:path]"
decl_stmt|;
specifier|final
name|String
name|union
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s UNION %s %s"
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|order
argument_list|)
decl_stmt|;
specifier|final
name|String
name|explainUnion
init|=
literal|"explain "
operator|+
name|union
decl_stmt|;
name|Result
name|explainResult
init|=
name|executeQuery
argument_list|(
name|explainUnion
argument_list|,
name|QueryEngineImpl
operator|.
name|SQL2
argument_list|,
name|QueryEngine
operator|.
name|NO_BINDINGS
argument_list|)
decl_stmt|;
name|int
name|explainCount
init|=
literal|0
decl_stmt|;
name|ResultRow
name|explainRow
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ResultRow
name|row
range|:
name|explainResult
operator|.
name|getRows
argument_list|()
control|)
block|{
if|if
condition|(
name|explainCount
operator|==
literal|0
condition|)
block|{
name|explainRow
operator|=
name|row
expr_stmt|;
block|}
name|explainCount
operator|=
name|explainCount
operator|+
literal|1
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"should exist 1 result"
argument_list|,
literal|1
argument_list|,
name|explainCount
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"explain row should not be null"
argument_list|,
name|explainRow
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"result should have 'plan' column"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|explainResult
operator|.
name|getColumnNames
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
literal|"plan"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"result should have 'statement' column"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|explainResult
operator|.
name|getColumnNames
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
literal|"statement"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|explainedStatement
init|=
name|explainRow
operator|.
name|getValue
argument_list|(
literal|"statement"
argument_list|)
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|STRING
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"'statement' should begin with 'select': "
operator|+
name|explainedStatement
argument_list|,
name|explainedStatement
operator|.
name|startsWith
argument_list|(
literal|"SELECT"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"'statement' should contain ' UNION ': "
operator|+
name|explainedStatement
argument_list|,
name|explainedStatement
operator|.
name|contains
argument_list|(
literal|" UNION "
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|int
name|limit
init|=
literal|3
decl_stmt|;
specifier|final
name|int
name|offset
init|=
literal|2
decl_stmt|;
name|String
index|[]
name|expected
init|=
block|{
literal|"/UnionQueryTest/a/b/c"
block|,
literal|"/UnionQueryTest/a/b/c/d"
block|,
literal|"/UnionQueryTest/a/b/c/d/e"
block|}
decl_stmt|;
name|Result
name|result
init|=
name|qe
operator|.
name|executeQuery
argument_list|(
name|explainedStatement
argument_list|,
name|QueryEngineImpl
operator|.
name|SQL2
argument_list|,
name|limit
argument_list|,
name|offset
argument_list|,
name|QueryEngine
operator|.
name|NO_BINDINGS
argument_list|,
name|QueryEngine
operator|.
name|NO_MAPPINGS
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ResultRow
argument_list|>
name|rows
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|result
operator|.
name|getRows
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|length
argument_list|,
name|rows
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ResultRow
name|rr
range|:
name|result
operator|.
name|getRows
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|rr
operator|.
name|getPath
argument_list|()
argument_list|,
name|expected
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExplainStatementXPath
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|xpath
init|=
literal|"/jcr:root/UnionQueryTest//(element(*, nt:base) | element(*, nt:folder)) order by jcr:path"
decl_stmt|;
specifier|final
name|String
name|explainUnion
init|=
literal|"explain "
operator|+
name|xpath
decl_stmt|;
name|Result
name|explainResult
init|=
name|executeQuery
argument_list|(
name|explainUnion
argument_list|,
name|QueryEngineImpl
operator|.
name|XPATH
argument_list|,
name|QueryEngine
operator|.
name|NO_BINDINGS
argument_list|)
decl_stmt|;
name|int
name|explainCount
init|=
literal|0
decl_stmt|;
name|ResultRow
name|explainRow
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ResultRow
name|row
range|:
name|explainResult
operator|.
name|getRows
argument_list|()
control|)
block|{
if|if
condition|(
name|explainCount
operator|==
literal|0
condition|)
block|{
name|explainRow
operator|=
name|row
expr_stmt|;
block|}
name|explainCount
operator|=
name|explainCount
operator|+
literal|1
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"should exist 1 result"
argument_list|,
literal|1
argument_list|,
name|explainCount
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"explain row should not be null"
argument_list|,
name|explainRow
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"result should have 'plan' column"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|explainResult
operator|.
name|getColumnNames
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
literal|"plan"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"result should have 'statement' column"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|explainResult
operator|.
name|getColumnNames
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
literal|"statement"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|explainedStatement
init|=
name|explainRow
operator|.
name|getValue
argument_list|(
literal|"statement"
argument_list|)
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|STRING
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"'statement' should begin with 'select': "
operator|+
name|explainedStatement
argument_list|,
name|explainedStatement
operator|.
name|startsWith
argument_list|(
literal|"select"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"'statement' should contain ' union ': "
operator|+
name|explainedStatement
argument_list|,
name|explainedStatement
operator|.
name|contains
argument_list|(
literal|" union "
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|int
name|limit
init|=
literal|3
decl_stmt|;
specifier|final
name|int
name|offset
init|=
literal|2
decl_stmt|;
name|String
index|[]
name|expected
init|=
block|{
literal|"/UnionQueryTest/a/b/c"
block|,
literal|"/UnionQueryTest/a/b/c/d"
block|,
literal|"/UnionQueryTest/a/b/c/d/e"
block|}
decl_stmt|;
name|Result
name|result
init|=
name|qe
operator|.
name|executeQuery
argument_list|(
name|explainedStatement
argument_list|,
name|QueryEngineImpl
operator|.
name|SQL2
argument_list|,
name|limit
argument_list|,
name|offset
argument_list|,
name|QueryEngine
operator|.
name|NO_BINDINGS
argument_list|,
name|QueryEngine
operator|.
name|NO_MAPPINGS
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ResultRow
argument_list|>
name|rows
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|result
operator|.
name|getRows
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|length
argument_list|,
name|rows
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ResultRow
name|rr
range|:
name|result
operator|.
name|getRows
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|rr
operator|.
name|getPath
argument_list|()
argument_list|,
name|expected
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|QueryImpl
name|createQuery
parameter_list|(
name|String
name|statement
parameter_list|,
name|ConstraintImpl
name|c
parameter_list|,
name|SourceImpl
name|sImpl
parameter_list|)
throws|throws
name|Exception
block|{
name|NamePathMapper
name|namePathMapper
init|=
operator|new
name|NamePathMapperImpl
argument_list|(
operator|new
name|GlobalNameMapper
argument_list|(
name|root
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|QueryImpl
argument_list|(
name|statement
argument_list|,
name|sImpl
argument_list|,
name|c
argument_list|,
operator|new
name|ColumnImpl
index|[]
block|{
operator|new
name|ColumnImpl
argument_list|(
literal|"a"
argument_list|,
literal|"jcr:path"
argument_list|,
literal|"jcr:path"
argument_list|)
block|}
argument_list|,
name|namePathMapper
argument_list|,
name|qeSettings
argument_list|,
operator|new
name|QueryStatsData
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|)
operator|.
operator|new
name|QueryExecutionStats
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

