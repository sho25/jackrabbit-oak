begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Stopwatch
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterators
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|sort
operator|.
name|StringSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Key
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|TimeInterval
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|gc
operator|.
name|DelegatingGCMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|gc
operator|.
name|GCMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|stats
operator|.
name|Clock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|TimeDurationFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|stats
operator|.
name|StatisticsProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|StandardSystemProperty
operator|.
name|LINE_SEPARATOR
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
operator|.
name|all
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterators
operator|.
name|partition
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Atomics
operator|.
name|newReference
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singletonMap
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|MICROSECONDS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Collection
operator|.
name|NODES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Collection
operator|.
name|SETTINGS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|MODIFIED_IN_SECS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|SplitDocType
operator|.
name|COMMIT_ROOT_ONLY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|SplitDocType
operator|.
name|DEFAULT_LEAF
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|SplitDocType
operator|.
name|DEFAULT_NO_BRANCH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Condition
operator|.
name|newEqualsCondition
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|slf4j
operator|.
name|helpers
operator|.
name|MessageFormatter
operator|.
name|arrayFormat
import|;
end_import

begin_class
specifier|public
class|class
name|VersionGarbageCollector
block|{
comment|//Kept less than MongoDocumentStore.IN_CLAUSE_BATCH_SIZE to avoid re-partitioning
specifier|private
specifier|static
specifier|final
name|int
name|DELETE_BATCH_SIZE
init|=
literal|450
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|UPDATE_BATCH_SIZE
init|=
literal|450
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PROGRESS_BATCH_SIZE
init|=
literal|10000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Key
name|KEY_MODIFIED
init|=
operator|new
name|Key
argument_list|(
name|MODIFIED_IN_SECS
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|STATUS_IDLE
init|=
literal|"IDLE"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|STATUS_INITIALIZING
init|=
literal|"INITIALIZING"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|VersionGarbageCollector
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Split document types which can be safely garbage collected      */
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|NodeDocument
operator|.
name|SplitDocType
argument_list|>
name|GC_TYPES
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|DEFAULT_LEAF
argument_list|,
name|COMMIT_ROOT_ONLY
argument_list|,
name|DEFAULT_NO_BRANCH
argument_list|)
decl_stmt|;
comment|/**      * Document id stored in settings collection that keeps info about version gc      */
specifier|private
specifier|static
specifier|final
name|String
name|SETTINGS_COLLECTION_ID
init|=
literal|"versionGC"
decl_stmt|;
comment|/**      * Property name to timestamp when last gc run happened      */
specifier|private
specifier|static
specifier|final
name|String
name|SETTINGS_COLLECTION_OLDEST_TIMESTAMP_PROP
init|=
literal|"lastOldestTimeStamp"
decl_stmt|;
comment|/**      * Property name to recommended time interval for next collection run      */
specifier|private
specifier|static
specifier|final
name|String
name|SETTINGS_COLLECTION_REC_INTERVAL_PROP
init|=
literal|"recommendedIntervalMs"
decl_stmt|;
specifier|private
specifier|final
name|DocumentNodeStore
name|nodeStore
decl_stmt|;
specifier|private
specifier|final
name|DocumentStore
name|ds
decl_stmt|;
specifier|private
specifier|final
name|VersionGCSupport
name|versionStore
decl_stmt|;
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|GCJob
argument_list|>
name|collector
init|=
name|newReference
argument_list|()
decl_stmt|;
specifier|private
name|VersionGCOptions
name|options
decl_stmt|;
specifier|private
name|GCMonitor
name|gcMonitor
init|=
name|GCMonitor
operator|.
name|EMPTY
decl_stmt|;
specifier|private
name|RevisionGCStats
name|gcStats
init|=
operator|new
name|RevisionGCStats
argument_list|(
name|StatisticsProvider
operator|.
name|NOOP
argument_list|)
decl_stmt|;
name|VersionGarbageCollector
parameter_list|(
name|DocumentNodeStore
name|nodeStore
parameter_list|,
name|VersionGCSupport
name|gcSupport
parameter_list|)
block|{
name|this
operator|.
name|nodeStore
operator|=
name|nodeStore
expr_stmt|;
name|this
operator|.
name|versionStore
operator|=
name|gcSupport
expr_stmt|;
name|this
operator|.
name|ds
operator|=
name|gcSupport
operator|.
name|getDocumentStore
argument_list|()
expr_stmt|;
name|this
operator|.
name|options
operator|=
operator|new
name|VersionGCOptions
argument_list|()
expr_stmt|;
block|}
name|void
name|setStatisticsProvider
parameter_list|(
name|StatisticsProvider
name|provider
parameter_list|)
block|{
name|this
operator|.
name|gcStats
operator|=
operator|new
name|RevisionGCStats
argument_list|(
name|provider
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Nonnull
name|RevisionGCStats
name|getRevisionGCStats
parameter_list|()
block|{
return|return
name|gcStats
return|;
block|}
specifier|public
name|VersionGCStats
name|gc
parameter_list|(
name|long
name|maxRevisionAge
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|maxRevisionAgeInMillis
init|=
name|unit
operator|.
name|toMillis
argument_list|(
name|maxRevisionAge
argument_list|)
decl_stmt|;
name|TimeInterval
name|maxRunTime
init|=
operator|new
name|TimeInterval
argument_list|(
name|nodeStore
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|options
operator|.
name|maxDurationMs
operator|>
literal|0
condition|)
block|{
name|maxRunTime
operator|=
name|maxRunTime
operator|.
name|startAndDuration
argument_list|(
name|options
operator|.
name|maxDurationMs
argument_list|)
expr_stmt|;
block|}
name|GCJob
name|job
init|=
operator|new
name|GCJob
argument_list|(
name|maxRevisionAgeInMillis
argument_list|,
name|options
argument_list|,
name|gcMonitor
argument_list|)
decl_stmt|;
if|if
condition|(
name|collector
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|job
argument_list|)
condition|)
block|{
name|VersionGCStats
name|overall
init|=
operator|new
name|VersionGCStats
argument_list|()
decl_stmt|;
name|overall
operator|.
name|active
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|averageDurationMs
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|maxRunTime
operator|.
name|contains
argument_list|(
name|nodeStore
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
operator|+
name|averageDurationMs
argument_list|)
condition|)
block|{
name|gcMonitor
operator|.
name|info
argument_list|(
literal|"Start {}. run (avg duration {} sec)"
argument_list|,
name|overall
operator|.
name|iterationCount
operator|+
literal|1
argument_list|,
name|averageDurationMs
operator|/
literal|1000.0
argument_list|)
expr_stmt|;
name|VersionGCStats
name|stats
init|=
name|job
operator|.
name|run
argument_list|()
decl_stmt|;
name|overall
operator|.
name|addRun
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|maxIterations
operator|>
literal|0
operator|&&
name|overall
operator|.
name|iterationCount
operator|>=
name|options
operator|.
name|maxIterations
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|overall
operator|.
name|needRepeat
condition|)
block|{
break|break;
block|}
name|averageDurationMs
operator|=
operator|(
operator|(
name|averageDurationMs
operator|*
operator|(
name|overall
operator|.
name|iterationCount
operator|-
literal|1
operator|)
operator|)
operator|+
name|stats
operator|.
name|active
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
operator|)
operator|/
name|overall
operator|.
name|iterationCount
expr_stmt|;
block|}
name|gcStats
operator|.
name|finished
argument_list|(
name|overall
argument_list|)
expr_stmt|;
return|return
name|overall
return|;
block|}
finally|finally
block|{
name|overall
operator|.
name|active
operator|.
name|stop
argument_list|()
expr_stmt|;
name|collector
operator|.
name|set
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|overall
operator|.
name|iterationCount
operator|>
literal|1
condition|)
block|{
name|gcMonitor
operator|.
name|info
argument_list|(
literal|"Revision garbage collection finished after {} iterations - aggregate statistics: {}"
argument_list|,
name|overall
operator|.
name|iterationCount
argument_list|,
name|overall
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Revision garbage collection is already running"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|cancel
parameter_list|()
block|{
name|GCJob
name|job
init|=
name|collector
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|job
operator|!=
literal|null
condition|)
block|{
name|job
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|String
name|getStatus
parameter_list|()
block|{
name|GCJob
name|job
init|=
name|collector
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|job
operator|==
literal|null
condition|)
block|{
return|return
name|STATUS_IDLE
return|;
block|}
else|else
block|{
return|return
name|job
operator|.
name|getStatus
argument_list|()
return|;
block|}
block|}
specifier|public
name|void
name|setGCMonitor
parameter_list|(
annotation|@
name|Nonnull
name|GCMonitor
name|gcMonitor
parameter_list|)
block|{
name|this
operator|.
name|gcMonitor
operator|=
name|checkNotNull
argument_list|(
name|gcMonitor
argument_list|)
expr_stmt|;
block|}
specifier|public
name|VersionGCOptions
name|getOptions
parameter_list|()
block|{
return|return
name|this
operator|.
name|options
return|;
block|}
specifier|public
name|void
name|setOptions
parameter_list|(
name|VersionGCOptions
name|options
parameter_list|)
block|{
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|ds
operator|.
name|remove
argument_list|(
name|SETTINGS
argument_list|,
name|SETTINGS_COLLECTION_ID
argument_list|)
expr_stmt|;
block|}
specifier|public
name|VersionGCInfo
name|getInfo
parameter_list|(
name|long
name|maxRevisionAge
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|maxRevisionAgeInMillis
init|=
name|unit
operator|.
name|toMillis
argument_list|(
name|maxRevisionAge
argument_list|)
decl_stmt|;
name|long
name|now
init|=
name|nodeStore
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|Recommendations
name|rec
init|=
operator|new
name|Recommendations
argument_list|(
name|maxRevisionAgeInMillis
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|int
name|estimatedIterations
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|rec
operator|.
name|suggestedIntervalMs
operator|>
literal|0
condition|)
block|{
name|estimatedIterations
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|now
operator|-
name|rec
operator|.
name|scope
operator|.
name|toMs
operator|)
operator|/
name|rec
operator|.
name|suggestedIntervalMs
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|VersionGCInfo
argument_list|(
name|rec
operator|.
name|lastOldestTimestamp
argument_list|,
name|rec
operator|.
name|scope
operator|.
name|fromMs
argument_list|,
name|rec
operator|.
name|deleteCandidateCount
argument_list|,
name|rec
operator|.
name|maxCollect
argument_list|,
name|rec
operator|.
name|suggestedIntervalMs
argument_list|,
name|rec
operator|.
name|scope
operator|.
name|toMs
argument_list|,
name|estimatedIterations
argument_list|)
return|;
block|}
specifier|public
specifier|static
class|class
name|VersionGCInfo
block|{
specifier|public
specifier|final
name|long
name|lastSuccess
decl_stmt|;
specifier|public
specifier|final
name|long
name|oldestRevisionEstimate
decl_stmt|;
specifier|public
specifier|final
name|long
name|revisionsCandidateCount
decl_stmt|;
specifier|public
specifier|final
name|long
name|collectLimit
decl_stmt|;
specifier|public
specifier|final
name|long
name|recommendedCleanupInterval
decl_stmt|;
specifier|public
specifier|final
name|long
name|recommendedCleanupTimestamp
decl_stmt|;
specifier|public
specifier|final
name|int
name|estimatedIterations
decl_stmt|;
name|VersionGCInfo
parameter_list|(
name|long
name|lastSuccess
parameter_list|,
name|long
name|oldestRevisionEstimate
parameter_list|,
name|long
name|revisionsCandidateCount
parameter_list|,
name|long
name|collectLimit
parameter_list|,
name|long
name|recommendedCleanupInterval
parameter_list|,
name|long
name|recommendedCleanupTimestamp
parameter_list|,
name|int
name|estimatedIterations
parameter_list|)
block|{
name|this
operator|.
name|lastSuccess
operator|=
name|lastSuccess
expr_stmt|;
name|this
operator|.
name|oldestRevisionEstimate
operator|=
name|oldestRevisionEstimate
expr_stmt|;
name|this
operator|.
name|revisionsCandidateCount
operator|=
name|revisionsCandidateCount
expr_stmt|;
name|this
operator|.
name|collectLimit
operator|=
name|collectLimit
expr_stmt|;
name|this
operator|.
name|recommendedCleanupInterval
operator|=
name|recommendedCleanupInterval
expr_stmt|;
name|this
operator|.
name|recommendedCleanupTimestamp
operator|=
name|recommendedCleanupTimestamp
expr_stmt|;
name|this
operator|.
name|estimatedIterations
operator|=
name|estimatedIterations
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
class|class
name|VersionGCStats
block|{
name|boolean
name|ignoredGCDueToCheckPoint
decl_stmt|;
name|boolean
name|canceled
decl_stmt|;
name|boolean
name|limitExceeded
decl_stmt|;
name|boolean
name|needRepeat
decl_stmt|;
name|int
name|iterationCount
decl_stmt|;
name|int
name|deletedDocGCCount
decl_stmt|;
name|int
name|deletedLeafDocGCCount
decl_stmt|;
name|int
name|splitDocGCCount
decl_stmt|;
name|int
name|intermediateSplitDocGCCount
decl_stmt|;
name|int
name|updateResurrectedGCCount
decl_stmt|;
specifier|final
name|TimeDurationFormatter
name|df
init|=
name|TimeDurationFormatter
operator|.
name|forLogging
argument_list|()
decl_stmt|;
specifier|final
name|Stopwatch
name|active
init|=
name|Stopwatch
operator|.
name|createUnstarted
argument_list|()
decl_stmt|;
specifier|final
name|Stopwatch
name|collectDeletedDocs
init|=
name|Stopwatch
operator|.
name|createUnstarted
argument_list|()
decl_stmt|;
specifier|final
name|Stopwatch
name|checkDeletedDocs
init|=
name|Stopwatch
operator|.
name|createUnstarted
argument_list|()
decl_stmt|;
specifier|final
name|Stopwatch
name|deleteDeletedDocs
init|=
name|Stopwatch
operator|.
name|createUnstarted
argument_list|()
decl_stmt|;
specifier|final
name|Stopwatch
name|collectAndDeleteSplitDocs
init|=
name|Stopwatch
operator|.
name|createUnstarted
argument_list|()
decl_stmt|;
specifier|final
name|Stopwatch
name|sortDocIds
init|=
name|Stopwatch
operator|.
name|createUnstarted
argument_list|()
decl_stmt|;
specifier|final
name|Stopwatch
name|updateResurrectedDocuments
init|=
name|Stopwatch
operator|.
name|createUnstarted
argument_list|()
decl_stmt|;
name|long
name|collectDeletedDocsElapsed
decl_stmt|,
name|checkDeletedDocsElapsed
decl_stmt|,
name|deleteDeletedDocsElapsed
decl_stmt|,
name|collectAndDeleteSplitDocsElapsed
decl_stmt|,
name|sortDocIdsElapsed
decl_stmt|,
name|updateResurrectedDocumentsElapsed
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|timings
decl_stmt|;
name|String
name|fmt
init|=
literal|"timeToCollectDeletedDocs=%s, timeToCheckDeletedDocs=%s, timeToSortDocIds=%s, timeTakenToUpdateResurrectedDocs=%s, timeTakenToDeleteDeletedDocs=%s, timeTakenToCollectAndDeleteSplitDocs=%s"
decl_stmt|;
comment|// aggregated timings?
if|if
condition|(
name|iterationCount
operator|>
literal|0
condition|)
block|{
name|timings
operator|=
name|String
operator|.
name|format
argument_list|(
name|fmt
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|collectDeletedDocsElapsed
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|checkDeletedDocsElapsed
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|sortDocIdsElapsed
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|updateResurrectedDocumentsElapsed
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|deleteDeletedDocsElapsed
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|collectAndDeleteSplitDocsElapsed
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timings
operator|=
name|String
operator|.
name|format
argument_list|(
name|fmt
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|collectDeletedDocs
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|checkDeletedDocs
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|sortDocIds
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|updateResurrectedDocuments
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|deleteDeletedDocs
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|collectAndDeleteSplitDocs
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|"VersionGCStats{"
operator|+
literal|"ignoredGCDueToCheckPoint="
operator|+
name|ignoredGCDueToCheckPoint
operator|+
literal|", canceled="
operator|+
name|canceled
operator|+
literal|", deletedDocGCCount="
operator|+
name|deletedDocGCCount
operator|+
literal|" (of which leaf: "
operator|+
name|deletedLeafDocGCCount
operator|+
literal|")"
operator|+
literal|", updateResurrectedGCCount="
operator|+
name|updateResurrectedGCCount
operator|+
literal|", splitDocGCCount="
operator|+
name|splitDocGCCount
operator|+
literal|", intermediateSplitDocGCCount="
operator|+
name|intermediateSplitDocGCCount
operator|+
literal|", iterationCount="
operator|+
name|iterationCount
operator|+
literal|", timeActive="
operator|+
name|df
operator|.
name|format
argument_list|(
name|active
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
argument_list|,
name|MICROSECONDS
argument_list|)
operator|+
literal|", "
operator|+
name|timings
operator|+
literal|"}"
return|;
block|}
name|void
name|addRun
parameter_list|(
name|VersionGCStats
name|run
parameter_list|)
block|{
operator|++
name|iterationCount
expr_stmt|;
name|this
operator|.
name|ignoredGCDueToCheckPoint
operator|=
name|run
operator|.
name|ignoredGCDueToCheckPoint
expr_stmt|;
name|this
operator|.
name|canceled
operator|=
name|run
operator|.
name|canceled
expr_stmt|;
name|this
operator|.
name|limitExceeded
operator|=
name|run
operator|.
name|limitExceeded
expr_stmt|;
name|this
operator|.
name|needRepeat
operator|=
name|run
operator|.
name|needRepeat
expr_stmt|;
name|this
operator|.
name|deletedDocGCCount
operator|+=
name|run
operator|.
name|deletedDocGCCount
expr_stmt|;
name|this
operator|.
name|deletedLeafDocGCCount
operator|+=
name|run
operator|.
name|deletedLeafDocGCCount
expr_stmt|;
name|this
operator|.
name|splitDocGCCount
operator|+=
name|run
operator|.
name|splitDocGCCount
expr_stmt|;
name|this
operator|.
name|intermediateSplitDocGCCount
operator|+=
name|run
operator|.
name|intermediateSplitDocGCCount
expr_stmt|;
name|this
operator|.
name|updateResurrectedGCCount
operator|+=
name|run
operator|.
name|updateResurrectedGCCount
expr_stmt|;
name|this
operator|.
name|collectDeletedDocsElapsed
operator|+=
name|run
operator|.
name|collectDeletedDocs
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
expr_stmt|;
name|this
operator|.
name|checkDeletedDocsElapsed
operator|+=
name|run
operator|.
name|checkDeletedDocs
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
expr_stmt|;
name|this
operator|.
name|deleteDeletedDocsElapsed
operator|+=
name|run
operator|.
name|deleteDeletedDocs
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
expr_stmt|;
name|this
operator|.
name|collectAndDeleteSplitDocsElapsed
operator|+=
name|run
operator|.
name|collectAndDeleteSplitDocs
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
expr_stmt|;
name|this
operator|.
name|sortDocIdsElapsed
operator|+=
name|run
operator|.
name|sortDocIds
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
expr_stmt|;
name|this
operator|.
name|updateResurrectedDocumentsElapsed
operator|+=
name|run
operator|.
name|updateResurrectedDocuments
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
enum|enum
name|GCPhase
block|{
name|NONE
block|,
name|COLLECTING
block|,
name|CHECKING
block|,
name|DELETING
block|,
name|SORTING
block|,
name|SPLITS_CLEANUP
block|,
name|UPDATING
block|}
comment|/**      * Keeps track of timers when switching GC phases.      *<p>      * Could be merged with VersionGCStats, however this way the public class is kept unchanged.      */
specifier|private
specifier|static
class|class
name|GCPhases
block|{
specifier|final
name|VersionGCStats
name|stats
decl_stmt|;
specifier|final
name|Stopwatch
name|elapsed
decl_stmt|;
specifier|private
specifier|final
name|GCMonitor
name|monitor
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|GCPhase
argument_list|>
name|phases
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|GCPhase
argument_list|,
name|Stopwatch
argument_list|>
name|watches
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|canceled
decl_stmt|;
name|GCPhases
parameter_list|(
name|AtomicBoolean
name|canceled
parameter_list|,
name|VersionGCStats
name|stats
parameter_list|,
name|GCMonitor
name|monitor
parameter_list|)
block|{
name|this
operator|.
name|stats
operator|=
name|stats
expr_stmt|;
name|this
operator|.
name|monitor
operator|=
name|monitor
expr_stmt|;
name|this
operator|.
name|elapsed
operator|=
name|Stopwatch
operator|.
name|createStarted
argument_list|()
expr_stmt|;
name|this
operator|.
name|watches
operator|.
name|put
argument_list|(
name|GCPhase
operator|.
name|NONE
argument_list|,
name|Stopwatch
operator|.
name|createStarted
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|watches
operator|.
name|put
argument_list|(
name|GCPhase
operator|.
name|COLLECTING
argument_list|,
name|stats
operator|.
name|collectDeletedDocs
argument_list|)
expr_stmt|;
name|this
operator|.
name|watches
operator|.
name|put
argument_list|(
name|GCPhase
operator|.
name|CHECKING
argument_list|,
name|stats
operator|.
name|checkDeletedDocs
argument_list|)
expr_stmt|;
name|this
operator|.
name|watches
operator|.
name|put
argument_list|(
name|GCPhase
operator|.
name|DELETING
argument_list|,
name|stats
operator|.
name|deleteDeletedDocs
argument_list|)
expr_stmt|;
name|this
operator|.
name|watches
operator|.
name|put
argument_list|(
name|GCPhase
operator|.
name|SORTING
argument_list|,
name|stats
operator|.
name|sortDocIds
argument_list|)
expr_stmt|;
name|this
operator|.
name|watches
operator|.
name|put
argument_list|(
name|GCPhase
operator|.
name|SPLITS_CLEANUP
argument_list|,
name|stats
operator|.
name|collectAndDeleteSplitDocs
argument_list|)
expr_stmt|;
name|this
operator|.
name|watches
operator|.
name|put
argument_list|(
name|GCPhase
operator|.
name|UPDATING
argument_list|,
name|stats
operator|.
name|updateResurrectedDocuments
argument_list|)
expr_stmt|;
name|this
operator|.
name|canceled
operator|=
name|canceled
expr_stmt|;
block|}
comment|/**          * Attempts to start a GC phase and tracks the time spent in this phase          * until {@link #stop(GCPhase)} is called.          *          * @param started the GC phase.          * @return {@code true} if the phase was started or {@code false} if the          *          revision GC was canceled and the phase should not start.          */
specifier|public
name|boolean
name|start
parameter_list|(
name|GCPhase
name|started
parameter_list|)
block|{
if|if
condition|(
name|canceled
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|suspend
argument_list|(
name|currentWatch
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|phases
operator|.
name|add
argument_list|(
name|started
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|()
expr_stmt|;
name|resume
argument_list|(
name|currentWatch
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|void
name|stop
parameter_list|(
name|GCPhase
name|phase
parameter_list|)
block|{
if|if
condition|(
operator|!
name|phases
operator|.
name|isEmpty
argument_list|()
operator|&&
name|phase
operator|==
name|phases
operator|.
name|get
argument_list|(
name|phases
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
condition|)
block|{
name|suspend
argument_list|(
name|currentWatch
argument_list|()
argument_list|)
expr_stmt|;
name|phases
operator|.
name|remove
argument_list|(
name|phases
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|()
expr_stmt|;
name|resume
argument_list|(
name|currentWatch
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
while|while
condition|(
operator|!
name|phases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|suspend
argument_list|(
name|currentWatch
argument_list|()
argument_list|)
expr_stmt|;
name|phases
operator|.
name|remove
argument_list|(
name|phases
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|elapsed
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
specifier|private
name|GCPhase
name|current
parameter_list|()
block|{
return|return
name|phases
operator|.
name|isEmpty
argument_list|()
condition|?
name|GCPhase
operator|.
name|NONE
else|:
name|phases
operator|.
name|get
argument_list|(
name|phases
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
specifier|private
name|Stopwatch
name|currentWatch
parameter_list|()
block|{
return|return
name|watches
operator|.
name|get
argument_list|(
name|current
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|void
name|resume
parameter_list|(
name|Stopwatch
name|w
parameter_list|)
block|{
if|if
condition|(
operator|!
name|w
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|w
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|suspend
parameter_list|(
name|Stopwatch
name|w
parameter_list|)
block|{
if|if
condition|(
name|w
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|w
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|updateStatus
parameter_list|()
block|{
name|GCPhase
name|p
init|=
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|GCPhase
operator|.
name|NONE
condition|)
block|{
name|monitor
operator|.
name|updateStatus
argument_list|(
name|p
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
class|class
name|GCJob
block|{
specifier|private
specifier|final
name|long
name|maxRevisionAgeMillis
decl_stmt|;
specifier|private
specifier|final
name|VersionGCOptions
name|options
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|cancel
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|GCMonitor
name|monitor
decl_stmt|;
specifier|private
specifier|final
name|Supplier
argument_list|<
name|String
argument_list|>
name|status
decl_stmt|;
name|GCJob
parameter_list|(
name|long
name|maxRevisionAgeMillis
parameter_list|,
name|VersionGCOptions
name|options
parameter_list|,
name|GCMonitor
name|gcMonitor
parameter_list|)
block|{
name|this
operator|.
name|maxRevisionAgeMillis
operator|=
name|maxRevisionAgeMillis
expr_stmt|;
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|GCMessageTracker
name|vgcm
init|=
operator|new
name|GCMessageTracker
argument_list|()
decl_stmt|;
name|this
operator|.
name|status
operator|=
name|vgcm
expr_stmt|;
name|this
operator|.
name|monitor
operator|=
operator|new
name|DelegatingGCMonitor
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|vgcm
argument_list|,
name|gcMonitor
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|monitor
operator|.
name|updateStatus
argument_list|(
name|STATUS_INITIALIZING
argument_list|)
expr_stmt|;
block|}
name|VersionGCStats
name|run
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|gc
argument_list|(
name|maxRevisionAgeMillis
argument_list|)
return|;
block|}
finally|finally
block|{
name|monitor
operator|.
name|updateStatus
argument_list|(
name|STATUS_IDLE
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|cancel
parameter_list|()
block|{
name|monitor
operator|.
name|info
argument_list|(
literal|"Canceling revision garbage collection."
argument_list|)
expr_stmt|;
name|cancel
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|String
name|getStatus
parameter_list|()
block|{
return|return
name|status
operator|.
name|get
argument_list|()
return|;
block|}
specifier|private
name|VersionGCStats
name|gc
parameter_list|(
name|long
name|maxRevisionAgeInMillis
parameter_list|)
throws|throws
name|IOException
block|{
name|VersionGCStats
name|stats
init|=
operator|new
name|VersionGCStats
argument_list|()
decl_stmt|;
name|stats
operator|.
name|active
operator|.
name|start
argument_list|()
expr_stmt|;
name|Recommendations
name|rec
init|=
operator|new
name|Recommendations
argument_list|(
name|maxRevisionAgeInMillis
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|GCPhases
name|phases
init|=
operator|new
name|GCPhases
argument_list|(
name|cancel
argument_list|,
name|stats
argument_list|,
name|gcMonitor
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|rec
operator|.
name|ignoreDueToCheckPoint
condition|)
block|{
name|phases
operator|.
name|stats
operator|.
name|ignoredGCDueToCheckPoint
operator|=
literal|true
expr_stmt|;
name|monitor
operator|.
name|skipped
argument_list|(
literal|"Checkpoint prevented revision garbage collection"
argument_list|)
expr_stmt|;
name|cancel
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|RevisionVector
name|headRevision
init|=
name|nodeStore
operator|.
name|getHeadRevision
argument_list|()
decl_stmt|;
specifier|final
name|RevisionVector
name|sweepRevisions
init|=
name|nodeStore
operator|.
name|getSweepRevisions
argument_list|()
decl_stmt|;
name|monitor
operator|.
name|info
argument_list|(
literal|"Looking at revisions in {}"
argument_list|,
name|rec
operator|.
name|scope
argument_list|)
expr_stmt|;
name|collectDeletedDocuments
argument_list|(
name|phases
argument_list|,
name|headRevision
argument_list|,
name|rec
argument_list|)
expr_stmt|;
name|collectSplitDocuments
argument_list|(
name|phases
argument_list|,
name|sweepRevisions
argument_list|,
name|rec
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LimitExceededException
name|ex
parameter_list|)
block|{
name|stats
operator|.
name|limitExceeded
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|phases
operator|.
name|close
argument_list|()
expr_stmt|;
name|stats
operator|.
name|canceled
operator|=
name|cancel
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
name|rec
operator|.
name|evaluate
argument_list|(
name|stats
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|info
argument_list|(
literal|"Revision garbage collection finished in {}. {}"
argument_list|,
name|TimeDurationFormatter
operator|.
name|forLogging
argument_list|()
operator|.
name|format
argument_list|(
name|phases
operator|.
name|elapsed
operator|.
name|elapsed
argument_list|(
name|MICROSECONDS
argument_list|)
argument_list|,
name|MICROSECONDS
argument_list|)
argument_list|,
name|stats
argument_list|)
expr_stmt|;
name|stats
operator|.
name|active
operator|.
name|stop
argument_list|()
expr_stmt|;
return|return
name|stats
return|;
block|}
specifier|private
name|void
name|collectSplitDocuments
parameter_list|(
name|GCPhases
name|phases
parameter_list|,
name|RevisionVector
name|sweepRevisions
parameter_list|,
name|Recommendations
name|rec
parameter_list|)
block|{
if|if
condition|(
name|phases
operator|.
name|start
argument_list|(
name|GCPhase
operator|.
name|SPLITS_CLEANUP
argument_list|)
condition|)
block|{
name|int
name|splitDocGCCount
init|=
name|phases
operator|.
name|stats
operator|.
name|splitDocGCCount
decl_stmt|;
name|int
name|intermediateSplitDocGCCount
init|=
name|phases
operator|.
name|stats
operator|.
name|intermediateSplitDocGCCount
decl_stmt|;
name|versionStore
operator|.
name|deleteSplitDocuments
argument_list|(
name|GC_TYPES
argument_list|,
name|sweepRevisions
argument_list|,
name|rec
operator|.
name|scope
operator|.
name|toMs
argument_list|,
name|phases
operator|.
name|stats
argument_list|)
expr_stmt|;
name|gcStats
operator|.
name|splitDocumentsDeleted
argument_list|(
name|phases
operator|.
name|stats
operator|.
name|splitDocGCCount
operator|-
name|splitDocGCCount
argument_list|)
expr_stmt|;
name|gcStats
operator|.
name|intermediateSplitDocumentsDeleted
argument_list|(
name|phases
operator|.
name|stats
operator|.
name|intermediateSplitDocGCCount
operator|-
name|intermediateSplitDocGCCount
argument_list|)
expr_stmt|;
name|phases
operator|.
name|stop
argument_list|(
name|GCPhase
operator|.
name|SPLITS_CLEANUP
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|collectDeletedDocuments
parameter_list|(
name|GCPhases
name|phases
parameter_list|,
name|RevisionVector
name|headRevision
parameter_list|,
name|Recommendations
name|rec
parameter_list|)
throws|throws
name|IOException
throws|,
name|LimitExceededException
block|{
name|int
name|docsTraversed
init|=
literal|0
decl_stmt|;
name|DeletedDocsGC
name|gc
init|=
operator|new
name|DeletedDocsGC
argument_list|(
name|headRevision
argument_list|,
name|cancel
argument_list|,
name|options
argument_list|,
name|monitor
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|phases
operator|.
name|start
argument_list|(
name|GCPhase
operator|.
name|COLLECTING
argument_list|)
condition|)
block|{
name|Iterable
argument_list|<
name|NodeDocument
argument_list|>
name|itr
init|=
name|versionStore
operator|.
name|getPossiblyDeletedDocs
argument_list|(
name|rec
operator|.
name|scope
operator|.
name|fromMs
argument_list|,
name|rec
operator|.
name|scope
operator|.
name|toMs
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|NodeDocument
name|doc
range|:
name|itr
control|)
block|{
comment|// continue with GC?
if|if
condition|(
name|cancel
operator|.
name|get
argument_list|()
condition|)
block|{
break|break;
block|}
comment|// Check if node is actually deleted at current revision
comment|// As node is not modified since oldestRevTimeStamp then
comment|// this node has not be revived again in past maxRevisionAge
comment|// So deleting it is safe
name|docsTraversed
operator|++
expr_stmt|;
if|if
condition|(
name|docsTraversed
operator|%
name|PROGRESS_BATCH_SIZE
operator|==
literal|0
condition|)
block|{
name|monitor
operator|.
name|info
argument_list|(
literal|"Iterated through {} documents so far. {} found to be deleted"
argument_list|,
name|docsTraversed
argument_list|,
name|gc
operator|.
name|getNumDocuments
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phases
operator|.
name|start
argument_list|(
name|GCPhase
operator|.
name|CHECKING
argument_list|)
condition|)
block|{
name|gc
operator|.
name|possiblyDeleted
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|phases
operator|.
name|stop
argument_list|(
name|GCPhase
operator|.
name|CHECKING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rec
operator|.
name|maxCollect
operator|>
literal|0
operator|&&
name|gc
operator|.
name|docIdsToDelete
operator|.
name|getSize
argument_list|()
operator|>
name|rec
operator|.
name|maxCollect
condition|)
block|{
throw|throw
operator|new
name|LimitExceededException
argument_list|()
throw|;
block|}
if|if
condition|(
name|gc
operator|.
name|hasLeafBatch
argument_list|()
condition|)
block|{
if|if
condition|(
name|phases
operator|.
name|start
argument_list|(
name|GCPhase
operator|.
name|DELETING
argument_list|)
condition|)
block|{
name|gc
operator|.
name|removeLeafDocuments
argument_list|(
name|phases
operator|.
name|stats
argument_list|)
expr_stmt|;
name|phases
operator|.
name|stop
argument_list|(
name|GCPhase
operator|.
name|DELETING
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gc
operator|.
name|hasRescurrectUpdateBatch
argument_list|()
condition|)
block|{
if|if
condition|(
name|phases
operator|.
name|start
argument_list|(
name|GCPhase
operator|.
name|UPDATING
argument_list|)
condition|)
block|{
name|gc
operator|.
name|updateResurrectedDocuments
argument_list|(
name|phases
operator|.
name|stats
argument_list|)
expr_stmt|;
name|phases
operator|.
name|stop
argument_list|(
name|GCPhase
operator|.
name|UPDATING
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|Utils
operator|.
name|closeIfCloseable
argument_list|(
name|itr
argument_list|)
expr_stmt|;
block|}
name|phases
operator|.
name|stop
argument_list|(
name|GCPhase
operator|.
name|COLLECTING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gc
operator|.
name|getNumDocuments
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|phases
operator|.
name|start
argument_list|(
name|GCPhase
operator|.
name|DELETING
argument_list|)
condition|)
block|{
name|gc
operator|.
name|removeLeafDocuments
argument_list|(
name|phases
operator|.
name|stats
argument_list|)
expr_stmt|;
name|phases
operator|.
name|stop
argument_list|(
name|GCPhase
operator|.
name|DELETING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phases
operator|.
name|start
argument_list|(
name|GCPhase
operator|.
name|SORTING
argument_list|)
condition|)
block|{
name|gc
operator|.
name|ensureSorted
argument_list|()
expr_stmt|;
name|phases
operator|.
name|stop
argument_list|(
name|GCPhase
operator|.
name|SORTING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phases
operator|.
name|start
argument_list|(
name|GCPhase
operator|.
name|DELETING
argument_list|)
condition|)
block|{
name|gc
operator|.
name|removeDocuments
argument_list|(
name|phases
operator|.
name|stats
argument_list|)
expr_stmt|;
name|phases
operator|.
name|stop
argument_list|(
name|GCPhase
operator|.
name|DELETING
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|phases
operator|.
name|start
argument_list|(
name|GCPhase
operator|.
name|UPDATING
argument_list|)
condition|)
block|{
name|gc
operator|.
name|updateResurrectedDocuments
argument_list|(
name|phases
operator|.
name|stats
argument_list|)
expr_stmt|;
name|phases
operator|.
name|stop
argument_list|(
name|GCPhase
operator|.
name|UPDATING
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|gc
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * A helper class to remove document for deleted nodes.      */
specifier|private
class|class
name|DeletedDocsGC
implements|implements
name|Closeable
block|{
specifier|private
specifier|final
name|RevisionVector
name|headRevision
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|cancel
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|leafDocIdsToDelete
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|resurrectedIds
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|StringSort
name|docIdsToDelete
decl_stmt|;
specifier|private
specifier|final
name|StringSort
name|prevDocIdsToDelete
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|exclude
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|sorted
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|Stopwatch
name|timer
decl_stmt|;
specifier|private
specifier|final
name|VersionGCOptions
name|options
decl_stmt|;
specifier|private
specifier|final
name|GCMonitor
name|monitor
decl_stmt|;
specifier|public
name|DeletedDocsGC
parameter_list|(
annotation|@
name|Nonnull
name|RevisionVector
name|headRevision
parameter_list|,
annotation|@
name|Nonnull
name|AtomicBoolean
name|cancel
parameter_list|,
annotation|@
name|Nonnull
name|VersionGCOptions
name|options
parameter_list|,
annotation|@
name|Nonnull
name|GCMonitor
name|monitor
parameter_list|)
block|{
name|this
operator|.
name|headRevision
operator|=
name|checkNotNull
argument_list|(
name|headRevision
argument_list|)
expr_stmt|;
name|this
operator|.
name|cancel
operator|=
name|checkNotNull
argument_list|(
name|cancel
argument_list|)
expr_stmt|;
name|this
operator|.
name|timer
operator|=
name|Stopwatch
operator|.
name|createUnstarted
argument_list|()
expr_stmt|;
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|this
operator|.
name|monitor
operator|=
name|monitor
expr_stmt|;
name|this
operator|.
name|docIdsToDelete
operator|=
name|newStringSort
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|this
operator|.
name|prevDocIdsToDelete
operator|=
name|newStringSort
argument_list|(
name|options
argument_list|)
expr_stmt|;
block|}
comment|/**          * @return the number of documents gathers so far that have been          * identified as garbage via {@link #possiblyDeleted(NodeDocument)}.          * This number does not include the previous documents.          */
name|long
name|getNumDocuments
parameter_list|()
block|{
return|return
name|docIdsToDelete
operator|.
name|getSize
argument_list|()
operator|+
name|leafDocIdsToDelete
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Informs the GC that the given document is possibly deleted. The          * implementation will check if the node still exists at the head          * revision passed to the constructor to this GC. The implementation          * will keep track of documents representing deleted nodes and remove          * them together with associated previous document          *          * @param doc the candidate document.          * @return true iff document is scheduled for deletion          */
name|boolean
name|possiblyDeleted
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|gcStats
operator|.
name|documentRead
argument_list|()
expr_stmt|;
comment|// construct an id that also contains
comment|// the _modified time of the document
name|String
name|id
init|=
name|doc
operator|.
name|getId
argument_list|()
operator|+
literal|"/"
operator|+
name|doc
operator|.
name|getModified
argument_list|()
decl_stmt|;
comment|// check if id is valid
try|try
block|{
name|Utils
operator|.
name|getDepthFromId
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|monitor
operator|.
name|warn
argument_list|(
literal|"Invalid GC id {} for document {}"
argument_list|,
name|id
argument_list|,
name|doc
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|doc
operator|.
name|getNodeAtRevision
argument_list|(
name|nodeStore
argument_list|,
name|headRevision
argument_list|,
literal|null
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// Collect id of all previous docs also
name|Iterator
argument_list|<
name|String
argument_list|>
name|previousDocs
init|=
name|previousDocIdsFor
argument_list|(
name|doc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|doc
operator|.
name|hasChildren
argument_list|()
operator|&&
operator|!
name|previousDocs
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|addLeafDocument
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addDocument
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|addPreviousDocuments
argument_list|(
name|previousDocs
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
name|addNonDeletedDocument
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**          * Removes the documents that have been identified as garbage. This          * also includes previous documents. This method will only remove          * documents that have not been modified since they were passed to          * {@link #possiblyDeleted(NodeDocument)}.          *          * @param stats to track the number of removed documents.          */
name|void
name|removeDocuments
parameter_list|(
name|VersionGCStats
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
name|removeLeafDocuments
argument_list|(
name|stats
argument_list|)
expr_stmt|;
name|stats
operator|.
name|deletedDocGCCount
operator|+=
name|removeDeletedDocuments
argument_list|(
name|getDocIdsToDelete
argument_list|()
argument_list|,
name|getDocIdsToDeleteSize
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|"(other)"
argument_list|)
expr_stmt|;
comment|// FIXME: this is incorrect because that method also removes intermediate docs
name|stats
operator|.
name|splitDocGCCount
operator|+=
name|removeDeletedPreviousDocuments
argument_list|()
expr_stmt|;
block|}
name|boolean
name|hasLeafBatch
parameter_list|()
block|{
return|return
name|leafDocIdsToDelete
operator|.
name|size
argument_list|()
operator|>=
name|DELETE_BATCH_SIZE
return|;
block|}
name|boolean
name|hasRescurrectUpdateBatch
parameter_list|()
block|{
return|return
name|resurrectedIds
operator|.
name|size
argument_list|()
operator|>=
name|UPDATE_BATCH_SIZE
return|;
block|}
name|void
name|removeLeafDocuments
parameter_list|(
name|VersionGCStats
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|removeCount
init|=
name|removeDeletedDocuments
argument_list|(
name|getLeafDocIdsToDelete
argument_list|()
argument_list|,
name|getLeafDocIdsToDeleteSize
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|"(leaf)"
argument_list|)
decl_stmt|;
name|leafDocIdsToDelete
operator|.
name|clear
argument_list|()
expr_stmt|;
name|stats
operator|.
name|deletedLeafDocGCCount
operator|+=
name|removeCount
expr_stmt|;
name|stats
operator|.
name|deletedDocGCCount
operator|+=
name|removeCount
expr_stmt|;
block|}
name|void
name|updateResurrectedDocuments
parameter_list|(
name|VersionGCStats
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|resurrectedIds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|int
name|updateCount
init|=
name|resetDeletedOnce
argument_list|(
name|resurrectedIds
argument_list|)
decl_stmt|;
name|resurrectedIds
operator|.
name|clear
argument_list|()
expr_stmt|;
name|stats
operator|.
name|updateResurrectedGCCount
operator|+=
name|updateCount
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
try|try
block|{
name|docIdsToDelete
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|monitor
operator|.
name|warn
argument_list|(
literal|"Failed to close docIdsToDelete: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|prevDocIdsToDelete
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|monitor
operator|.
name|warn
argument_list|(
literal|"Failed to close prevDocIdsToDelete: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|//------------------------------< internal>----------------------------
specifier|private
name|void
name|delayOnModifications
parameter_list|(
name|long
name|durationMs
parameter_list|)
block|{
name|long
name|delayMs
init|=
name|Math
operator|.
name|round
argument_list|(
name|durationMs
operator|*
name|options
operator|.
name|delayFactor
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cancel
operator|.
name|get
argument_list|()
operator|&&
name|delayMs
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Clock
name|clock
init|=
name|nodeStore
operator|.
name|getClock
argument_list|()
decl_stmt|;
name|clock
operator|.
name|waitUntil
argument_list|(
name|clock
operator|.
name|getTime
argument_list|()
operator|+
name|delayMs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
comment|/* ignore */
block|}
block|}
block|}
specifier|private
name|Iterator
argument_list|<
name|String
argument_list|>
name|previousDocIdsFor
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
block|{
name|Map
argument_list|<
name|Revision
argument_list|,
name|Range
argument_list|>
name|prevRanges
init|=
name|doc
operator|.
name|getPreviousRanges
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|prevRanges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Iterators
operator|.
name|emptyIterator
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|all
argument_list|(
name|prevRanges
operator|.
name|values
argument_list|()
argument_list|,
name|FIRST_LEVEL
argument_list|)
condition|)
block|{
comment|// all previous document ids can be constructed from the
comment|// previous ranges map. this works for first level previous
comment|// documents only.
specifier|final
name|String
name|path
init|=
name|doc
operator|.
name|getPath
argument_list|()
decl_stmt|;
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|prevRanges
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Revision
argument_list|,
name|Range
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|Revision
argument_list|,
name|Range
argument_list|>
name|input
parameter_list|)
block|{
name|int
name|h
init|=
name|input
operator|.
name|getValue
argument_list|()
operator|.
name|getHeight
argument_list|()
decl_stmt|;
return|return
name|Utils
operator|.
name|getPreviousIdFor
argument_list|(
name|path
argument_list|,
name|input
operator|.
name|getKey
argument_list|()
argument_list|,
name|h
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
else|else
block|{
comment|// need to fetch the previous documents to get their ids
return|return
name|Iterators
operator|.
name|transform
argument_list|(
name|doc
operator|.
name|getAllPreviousDocs
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|NodeDocument
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|NodeDocument
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getId
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
block|}
specifier|private
name|void
name|addDocument
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|IOException
block|{
name|docIdsToDelete
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addLeafDocument
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|IOException
block|{
name|leafDocIdsToDelete
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addNonDeletedDocument
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|IOException
block|{
name|resurrectedIds
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
specifier|private
name|long
name|getNumPreviousDocuments
parameter_list|()
block|{
return|return
name|prevDocIdsToDelete
operator|.
name|getSize
argument_list|()
operator|-
name|exclude
operator|.
name|size
argument_list|()
return|;
block|}
specifier|private
name|void
name|addPreviousDocuments
parameter_list|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|ids
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|prevDocIdsToDelete
operator|.
name|add
argument_list|(
name|ids
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Iterator
argument_list|<
name|String
argument_list|>
name|getDocIdsToDelete
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureSorted
argument_list|()
expr_stmt|;
return|return
name|docIdsToDelete
operator|.
name|getIds
argument_list|()
return|;
block|}
specifier|private
name|long
name|getDocIdsToDeleteSize
parameter_list|()
block|{
return|return
name|docIdsToDelete
operator|.
name|getSize
argument_list|()
return|;
block|}
specifier|private
name|Iterator
argument_list|<
name|String
argument_list|>
name|getLeafDocIdsToDelete
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|leafDocIdsToDelete
operator|.
name|iterator
argument_list|()
return|;
block|}
specifier|private
name|long
name|getLeafDocIdsToDeleteSize
parameter_list|()
block|{
return|return
name|leafDocIdsToDelete
operator|.
name|size
argument_list|()
return|;
block|}
specifier|private
name|void
name|concurrentModification
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
block|{
name|Iterator
argument_list|<
name|NodeDocument
argument_list|>
name|it
init|=
name|doc
operator|.
name|getAllPreviousDocs
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|exclude
operator|.
name|add
argument_list|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Iterator
argument_list|<
name|String
argument_list|>
name|getPrevDocIdsToDelete
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureSorted
argument_list|()
expr_stmt|;
return|return
name|Iterators
operator|.
name|filter
argument_list|(
name|prevDocIdsToDelete
operator|.
name|getIds
argument_list|()
argument_list|,
operator|new
name|Predicate
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
operator|!
name|exclude
operator|.
name|contains
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|private
name|int
name|removeDeletedDocuments
parameter_list|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|docIdsToDelete
parameter_list|,
name|long
name|numDocuments
parameter_list|,
name|boolean
name|leaves
parameter_list|,
name|String
name|label
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|numDocuments
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|monitor
operator|.
name|info
argument_list|(
literal|"Proceeding to delete [{}] documents [{}]"
argument_list|,
name|numDocuments
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|idListItr
init|=
name|partition
argument_list|(
name|docIdsToDelete
argument_list|,
name|DELETE_BATCH_SIZE
argument_list|)
decl_stmt|;
name|int
name|deletedCount
init|=
literal|0
decl_stmt|;
name|int
name|lastLoggedCount
init|=
literal|0
decl_stmt|;
name|int
name|recreatedCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|idListItr
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|cancel
operator|.
name|get
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
name|deletionBatch
init|=
name|Maps
operator|.
name|newLinkedHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|idListItr
operator|.
name|next
argument_list|()
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|parsed
decl_stmt|;
try|try
block|{
name|parsed
operator|=
name|parseEntry
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|monitor
operator|.
name|warn
argument_list|(
literal|"Invalid _modified suffix for {}"
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|deletionBatch
operator|.
name|put
argument_list|(
name|parsed
operator|.
name|getKey
argument_list|()
argument_list|,
name|singletonMap
argument_list|(
name|KEY_MODIFIED
argument_list|,
name|newEqualsCondition
argument_list|(
name|parsed
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Performing batch deletion of documents with following ids. \n"
argument_list|)
decl_stmt|;
name|Joiner
operator|.
name|on
argument_list|(
name|LINE_SEPARATOR
operator|.
name|value
argument_list|()
argument_list|)
operator|.
name|appendTo
argument_list|(
name|sb
argument_list|,
name|deletionBatch
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|timer
operator|.
name|reset
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|nRemoved
init|=
name|ds
operator|.
name|remove
argument_list|(
name|NODES
argument_list|,
name|deletionBatch
argument_list|)
decl_stmt|;
if|if
condition|(
name|nRemoved
operator|<
name|deletionBatch
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// some nodes were re-created while GC was running
comment|// find the document that still exist
for|for
control|(
name|String
name|id
range|:
name|deletionBatch
operator|.
name|keySet
argument_list|()
control|)
block|{
name|NodeDocument
name|d
init|=
name|ds
operator|.
name|find
argument_list|(
name|NODES
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
block|{
name|concurrentModification
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
name|recreatedCount
operator|+=
operator|(
name|deletionBatch
operator|.
name|size
argument_list|()
operator|-
name|nRemoved
operator|)
expr_stmt|;
block|}
name|deletedCount
operator|+=
name|nRemoved
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Deleted [{}] documents so far"
argument_list|,
name|deletedCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|leaves
condition|)
block|{
name|gcStats
operator|.
name|leafDocumentsDeleted
argument_list|(
name|deletedCount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcStats
operator|.
name|documentsDeleted
argument_list|(
name|deletedCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deletedCount
operator|+
name|recreatedCount
operator|-
name|lastLoggedCount
operator|>=
name|PROGRESS_BATCH_SIZE
condition|)
block|{
name|lastLoggedCount
operator|=
name|deletedCount
operator|+
name|recreatedCount
expr_stmt|;
name|double
name|progress
init|=
name|lastLoggedCount
operator|*
literal|1.0
operator|/
name|getNumDocuments
argument_list|()
operator|*
literal|100
decl_stmt|;
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Deleted %d (%1.2f%%) documents so far"
argument_list|,
name|deletedCount
argument_list|,
name|progress
argument_list|)
decl_stmt|;
name|monitor
operator|.
name|info
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|delayOnModifications
argument_list|(
name|timer
operator|.
name|stop
argument_list|()
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|deletedCount
return|;
block|}
specifier|private
name|int
name|resetDeletedOnce
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|resurrectedDocuments
parameter_list|)
throws|throws
name|IOException
block|{
name|monitor
operator|.
name|info
argument_list|(
literal|"Proceeding to reset [{}] _deletedOnce flags"
argument_list|,
name|resurrectedDocuments
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|updateCount
init|=
literal|0
decl_stmt|;
name|timer
operator|.
name|reset
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|String
name|s
range|:
name|resurrectedDocuments
control|)
block|{
if|if
condition|(
operator|!
name|cancel
operator|.
name|get
argument_list|()
condition|)
block|{
try|try
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|parsed
init|=
name|parseEntry
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|UpdateOp
name|up
init|=
operator|new
name|UpdateOp
argument_list|(
name|parsed
operator|.
name|getKey
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|up
operator|.
name|equals
argument_list|(
name|MODIFIED_IN_SECS
argument_list|,
name|parsed
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|up
operator|.
name|remove
argument_list|(
name|NodeDocument
operator|.
name|DELETED_ONCE
argument_list|)
expr_stmt|;
name|NodeDocument
name|r
init|=
name|ds
operator|.
name|findAndUpdate
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
name|up
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|updateCount
operator|+=
literal|1
expr_stmt|;
name|gcStats
operator|.
name|deletedOnceFlagReset
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
name|monitor
operator|.
name|warn
argument_list|(
literal|"Invalid _modified suffix for {}"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|ex
parameter_list|)
block|{
name|monitor
operator|.
name|warn
argument_list|(
literal|"updating {}: {}"
argument_list|,
name|s
argument_list|,
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|delayOnModifications
argument_list|(
name|timer
operator|.
name|stop
argument_list|()
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|updateCount
return|;
block|}
specifier|private
name|int
name|removeDeletedPreviousDocuments
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|num
init|=
name|getNumPreviousDocuments
argument_list|()
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|monitor
operator|.
name|info
argument_list|(
literal|"Proceeding to delete [{}] previous documents"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|int
name|deletedCount
init|=
literal|0
decl_stmt|;
name|int
name|lastLoggedCount
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|idListItr
init|=
name|partition
argument_list|(
name|getPrevDocIdsToDelete
argument_list|()
argument_list|,
name|DELETE_BATCH_SIZE
argument_list|)
decl_stmt|;
while|while
condition|(
name|idListItr
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|cancel
operator|.
name|get
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|deletionBatch
init|=
name|idListItr
operator|.
name|next
argument_list|()
decl_stmt|;
name|deletedCount
operator|+=
name|deletionBatch
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Performing batch deletion of previous documents with following ids. \n"
argument_list|)
decl_stmt|;
name|Joiner
operator|.
name|on
argument_list|(
name|LINE_SEPARATOR
operator|.
name|value
argument_list|()
argument_list|)
operator|.
name|appendTo
argument_list|(
name|sb
argument_list|,
name|deletionBatch
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ds
operator|.
name|remove
argument_list|(
name|NODES
argument_list|,
name|deletionBatch
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Deleted [{}] previous documents so far"
argument_list|,
name|deletedCount
argument_list|)
expr_stmt|;
name|gcStats
operator|.
name|splitDocumentsDeleted
argument_list|(
name|deletedCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|deletedCount
operator|-
name|lastLoggedCount
operator|>=
name|PROGRESS_BATCH_SIZE
condition|)
block|{
name|lastLoggedCount
operator|=
name|deletedCount
expr_stmt|;
name|double
name|progress
init|=
name|deletedCount
operator|*
literal|1.0
operator|/
operator|(
name|prevDocIdsToDelete
operator|.
name|getSize
argument_list|()
operator|-
name|exclude
operator|.
name|size
argument_list|()
operator|)
operator|*
literal|100
decl_stmt|;
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Deleted %d (%1.2f%%) previous documents so far"
argument_list|,
name|deletedCount
argument_list|,
name|progress
argument_list|)
decl_stmt|;
name|monitor
operator|.
name|info
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|deletedCount
return|;
block|}
specifier|private
name|void
name|ensureSorted
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|sorted
condition|)
block|{
name|docIdsToDelete
operator|.
name|sort
argument_list|()
expr_stmt|;
name|prevDocIdsToDelete
operator|.
name|sort
argument_list|()
expr_stmt|;
name|sorted
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**          * Parses an id/modified entry and returns the two components as a          * Map.Entry.          *          * @param entry the id/modified String.          * @return the parsed components.          * @throws IllegalArgumentException if the entry is malformed.          */
specifier|private
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|parseEntry
parameter_list|(
name|String
name|entry
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|int
name|idx
init|=
name|entry
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|entry
argument_list|)
throw|;
block|}
name|String
name|id
init|=
name|entry
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx
argument_list|)
decl_stmt|;
name|long
name|modified
decl_stmt|;
try|try
block|{
name|modified
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|entry
operator|.
name|substring
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|entry
argument_list|)
throw|;
block|}
return|return
name|Maps
operator|.
name|immutableEntry
argument_list|(
name|id
argument_list|,
name|modified
argument_list|)
return|;
block|}
block|}
annotation|@
name|Nonnull
specifier|private
name|StringSort
name|newStringSort
parameter_list|(
name|VersionGCOptions
name|options
parameter_list|)
block|{
return|return
operator|new
name|StringSort
argument_list|(
name|options
operator|.
name|overflowToDiskThreshold
argument_list|,
name|NodeDocumentIdComparator
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
specifier|private
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Range
argument_list|>
name|FIRST_LEVEL
init|=
operator|new
name|Predicate
argument_list|<
name|Range
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
annotation|@
name|Nullable
name|Range
name|input
parameter_list|)
block|{
return|return
name|input
operator|!=
literal|null
operator|&&
name|input
operator|.
name|height
operator|==
literal|0
return|;
block|}
block|}
decl_stmt|;
specifier|private
class|class
name|Recommendations
block|{
specifier|final
name|boolean
name|ignoreDueToCheckPoint
decl_stmt|;
specifier|final
name|TimeInterval
name|scope
decl_stmt|;
specifier|final
name|long
name|maxCollect
decl_stmt|;
specifier|final
name|long
name|deleteCandidateCount
decl_stmt|;
specifier|final
name|long
name|lastOldestTimestamp
decl_stmt|;
specifier|private
specifier|final
name|long
name|precisionMs
decl_stmt|;
specifier|private
specifier|final
name|long
name|suggestedIntervalMs
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|scopeIsComplete
decl_stmt|;
comment|/**          * Gives a recommendation about parameters for the next revision garbage collection run.          *<p>          * With the given maximum age of revisions to keep (earliest time in the past to collect),          * the desired precision in which times shall be sliced and the given limit on the number          * of collected documents in one run, calculate<ol>          *<li>if gc shall run at all (ignoreDueToCheckPoint)</li>          *<li>in which time interval documents shall be collected (scope)</li>          *<li>if collection should fail if it reaches maxCollect documents, maxCollect will specify          *     the limit or be 0 if no limit shall be enforced.</li>          *</ol>          * After a run, recommendations evaluate the result of the gc to update its persisted recommendations          * for future runs.          *<p>          * In the settings collection, recommendations keeps "revisionsOlderThan" from the last successful run.          * It also updates the time interval recommended for the next run.          *          * @param maxRevisionAgeMs the minimum age for revisions to be collected          * @param options options for running the gc          */
name|Recommendations
parameter_list|(
name|long
name|maxRevisionAgeMs
parameter_list|,
name|VersionGCOptions
name|options
parameter_list|)
block|{
name|TimeInterval
name|keep
init|=
operator|new
name|TimeInterval
argument_list|(
name|nodeStore
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
operator|-
name|maxRevisionAgeMs
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
name|boolean
name|ignoreDueToCheckPoint
init|=
literal|false
decl_stmt|;
name|long
name|deletedOnceCount
init|=
literal|0
decl_stmt|;
name|long
name|suggestedIntervalMs
decl_stmt|;
name|long
name|oldestPossible
decl_stmt|;
name|long
name|collectLimit
init|=
name|options
operator|.
name|collectLimit
decl_stmt|;
name|lastOldestTimestamp
operator|=
name|getLongSetting
argument_list|(
name|SETTINGS_COLLECTION_OLDEST_TIMESTAMP_PROP
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastOldestTimestamp
operator|==
literal|0
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No lastOldestTimestamp found, querying for the oldest deletedOnce candidate"
argument_list|)
expr_stmt|;
name|oldestPossible
operator|=
name|versionStore
operator|.
name|getOldestDeletedOnceTimestamp
argument_list|(
name|nodeStore
operator|.
name|getClock
argument_list|()
argument_list|,
name|options
operator|.
name|precisionMs
argument_list|)
operator|-
literal|1
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"lastOldestTimestamp found: {}"
argument_list|,
name|Utils
operator|.
name|timestampToString
argument_list|(
name|oldestPossible
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oldestPossible
operator|=
name|lastOldestTimestamp
operator|-
literal|1
expr_stmt|;
block|}
name|TimeInterval
name|scope
init|=
operator|new
name|TimeInterval
argument_list|(
name|oldestPossible
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
name|scope
operator|=
name|scope
operator|.
name|notLaterThan
argument_list|(
name|keep
operator|.
name|fromMs
argument_list|)
expr_stmt|;
name|suggestedIntervalMs
operator|=
name|getLongSetting
argument_list|(
name|SETTINGS_COLLECTION_REC_INTERVAL_PROP
argument_list|)
expr_stmt|;
if|if
condition|(
name|suggestedIntervalMs
operator|>
literal|0
condition|)
block|{
name|suggestedIntervalMs
operator|=
name|Math
operator|.
name|max
argument_list|(
name|suggestedIntervalMs
argument_list|,
name|options
operator|.
name|precisionMs
argument_list|)
expr_stmt|;
if|if
condition|(
name|suggestedIntervalMs
operator|<
name|scope
operator|.
name|getDurationMs
argument_list|()
condition|)
block|{
name|scope
operator|=
name|scope
operator|.
name|startAndDuration
argument_list|(
name|suggestedIntervalMs
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"previous runs recommend a {} sec duration, scope now {}"
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|toSeconds
argument_list|(
name|suggestedIntervalMs
argument_list|)
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Need to guess. Count the overall number of _deletedOnce documents. If those                  * are more than we want to collect in a single run, reduce the time scope so                  * that we likely see a fitting fraction of those documents.                  */
try|try
block|{
name|long
name|preferredLimit
init|=
name|Math
operator|.
name|min
argument_list|(
name|collectLimit
argument_list|,
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|options
operator|.
name|overflowToDiskThreshold
operator|*
literal|0.95
argument_list|)
argument_list|)
decl_stmt|;
name|deletedOnceCount
operator|=
name|versionStore
operator|.
name|getDeletedOnceCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|deletedOnceCount
operator|>
name|preferredLimit
condition|)
block|{
name|double
name|chunks
init|=
operator|(
operator|(
name|double
operator|)
name|deletedOnceCount
operator|)
operator|/
name|preferredLimit
decl_stmt|;
name|suggestedIntervalMs
operator|=
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
operator|(
name|scope
operator|.
name|getDurationMs
argument_list|()
operator|+
name|maxRevisionAgeMs
operator|)
operator|/
name|chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|suggestedIntervalMs
operator|<
name|scope
operator|.
name|getDurationMs
argument_list|()
condition|)
block|{
name|scope
operator|=
name|scope
operator|.
name|startAndDuration
argument_list|(
name|suggestedIntervalMs
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"deletedOnce candidates: {} found, {} preferred, scope now {}"
argument_list|,
name|deletedOnceCount
argument_list|,
name|preferredLimit
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|ex
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"check on upper bounds of delete candidates not supported, skipped"
argument_list|)
expr_stmt|;
block|}
block|}
comment|//Check for any registered checkpoint which prevent the GC from running
name|Revision
name|checkpoint
init|=
name|nodeStore
operator|.
name|getCheckpoints
argument_list|()
operator|.
name|getOldestRevisionToKeep
argument_list|()
decl_stmt|;
if|if
condition|(
name|checkpoint
operator|!=
literal|null
operator|&&
name|scope
operator|.
name|endsAfter
argument_list|(
name|checkpoint
operator|.
name|getTimestamp
argument_list|()
argument_list|)
condition|)
block|{
name|TimeInterval
name|minimalScope
init|=
name|scope
operator|.
name|startAndDuration
argument_list|(
name|options
operator|.
name|precisionMs
argument_list|)
decl_stmt|;
if|if
condition|(
name|minimalScope
operator|.
name|endsAfter
argument_list|(
name|checkpoint
operator|.
name|getTimestamp
argument_list|()
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Ignoring RGC run because a valid checkpoint [{}] exists inside minimal scope {}."
argument_list|,
name|checkpoint
operator|.
name|toReadableString
argument_list|()
argument_list|,
name|minimalScope
argument_list|)
expr_stmt|;
name|ignoreDueToCheckPoint
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|scope
operator|=
name|scope
operator|.
name|notLaterThan
argument_list|(
name|checkpoint
operator|.
name|getTimestamp
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"checkpoint at [{}] found, scope now {}"
argument_list|,
name|Utils
operator|.
name|timestampToString
argument_list|(
name|checkpoint
operator|.
name|getTimestamp
argument_list|()
argument_list|)
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scope
operator|.
name|getDurationMs
argument_list|()
operator|<=
name|options
operator|.
name|precisionMs
condition|)
block|{
comment|// If we have narrowed the collect time interval down as much as we can, no
comment|// longer enforce a limit. We need to get through this.
name|collectLimit
operator|=
literal|0
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"time interval<= precision ({} ms), disabling collection limits"
argument_list|,
name|options
operator|.
name|precisionMs
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|precisionMs
operator|=
name|options
operator|.
name|precisionMs
expr_stmt|;
name|this
operator|.
name|ignoreDueToCheckPoint
operator|=
name|ignoreDueToCheckPoint
expr_stmt|;
name|this
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
name|this
operator|.
name|scopeIsComplete
operator|=
name|scope
operator|.
name|toMs
operator|>=
name|keep
operator|.
name|fromMs
expr_stmt|;
name|this
operator|.
name|maxCollect
operator|=
name|collectLimit
expr_stmt|;
name|this
operator|.
name|suggestedIntervalMs
operator|=
name|suggestedIntervalMs
expr_stmt|;
name|this
operator|.
name|deleteCandidateCount
operator|=
name|deletedOnceCount
expr_stmt|;
block|}
comment|/**          * Evaluate the results of the last run. Update recommendations for future runs.          * Will set {@link VersionGCStats#needRepeat} if collection needs to run another          * iteration for collecting documents up to "now".          *          * @param stats the statistics from the last run          */
specifier|public
name|void
name|evaluate
parameter_list|(
name|VersionGCStats
name|stats
parameter_list|)
block|{
if|if
condition|(
name|stats
operator|.
name|limitExceeded
condition|)
block|{
comment|// if the limit was exceeded, slash the recommended interval in half.
name|long
name|nextDuration
init|=
name|Math
operator|.
name|max
argument_list|(
name|precisionMs
argument_list|,
name|scope
operator|.
name|getDurationMs
argument_list|()
operator|/
literal|2
argument_list|)
decl_stmt|;
name|gcMonitor
operator|.
name|info
argument_list|(
literal|"Limit {} documents exceeded, reducing next collection interval to {} seconds"
argument_list|,
name|this
operator|.
name|maxCollect
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|toSeconds
argument_list|(
name|nextDuration
argument_list|)
argument_list|)
expr_stmt|;
name|setLongSetting
argument_list|(
name|SETTINGS_COLLECTION_REC_INTERVAL_PROP
argument_list|,
name|nextDuration
argument_list|)
expr_stmt|;
name|stats
operator|.
name|needRepeat
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|stats
operator|.
name|canceled
operator|&&
operator|!
name|stats
operator|.
name|ignoredGCDueToCheckPoint
condition|)
block|{
comment|// success, we would not expect to encounter revisions older than this in the future
name|setLongSetting
argument_list|(
name|SETTINGS_COLLECTION_OLDEST_TIMESTAMP_PROP
argument_list|,
name|scope
operator|.
name|toMs
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxCollect
operator|<=
literal|0
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"successful run without effective limit, keeping recommendations"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scope
operator|.
name|getDurationMs
argument_list|()
operator|==
name|suggestedIntervalMs
condition|)
block|{
name|int
name|count
init|=
name|stats
operator|.
name|deletedDocGCCount
operator|-
name|stats
operator|.
name|deletedLeafDocGCCount
decl_stmt|;
name|double
name|used
init|=
name|count
operator|/
operator|(
name|double
operator|)
name|maxCollect
decl_stmt|;
if|if
condition|(
name|used
operator|<
literal|0.66
condition|)
block|{
name|long
name|nextDuration
init|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|suggestedIntervalMs
operator|*
literal|1.5
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"successful run using {}% of limit, raising recommended interval to {} seconds"
argument_list|,
name|Math
operator|.
name|round
argument_list|(
name|used
operator|*
literal|1000
argument_list|)
operator|/
literal|10.0
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|toSeconds
argument_list|(
name|nextDuration
argument_list|)
argument_list|)
expr_stmt|;
name|setLongSetting
argument_list|(
name|SETTINGS_COLLECTION_REC_INTERVAL_PROP
argument_list|,
name|nextDuration
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"successful run not following recommendations, keeping them"
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|needRepeat
operator|=
operator|!
name|scopeIsComplete
expr_stmt|;
block|}
block|}
specifier|private
name|long
name|getLongSetting
parameter_list|(
name|String
name|propName
parameter_list|)
block|{
name|Document
name|versionGCDoc
init|=
name|ds
operator|.
name|find
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|,
name|SETTINGS_COLLECTION_ID
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|versionGCDoc
operator|!=
literal|null
condition|)
block|{
name|Long
name|l
init|=
operator|(
name|Long
operator|)
name|versionGCDoc
operator|.
name|get
argument_list|(
name|propName
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|!=
literal|null
condition|)
block|{
return|return
name|l
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
specifier|private
name|void
name|setLongSetting
parameter_list|(
name|String
name|propName
parameter_list|,
name|long
name|val
parameter_list|)
block|{
name|UpdateOp
name|updateOp
init|=
operator|new
name|UpdateOp
argument_list|(
name|SETTINGS_COLLECTION_ID
argument_list|,
operator|(
name|ds
operator|.
name|find
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|,
name|SETTINGS_COLLECTION_ID
argument_list|)
operator|==
literal|null
operator|)
argument_list|)
decl_stmt|;
name|updateOp
operator|.
name|set
argument_list|(
name|propName
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ds
operator|.
name|createOrUpdate
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|,
name|updateOp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * GCMessageTracker is a partial implementation of GCMonitor. We use it to      * keep track of the last message issued by the GC job.      */
specifier|private
specifier|static
class|class
name|GCMessageTracker
extends|extends
name|GCMonitor
operator|.
name|Empty
implements|implements
name|Supplier
argument_list|<
name|String
argument_list|>
block|{
specifier|private
specifier|volatile
name|String
name|lastMessage
init|=
name|STATUS_INITIALIZING
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|info
parameter_list|(
name|String
name|message
parameter_list|,
name|Object
modifier|...
name|arguments
parameter_list|)
block|{
name|lastMessage
operator|=
name|arrayFormat
argument_list|(
name|message
argument_list|,
name|arguments
argument_list|)
operator|.
name|getMessage
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|warn
parameter_list|(
name|String
name|message
parameter_list|,
name|Object
modifier|...
name|arguments
parameter_list|)
block|{
name|lastMessage
operator|=
name|arrayFormat
argument_list|(
name|message
argument_list|,
name|arguments
argument_list|)
operator|.
name|getMessage
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|error
parameter_list|(
name|String
name|message
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|lastMessage
operator|=
name|message
operator|+
literal|" ("
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|")"
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|()
block|{
return|return
name|lastMessage
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|LimitExceededException
extends|extends
name|Exception
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|6578586397629516408L
decl_stmt|;
block|}
block|}
end_class

end_unit

