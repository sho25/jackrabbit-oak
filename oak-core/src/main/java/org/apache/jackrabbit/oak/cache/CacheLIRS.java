begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|cache
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheLoader
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheStats
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LoadingCache
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|Weigher
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_comment
comment|/**  * A scan resistant cache. It is meant to cache objects that are relatively  * costly to acquire, for example file content.  *<p>  * This implementation is multi-threading safe and supports concurrent access.  * Null keys or null values are not allowed. The map fill factor is at most 75%.  *<p>  * Each entry is assigned a distinct memory size, and the cache will try to use  * at most the specified amount of memory. The memory unit is not relevant,  * however it is suggested to use bytes as the unit.  *<p>  * This class implements an approximation of the the LIRS replacement algorithm  * invented by Xiaodong Zhang and Song Jiang as described in  * http://www.cse.ohio-state.edu/~zhang/lirs-sigmetrics-02.html with a few  * smaller changes: An additional queue for non-resident entries is used, to  * prevent unbound memory usage. The maximum size of this queue is at most the  * size of the rest of the stack. About 6.25% of the mapped entries are cold.  *<p>  * Internally, the cache is split into a number of segments, and each segment is  * an individual LIRS cache.  *<p>  * Accessed entries are only moved to the top of the stack if at least a number  * of other entries have been moved to the front (1% by default). Write access  * and moving entries to the top of the stack is synchronized per segment.  *  * @author Thomas Mueller  * @param<K> the key type  * @param<V> the value type  */
end_comment

begin_class
specifier|public
class|class
name|CacheLIRS
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|LoadingCache
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/**      * The maximum memory this cache should use.      */
specifier|private
name|long
name|maxMemory
decl_stmt|;
comment|/**      * The average memory used by one entry.      */
specifier|private
name|int
name|averageMemory
decl_stmt|;
specifier|private
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
decl_stmt|;
specifier|private
specifier|final
name|int
name|segmentCount
decl_stmt|;
specifier|private
specifier|final
name|int
name|segmentShift
decl_stmt|;
specifier|private
specifier|final
name|int
name|segmentMask
decl_stmt|;
specifier|private
specifier|final
name|int
name|stackMoveDistance
decl_stmt|;
specifier|private
specifier|final
name|Weigher
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
decl_stmt|;
specifier|private
specifier|final
name|CacheLoader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loader
decl_stmt|;
comment|/**      * Create a new cache with the given number of entries, and the default      * settings (an average size of 1 per entry, 16 segments, and stack move      * distance equals to the maximum number of entries divided by 100).      *      * @param maxEntries the maximum number of entries      */
specifier|public
name|CacheLIRS
parameter_list|(
name|int
name|maxEntries
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|maxEntries
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|maxEntries
operator|/
literal|100
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new cache with the given memory size.      *      * @param maxMemory the maximum memory to use (1 or larger)      * @param averageMemory the average memory (1 or larger)      * @param segmentCount the number of cache segments (must be a power of 2)      * @param stackMoveDistance how many other item are to be moved to the top      *        of the stack before the current item is moved      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|CacheLIRS
parameter_list|(
name|Weigher
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
parameter_list|,
name|long
name|maxMemory
parameter_list|,
name|int
name|averageMemory
parameter_list|,
name|int
name|segmentCount
parameter_list|,
name|int
name|stackMoveDistance
parameter_list|,
specifier|final
name|CacheLoader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
block|{
name|this
operator|.
name|weigher
operator|=
name|weigher
expr_stmt|;
name|setMaxMemory
argument_list|(
name|maxMemory
argument_list|)
expr_stmt|;
name|setAverageMemory
argument_list|(
name|averageMemory
argument_list|)
expr_stmt|;
if|if
condition|(
name|Integer
operator|.
name|bitCount
argument_list|(
name|segmentCount
argument_list|)
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The segment count must be a power of 2, is "
operator|+
name|segmentCount
argument_list|)
throw|;
block|}
name|this
operator|.
name|segmentCount
operator|=
name|segmentCount
expr_stmt|;
name|this
operator|.
name|segmentMask
operator|=
name|segmentCount
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|stackMoveDistance
operator|=
name|stackMoveDistance
expr_stmt|;
name|segments
operator|=
operator|new
name|Segment
index|[
name|segmentCount
index|]
expr_stmt|;
name|invalidateAll
argument_list|()
expr_stmt|;
name|this
operator|.
name|segmentShift
operator|=
name|Integer
operator|.
name|numberOfTrailingZeros
argument_list|(
name|segments
index|[
literal|0
index|]
operator|.
name|entries
operator|.
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|loader
operator|=
name|loader
expr_stmt|;
block|}
comment|/**      * Remove all entries.      */
annotation|@
name|Override
specifier|public
name|void
name|invalidateAll
parameter_list|()
block|{
name|long
name|max
init|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|maxMemory
operator|/
name|segmentCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segmentCount
condition|;
name|i
operator|++
control|)
block|{
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|old
init|=
name|segments
index|[
name|i
index|]
decl_stmt|;
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
init|=
operator|new
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|max
argument_list|,
name|averageMemory
argument_list|,
name|stackMoveDistance
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|hitCount
operator|=
name|old
operator|.
name|hitCount
expr_stmt|;
name|s
operator|.
name|missCount
operator|=
name|old
operator|.
name|missCount
expr_stmt|;
name|s
operator|.
name|loadSuccessCount
operator|=
name|old
operator|.
name|loadSuccessCount
expr_stmt|;
name|s
operator|.
name|loadExceptionCount
operator|=
name|old
operator|.
name|loadExceptionCount
expr_stmt|;
name|s
operator|.
name|totalLoadTime
operator|=
name|old
operator|.
name|totalLoadTime
expr_stmt|;
name|s
operator|.
name|evictionCount
operator|=
name|old
operator|.
name|evictionCount
expr_stmt|;
block|}
name|segments
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
block|}
block|}
specifier|private
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|find
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|find
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**      * Check whether there is a resident entry for the given key. This      * method does not adjust the internal state of the cache.      *      * @param key the key (may not be null)      * @return true if there is a resident entry      */
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|containsKey
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**      * Get the value for the given key if the entry is cached. This method does      * not modify the internal state.      *      * @param key the key (may not be null)      * @return the value, or null if there is no resident entry      */
specifier|public
name|V
name|peek
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|find
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|e
operator|==
literal|null
condition|?
literal|null
else|:
name|e
operator|.
name|value
return|;
block|}
comment|/**      * Add an entry to the cache. The entry may or may not exist in the      * cache yet. This method will usually mark unknown entries as cold and      * known entries as hot.      *      * @param key the key (may not be null)      * @param value the value (may not be null)      * @param memory the memory used for the given entry      * @return the old value, or null if there was no resident entry      */
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|memory
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|memory
argument_list|)
return|;
block|}
comment|/**      * Add an entry to the cache using the average memory size.      *      * @param key the key (may not be null)      * @param value the value (may not be null)      */
annotation|@
name|Override
specifier|public
name|void
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|sizeOf
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|,
name|Callable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|valueLoader
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|valueLoader
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|loader
argument_list|)
return|;
block|}
comment|/**      * Get the value for the given key if the entry is cached. This method      * adjusts the internal state of the cache sometimes, to ensure commonly      * used entries stay in the cache.      *      * @param key the key (may not be null)      * @return the value, or null if there is no resident entry      */
annotation|@
name|Override
annotation|@
name|Nullable
specifier|public
name|V
name|getIfPresent
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**      * Get the size of the given value. The default implementation returns the      * average memory as configured for this cache.      *      * @param key the key      * @param value the value      * @return the size      */
specifier|protected
name|int
name|sizeOf
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|weigher
operator|==
literal|null
condition|)
block|{
return|return
name|averageMemory
return|;
block|}
return|return
name|weigher
operator|.
name|weigh
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**      * Remove an entry. Both resident and non-resident entries can be      * removed.      *      * @param key the key (may not be null)      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|invalidate
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|invalidate
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|void
name|invalidateAll
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|keys
parameter_list|)
block|{
for|for
control|(
name|K
name|k
range|:
operator|(
name|Iterable
argument_list|<
name|K
argument_list|>
operator|)
name|keys
control|)
block|{
name|invalidate
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get the memory used for the given key.      *      * @param key the key (may not be null)      * @return the memory, or 0 if there is no resident entry      */
specifier|public
name|int
name|getMemory
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|getHash
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|getSegment
argument_list|(
name|hash
argument_list|)
operator|.
name|getMemory
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
specifier|private
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getSegment
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
name|int
name|segmentIndex
init|=
operator|(
name|hash
operator|>>>
name|segmentShift
operator|)
operator|&
name|segmentMask
decl_stmt|;
return|return
name|segments
index|[
name|segmentIndex
index|]
return|;
block|}
comment|/**      * Get the hash code for the given key. The hash code is      * further enhanced to spread the values more evenly.      *      * @param key the key      * @return the hash code      */
specifier|static
name|int
name|getHash
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|key
operator|.
name|hashCode
argument_list|()
decl_stmt|;
comment|// a supplemental secondary hash function
comment|// to protect against hash codes that don't differ much
name|hash
operator|=
operator|(
operator|(
name|hash
operator|>>>
literal|16
operator|)
operator|^
name|hash
operator|)
operator|*
literal|0x45d9f3b
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
name|hash
operator|>>>
literal|16
operator|)
operator|^
name|hash
operator|)
operator|*
literal|0x45d9f3b
expr_stmt|;
name|hash
operator|=
operator|(
name|hash
operator|>>>
literal|16
operator|)
operator|^
name|hash
expr_stmt|;
return|return
name|hash
return|;
block|}
comment|/**      * Get the currently used memory.      *      * @return the used memory      */
specifier|public
name|long
name|getUsedMemory
parameter_list|()
block|{
name|long
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|x
operator|+=
name|s
operator|.
name|usedMemory
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/**      * Set the maximum memory this cache should use. This will not      * immediately cause entries to get removed however; it will only change      * the limit. To resize the internal array, call the clear method.      *      * @param maxMemory the maximum size (1 or larger)      */
specifier|public
name|void
name|setMaxMemory
parameter_list|(
name|long
name|maxMemory
parameter_list|)
block|{
if|if
condition|(
name|maxMemory
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Max memory must be larger than 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|maxMemory
operator|=
name|maxMemory
expr_stmt|;
if|if
condition|(
name|segments
operator|!=
literal|null
condition|)
block|{
name|long
name|max
init|=
literal|1
operator|+
name|maxMemory
operator|/
name|segments
operator|.
name|length
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|s
operator|.
name|setMaxMemory
argument_list|(
name|max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Set the average memory used per entry. It is used to calculate the      * length of the internal array.      *      * @param averageMemory the average memory used (1 or larger)      */
specifier|public
name|void
name|setAverageMemory
parameter_list|(
name|int
name|averageMemory
parameter_list|)
block|{
if|if
condition|(
name|averageMemory
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Average memory must be larger than 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|averageMemory
operator|=
name|averageMemory
expr_stmt|;
if|if
condition|(
name|segments
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|s
operator|.
name|setAverageMemory
argument_list|(
name|averageMemory
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Get the average memory used per entry.      *      * @return the average memory      */
specifier|public
name|int
name|getAverageMemory
parameter_list|()
block|{
return|return
name|averageMemory
return|;
block|}
comment|/**      * Get the maximum memory to use.      *      * @return the maximum memory      */
specifier|public
name|long
name|getMaxMemory
parameter_list|()
block|{
return|return
name|maxMemory
return|;
block|}
comment|/**      * Get the entry set for all resident entries.      *      * @return the entry set      */
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|K
name|k
range|:
name|keySet
argument_list|()
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|k
argument_list|,
name|find
argument_list|(
name|k
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|map
operator|.
name|entrySet
argument_list|()
return|;
block|}
comment|/**      * Get the set of keys for resident entries.      *      * @return the set of keys      */
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|HashSet
argument_list|<
name|K
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|K
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|s
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
comment|/**      * Get the number of non-resident entries in the cache.      *      * @return the number of non-resident entries      */
specifier|public
name|int
name|sizeNonResident
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|x
operator|+=
name|s
operator|.
name|queue2Size
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/**      * Get the length of the internal map array.      *      * @return the size of the array      */
specifier|public
name|int
name|sizeMapArray
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|x
operator|+=
name|s
operator|.
name|entries
operator|.
name|length
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/**      * Get the number of hot entries in the cache.      *      * @return the number of hot entries      */
specifier|public
name|int
name|sizeHot
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|x
operator|+=
name|s
operator|.
name|mapSize
operator|-
name|s
operator|.
name|queueSize
operator|-
name|s
operator|.
name|queue2Size
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/**      * Get the number of resident entries.      *      * @return the number of entries      */
annotation|@
name|Override
specifier|public
name|long
name|size
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|x
operator|+=
name|s
operator|.
name|mapSize
operator|-
name|s
operator|.
name|queue2Size
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/**      * Get the list of keys. This method allows to read the internal state of      * the cache.      *      * @param cold if true, only keys for the cold entries are returned      * @param nonResident true for non-resident entries      * @return the key list      */
specifier|public
specifier|synchronized
name|List
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|(
name|boolean
name|cold
parameter_list|,
name|boolean
name|nonResident
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|K
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<
name|K
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|keys
operator|.
name|addAll
argument_list|(
name|s
operator|.
name|keys
argument_list|(
name|cold
argument_list|,
name|nonResident
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|keys
return|;
block|}
annotation|@
name|Override
specifier|public
name|CacheStats
name|stats
parameter_list|()
block|{
name|long
name|hitCount
init|=
literal|0
decl_stmt|;
name|long
name|missCount
init|=
literal|0
decl_stmt|;
name|long
name|loadSuccessCount
init|=
literal|0
decl_stmt|;
name|long
name|loadExceptionCount
init|=
literal|0
decl_stmt|;
name|long
name|totalLoadTime
init|=
literal|0
decl_stmt|;
name|long
name|evictionCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
range|:
name|segments
control|)
block|{
name|hitCount
operator|+=
name|s
operator|.
name|hitCount
expr_stmt|;
name|missCount
operator|+=
name|s
operator|.
name|missCount
expr_stmt|;
name|loadSuccessCount
operator|+=
name|s
operator|.
name|loadSuccessCount
expr_stmt|;
name|loadExceptionCount
operator|+=
name|s
operator|.
name|loadExceptionCount
expr_stmt|;
name|totalLoadTime
operator|+=
name|s
operator|.
name|totalLoadTime
expr_stmt|;
name|evictionCount
operator|+=
name|s
operator|.
name|evictionCount
expr_stmt|;
block|}
name|CacheStats
name|stats
init|=
operator|new
name|CacheStats
argument_list|(
name|hitCount
argument_list|,
name|missCount
argument_list|,
name|loadSuccessCount
argument_list|,
name|loadExceptionCount
argument_list|,
name|totalLoadTime
argument_list|,
name|evictionCount
argument_list|)
decl_stmt|;
return|return
name|stats
return|;
block|}
comment|/**      * A cache segment      *      * @param<K> the key type      * @param<V> the value type      */
specifier|static
class|class
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**          * The number of (hot, cold, and non-resident) entries in the map.          */
name|int
name|mapSize
decl_stmt|;
comment|/**          * The size of the LIRS queue for resident cold entries.          */
name|int
name|queueSize
decl_stmt|;
comment|/**          * The size of the LIRS queue for non-resident cold entries.          */
name|int
name|queue2Size
decl_stmt|;
comment|/**          * The map array. The size is always a power of 2.          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|entries
decl_stmt|;
comment|/**          * The currently used memory.          */
name|long
name|usedMemory
decl_stmt|;
name|long
name|hitCount
decl_stmt|;
name|long
name|missCount
decl_stmt|;
name|long
name|loadSuccessCount
decl_stmt|;
name|long
name|loadExceptionCount
decl_stmt|;
name|long
name|totalLoadTime
decl_stmt|;
name|long
name|evictionCount
decl_stmt|;
comment|/**          * The cache.          */
specifier|private
specifier|final
name|CacheLIRS
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cache
decl_stmt|;
comment|/**          * How many other item are to be moved to the top of the stack before          * the current item is moved.          */
specifier|private
specifier|final
name|int
name|stackMoveDistance
decl_stmt|;
comment|/**          * The maximum memory this cache should use.          */
specifier|private
name|long
name|maxMemory
decl_stmt|;
comment|/**          * The average memory used by one entry.          */
specifier|private
name|int
name|averageMemory
decl_stmt|;
comment|/**          * The bit mask that is applied to the key hash code to get the index in the          * map array. The mask is the length of the array minus one.          */
specifier|private
name|int
name|mask
decl_stmt|;
comment|/**          * The LIRS stack size.          */
specifier|private
name|int
name|stackSize
decl_stmt|;
comment|/**          * The stack of recently referenced elements. This includes all hot entries,          * the recently referenced cold entries, and all non-resident cold entries.          *<p>          * There is always at least one entry: the head entry.          */
specifier|private
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|stack
decl_stmt|;
comment|/**          * The queue of resident cold entries.          *<p>          * There is always at least one entry: the head entry.          */
specifier|private
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|queue
decl_stmt|;
comment|/**          * The queue of non-resident cold entries.          *<p>          * There is always at least one entry: the head entry.          */
specifier|private
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|queue2
decl_stmt|;
comment|/**          * The number of times any item was moved to the top of the stack.          */
specifier|private
name|int
name|stackMoveCounter
decl_stmt|;
comment|/**          * Create a new cache.          *          * @param maxMemory the maximum memory to use          * @param averageMemory the average memory usage of an object          * @param stackMoveDistance the number of other entries to be moved to          *        the top of the stack before moving an entry to the top          */
name|Segment
parameter_list|(
name|CacheLIRS
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cache
parameter_list|,
name|long
name|maxMemory
parameter_list|,
name|int
name|averageMemory
parameter_list|,
name|int
name|stackMoveDistance
parameter_list|)
block|{
name|this
operator|.
name|cache
operator|=
name|cache
expr_stmt|;
name|setMaxMemory
argument_list|(
name|maxMemory
argument_list|)
expr_stmt|;
name|setAverageMemory
argument_list|(
name|averageMemory
argument_list|)
expr_stmt|;
name|this
operator|.
name|stackMoveDistance
operator|=
name|stackMoveDistance
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|clear
parameter_list|()
block|{
comment|// calculate the size of the map array
comment|// assume a fill factor of at most 80%
name|long
name|maxLen
init|=
call|(
name|long
call|)
argument_list|(
name|maxMemory
operator|/
name|averageMemory
operator|/
literal|0.75
argument_list|)
decl_stmt|;
comment|// the size needs to be a power of 2
name|long
name|l
init|=
literal|8
decl_stmt|;
while|while
condition|(
name|l
operator|<
name|maxLen
condition|)
block|{
name|l
operator|+=
name|l
expr_stmt|;
block|}
comment|// the array size is at most 2^31 elements
name|int
name|len
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
literal|1L
operator|<<
literal|31
argument_list|,
name|l
argument_list|)
decl_stmt|;
comment|// the bit mask has all bits set
name|mask
operator|=
name|len
operator|-
literal|1
expr_stmt|;
comment|// initialize the stack and queue heads
name|stack
operator|=
operator|new
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
expr_stmt|;
name|stack
operator|.
name|stackPrev
operator|=
name|stack
operator|.
name|stackNext
operator|=
name|stack
expr_stmt|;
name|queue
operator|=
operator|new
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
expr_stmt|;
name|queue
operator|.
name|queuePrev
operator|=
name|queue
operator|.
name|queueNext
operator|=
name|queue
expr_stmt|;
name|queue2
operator|=
operator|new
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
expr_stmt|;
name|queue2
operator|.
name|queuePrev
operator|=
name|queue2
operator|.
name|queueNext
operator|=
name|queue2
expr_stmt|;
comment|// first set to null - avoiding out of memory
name|entries
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|e
init|=
operator|new
name|Entry
index|[
name|len
index|]
decl_stmt|;
name|entries
operator|=
name|e
expr_stmt|;
name|mapSize
operator|=
literal|0
expr_stmt|;
name|usedMemory
operator|=
literal|0
expr_stmt|;
name|stackSize
operator|=
name|queueSize
operator|=
name|queue2Size
operator|=
literal|0
expr_stmt|;
block|}
comment|/**          * Get the memory used for the given key.          *          * @param key the key (may not be null)          * @param hash the hash          * @return the memory, or 0 if there is no resident entry          */
name|int
name|getMemory
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|find
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
return|return
name|e
operator|==
literal|null
condition|?
literal|0
else|:
name|e
operator|.
name|memory
return|;
block|}
comment|/**          * Get the value for the given key if the entry is cached. This method          * adjusts the internal state of the cache sometimes, to ensure commonly          * used entries stay in the cache.          *          * @param key the key (may not be null)          * @param hash the hash          * @return the value, or null if there is no resident entry          */
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|find
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
comment|// the entry was not found
name|missCount
operator|++
expr_stmt|;
return|return
literal|null
return|;
block|}
name|V
name|value
init|=
name|e
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// it was a non-resident entry
name|missCount
operator|++
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|e
operator|.
name|isHot
argument_list|()
condition|)
block|{
if|if
condition|(
name|e
operator|!=
name|stack
operator|.
name|stackNext
condition|)
block|{
if|if
condition|(
name|stackMoveDistance
operator|==
literal|0
operator|||
name|stackMoveCounter
operator|-
name|e
operator|.
name|topMove
operator|>
name|stackMoveDistance
condition|)
block|{
name|access
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|access
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
name|hitCount
operator|++
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/**          * Access an item, moving the entry to the top of the stack or front of the          * queue if found.          *          * @param key the key          */
specifier|private
specifier|synchronized
name|void
name|access
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|find
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|e
operator|.
name|value
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|e
operator|.
name|isHot
argument_list|()
condition|)
block|{
if|if
condition|(
name|e
operator|!=
name|stack
operator|.
name|stackNext
condition|)
block|{
if|if
condition|(
name|stackMoveDistance
operator|==
literal|0
operator|||
name|stackMoveCounter
operator|-
name|e
operator|.
name|topMove
operator|>
name|stackMoveDistance
condition|)
block|{
comment|// move a hot entry to the top of the stack
comment|// unless it is already there
name|boolean
name|wasEnd
init|=
name|e
operator|==
name|stack
operator|.
name|stackPrev
decl_stmt|;
name|removeFromStack
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasEnd
condition|)
block|{
comment|// if moving the last entry, the last entry
comment|// could now be cold, which is not allowed
name|pruneStack
argument_list|()
expr_stmt|;
block|}
name|addToStack
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|removeFromQueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|stackNext
operator|!=
literal|null
condition|)
block|{
comment|// resident cold entries become hot
comment|// if they are on the stack
name|removeFromStack
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// which means a hot entry needs to become cold
comment|// (this entry is cold, that means there is at least one
comment|// more entry in the stack, which must be hot)
name|convertOldestHotToCold
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// cold entries that are not on the stack
comment|// move to the front of the queue
name|addToQueue
argument_list|(
name|queue
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// in any case, the cold entry is moved to the top of the stack
name|addToStack
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|synchronized
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|Callable
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|valueLoader
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|V
name|value
init|=
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
name|value
operator|=
name|valueLoader
operator|.
name|call
argument_list|()
expr_stmt|;
name|loadSuccessCount
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|loadExceptionCount
operator|++
expr_stmt|;
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|long
name|time
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
decl_stmt|;
name|totalLoadTime
operator|+=
name|time
expr_stmt|;
block|}
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|cache
operator|.
name|sizeOf
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
specifier|synchronized
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|CacheLoader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|V
name|value
init|=
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
name|value
operator|=
name|loader
operator|.
name|load
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|loadSuccessCount
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|loadExceptionCount
operator|++
expr_stmt|;
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|long
name|time
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
decl_stmt|;
name|totalLoadTime
operator|+=
name|time
expr_stmt|;
block|}
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
name|cache
operator|.
name|sizeOf
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/**          * Add an entry to the cache. The entry may or may not exist in the          * cache yet. This method will usually mark unknown entries as cold and          * known entries as hot.          *          * @param key the key (may not be null)          * @param hash the hash          * @param value the value (may not be null)          * @param memory the memory used for the given entry          * @return the old value, or null if there was no resident entry          */
specifier|synchronized
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|memory
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The value may not be null"
argument_list|)
throw|;
block|}
name|V
name|old
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|find
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|old
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|old
operator|=
name|e
operator|.
name|value
expr_stmt|;
name|invalidate
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
operator|new
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
expr_stmt|;
name|e
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|e
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|e
operator|.
name|memory
operator|=
name|memory
expr_stmt|;
name|int
name|index
init|=
name|hash
operator|&
name|mask
decl_stmt|;
name|e
operator|.
name|mapNext
operator|=
name|entries
index|[
name|index
index|]
expr_stmt|;
name|entries
index|[
name|index
index|]
operator|=
name|e
expr_stmt|;
name|usedMemory
operator|+=
name|memory
expr_stmt|;
if|if
condition|(
name|usedMemory
operator|>
name|maxMemory
operator|&&
name|mapSize
operator|>
literal|0
condition|)
block|{
comment|// an old entry needs to be removed
name|evict
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|mapSize
operator|++
expr_stmt|;
comment|// added entries are always added to the stack
name|addToStack
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|old
return|;
block|}
comment|/**          * Remove an entry. Both resident and non-resident entries can be          * removed.          *          * @param key the key (may not be null)          * @param hash the hash          */
specifier|synchronized
name|void
name|invalidate
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|int
name|index
init|=
name|hash
operator|&
name|mask
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|entries
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|e
operator|.
name|key
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|entries
index|[
name|index
index|]
operator|=
name|e
operator|.
name|mapNext
expr_stmt|;
block|}
else|else
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|last
decl_stmt|;
do|do
block|{
name|last
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|e
operator|.
name|mapNext
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return;
block|}
block|}
do|while
condition|(
operator|!
name|e
operator|.
name|key
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
do|;
name|last
operator|.
name|mapNext
operator|=
name|e
operator|.
name|mapNext
expr_stmt|;
block|}
name|mapSize
operator|--
expr_stmt|;
name|usedMemory
operator|-=
name|e
operator|.
name|memory
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|stackNext
operator|!=
literal|null
condition|)
block|{
name|removeFromStack
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|.
name|isHot
argument_list|()
condition|)
block|{
comment|// when removing a hot entry, the newest cold entry gets hot,
comment|// so the number of hot entries does not change
name|e
operator|=
name|queue
operator|.
name|queueNext
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|queue
condition|)
block|{
name|removeFromQueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|stackNext
operator|==
literal|null
condition|)
block|{
name|addToStackBottom
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|removeFromQueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|pruneStack
argument_list|()
expr_stmt|;
block|}
comment|/**          * Evict cold entries (resident and non-resident) until the memory limit is          * reached. The new entry is added as a cold entry, except if it is the only          * entry.          *          * @param newCold a new cold entry          */
specifier|private
name|void
name|evict
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newCold
parameter_list|)
block|{
comment|// ensure there are not too many hot entries: right shift of 5 is
comment|// division by 32, that means if there are only 1/32 (3.125%) or
comment|// less cold entries, a hot entry needs to become cold
while|while
condition|(
name|queueSize
operator|<=
operator|(
name|mapSize
operator|>>>
literal|5
operator|)
operator|&&
name|stackSize
operator|>
literal|0
condition|)
block|{
name|convertOldestHotToCold
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|stackSize
operator|>
literal|0
condition|)
block|{
comment|// the new cold entry is at the top of the queue
name|addToQueue
argument_list|(
name|queue
argument_list|,
name|newCold
argument_list|)
expr_stmt|;
block|}
comment|// the oldest resident cold entries become non-resident
comment|// but at least one cold entry (the new one) must stay
while|while
condition|(
name|usedMemory
operator|>
name|maxMemory
operator|&&
name|queueSize
operator|>
literal|1
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|queue
operator|.
name|queuePrev
decl_stmt|;
name|usedMemory
operator|-=
name|e
operator|.
name|memory
expr_stmt|;
name|evictionCount
operator|++
expr_stmt|;
name|removeFromQueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|value
operator|=
literal|null
expr_stmt|;
name|e
operator|.
name|memory
operator|=
literal|0
expr_stmt|;
name|addToQueue
argument_list|(
name|queue2
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// the size of the non-resident-cold entries needs to be limited
while|while
condition|(
name|queue2Size
operator|+
name|queue2Size
operator|>
name|stackSize
condition|)
block|{
name|e
operator|=
name|queue2
operator|.
name|queuePrev
expr_stmt|;
name|int
name|hash
init|=
name|getHash
argument_list|(
name|e
operator|.
name|key
argument_list|)
decl_stmt|;
name|invalidate
argument_list|(
name|e
operator|.
name|key
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|convertOldestHotToCold
parameter_list|()
block|{
comment|// the last entry of the stack is known to be hot
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|last
init|=
name|stack
operator|.
name|stackPrev
decl_stmt|;
if|if
condition|(
name|last
operator|==
name|stack
condition|)
block|{
comment|// never remove the stack head itself (this would mean the
comment|// internal structure of the cache is corrupt)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
comment|// remove from stack - which is done anyway in the stack pruning, but we
comment|// can do it here as well
name|removeFromStack
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|// adding an entry to the queue will make it cold
name|addToQueue
argument_list|(
name|queue
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|pruneStack
argument_list|()
expr_stmt|;
block|}
comment|/**          * Ensure the last entry of the stack is cold.          */
specifier|private
name|void
name|pruneStack
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|last
init|=
name|stack
operator|.
name|stackPrev
decl_stmt|;
comment|// must stop at a hot entry or the stack head,
comment|// but the stack head itself is also hot, so we
comment|// don't have to test it
if|if
condition|(
name|last
operator|.
name|isHot
argument_list|()
condition|)
block|{
break|break;
block|}
comment|// the cold entry is still in the queue
name|removeFromStack
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Try to find an entry in the map.          *          * @param key the key          * @param hash the hash          * @return the entry (might be a non-resident)          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|find
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|int
name|index
init|=
name|hash
operator|&
name|mask
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|entries
index|[
name|index
index|]
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
operator|&&
operator|!
name|e
operator|.
name|key
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|e
operator|=
name|e
operator|.
name|mapNext
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
specifier|private
name|void
name|addToStack
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
name|e
operator|.
name|stackPrev
operator|=
name|stack
expr_stmt|;
name|e
operator|.
name|stackNext
operator|=
name|stack
operator|.
name|stackNext
expr_stmt|;
name|e
operator|.
name|stackNext
operator|.
name|stackPrev
operator|=
name|e
expr_stmt|;
name|stack
operator|.
name|stackNext
operator|=
name|e
expr_stmt|;
name|stackSize
operator|++
expr_stmt|;
name|e
operator|.
name|topMove
operator|=
name|stackMoveCounter
operator|++
expr_stmt|;
block|}
specifier|private
name|void
name|addToStackBottom
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
name|e
operator|.
name|stackNext
operator|=
name|stack
expr_stmt|;
name|e
operator|.
name|stackPrev
operator|=
name|stack
operator|.
name|stackPrev
expr_stmt|;
name|e
operator|.
name|stackPrev
operator|.
name|stackNext
operator|=
name|e
expr_stmt|;
name|stack
operator|.
name|stackPrev
operator|=
name|e
expr_stmt|;
name|stackSize
operator|++
expr_stmt|;
block|}
specifier|private
name|void
name|removeFromStack
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
name|e
operator|.
name|stackPrev
operator|.
name|stackNext
operator|=
name|e
operator|.
name|stackNext
expr_stmt|;
name|e
operator|.
name|stackNext
operator|.
name|stackPrev
operator|=
name|e
operator|.
name|stackPrev
expr_stmt|;
name|e
operator|.
name|stackPrev
operator|=
name|e
operator|.
name|stackNext
operator|=
literal|null
expr_stmt|;
name|stackSize
operator|--
expr_stmt|;
block|}
specifier|private
name|void
name|addToQueue
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|q
parameter_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
name|e
operator|.
name|queuePrev
operator|=
name|q
expr_stmt|;
name|e
operator|.
name|queueNext
operator|=
name|q
operator|.
name|queueNext
expr_stmt|;
name|e
operator|.
name|queueNext
operator|.
name|queuePrev
operator|=
name|e
expr_stmt|;
name|q
operator|.
name|queueNext
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|value
operator|!=
literal|null
condition|)
block|{
name|queueSize
operator|++
expr_stmt|;
block|}
else|else
block|{
name|queue2Size
operator|++
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|removeFromQueue
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
name|e
operator|.
name|queuePrev
operator|.
name|queueNext
operator|=
name|e
operator|.
name|queueNext
expr_stmt|;
name|e
operator|.
name|queueNext
operator|.
name|queuePrev
operator|=
name|e
operator|.
name|queuePrev
expr_stmt|;
name|e
operator|.
name|queuePrev
operator|=
name|e
operator|.
name|queueNext
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|value
operator|!=
literal|null
condition|)
block|{
name|queueSize
operator|--
expr_stmt|;
block|}
else|else
block|{
name|queue2Size
operator|--
expr_stmt|;
block|}
block|}
comment|/**          * Get the list of keys. This method allows to read the internal state of          * the cache.          *          * @param cold if true, only keys for the cold entries are returned          * @param nonResident true for non-resident entries          * @return the key list          */
specifier|synchronized
name|List
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|(
name|boolean
name|cold
parameter_list|,
name|boolean
name|nonResident
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|K
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<
name|K
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cold
condition|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|start
init|=
name|nonResident
condition|?
name|queue2
else|:
name|queue
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|start
operator|.
name|queueNext
init|;
name|e
operator|!=
name|start
condition|;
name|e
operator|=
name|e
operator|.
name|queueNext
control|)
block|{
name|keys
operator|.
name|add
argument_list|(
name|e
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|stack
operator|.
name|stackNext
init|;
name|e
operator|!=
name|stack
condition|;
name|e
operator|=
name|e
operator|.
name|stackNext
control|)
block|{
name|keys
operator|.
name|add
argument_list|(
name|e
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|keys
return|;
block|}
comment|/**          * Check whether there is a resident entry for the given key. This          * method does not adjust the internal state of the cache.          *          * @param key the key (may not be null)          * @param hash the hash          * @return true if there is a resident entry          */
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|find
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
return|return
name|e
operator|!=
literal|null
operator|&&
name|e
operator|.
name|value
operator|!=
literal|null
return|;
block|}
comment|/**          * Get the set of keys for resident entries.          *          * @return the set of keys          */
specifier|synchronized
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|HashSet
argument_list|<
name|K
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|K
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|stack
operator|.
name|stackNext
init|;
name|e
operator|!=
name|stack
condition|;
name|e
operator|=
name|e
operator|.
name|stackNext
control|)
block|{
name|set
operator|.
name|add
argument_list|(
name|e
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|queue
operator|.
name|queueNext
init|;
name|e
operator|!=
name|queue
condition|;
name|e
operator|=
name|e
operator|.
name|queueNext
control|)
block|{
name|set
operator|.
name|add
argument_list|(
name|e
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
comment|/**          * Set the maximum memory this cache should use. This will not          * immediately cause entries to get removed however; it will only change          * the limit. To resize the internal array, call the clear method.          *          * @param maxMemory the maximum size (1 or larger)          */
name|void
name|setMaxMemory
parameter_list|(
name|long
name|maxMemory
parameter_list|)
block|{
if|if
condition|(
name|maxMemory
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Max memory must be larger than 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|maxMemory
operator|=
name|maxMemory
expr_stmt|;
block|}
comment|/**          * Set the average memory used per entry. It is used to calculate the          * length of the internal array.          *          * @param averageMemory the average memory used (1 or larger)          */
name|void
name|setAverageMemory
parameter_list|(
name|int
name|averageMemory
parameter_list|)
block|{
if|if
condition|(
name|averageMemory
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Average memory must be larger than 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|averageMemory
operator|=
name|averageMemory
expr_stmt|;
block|}
block|}
comment|/**      * A cache entry. Each entry is either hot (low inter-reference recency;      * LIR), cold (high inter-reference recency; HIR), or non-resident-cold. Hot      * entries are in the stack only. Cold entries are in the queue, and may be      * in the stack. Non-resident-cold entries have their value set to null and      * are in the stack and in the non-resident queue.      *      * @param<K> the key type      * @param<V> the value type      */
specifier|static
class|class
name|Entry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**          * The key.          */
name|K
name|key
decl_stmt|;
comment|/**          * The value. Set to null for non-resident-cold entries.          */
name|V
name|value
decl_stmt|;
comment|/**          * The estimated memory used.          */
name|int
name|memory
decl_stmt|;
comment|/**          * When the item was last moved to the top of the stack.          */
name|int
name|topMove
decl_stmt|;
comment|/**          * The next entry in the stack.          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|stackNext
decl_stmt|;
comment|/**          * The previous entry in the stack.          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|stackPrev
decl_stmt|;
comment|/**          * The next entry in the queue (either the resident queue or the          * non-resident queue).          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|queueNext
decl_stmt|;
comment|/**          * The previous entry in the queue.          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|queuePrev
decl_stmt|;
comment|/**          * The next entry in the map          */
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|mapNext
decl_stmt|;
comment|/**          * Whether this entry is hot. Cold entries are in one of the two queues.          *          * @return whether the entry is hot          */
name|boolean
name|isHot
parameter_list|()
block|{
return|return
name|queueNext
operator|==
literal|null
return|;
block|}
block|}
comment|/**      * A builder for the cache.      */
specifier|public
specifier|static
class|class
name|Builder
block|{
specifier|private
name|Weigher
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|weigher
decl_stmt|;
specifier|private
name|long
name|maxWeight
decl_stmt|;
specifier|private
name|int
name|averageWeight
init|=
literal|100
decl_stmt|;
specifier|public
name|Builder
name|recordStats
parameter_list|()
block|{
return|return
name|this
return|;
block|}
specifier|public
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Builder
name|weigher
parameter_list|(
name|Weigher
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
parameter_list|)
block|{
name|this
operator|.
name|weigher
operator|=
name|weigher
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|Builder
name|maximumWeight
parameter_list|(
name|long
name|maxWeight
parameter_list|)
block|{
name|this
operator|.
name|maxWeight
operator|=
name|maxWeight
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|Builder
name|maximumSize
parameter_list|(
name|int
name|maxSize
parameter_list|)
block|{
name|this
operator|.
name|maxWeight
operator|=
name|maxSize
expr_stmt|;
name|this
operator|.
name|averageWeight
operator|=
literal|1
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|CacheLIRS
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|build
parameter_list|()
block|{
return|return
name|build
argument_list|(
literal|null
argument_list|)
return|;
block|}
specifier|public
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|CacheLIRS
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|build
parameter_list|(
name|CacheLoader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cacheLoader
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Weigher
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|w
init|=
operator|(
name|Weigher
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|weigher
decl_stmt|;
return|return
operator|new
name|CacheLIRS
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|w
argument_list|,
name|maxWeight
argument_list|,
name|averageWeight
argument_list|,
literal|16
argument_list|,
literal|16
argument_list|,
name|cacheLoader
argument_list|)
return|;
block|}
block|}
comment|/**      * Create a builder.      *       * @return the builder      */
specifier|public
specifier|static
name|Builder
name|newBuilder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getAllPresent
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|keys
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|asMap
parameter_list|()
block|{
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|K
name|key
range|:
name|keySet
argument_list|()
control|)
block|{
name|V
name|value
init|=
name|peek
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|cleanUp
parameter_list|()
block|{
comment|// nothing to do
block|}
annotation|@
name|Override
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|V
name|getUnchecked
parameter_list|(
name|K
name|key
parameter_list|)
block|{
comment|// TODO Auto-generated method stub
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|ImmutableMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getAll
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|keys
parameter_list|)
throws|throws
name|ExecutionException
block|{
comment|// TODO Auto-generated method stub
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|apply
parameter_list|(
name|K
name|key
parameter_list|)
block|{
comment|// TODO Auto-generated method stub
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|refresh
parameter_list|(
name|K
name|key
parameter_list|)
block|{
comment|// TODO Auto-generated method stub
block|}
block|}
end_class

end_unit

