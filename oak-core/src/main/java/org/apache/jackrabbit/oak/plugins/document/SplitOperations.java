begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|memory
operator|.
name|MemoryDocumentStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
operator|.
name|filter
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|COMMIT_ROOT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|DOC_SIZE_THRESHOLD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|PREV_SPLIT_FACTOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|REVISIONS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|SPLIT_RATIO
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|SplitDocType
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|isCommitRootEntry
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|isRevisionsEntry
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|removePrevious
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|setHasBinary
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
operator|.
name|setPrevious
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|Utils
operator|.
name|PROPERTY_OR_DELETED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|Utils
operator|.
name|getPreviousIdFor
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|Utils
operator|.
name|isRevisionNewer
import|;
end_import

begin_comment
comment|/**  * Utility class to create document split operations.  */
end_comment

begin_class
class|class
name|SplitOperations
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SplitOperations
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|GARBAGE_LIMIT
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"oak.documentMK.garbage.limit"
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|DocumentStore
name|STORE
init|=
operator|new
name|MemoryDocumentStore
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|NodeDocument
name|doc
decl_stmt|;
specifier|private
specifier|final
name|String
name|path
decl_stmt|;
specifier|private
specifier|final
name|String
name|id
decl_stmt|;
specifier|private
specifier|final
name|Revision
name|headRevision
decl_stmt|;
specifier|private
specifier|final
name|RevisionContext
name|context
decl_stmt|;
specifier|private
specifier|final
name|int
name|numRevsThreshold
decl_stmt|;
specifier|private
name|Revision
name|high
decl_stmt|;
specifier|private
name|Revision
name|low
decl_stmt|;
specifier|private
name|int
name|numValues
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|NavigableMap
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
argument_list|>
name|committedChanges
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|Revision
argument_list|>
name|changes
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|Revision
argument_list|>
argument_list|>
name|garbage
decl_stmt|;
specifier|private
name|int
name|garbageCount
init|=
literal|0
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|Revision
argument_list|>
name|mostRecentRevs
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|Revision
argument_list|>
name|splitRevs
decl_stmt|;
specifier|private
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|splitOps
decl_stmt|;
specifier|private
name|UpdateOp
name|main
decl_stmt|;
specifier|private
name|SplitOperations
parameter_list|(
annotation|@
name|Nonnull
name|NodeDocument
name|doc
parameter_list|,
annotation|@
name|Nonnull
name|RevisionContext
name|context
parameter_list|,
annotation|@
name|Nonnull
name|Revision
name|headRevision
parameter_list|,
name|int
name|numRevsThreshold
parameter_list|)
block|{
name|this
operator|.
name|doc
operator|=
name|checkNotNull
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|checkNotNull
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|doc
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|doc
operator|.
name|getId
argument_list|()
expr_stmt|;
name|this
operator|.
name|headRevision
operator|=
name|checkNotNull
argument_list|(
name|headRevision
argument_list|)
expr_stmt|;
name|this
operator|.
name|numRevsThreshold
operator|=
name|numRevsThreshold
expr_stmt|;
block|}
comment|/**      * Creates a list of update operations in case the given document requires      * a split. A caller must explicitly pass a head revision even though it      * is available through the {@link RevisionContext}. The given head revision      * must reflect a head state before {@code doc} was retrieved from the      * document store. This is important in order to maintain consistency.      * See OAK-3081 for details.      *      * @param doc a main document.      * @param context the revision context.      * @param headRevision the head revision before the document was retrieved      *                     from the document store.      * @param numRevsThreshold only split off at least this number of revisions.      * @return list of update operations. An empty list indicates the document      *          does not require a split.      * @throws IllegalArgumentException if the given document is a split      *                                  document.      */
annotation|@
name|Nonnull
specifier|static
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|forDocument
parameter_list|(
annotation|@
name|Nonnull
name|NodeDocument
name|doc
parameter_list|,
annotation|@
name|Nonnull
name|RevisionContext
name|context
parameter_list|,
annotation|@
name|Nonnull
name|Revision
name|headRevision
parameter_list|,
name|int
name|numRevsThreshold
parameter_list|)
block|{
if|if
condition|(
name|doc
operator|.
name|isSplitDocument
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Not a main document: "
operator|+
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|new
name|SplitOperations
argument_list|(
name|doc
argument_list|,
name|context
argument_list|,
name|headRevision
argument_list|,
name|numRevsThreshold
argument_list|)
operator|.
name|create
argument_list|()
return|;
block|}
specifier|private
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|create
parameter_list|()
block|{
if|if
condition|(
operator|!
name|considerSplit
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|splitOps
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|()
expr_stmt|;
name|mostRecentRevs
operator|=
name|Sets
operator|.
name|newHashSet
argument_list|()
expr_stmt|;
name|splitRevs
operator|=
name|Sets
operator|.
name|newHashSet
argument_list|()
expr_stmt|;
name|garbage
operator|=
name|Maps
operator|.
name|newHashMap
argument_list|()
expr_stmt|;
name|changes
operator|=
name|Sets
operator|.
name|newHashSet
argument_list|()
expr_stmt|;
name|committedChanges
operator|=
name|Maps
operator|.
name|newHashMap
argument_list|()
expr_stmt|;
name|collectLocalChanges
argument_list|(
name|committedChanges
argument_list|,
name|changes
argument_list|)
expr_stmt|;
comment|// revisions of the most recent committed changes on this document
comment|// these are kept in the main document. _revisions and _commitRoot
comment|// entries with these revisions are retained in the main document
name|populateSplitRevs
argument_list|()
expr_stmt|;
comment|// collect _revisions and _commitRoot entries for split document
name|collectRevisionsAndCommitRoot
argument_list|()
expr_stmt|;
comment|// create split ops out of the split values
name|main
operator|=
name|createSplitOps
argument_list|()
expr_stmt|;
comment|// create intermediate docs if needed
name|createIntermediateDocs
argument_list|()
expr_stmt|;
comment|// remove stale references to previous docs
name|disconnectStalePrevDocs
argument_list|()
expr_stmt|;
comment|// remove garbage
name|removeGarbage
argument_list|()
expr_stmt|;
comment|// main document must be updated last
if|if
condition|(
name|main
operator|!=
literal|null
condition|)
block|{
name|splitOps
operator|.
name|add
argument_list|(
name|main
argument_list|)
expr_stmt|;
block|}
return|return
name|splitOps
return|;
block|}
specifier|private
name|boolean
name|considerSplit
parameter_list|()
block|{
name|SortedMap
argument_list|<
name|Revision
argument_list|,
name|Range
argument_list|>
name|previous
init|=
name|doc
operator|.
name|getPreviousRanges
argument_list|()
decl_stmt|;
comment|// only consider if there are enough commits,
comment|// unless document is really big
return|return
name|doc
operator|.
name|getLocalRevisions
argument_list|()
operator|.
name|size
argument_list|()
operator|+
name|doc
operator|.
name|getLocalCommitRoot
argument_list|()
operator|.
name|size
argument_list|()
operator|>
name|numRevsThreshold
operator|||
name|doc
operator|.
name|getMemory
argument_list|()
operator|>=
name|DOC_SIZE_THRESHOLD
operator|||
name|previous
operator|.
name|size
argument_list|()
operator|>=
name|PREV_SPLIT_FACTOR
operator|||
operator|!
name|doc
operator|.
name|getStalePrev
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**      * Populate the {@link #splitRevs} with the revisions of the committed      * changes that will be moved to a previous document. For each property,      * all but the most recent change will be moved.      */
specifier|private
name|void
name|populateSplitRevs
parameter_list|()
block|{
for|for
control|(
name|NavigableMap
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|splitMap
range|:
name|committedChanges
operator|.
name|values
argument_list|()
control|)
block|{
comment|// keep the most recent changes in the main document
if|if
condition|(
operator|!
name|splitMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Revision
name|r
init|=
name|splitMap
operator|.
name|lastKey
argument_list|()
decl_stmt|;
name|splitMap
operator|.
name|remove
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|splitRevs
operator|.
name|addAll
argument_list|(
name|splitMap
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|mostRecentRevs
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|splitMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// remember highest / lowest revision
name|trackHigh
argument_list|(
name|splitMap
operator|.
name|lastKey
argument_list|()
argument_list|)
expr_stmt|;
name|trackLow
argument_list|(
name|splitMap
operator|.
name|firstKey
argument_list|()
argument_list|)
expr_stmt|;
name|numValues
operator|+=
name|splitMap
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Collect _revisions and _commitRoot entries that can be moved to a      * previous document.      */
specifier|private
name|void
name|collectRevisionsAndCommitRoot
parameter_list|()
block|{
name|NavigableMap
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|revisions
init|=
operator|new
name|TreeMap
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
argument_list|(
name|context
operator|.
name|getRevisionComparator
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|doc
operator|.
name|getLocalRevisions
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|splitRevs
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|revisions
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|numValues
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// move _revisions entries that act as commit root without
comment|// local changes
if|if
condition|(
name|context
operator|.
name|getClusterId
argument_list|()
operator|!=
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getClusterId
argument_list|()
condition|)
block|{
comment|// only consider local changes
continue|continue;
block|}
if|if
condition|(
name|doc
operator|.
name|isCommitted
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|&&
operator|!
name|mostRecentRevs
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
comment|// this is a commit root for changes in other documents
name|revisions
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|numValues
operator|++
expr_stmt|;
name|trackHigh
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|trackLow
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|committedChanges
operator|.
name|put
argument_list|(
name|REVISIONS
argument_list|,
name|revisions
argument_list|)
expr_stmt|;
name|NavigableMap
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|commitRoot
init|=
operator|new
name|TreeMap
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
argument_list|(
name|context
operator|.
name|getRevisionComparator
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|mostRecent
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|doc
operator|.
name|getLocalCommitRoot
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Revision
name|r
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|splitRevs
operator|.
name|contains
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|commitRoot
operator|.
name|put
argument_list|(
name|r
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|numValues
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|getClusterId
argument_list|()
operator|==
name|context
operator|.
name|getClusterId
argument_list|()
operator|&&
operator|!
name|changes
operator|.
name|contains
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// OAK-2528: _commitRoot entry without associated change
comment|// consider all but most recent as garbage (OAK-3333)
if|if
condition|(
name|mostRecent
condition|)
block|{
name|mostRecent
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|addGarbage
argument_list|(
name|r
argument_list|,
name|COMMIT_ROOT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|committedChanges
operator|.
name|put
argument_list|(
name|COMMIT_ROOT
argument_list|,
name|commitRoot
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates {@link UpdateOp}s for intermediate documents if necessary.      */
specifier|private
name|void
name|createIntermediateDocs
parameter_list|()
block|{
comment|// collect ranges and create a histogram of the height
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Range
argument_list|>
argument_list|>
name|prevHisto
init|=
name|getPreviousDocsHistogram
argument_list|()
decl_stmt|;
comment|// check if we need to create intermediate previous documents
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Range
argument_list|>
argument_list|>
name|entry
range|:
name|prevHisto
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
operator|>=
name|PREV_SPLIT_FACTOR
condition|)
block|{
if|if
condition|(
name|main
operator|==
literal|null
condition|)
block|{
name|main
operator|=
operator|new
name|UpdateOp
argument_list|(
name|id
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// calculate range
name|Revision
name|h
init|=
literal|null
decl_stmt|;
name|Revision
name|l
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Range
name|r
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
name|h
operator|==
literal|null
operator|||
name|isRevisionNewer
argument_list|(
name|context
argument_list|,
name|r
operator|.
name|high
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|h
operator|=
name|r
operator|.
name|high
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|==
literal|null
operator|||
name|isRevisionNewer
argument_list|(
name|context
argument_list|,
name|l
argument_list|,
name|r
operator|.
name|low
argument_list|)
condition|)
block|{
name|l
operator|=
name|r
operator|.
name|low
expr_stmt|;
block|}
name|removePrevious
argument_list|(
name|main
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|==
literal|null
operator|||
name|l
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
name|String
name|prevPath
init|=
name|Utils
operator|.
name|getPreviousPathFor
argument_list|(
name|path
argument_list|,
name|h
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|String
name|prevId
init|=
name|Utils
operator|.
name|getIdFromPath
argument_list|(
name|prevPath
argument_list|)
decl_stmt|;
name|UpdateOp
name|intermediate
init|=
operator|new
name|UpdateOp
argument_list|(
name|prevId
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|intermediate
operator|.
name|set
argument_list|(
name|Document
operator|.
name|ID
argument_list|,
name|prevId
argument_list|)
expr_stmt|;
if|if
condition|(
name|Utils
operator|.
name|isLongPath
argument_list|(
name|prevPath
argument_list|)
condition|)
block|{
name|intermediate
operator|.
name|set
argument_list|(
name|NodeDocument
operator|.
name|PATH
argument_list|,
name|prevPath
argument_list|)
expr_stmt|;
block|}
name|setPrevious
argument_list|(
name|main
argument_list|,
operator|new
name|Range
argument_list|(
name|h
argument_list|,
name|l
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Range
name|r
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|setPrevious
argument_list|(
name|intermediate
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|setIntermediateDocProps
argument_list|(
name|intermediate
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|splitOps
operator|.
name|add
argument_list|(
name|intermediate
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Creates split {@link UpdateOp} if there is enough data to split off. The      * {@link UpdateOp} for the new previous document is placed into the list of      * {@link #splitOps}. The {@link UpdateOp} for the main document is not      * added to the list but rather returned.      *      * @return the UpdateOp for the main document or {@code null} if there is      *          not enough data to split.      */
annotation|@
name|CheckForNull
specifier|private
name|UpdateOp
name|createSplitOps
parameter_list|()
block|{
name|UpdateOp
name|main
init|=
literal|null
decl_stmt|;
comment|// check if we have enough data to split off
if|if
condition|(
name|high
operator|!=
literal|null
operator|&&
name|low
operator|!=
literal|null
operator|&&
operator|(
name|numValues
operator|>=
name|numRevsThreshold
operator|||
name|doc
operator|.
name|getMemory
argument_list|()
operator|>
name|DOC_SIZE_THRESHOLD
operator|)
condition|)
block|{
comment|// enough changes to split off
comment|// move to another document
name|main
operator|=
operator|new
name|UpdateOp
argument_list|(
name|id
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|setPrevious
argument_list|(
name|main
argument_list|,
operator|new
name|Range
argument_list|(
name|high
argument_list|,
name|low
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|oldPath
init|=
name|Utils
operator|.
name|getPreviousPathFor
argument_list|(
name|path
argument_list|,
name|high
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|UpdateOp
name|old
init|=
operator|new
name|UpdateOp
argument_list|(
name|Utils
operator|.
name|getIdFromPath
argument_list|(
name|oldPath
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|old
operator|.
name|set
argument_list|(
name|Document
operator|.
name|ID
argument_list|,
name|old
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Utils
operator|.
name|isLongPath
argument_list|(
name|oldPath
argument_list|)
condition|)
block|{
name|old
operator|.
name|set
argument_list|(
name|NodeDocument
operator|.
name|PATH
argument_list|,
name|oldPath
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|property
range|:
name|committedChanges
operator|.
name|keySet
argument_list|()
control|)
block|{
name|NavigableMap
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|splitMap
init|=
name|committedChanges
operator|.
name|get
argument_list|(
name|property
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|splitMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Revision
name|r
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|isRevisionsEntry
argument_list|(
name|property
argument_list|)
operator|||
name|isCommitRootEntry
argument_list|(
name|property
argument_list|)
condition|)
block|{
comment|// only remove from main document if it is not
comment|// referenced anymore from from most recent changes
if|if
condition|(
operator|!
name|mostRecentRevs
operator|.
name|contains
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|main
operator|.
name|removeMapEntry
argument_list|(
name|property
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|main
operator|.
name|removeMapEntry
argument_list|(
name|property
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|old
operator|.
name|setMapEntry
argument_list|(
name|property
argument_list|,
name|r
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check size of old document
name|NodeDocument
name|oldDoc
init|=
operator|new
name|NodeDocument
argument_list|(
name|STORE
argument_list|)
decl_stmt|;
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|oldDoc
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|setSplitDocProps
argument_list|(
name|doc
argument_list|,
name|oldDoc
argument_list|,
name|old
argument_list|,
name|high
argument_list|)
expr_stmt|;
comment|// only split if enough of the data can be moved to old document
if|if
condition|(
name|oldDoc
operator|.
name|getMemory
argument_list|()
operator|>
name|doc
operator|.
name|getMemory
argument_list|()
operator|*
name|SPLIT_RATIO
operator|||
name|numValues
operator|>=
name|numRevsThreshold
condition|)
block|{
name|splitOps
operator|.
name|add
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|main
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
name|main
return|;
block|}
comment|/**      * Returns a histogram of the height of the previous documents referenced      * by this document. This only includes direct references and not indirectly      * referenced previous documents through intermediate previous docs.      *      * @return histogram of the height of the previous documents.      */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Range
argument_list|>
argument_list|>
name|getPreviousDocsHistogram
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Range
argument_list|>
argument_list|>
name|prevHisto
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Revision
argument_list|,
name|Range
argument_list|>
name|entry
range|:
name|doc
operator|.
name|getPreviousRanges
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Revision
name|rev
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|rev
operator|.
name|getClusterId
argument_list|()
operator|!=
name|context
operator|.
name|getClusterId
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|Range
name|r
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Range
argument_list|>
name|list
init|=
name|prevHisto
operator|.
name|get
argument_list|(
name|r
operator|.
name|getHeight
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|list
operator|=
operator|new
name|ArrayList
argument_list|<
name|Range
argument_list|>
argument_list|()
expr_stmt|;
name|prevHisto
operator|.
name|put
argument_list|(
name|r
operator|.
name|getHeight
argument_list|()
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|prevHisto
return|;
block|}
comment|/**      * Collects all local property changes committed by the current      * cluster node.      *      * @param committedLocally local changes committed by the current cluster node.      * @param changes all revisions of local changes (committed and uncommitted).      */
specifier|private
name|void
name|collectLocalChanges
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|NavigableMap
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
argument_list|>
name|committedLocally
parameter_list|,
name|Set
argument_list|<
name|Revision
argument_list|>
name|changes
parameter_list|)
block|{
for|for
control|(
name|String
name|property
range|:
name|filter
argument_list|(
name|doc
operator|.
name|keySet
argument_list|()
argument_list|,
name|PROPERTY_OR_DELETED
argument_list|)
control|)
block|{
name|NavigableMap
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|splitMap
init|=
operator|new
name|TreeMap
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
argument_list|(
name|context
operator|.
name|getRevisionComparator
argument_list|()
argument_list|)
decl_stmt|;
name|committedLocally
operator|.
name|put
argument_list|(
name|property
argument_list|,
name|splitMap
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|valueMap
init|=
name|doc
operator|.
name|getLocalMap
argument_list|(
name|property
argument_list|)
decl_stmt|;
comment|// collect committed changes of this cluster node
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|valueMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Revision
name|rev
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|rev
operator|.
name|getClusterId
argument_list|()
operator|!=
name|context
operator|.
name|getClusterId
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|changes
operator|.
name|add
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|.
name|isCommitted
argument_list|(
name|rev
argument_list|)
condition|)
block|{
name|splitMap
operator|.
name|put
argument_list|(
name|rev
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isGarbage
argument_list|(
name|rev
argument_list|)
condition|)
block|{
name|addGarbage
argument_list|(
name|rev
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|boolean
name|isGarbage
parameter_list|(
name|Revision
name|rev
parameter_list|)
block|{
name|Comparator
argument_list|<
name|Revision
argument_list|>
name|comp
init|=
name|context
operator|.
name|getRevisionComparator
argument_list|()
decl_stmt|;
comment|// use headRevision as passed in the constructor instead
comment|// of the head revision from the RevisionContext. see OAK-3081
if|if
condition|(
name|comp
operator|.
name|compare
argument_list|(
name|headRevision
argument_list|,
name|rev
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|// this may be an in-progress commit
return|return
literal|false
return|;
block|}
comment|// garbage if not part of an active branch
return|return
name|context
operator|.
name|getBranches
argument_list|()
operator|.
name|getBranchCommit
argument_list|(
name|rev
argument_list|)
operator|==
literal|null
return|;
block|}
specifier|private
name|void
name|addGarbage
parameter_list|(
name|Revision
name|rev
parameter_list|,
name|String
name|property
parameter_list|)
block|{
if|if
condition|(
name|garbageCount
operator|>
name|GARBAGE_LIMIT
condition|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|Revision
argument_list|>
name|revisions
init|=
name|garbage
operator|.
name|get
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|revisions
operator|==
literal|null
condition|)
block|{
name|revisions
operator|=
name|Sets
operator|.
name|newHashSet
argument_list|()
expr_stmt|;
name|garbage
operator|.
name|put
argument_list|(
name|property
argument_list|,
name|revisions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|revisions
operator|.
name|add
argument_list|(
name|rev
argument_list|)
condition|)
block|{
name|garbageCount
operator|++
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|disconnectStalePrevDocs
parameter_list|()
block|{
name|NavigableMap
argument_list|<
name|Revision
argument_list|,
name|Range
argument_list|>
name|ranges
init|=
name|doc
operator|.
name|getPreviousRanges
argument_list|(
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Revision
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|doc
operator|.
name|getStalePrev
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Revision
name|r
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|getClusterId
argument_list|()
operator|!=
name|context
operator|.
name|getClusterId
argument_list|()
condition|)
block|{
comment|// only process revisions of this cluster node
continue|continue;
block|}
if|if
condition|(
name|main
operator|==
literal|null
condition|)
block|{
name|main
operator|=
operator|new
name|UpdateOp
argument_list|(
name|id
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|NodeDocument
operator|.
name|removeStalePrevious
argument_list|(
name|main
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ranges
operator|.
name|containsKey
argument_list|(
name|r
argument_list|)
operator|&&
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|ranges
operator|.
name|get
argument_list|(
name|r
argument_list|)
operator|.
name|height
argument_list|)
argument_list|)
condition|)
block|{
name|NodeDocument
operator|.
name|removePrevious
argument_list|(
name|main
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// reference was moved to an intermediate doc
comment|// while the last GC was running
comment|// -> need to locate intermediate doc and disconnect from there
name|int
name|height
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|NodeDocument
name|intermediate
init|=
name|doc
operator|.
name|findPrevReferencingDoc
argument_list|(
name|r
argument_list|,
name|height
argument_list|)
decl_stmt|;
if|if
condition|(
name|intermediate
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Split document {} not referenced anymore. Main document is {}"
argument_list|,
name|getPreviousIdFor
argument_list|(
name|doc
operator|.
name|getPath
argument_list|()
argument_list|,
name|r
argument_list|,
name|height
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UpdateOp
name|op
init|=
operator|new
name|UpdateOp
argument_list|(
name|intermediate
operator|.
name|getId
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|NodeDocument
operator|.
name|removePrevious
argument_list|(
name|op
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|splitOps
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|removeGarbage
parameter_list|()
block|{
if|if
condition|(
name|garbage
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|main
operator|==
literal|null
condition|)
block|{
name|main
operator|=
operator|new
name|UpdateOp
argument_list|(
name|id
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|Revision
argument_list|>
argument_list|>
name|entry
range|:
name|garbage
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|Revision
name|r
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|main
operator|.
name|removeMapEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROPERTY_OR_DELETED
operator|.
name|apply
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|NodeDocument
operator|.
name|removeCommitRoot
argument_list|(
name|main
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|NodeDocument
operator|.
name|removeRevision
argument_list|(
name|main
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|trackHigh
parameter_list|(
name|Revision
name|r
parameter_list|)
block|{
if|if
condition|(
name|high
operator|==
literal|null
operator|||
name|isRevisionNewer
argument_list|(
name|context
argument_list|,
name|r
argument_list|,
name|high
argument_list|)
condition|)
block|{
name|high
operator|=
name|r
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|trackLow
parameter_list|(
name|Revision
name|r
parameter_list|)
block|{
if|if
condition|(
name|low
operator|==
literal|null
operator|||
name|isRevisionNewer
argument_list|(
name|context
argument_list|,
name|low
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|low
operator|=
name|r
expr_stmt|;
block|}
block|}
comment|/**      * Set various split document related flag/properties      *      * @param mainDoc main document from which split document is being created      * @param old updateOp of the old document created via split      * @param oldDoc old document created via split      * @param maxRev max revision stored in the split document oldDoc      */
specifier|private
specifier|static
name|void
name|setSplitDocProps
parameter_list|(
name|NodeDocument
name|mainDoc
parameter_list|,
name|NodeDocument
name|oldDoc
parameter_list|,
name|UpdateOp
name|old
parameter_list|,
name|Revision
name|maxRev
parameter_list|)
block|{
name|setSplitDocMaxRev
argument_list|(
name|old
argument_list|,
name|maxRev
argument_list|)
expr_stmt|;
name|SplitDocType
name|type
init|=
name|SplitDocType
operator|.
name|DEFAULT
decl_stmt|;
if|if
condition|(
operator|!
name|mainDoc
operator|.
name|hasChildren
argument_list|()
condition|)
block|{
name|type
operator|=
name|SplitDocType
operator|.
name|DEFAULT_LEAF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldDoc
operator|.
name|getLocalRevisions
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|type
operator|=
name|SplitDocType
operator|.
name|COMMIT_ROOT_ONLY
expr_stmt|;
block|}
comment|// Copy over the hasBinary flag
if|if
condition|(
name|mainDoc
operator|.
name|hasBinary
argument_list|()
condition|)
block|{
name|setHasBinary
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
name|setSplitDocType
argument_list|(
name|old
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set various properties for intermediate split document      *      * @param intermediate updateOp of the intermediate doc getting created      * @param maxRev max revision stored in the intermediate      */
specifier|private
specifier|static
name|void
name|setIntermediateDocProps
parameter_list|(
name|UpdateOp
name|intermediate
parameter_list|,
name|Revision
name|maxRev
parameter_list|)
block|{
name|setSplitDocMaxRev
argument_list|(
name|intermediate
argument_list|,
name|maxRev
argument_list|)
expr_stmt|;
name|setSplitDocType
argument_list|(
name|intermediate
argument_list|,
name|SplitDocType
operator|.
name|INTERMEDIATE
argument_list|)
expr_stmt|;
block|}
comment|//----------------------------< internal modifiers>------------------------
specifier|private
specifier|static
name|void
name|setSplitDocType
parameter_list|(
annotation|@
name|Nonnull
name|UpdateOp
name|op
parameter_list|,
annotation|@
name|Nonnull
name|SplitDocType
name|type
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|op
argument_list|)
operator|.
name|set
argument_list|(
name|NodeDocument
operator|.
name|SD_TYPE
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|setSplitDocMaxRev
parameter_list|(
annotation|@
name|Nonnull
name|UpdateOp
name|op
parameter_list|,
annotation|@
name|Nonnull
name|Revision
name|maxRev
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|op
argument_list|)
operator|.
name|set
argument_list|(
name|NodeDocument
operator|.
name|SD_MAX_REV_TIME_IN_SECS
argument_list|,
name|NodeDocument
operator|.
name|getModifiedInSecs
argument_list|(
name|maxRev
operator|.
name|getTimestamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

