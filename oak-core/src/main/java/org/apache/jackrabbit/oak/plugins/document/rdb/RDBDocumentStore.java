begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|rdb
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
operator|.
name|newArrayList
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
operator|.
name|partition
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateUtils
operator|.
name|checkConditions
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|rdb
operator|.
name|RDBJDBCTools
operator|.
name|closeResultSet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|rdb
operator|.
name|RDBJDBCTools
operator|.
name|closeStatement
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|rdb
operator|.
name|RDBJDBCTools
operator|.
name|createTableName
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DatabaseMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSetMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Deflater
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPOutputStream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|sql
operator|.
name|DataSource
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Stopwatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|cache
operator|.
name|CacheStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentMK
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentStoreException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|DocumentStoreStatsCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|NodeDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Key
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateOp
operator|.
name|Operation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|UpdateUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|cache
operator|.
name|CacheInvalidationStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|cache
operator|.
name|NodeDocumentCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|locks
operator|.
name|NodeDocumentLocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|locks
operator|.
name|StripedNodeDocumentLocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|mongo
operator|.
name|MongoDocumentStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|util
operator|.
name|OakVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
operator|.
name|BloomFilter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
operator|.
name|Funnel
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|hash
operator|.
name|PrimitiveSink
import|;
end_import

begin_comment
comment|/**  * Implementation of {@link DocumentStore} for relational databases.  *   *<h3>Supported Databases</h3>  *<p>  * The code is supposed to be sufficiently generic to run with a variety of  * database implementations. However, the tables are created when required to  * simplify testing, and<em>that</em> code specifically supports these  * databases:  *<ul>  *<li>H2DB</li>  *<li>Apache Derby</li>  *<li>IBM DB2</li>  *<li>PostgreSQL</li>  *<li>MariaDB (MySQL) (experimental)</li>  *<li>Microsoft SQL Server (experimental)</li>  *<li>Oracle (experimental)</li>  *</ul>  *   *<h3>Table Layout</h3>  *<p>  * Data for each of the DocumentStore's {@link Collection}s is stored in its own  * database table (with a name matching the collection).  *<p>  * The tables essentially implement key/value storage, where the key usually is  * derived from an Oak path, and the value is a serialization of a  * {@link Document} (or a part of one). Additional fields are used for queries,  * debugging, and concurrency control:  *<table style="text-align: left;">  *<thead>  *<tr>  *<th>Column</th>  *<th>Type</th>  *<th>Description</th>  *</tr>  *</thead><tbody>  *<tr>  *<th>ID</th>  *<td>varchar(512) not null primary key</td>  *<td>the document's key (for databases that can not handle 512 character  * primary keys, such as MySQL, varbinary is possible as wells)</td>  *</tr>  *<tr>  *<th>MODIFIED</th>  *<td>bigint</td>  *<td>low-resolution timestamp  *</tr>  *<tr>  *<th>HASBINARY</th>  *<td>smallint</td>  *<td>flag indicating whether the document has binary properties  *</tr>  *<tr>  *<th>DELETEDONCE</th>  *<td>smallint</td>  *<td>flag indicating whether the document has been deleted once  *</tr>  *<tr>  *<th>MODCOUNT</th>  *<td>bigint</td>  *<td>modification counter, used for avoiding overlapping updates</td>  *</tr>  *<tr>  *<th>DSIZE</th>  *<td>bigint</td>  *<td>the approximate size of the document's JSON serialization (for debugging  * purposes)</td>  *</tr>  *<tr>  *<th>DATA</th>  *<td>varchar(16384)</td>  *<td>the document's JSON serialization (only used for small document sizes, in  * which case BDATA (below) is not set), or a sequence of JSON serialized update  * operations to be applied against the last full serialization</td>  *</tr>  *<tr>  *<th>BDATA</th>  *<td>blob</td>  *<td>the document's JSON serialization (usually GZIPped, only used for "large"  * documents)</td>  *</tr>  *</tbody>  *</table>  *<p>  * The names of database tables can be prefixed; the purpose is mainly for  * testing, as tables can also be dropped automatically when the store is  * disposed (this only happens for those tables that have been created on  * demand).  *<p>  *<em>Note that the database needs to be created/configured to support all Unicode  * characters in text fields, and to collate by Unicode code point (in DB2: "collate using identity",  * in Postgres: "C").  * THIS IS NOT THE DEFAULT!</em>  *<p>  *<em>For MySQL, the database parameter "max_allowed_packet" needs to be increased to support ~16M blobs.</em>  *   *<h3>Caching</h3>  *<p>  * The cache borrows heavily from the {@link MongoDocumentStore} implementation.  *   *<h3>Queries</h3>  *<p>  * The implementation currently supports only three indexed properties:  * "_bin", "deletedOnce", and "_modified". Attempts to use a different indexed property will  * cause a {@link DocumentStoreException}.  */
end_comment

begin_class
specifier|public
class|class
name|RDBDocumentStore
implements|implements
name|DocumentStore
block|{
comment|/**      * Creates a {@linkplain RDBDocumentStore} instance using the provided      * {@link DataSource}, {@link DocumentMK.Builder}, and {@link RDBOptions}.      */
specifier|public
name|RDBDocumentStore
parameter_list|(
name|DataSource
name|ds
parameter_list|,
name|DocumentMK
operator|.
name|Builder
name|builder
parameter_list|,
name|RDBOptions
name|options
parameter_list|)
block|{
try|try
block|{
name|initialize
argument_list|(
name|ds
argument_list|,
name|builder
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"initializing RDB document store"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates a {@linkplain RDBDocumentStore} instance using the provided      * {@link DataSource}, {@link DocumentMK.Builder}, and default      * {@link RDBOptions}.      */
specifier|public
name|RDBDocumentStore
parameter_list|(
name|DataSource
name|ds
parameter_list|,
name|DocumentMK
operator|.
name|Builder
name|builder
parameter_list|)
block|{
name|this
argument_list|(
name|ds
argument_list|,
name|builder
argument_list|,
operator|new
name|RDBOptions
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|find
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
return|return
name|find
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|find
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
specifier|final
name|String
name|id
parameter_list|,
name|int
name|maxCacheAge
parameter_list|)
block|{
return|return
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|maxCacheAge
argument_list|)
return|;
block|}
annotation|@
name|Nonnull
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|query
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|query
argument_list|(
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Nonnull
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|query
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|String
name|indexedProperty
parameter_list|,
name|long
name|startValue
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|List
argument_list|<
name|QueryCondition
argument_list|>
name|conditions
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexedProperty
operator|!=
literal|null
condition|)
block|{
name|conditions
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
operator|new
name|QueryCondition
argument_list|(
name|indexedProperty
argument_list|,
literal|">="
argument_list|,
name|startValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|internalQuery
argument_list|(
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
name|EMPTY_KEY_PATTERN
argument_list|,
name|conditions
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Nonnull
specifier|protected
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|query
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|excludeKeyPatterns
parameter_list|,
name|List
argument_list|<
name|QueryCondition
argument_list|>
name|conditions
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|internalQuery
argument_list|(
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
name|excludeKeyPatterns
argument_list|,
name|conditions
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|remove
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|delete
argument_list|(
name|collection
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|remove
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
block|{
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|delete
argument_list|(
name|collection
argument_list|,
name|ids
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|int
name|remove
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
name|toRemove
parameter_list|)
block|{
name|int
name|num
init|=
name|delete
argument_list|(
name|collection
argument_list|,
name|toRemove
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|id
range|:
name|toRemove
operator|.
name|keySet
argument_list|()
control|)
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|create
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updateOps
parameter_list|)
block|{
return|return
name|internalCreate
argument_list|(
name|collection
argument_list|,
name|updateOps
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|update
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|,
name|UpdateOp
name|updateOp
parameter_list|)
block|{
name|UpdateUtils
operator|.
name|assertUnconditional
argument_list|(
name|updateOp
argument_list|)
expr_stmt|;
name|internalUpdate
argument_list|(
name|collection
argument_list|,
name|keys
argument_list|,
name|updateOp
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|createOrUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
name|UpdateUtils
operator|.
name|assertUnconditional
argument_list|(
name|update
argument_list|)
expr_stmt|;
return|return
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|createOrUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updateOps
parameter_list|)
block|{
if|if
condition|(
operator|!
name|BATCHUPDATES
operator|||
name|dbInfo
operator|==
name|RDBDocumentStoreDB
operator|.
name|ORACLE
comment|/* see OAK-3938 */
condition|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|(
name|updateOps
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|UpdateOp
name|update
range|:
name|updateOps
control|)
block|{
name|results
operator|.
name|add
argument_list|(
name|createOrUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
specifier|final
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|UpdateOp
argument_list|,
name|T
argument_list|>
name|results
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|UpdateOp
argument_list|,
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
name|operationsToCover
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|UpdateOp
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|UpdateOp
argument_list|>
name|duplicates
init|=
operator|new
name|HashSet
argument_list|<
name|UpdateOp
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateOp
name|updateOp
range|:
name|updateOps
control|)
block|{
name|UpdateUtils
operator|.
name|assertUnconditional
argument_list|(
name|updateOp
argument_list|)
expr_stmt|;
if|if
condition|(
name|operationsToCover
operator|.
name|containsKey
argument_list|(
name|updateOp
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|duplicates
operator|.
name|add
argument_list|(
name|updateOp
argument_list|)
expr_stmt|;
name|results
operator|.
name|put
argument_list|(
name|updateOp
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UpdateOp
name|clone
init|=
name|updateOp
operator|.
name|copy
argument_list|()
decl_stmt|;
name|addUpdateCounters
argument_list|(
name|clone
argument_list|)
expr_stmt|;
name|operationsToCover
operator|.
name|put
argument_list|(
name|clone
operator|.
name|getId
argument_list|()
argument_list|,
name|clone
argument_list|)
expr_stmt|;
name|results
operator|.
name|put
argument_list|(
name|clone
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|oldDocs
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|oldDocs
operator|.
name|putAll
argument_list|(
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|operationsToCover
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// iteration count
comment|// bulk update requires two DB requests, so if we have<= 2 operations
comment|// it's better to send them sequentially
while|while
condition|(
name|operationsToCover
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
comment|// We should try to insert documents only during the first
comment|// iteration. In the 2nd and 3rd iterations we only deal with
comment|// conflicting documents, so they already exist in the database
comment|// and there's no point in inserting them.
name|boolean
name|upsert
init|=
name|i
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|++
operator|==
literal|3
condition|)
block|{
comment|// operations that conflicted in 3 consecutive bulk
comment|// updates should be applied sequentially
break|break;
block|}
for|for
control|(
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|partition
range|:
name|partition
argument_list|(
name|newArrayList
argument_list|(
name|operationsToCover
operator|.
name|values
argument_list|()
argument_list|)
argument_list|,
name|CHUNKSIZE
argument_list|)
control|)
block|{
name|Map
argument_list|<
name|UpdateOp
argument_list|,
name|T
argument_list|>
name|successfulUpdates
init|=
name|bulkUpdate
argument_list|(
name|collection
argument_list|,
name|partition
argument_list|,
name|oldDocs
argument_list|,
name|upsert
argument_list|)
decl_stmt|;
name|results
operator|.
name|putAll
argument_list|(
name|successfulUpdates
argument_list|)
expr_stmt|;
name|operationsToCover
operator|.
name|values
argument_list|()
operator|.
name|removeAll
argument_list|(
name|successfulUpdates
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if there are some changes left, we'll apply them one after another
for|for
control|(
name|UpdateOp
name|updateOp
range|:
name|updateOps
control|)
block|{
name|UpdateOp
name|conflictedOp
init|=
name|operationsToCover
operator|.
name|remove
argument_list|(
name|updateOp
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|conflictedOp
operator|!=
literal|null
condition|)
block|{
name|results
operator|.
name|put
argument_list|(
name|conflictedOp
argument_list|,
name|createOrUpdate
argument_list|(
name|collection
argument_list|,
name|updateOp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|duplicates
operator|.
name|contains
argument_list|(
name|updateOp
argument_list|)
condition|)
block|{
name|results
operator|.
name|put
argument_list|(
name|updateOp
argument_list|,
name|createOrUpdate
argument_list|(
name|collection
argument_list|,
name|updateOp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|stats
operator|.
name|doneCreateOrUpdate
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|Lists
operator|.
name|transform
argument_list|(
name|updateOps
argument_list|,
operator|new
name|Function
argument_list|<
name|UpdateOp
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|apply
parameter_list|(
name|UpdateOp
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|getId
argument_list|()
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|(
name|results
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|readDocumentCached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|documents
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|NodeDocument
name|cached
init|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
operator|&&
name|cached
operator|!=
name|NodeDocument
operator|.
name|NULL
condition|)
block|{
name|T
name|doc
init|=
name|castAsT
argument_list|(
name|unwrap
argument_list|(
name|cached
argument_list|)
argument_list|)
decl_stmt|;
name|documents
operator|.
name|put
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|documentsToRead
init|=
name|Sets
operator|.
name|difference
argument_list|(
name|keys
argument_list|,
name|documents
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|readDocuments
init|=
name|readDocumentsUncached
argument_list|(
name|collection
argument_list|,
name|documentsToRead
argument_list|)
decl_stmt|;
name|documents
operator|.
name|putAll
argument_list|(
name|readDocuments
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
for|for
control|(
name|T
name|doc
range|:
name|readDocuments
operator|.
name|values
argument_list|()
control|)
block|{
name|nodesCache
operator|.
name|putIfAbsent
argument_list|(
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|documents
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|readDocumentsUncached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getROConnection
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|RDBRow
argument_list|>
name|rows
init|=
name|db
operator|.
name|read
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|keys
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|rows
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|RDBRow
name|row
init|=
name|rows
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|T
name|document
init|=
name|convertFromDBObject
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
decl_stmt|;
name|result
operator|.
name|put
argument_list|(
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|document
argument_list|)
expr_stmt|;
block|}
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|Map
argument_list|<
name|UpdateOp
argument_list|,
name|T
argument_list|>
name|bulkUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updates
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|oldDocs
parameter_list|,
name|boolean
name|upsert
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|missingDocs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateOp
name|op
range|:
name|updates
control|)
block|{
if|if
condition|(
operator|!
name|oldDocs
operator|.
name|containsKey
argument_list|(
name|op
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|missingDocs
operator|.
name|add
argument_list|(
name|op
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|T
name|doc
range|:
name|readDocumentsUncached
argument_list|(
name|collection
argument_list|,
name|missingDocs
argument_list|)
operator|.
name|values
argument_list|()
control|)
block|{
name|oldDocs
operator|.
name|put
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|,
name|doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|nodesCache
operator|.
name|putIfAbsent
argument_list|(
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|T
argument_list|>
name|docsToUpdate
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|(
name|updates
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|keysToUpdate
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateOp
name|update
range|:
name|updates
control|)
block|{
name|String
name|id
init|=
name|update
operator|.
name|getId
argument_list|()
decl_stmt|;
name|T
name|modifiedDoc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDocs
operator|.
name|containsKey
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|oldDocs
operator|.
name|get
argument_list|(
name|id
argument_list|)
operator|.
name|deepCopy
argument_list|(
name|modifiedDoc
argument_list|)
expr_stmt|;
block|}
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|modifiedDoc
argument_list|,
name|update
argument_list|)
expr_stmt|;
name|docsToUpdate
operator|.
name|add
argument_list|(
name|modifiedDoc
argument_list|)
expr_stmt|;
name|keysToUpdate
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|successfulUpdates
init|=
name|db
operator|.
name|update
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|docsToUpdate
argument_list|,
name|upsert
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|failedUpdates
init|=
name|Sets
operator|.
name|difference
argument_list|(
name|keysToUpdate
argument_list|,
name|successfulUpdates
argument_list|)
decl_stmt|;
name|oldDocs
operator|.
name|keySet
argument_list|()
operator|.
name|removeAll
argument_list|(
name|failedUpdates
argument_list|)
expr_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
for|for
control|(
name|T
name|doc
range|:
name|docsToUpdate
control|)
block|{
name|String
name|id
init|=
name|doc
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
name|successfulUpdates
operator|.
name|contains
argument_list|(
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|oldDocs
operator|.
name|containsKey
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|nodesCache
operator|.
name|replaceCachedDocument
argument_list|(
operator|(
name|NodeDocument
operator|)
name|oldDocs
operator|.
name|get
argument_list|(
name|id
argument_list|)
argument_list|,
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodesCache
operator|.
name|putIfAbsent
argument_list|(
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Map
argument_list|<
name|UpdateOp
argument_list|,
name|T
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|UpdateOp
argument_list|,
name|T
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateOp
name|op
range|:
name|updates
control|)
block|{
if|if
condition|(
name|successfulUpdates
operator|.
name|contains
argument_list|(
name|op
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|oldDocs
operator|.
name|get
argument_list|(
name|op
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|findAndUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
return|return
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CacheInvalidationStats
name|invalidateCache
parameter_list|()
block|{
for|for
control|(
name|NodeDocument
name|nd
range|:
name|nodesCache
operator|.
name|values
argument_list|()
control|)
block|{
name|nd
operator|.
name|markUpToDate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|CacheInvalidationStats
name|invalidateCache
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|)
block|{
comment|//TODO: optimize me
return|return
name|invalidateCache
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|invalidateCache
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|invalidateCache
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|invalidateCache
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|,
name|boolean
name|remove
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|invalidateNodesCache
argument_list|(
name|id
argument_list|,
name|remove
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|invalidateNodesCache
parameter_list|(
name|String
name|id
parameter_list|,
name|boolean
name|remove
parameter_list|)
block|{
name|Lock
name|lock
init|=
name|locks
operator|.
name|acquire
argument_list|(
name|id
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|remove
condition|)
block|{
name|nodesCache
operator|.
name|invalidate
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NodeDocument
name|entry
init|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|markUpToDate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|determineServerTimeDifferenceMillis
parameter_list|()
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getROConnection
argument_list|()
expr_stmt|;
name|long
name|result
init|=
name|this
operator|.
name|db
operator|.
name|determineServerTimeDifferenceMillis
argument_list|(
name|connection
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Trying to determine time difference to server"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
comment|// used for diagnostics
specifier|private
name|String
name|droppedTables
init|=
literal|""
decl_stmt|;
specifier|public
name|String
name|getDroppedTables
parameter_list|()
block|{
return|return
name|this
operator|.
name|droppedTables
return|;
block|}
comment|// table names
specifier|private
specifier|static
name|Map
argument_list|<
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
argument_list|,
name|String
argument_list|>
name|TABLEMAP
decl_stmt|;
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|TABLENAMES
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
argument_list|,
name|String
argument_list|>
name|tmp
init|=
operator|new
name|HashMap
argument_list|<
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|tmp
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
literal|"CLUSTERNODES"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|JOURNAL
argument_list|,
literal|"JOURNAL"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
literal|"NODES"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|,
literal|"SETTINGS"
argument_list|)
expr_stmt|;
name|TABLEMAP
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tl
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|TABLEMAP
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|TABLENAMES
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|getTableNames
parameter_list|()
block|{
return|return
name|TABLENAMES
return|;
block|}
comment|/**      * Holds the data about a table that can vary: name, whether the primary key      * is binary, and the estimated size of the "data" column.      */
specifier|static
class|class
name|RDBTableMetaData
block|{
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
name|boolean
name|idIsBinary
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|dataLimitInOctets
init|=
literal|16384
decl_stmt|;
specifier|public
name|RDBTableMetaData
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
specifier|public
name|int
name|getDataLimitInOctets
parameter_list|()
block|{
return|return
name|this
operator|.
name|dataLimitInOctets
return|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|this
operator|.
name|name
return|;
block|}
specifier|public
name|boolean
name|isIdBinary
parameter_list|()
block|{
return|return
name|this
operator|.
name|idIsBinary
return|;
block|}
specifier|public
name|void
name|setIdIsBinary
parameter_list|(
name|boolean
name|idIsBinary
parameter_list|)
block|{
name|this
operator|.
name|idIsBinary
operator|=
name|idIsBinary
expr_stmt|;
block|}
specifier|public
name|void
name|setDataLimitInOctets
parameter_list|(
name|int
name|dataLimitInOctets
parameter_list|)
block|{
name|this
operator|.
name|dataLimitInOctets
operator|=
name|dataLimitInOctets
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
name|Map
argument_list|<
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
argument_list|,
name|RDBTableMetaData
argument_list|>
name|tableMeta
init|=
operator|new
name|HashMap
argument_list|<
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
argument_list|,
name|RDBTableMetaData
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|dispose
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|tablesToBeDropped
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|dropped
init|=
literal|""
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempting to drop: "
operator|+
name|this
operator|.
name|tablesToBeDropped
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|tname
range|:
name|this
operator|.
name|tablesToBeDropped
control|)
block|{
name|Connection
name|con
init|=
literal|null
decl_stmt|;
try|try
block|{
name|con
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
literal|"drop table "
operator|+
name|tname
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
name|dropped
operator|+=
name|tname
operator|+
literal|" "
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempting to drop: "
operator|+
name|tname
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|closeStatement
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"attempting to drop: "
operator|+
name|tname
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|con
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|droppedTables
operator|=
name|dropped
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|this
operator|.
name|ch
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"closing connection handler"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|this
operator|.
name|nodesCache
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error occurred while closing nodes cache"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"RDBDocumentStore ("
operator|+
name|OakVersion
operator|.
name|getVersion
argument_list|()
operator|+
literal|") disposed"
operator|+
name|getCnStats
argument_list|()
operator|+
operator|(
name|this
operator|.
name|droppedTables
operator|.
name|isEmpty
argument_list|()
condition|?
literal|""
else|:
literal|" (tables dropped: "
operator|+
name|this
operator|.
name|droppedTables
operator|+
literal|")"
operator|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|getIfCached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|!=
name|Collection
operator|.
name|NODES
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|NodeDocument
name|doc
init|=
name|unwrap
argument_list|(
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|id
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|castAsT
argument_list|(
name|doc
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Iterable
argument_list|<
name|CacheStats
argument_list|>
name|getCacheStats
parameter_list|()
block|{
return|return
name|nodesCache
operator|.
name|getCacheStats
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getMetadata
parameter_list|()
block|{
return|return
name|metadata
return|;
block|}
comment|// implementation
specifier|private
specifier|static
specifier|final
name|String
name|MODIFIED
init|=
literal|"_modified"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|MODCOUNT
init|=
literal|"_modCount"
decl_stmt|;
comment|/**      * Optional counter for changes to "_collisions" map ({@link NodeDocument#COLLISIONS}).      */
specifier|public
specifier|static
specifier|final
name|String
name|COLLISIONSMODCOUNT
init|=
literal|"_collisionsModCount"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ID
init|=
literal|"_id"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RDBDocumentStore
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|Exception
name|callStack
decl_stmt|;
specifier|private
name|RDBConnectionHandler
name|ch
decl_stmt|;
comment|// from options
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|tablesToBeDropped
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// ratio between Java characters and UTF-8 encoding
comment|// a) single characters will fit into 3 bytes
comment|// b) a surrogate pair (two Java characters) will fit into 4 bytes
comment|// thus...
specifier|public
specifier|static
specifier|final
name|int
name|CHAR2OCTETRATIO
init|=
literal|3
decl_stmt|;
comment|// number of retries for updates
specifier|private
specifier|static
specifier|final
name|int
name|RETRIES
init|=
literal|10
decl_stmt|;
comment|// see OAK-2044
specifier|protected
specifier|static
specifier|final
name|boolean
name|USECMODCOUNT
init|=
literal|true
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Key
name|MODIFIEDKEY
init|=
operator|new
name|Key
argument_list|(
name|MODIFIED
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// DB-specific information
specifier|private
name|RDBDocumentStoreDB
name|dbInfo
decl_stmt|;
comment|// utility class for performing low-level operations
specifier|private
name|RDBDocumentStoreJDBC
name|db
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMPTY_KEY_PATTERN
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|metadata
decl_stmt|;
specifier|private
name|DocumentStoreStatsCollector
name|stats
decl_stmt|;
comment|// set of supported indexed properties
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|INDEXEDPROPERTIES
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|MODIFIED
block|,
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
block|,
name|NodeDocument
operator|.
name|DELETED_ONCE
block|}
argument_list|)
argument_list|)
decl_stmt|;
comment|// set of required table columns
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|REQUIREDCOLUMNS
init|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"id"
block|,
literal|"dsize"
block|,
literal|"deletedonce"
block|,
literal|"bdata"
block|,
literal|"data"
block|,
literal|"cmodcount"
block|,
literal|"modcount"
block|,
literal|"hasbinary"
block|,
literal|"modified"
block|}
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// set of properties not serialized to JSON
comment|// when adding new columns also update UNHANDLEDPROPS!
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|COLUMNPROPERTIES
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|ID
block|,
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
block|,
name|NodeDocument
operator|.
name|DELETED_ONCE
block|,
name|COLLISIONSMODCOUNT
block|,
name|MODIFIED
block|,
name|MODCOUNT
block|}
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|RDBDocumentSerializer
name|ser
init|=
operator|new
name|RDBDocumentSerializer
argument_list|(
name|this
argument_list|,
name|COLUMNPROPERTIES
argument_list|)
decl_stmt|;
specifier|private
name|void
name|initialize
parameter_list|(
name|DataSource
name|ds
parameter_list|,
name|DocumentMK
operator|.
name|Builder
name|builder
parameter_list|,
name|RDBOptions
name|options
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|stats
operator|=
name|builder
operator|.
name|getDocumentStoreStatsCollector
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableMeta
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
operator|new
name|RDBTableMetaData
argument_list|(
name|createTableName
argument_list|(
name|options
operator|.
name|getTablePrefix
argument_list|()
argument_list|,
name|TABLEMAP
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableMeta
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
operator|new
name|RDBTableMetaData
argument_list|(
name|createTableName
argument_list|(
name|options
operator|.
name|getTablePrefix
argument_list|()
argument_list|,
name|TABLEMAP
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableMeta
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|JOURNAL
argument_list|,
operator|new
name|RDBTableMetaData
argument_list|(
name|createTableName
argument_list|(
name|options
operator|.
name|getTablePrefix
argument_list|()
argument_list|,
name|TABLEMAP
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|JOURNAL
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableMeta
operator|.
name|put
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|,
operator|new
name|RDBTableMetaData
argument_list|(
name|createTableName
argument_list|(
name|options
operator|.
name|getTablePrefix
argument_list|()
argument_list|,
name|TABLEMAP
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|ch
operator|=
operator|new
name|RDBConnectionHandler
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|this
operator|.
name|callStack
operator|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|?
operator|new
name|Exception
argument_list|(
literal|"call stack of RDBDocumentStore creation"
argument_list|)
else|:
literal|null
expr_stmt|;
name|this
operator|.
name|locks
operator|=
operator|new
name|StripedNodeDocumentLocks
argument_list|()
expr_stmt|;
name|this
operator|.
name|nodesCache
operator|=
name|builder
operator|.
name|buildNodeDocumentCache
argument_list|(
name|this
argument_list|,
name|locks
argument_list|)
expr_stmt|;
name|Connection
name|con
init|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
decl_stmt|;
name|int
name|isolation
init|=
name|con
operator|.
name|getTransactionIsolation
argument_list|()
decl_stmt|;
name|String
name|isolationDiags
init|=
name|RDBJDBCTools
operator|.
name|isolationLevelToString
argument_list|(
name|isolation
argument_list|)
decl_stmt|;
if|if
condition|(
name|isolation
operator|!=
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Detected transaction isolation level "
operator|+
name|isolationDiags
operator|+
literal|" is "
operator|+
operator|(
name|isolation
operator|<
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
condition|?
literal|"lower"
else|:
literal|"higher"
operator|)
operator|+
literal|" than expected "
operator|+
name|RDBJDBCTools
operator|.
name|isolationLevelToString
argument_list|(
name|Connection
operator|.
name|TRANSACTION_READ_COMMITTED
argument_list|)
operator|+
literal|" - check datasource configuration"
argument_list|)
expr_stmt|;
block|}
name|DatabaseMetaData
name|md
init|=
name|con
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|String
name|dbDesc
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s %s (%d.%d)"
argument_list|,
name|md
operator|.
name|getDatabaseProductName
argument_list|()
argument_list|,
name|md
operator|.
name|getDatabaseProductVersion
argument_list|()
argument_list|,
name|md
operator|.
name|getDatabaseMajorVersion
argument_list|()
argument_list|,
name|md
operator|.
name|getDatabaseMinorVersion
argument_list|()
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"[\r\n\t]"
argument_list|,
literal|" "
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|driverDesc
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s %s (%d.%d)"
argument_list|,
name|md
operator|.
name|getDriverName
argument_list|()
argument_list|,
name|md
operator|.
name|getDriverVersion
argument_list|()
argument_list|,
name|md
operator|.
name|getDriverMajorVersion
argument_list|()
argument_list|,
name|md
operator|.
name|getDriverMinorVersion
argument_list|()
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"[\r\n\t]"
argument_list|,
literal|" "
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|dbUrl
init|=
name|md
operator|.
name|getURL
argument_list|()
decl_stmt|;
name|this
operator|.
name|dbInfo
operator|=
name|RDBDocumentStoreDB
operator|.
name|getValue
argument_list|(
name|md
operator|.
name|getDatabaseProductName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|db
operator|=
operator|new
name|RDBDocumentStoreJDBC
argument_list|(
name|this
operator|.
name|dbInfo
argument_list|,
name|this
operator|.
name|ser
argument_list|,
name|QUERYHITSLIMIT
argument_list|,
name|QUERYTIMELIMIT
argument_list|)
expr_stmt|;
name|this
operator|.
name|metadata
operator|=
name|ImmutableMap
operator|.
expr|<
name|String
operator|,
name|String
operator|>
name|builder
argument_list|()
operator|.
name|put
argument_list|(
literal|"type"
argument_list|,
literal|"rdb"
argument_list|)
operator|.
name|put
argument_list|(
literal|"db"
argument_list|,
name|md
operator|.
name|getDatabaseProductName
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"version"
argument_list|,
name|md
operator|.
name|getDatabaseProductVersion
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|String
name|versionDiags
init|=
name|dbInfo
operator|.
name|checkVersion
argument_list|(
name|md
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|versionDiags
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|versionDiags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
literal|""
operator|.
name|equals
argument_list|(
name|dbInfo
operator|.
name|getInitializationStatement
argument_list|()
argument_list|)
condition|)
block|{
name|Statement
name|stmt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stmt
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|stmt
operator|.
name|execute
argument_list|(
name|dbInfo
operator|.
name|getInitializationStatement
argument_list|()
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|closeStatement
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|tablesCreated
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tablesPresent
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|tableDiags
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
try|try
block|{
name|createTableFor
argument_list|(
name|con
argument_list|,
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|,
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|CLUSTER_NODES
argument_list|)
argument_list|,
name|tablesCreated
argument_list|,
name|tablesPresent
argument_list|,
name|tableDiags
argument_list|)
expr_stmt|;
name|createTableFor
argument_list|(
name|con
argument_list|,
name|Collection
operator|.
name|NODES
argument_list|,
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|)
argument_list|,
name|tablesCreated
argument_list|,
name|tablesPresent
argument_list|,
name|tableDiags
argument_list|)
expr_stmt|;
name|createTableFor
argument_list|(
name|con
argument_list|,
name|Collection
operator|.
name|SETTINGS
argument_list|,
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|SETTINGS
argument_list|)
argument_list|,
name|tablesCreated
argument_list|,
name|tablesPresent
argument_list|,
name|tableDiags
argument_list|)
expr_stmt|;
name|createTableFor
argument_list|(
name|con
argument_list|,
name|Collection
operator|.
name|JOURNAL
argument_list|,
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|JOURNAL
argument_list|)
argument_list|,
name|tablesCreated
argument_list|,
name|tablesPresent
argument_list|,
name|tableDiags
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
name|con
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|.
name|isDropTablesOnClose
argument_list|()
condition|)
block|{
name|tablesToBeDropped
operator|.
name|addAll
argument_list|(
name|tablesCreated
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tableDiags
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|tableDiags
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|String
name|diag
init|=
name|dbInfo
operator|.
name|getAdditionalDiagnostics
argument_list|(
name|this
operator|.
name|ch
argument_list|,
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"RDBDocumentStore ("
operator|+
name|OakVersion
operator|.
name|getVersion
argument_list|()
operator|+
literal|") instantiated for database "
operator|+
name|dbDesc
operator|+
literal|", using driver: "
operator|+
name|driverDesc
operator|+
literal|", connecting to: "
operator|+
name|dbUrl
operator|+
operator|(
name|diag
operator|.
name|isEmpty
argument_list|()
condition|?
literal|""
else|:
operator|(
literal|", properties: "
operator|+
name|diag
operator|)
operator|)
operator|+
literal|", transaction isolation level: "
operator|+
name|isolationDiags
operator|+
name|tableDiags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tablesPresent
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Tables present upon startup: "
operator|+
name|tablesPresent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tablesCreated
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Tables created upon startup: "
operator|+
name|tablesCreated
operator|+
operator|(
name|options
operator|.
name|isDropTablesOnClose
argument_list|()
condition|?
literal|" (will be dropped on exit)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isBinaryType
parameter_list|(
name|int
name|sqlType
parameter_list|)
block|{
return|return
name|sqlType
operator|==
name|Types
operator|.
name|VARBINARY
operator|||
name|sqlType
operator|==
name|Types
operator|.
name|BINARY
operator|||
name|sqlType
operator|==
name|Types
operator|.
name|LONGVARBINARY
return|;
block|}
specifier|private
name|void
name|obtainFlagsFromResultSetMeta
parameter_list|(
name|ResultSetMetaData
name|met
parameter_list|,
name|RDBTableMetaData
name|tmd
parameter_list|)
throws|throws
name|SQLException
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|met
operator|.
name|getColumnCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|lcName
init|=
name|met
operator|.
name|getColumnName
argument_list|(
name|i
argument_list|)
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"id"
operator|.
name|equals
argument_list|(
name|lcName
argument_list|)
condition|)
block|{
name|tmd
operator|.
name|setIdIsBinary
argument_list|(
name|isBinaryType
argument_list|(
name|met
operator|.
name|getColumnType
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"data"
operator|.
name|equals
argument_list|(
name|lcName
argument_list|)
condition|)
block|{
name|tmd
operator|.
name|setDataLimitInOctets
argument_list|(
name|met
operator|.
name|getPrecision
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|String
name|asQualifiedDbName
parameter_list|(
name|String
name|one
parameter_list|,
name|String
name|two
parameter_list|)
block|{
if|if
condition|(
name|one
operator|==
literal|null
operator|&&
name|two
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|one
operator|=
name|one
operator|==
literal|null
condition|?
literal|""
else|:
name|one
operator|.
name|trim
argument_list|()
expr_stmt|;
name|two
operator|=
name|two
operator|==
literal|null
condition|?
literal|""
else|:
name|two
operator|.
name|trim
argument_list|()
expr_stmt|;
return|return
name|one
operator|.
name|isEmpty
argument_list|()
condition|?
name|two
else|:
name|one
operator|+
literal|"."
operator|+
name|two
return|;
block|}
block|}
specifier|private
specifier|static
name|String
name|indexTypeAsString
parameter_list|(
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DatabaseMetaData
operator|.
name|tableIndexClustered
case|:
return|return
literal|"clustered"
return|;
case|case
name|DatabaseMetaData
operator|.
name|tableIndexHashed
case|:
return|return
literal|"hashed"
return|;
case|case
name|DatabaseMetaData
operator|.
name|tableIndexStatistic
case|:
return|return
literal|"statistic"
return|;
case|case
name|DatabaseMetaData
operator|.
name|tableIndexOther
case|:
return|return
literal|"other"
return|;
default|default:
return|return
literal|"indexType="
operator|+
name|type
return|;
block|}
block|}
specifier|private
name|String
name|dumpIndexData
parameter_list|(
name|DatabaseMetaData
name|met
parameter_list|,
name|ResultSetMetaData
name|rmet
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// if the result set metadata provides a table name, use that (the other one
comment|// might be inaccurate due to case insensitivity issues
name|String
name|rmetTableName
init|=
name|rmet
operator|.
name|getTableName
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rmetTableName
operator|!=
literal|null
operator|&&
operator|!
name|rmetTableName
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|tableName
operator|=
name|rmetTableName
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
name|String
name|rmetSchemaName
init|=
name|rmet
operator|.
name|getSchemaName
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|rmetSchemaName
operator|=
name|rmetSchemaName
operator|==
literal|null
condition|?
literal|""
else|:
name|rmetSchemaName
operator|.
name|trim
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|indices
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|rs
operator|=
name|met
operator|.
name|getIndexInfo
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|getIndexInformation
argument_list|(
name|rs
argument_list|,
name|rmetSchemaName
argument_list|,
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|indices
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|tableName
operator|.
name|equals
argument_list|(
name|tableName
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
argument_list|)
condition|)
block|{
comment|// might have failed due to the DB's handling on ucase/lcase, retry ucase
name|rs
operator|=
name|met
operator|.
name|getIndexInfo
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|tableName
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|getIndexInformation
argument_list|(
name|rs
argument_list|,
name|rmetSchemaName
argument_list|,
name|indices
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|index
range|:
name|indices
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|boolean
name|nonUnique
init|=
operator|(
operator|(
name|Boolean
operator|)
name|index
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
literal|"nonunique"
argument_list|)
operator|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|fields
init|=
operator|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
operator|)
name|index
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
literal|"fields"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%sindex %s on %s ("
argument_list|,
name|nonUnique
condition|?
literal|""
else|:
literal|"unique "
argument_list|,
name|index
operator|.
name|getKey
argument_list|()
argument_list|,
name|index
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
literal|"tname"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|delim
init|=
literal|""
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
operator|.
name|values
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|delim
argument_list|)
expr_stmt|;
name|delim
operator|=
literal|", "
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|index
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|"/* "
argument_list|)
operator|.
name|append
argument_list|(
literal|" */"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// well it was best-effort
return|return
name|String
operator|.
name|format
argument_list|(
literal|"/* exception while retrieving index information: %s, code %d, state %s */"
argument_list|,
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
operator|.
name|getErrorCode
argument_list|()
argument_list|,
name|ex
operator|.
name|getSQLState
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|closeResultSet
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|getIndexInformation
parameter_list|(
name|ResultSet
name|rs
parameter_list|,
name|String
name|rmetSchemaName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|indices
parameter_list|)
throws|throws
name|SQLException
block|{
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|name
init|=
name|asQualifiedDbName
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|5
argument_list|)
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|info
init|=
name|indices
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|info
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
expr_stmt|;
name|indices
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"fields"
argument_list|,
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|put
argument_list|(
literal|"nonunique"
argument_list|,
name|rs
operator|.
name|getBoolean
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"type"
argument_list|,
name|indexTypeAsString
argument_list|(
name|rs
operator|.
name|getInt
argument_list|(
literal|7
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|inSchema
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|inSchema
operator|=
name|inSchema
operator|==
literal|null
condition|?
literal|""
else|:
name|inSchema
operator|.
name|trim
argument_list|()
expr_stmt|;
comment|// skip indices on tables in other schemas in case we have that information
if|if
condition|(
name|rmetSchemaName
operator|.
name|isEmpty
argument_list|()
operator|||
name|inSchema
operator|.
name|isEmpty
argument_list|()
operator|||
name|rmetSchemaName
operator|.
name|equals
argument_list|(
name|inSchema
argument_list|)
condition|)
block|{
name|String
name|tname
init|=
name|asQualifiedDbName
argument_list|(
name|inSchema
argument_list|,
name|rs
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"tname"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|String
name|cname
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|9
argument_list|)
decl_stmt|;
if|if
condition|(
name|cname
operator|!=
literal|null
condition|)
block|{
name|String
name|order
init|=
literal|"A"
operator|.
name|equals
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|10
argument_list|)
argument_list|)
condition|?
literal|" ASC"
else|:
operator|(
literal|"D"
operator|.
name|equals
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|10
argument_list|)
argument_list|)
condition|?
literal|" DESC"
else|:
literal|""
operator|)
decl_stmt|;
operator|(
operator|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
operator|)
name|info
operator|.
name|get
argument_list|(
literal|"fields"
argument_list|)
operator|)
operator|.
name|put
argument_list|(
name|rs
operator|.
name|getInt
argument_list|(
literal|8
argument_list|)
argument_list|,
name|cname
operator|+
name|order
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|private
name|void
name|createTableFor
parameter_list|(
name|Connection
name|con
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|Document
argument_list|>
name|col
parameter_list|,
name|RDBTableMetaData
name|tmd
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tablesCreated
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tablesPresent
parameter_list|,
name|StringBuilder
name|diagnostics
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|dbname
init|=
name|this
operator|.
name|dbInfo
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|con
operator|.
name|getMetaData
argument_list|()
operator|.
name|getURL
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dbname
operator|+=
literal|" ("
operator|+
name|con
operator|.
name|getMetaData
argument_list|()
operator|.
name|getURL
argument_list|()
operator|+
literal|")"
expr_stmt|;
block|}
name|String
name|tableName
init|=
name|tmd
operator|.
name|getName
argument_list|()
decl_stmt|;
name|PreparedStatement
name|checkStatement
init|=
literal|null
decl_stmt|,
name|checkStatement2
init|=
literal|null
decl_stmt|;
name|ResultSet
name|checkResultSet
init|=
literal|null
decl_stmt|;
name|Statement
name|creatStatement
init|=
literal|null
decl_stmt|;
try|try
block|{
name|checkStatement
operator|=
name|con
operator|.
name|prepareStatement
argument_list|(
literal|"select * from "
operator|+
name|tableName
operator|+
literal|" where ID = ?"
argument_list|)
expr_stmt|;
name|checkStatement
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
literal|"0:/"
argument_list|)
expr_stmt|;
name|checkResultSet
operator|=
name|checkStatement
operator|.
name|executeQuery
argument_list|()
expr_stmt|;
comment|// try to discover size of DATA column and binary-ness of ID
name|ResultSetMetaData
name|met
init|=
name|checkResultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|obtainFlagsFromResultSetMeta
argument_list|(
name|met
argument_list|,
name|tmd
argument_list|)
expr_stmt|;
comment|// check that all required columns are present
name|Set
argument_list|<
name|String
argument_list|>
name|requiredColumns
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|REQUIREDCOLUMNS
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|unknownColumns
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|met
operator|.
name|getColumnCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|cname
init|=
name|met
operator|.
name|getColumnName
argument_list|(
name|i
argument_list|)
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|requiredColumns
operator|.
name|remove
argument_list|(
name|cname
argument_list|)
condition|)
block|{
name|unknownColumns
operator|.
name|add
argument_list|(
name|cname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|requiredColumns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Table %s: the following required columns are missing: %s"
argument_list|,
name|tableName
argument_list|,
name|requiredColumns
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|message
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|unknownColumns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Table %s: the following columns are unknown and will not be maintained: %s"
argument_list|,
name|tableName
argument_list|,
name|unknownColumns
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|col
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|String
name|tableInfo
init|=
name|RDBJDBCTools
operator|.
name|dumpResultSetMeta
argument_list|(
name|met
argument_list|)
decl_stmt|;
name|diagnostics
operator|.
name|append
argument_list|(
name|tableInfo
argument_list|)
expr_stmt|;
name|String
name|indexInfo
init|=
name|dumpIndexData
argument_list|(
name|con
operator|.
name|getMetaData
argument_list|()
argument_list|,
name|met
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|indexInfo
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|diagnostics
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|indexInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|tablesPresent
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
comment|// table does not appear to exist
name|con
operator|.
name|rollback
argument_list|()
expr_stmt|;
try|try
block|{
name|creatStatement
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|creatStatement
operator|.
name|execute
argument_list|(
name|this
operator|.
name|dbInfo
operator|.
name|getTableCreationStatement
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|creatStatement
operator|.
name|close
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|ic
range|:
name|this
operator|.
name|dbInfo
operator|.
name|getIndexCreationStatements
argument_list|(
name|tableName
argument_list|)
control|)
block|{
name|creatStatement
operator|=
name|con
operator|.
name|createStatement
argument_list|()
expr_stmt|;
name|creatStatement
operator|.
name|execute
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|creatStatement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|con
operator|.
name|commit
argument_list|()
expr_stmt|;
name|tablesCreated
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|checkStatement2
operator|=
name|con
operator|.
name|prepareStatement
argument_list|(
literal|"select * from "
operator|+
name|tableName
operator|+
literal|" where ID = ?"
argument_list|)
expr_stmt|;
name|checkStatement2
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
literal|"0:/"
argument_list|)
expr_stmt|;
name|ResultSet
name|rs
init|=
name|checkStatement2
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
comment|// try to discover size of DATA column and binary-ness of ID
name|ResultSetMetaData
name|met
init|=
name|rs
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|obtainFlagsFromResultSetMeta
argument_list|(
name|met
argument_list|,
name|tmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|String
name|tableInfo
init|=
name|RDBJDBCTools
operator|.
name|dumpResultSetMeta
argument_list|(
name|met
argument_list|)
decl_stmt|;
name|diagnostics
operator|.
name|append
argument_list|(
name|tableInfo
argument_list|)
expr_stmt|;
name|String
name|indexInfo
init|=
name|dumpIndexData
argument_list|(
name|con
operator|.
name|getMetaData
argument_list|()
argument_list|,
name|met
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|indexInfo
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|diagnostics
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|indexInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex2
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to create table "
operator|+
name|tableName
operator|+
literal|" in "
operator|+
name|dbname
argument_list|,
name|ex2
argument_list|)
expr_stmt|;
throw|throw
name|ex2
throw|;
block|}
block|}
finally|finally
block|{
name|closeResultSet
argument_list|(
name|checkResultSet
argument_list|)
expr_stmt|;
name|closeStatement
argument_list|(
name|checkStatement
argument_list|)
expr_stmt|;
name|closeStatement
argument_list|(
name|checkStatement2
argument_list|)
expr_stmt|;
name|closeStatement
argument_list|(
name|creatStatement
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|ch
operator|.
name|isClosed
argument_list|()
operator|&&
name|this
operator|.
name|callStack
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"finalizing RDBDocumentStore that was not disposed"
argument_list|,
name|this
operator|.
name|callStack
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|readDocumentCached
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
specifier|final
name|String
name|id
parameter_list|,
name|int
name|maxCacheAge
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|!=
name|Collection
operator|.
name|NODES
condition|)
block|{
return|return
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
name|NodeDocument
name|doc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|maxCacheAge
operator|>
literal|0
condition|)
block|{
comment|// first try without lock
name|doc
operator|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|long
name|lastCheckTime
init|=
name|doc
operator|.
name|getLastCheckTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastCheckTime
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|maxCacheAge
operator|==
name|Integer
operator|.
name|MAX_VALUE
operator|||
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastCheckTime
operator|<
name|maxCacheAge
condition|)
block|{
name|stats
operator|.
name|doneFindCached
argument_list|(
name|Collection
operator|.
name|NODES
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|castAsT
argument_list|(
name|unwrap
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
block|}
try|try
block|{
name|Lock
name|lock
init|=
name|locks
operator|.
name|acquire
argument_list|(
name|id
argument_list|)
decl_stmt|;
try|try
block|{
comment|// caller really wants the cache to be cleared
if|if
condition|(
name|maxCacheAge
operator|==
literal|0
condition|)
block|{
name|invalidateNodesCache
argument_list|(
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|doc
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|NodeDocument
name|cachedDoc
init|=
name|doc
decl_stmt|;
name|doc
operator|=
name|nodesCache
operator|.
name|get
argument_list|(
name|id
argument_list|,
operator|new
name|Callable
argument_list|<
name|NodeDocument
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|NodeDocument
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|NodeDocument
name|doc
init|=
operator|(
name|NodeDocument
operator|)
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|cachedDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|seal
argument_list|()
expr_stmt|;
block|}
return|return
name|wrap
argument_list|(
name|doc
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// inspect the doc whether it can be used
name|long
name|lastCheckTime
init|=
name|doc
operator|.
name|getLastCheckTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastCheckTime
operator|!=
literal|0
operator|&&
operator|(
name|maxCacheAge
operator|==
literal|0
operator|||
name|maxCacheAge
operator|==
name|Integer
operator|.
name|MAX_VALUE
operator|)
condition|)
block|{
comment|// we either just cleared the cache or the caller does
comment|// not care;
block|}
elseif|else
if|if
condition|(
name|lastCheckTime
operator|!=
literal|0
operator|&&
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastCheckTime
operator|<
name|maxCacheAge
operator|)
condition|)
block|{
comment|// is new enough
block|}
else|else
block|{
comment|// need to at least revalidate
name|NodeDocument
name|ndoc
init|=
operator|(
name|NodeDocument
operator|)
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|id
argument_list|,
name|cachedDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|ndoc
operator|!=
literal|null
condition|)
block|{
name|ndoc
operator|.
name|seal
argument_list|()
expr_stmt|;
block|}
name|doc
operator|=
name|wrap
argument_list|(
name|ndoc
argument_list|)
expr_stmt|;
name|nodesCache
operator|.
name|put
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|castAsT
argument_list|(
name|unwrap
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Failed to load document with "
operator|+
name|id
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|internalCreate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|updates
parameter_list|)
block|{
specifier|final
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|updates
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
try|try
block|{
comment|// try up to CHUNKSIZE ops in one transaction
for|for
control|(
name|List
argument_list|<
name|UpdateOp
argument_list|>
name|chunks
range|:
name|Lists
operator|.
name|partition
argument_list|(
name|updates
argument_list|,
name|CHUNKSIZE
argument_list|)
control|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|docs
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdateOp
name|update
range|:
name|chunks
control|)
block|{
name|ids
operator|.
name|add
argument_list|(
name|update
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|maintainUpdateStats
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|UpdateUtils
operator|.
name|assertUnconditional
argument_list|(
name|update
argument_list|)
expr_stmt|;
name|T
name|doc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|addUpdateCounters
argument_list|(
name|update
argument_list|)
expr_stmt|;
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|doc
argument_list|,
name|update
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|update
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"ID mismatch - UpdateOp: "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|", ID property: "
operator|+
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
name|docs
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|boolean
name|done
init|=
name|insertDocuments
argument_list|(
name|collection
argument_list|,
name|docs
argument_list|)
decl_stmt|;
if|if
condition|(
name|done
condition|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
for|for
control|(
name|T
name|doc
range|:
name|docs
control|)
block|{
name|nodesCache
operator|.
name|putIfAbsent
argument_list|(
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|success
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|success
return|;
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|ex
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|stats
operator|.
name|doneCreate
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|ids
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|internalCreateOrUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|,
name|boolean
name|allowCreate
parameter_list|,
name|boolean
name|checkConditions
parameter_list|)
block|{
name|T
name|oldDoc
init|=
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|allowCreate
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|update
operator|.
name|isNew
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"Document does not exist: "
operator|+
name|update
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
name|T
name|doc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|checkConditions
operator|&&
operator|!
name|checkConditions
argument_list|(
name|doc
argument_list|,
name|update
operator|.
name|getConditions
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|addUpdateCounters
argument_list|(
name|update
argument_list|)
expr_stmt|;
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|doc
argument_list|,
name|update
argument_list|)
expr_stmt|;
try|try
block|{
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|insertDocuments
argument_list|(
name|collection
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|doc
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"Can't insert the document: "
operator|+
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|nodesCache
operator|.
name|putIfAbsent
argument_list|(
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|doneFindAndModify
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|oldDoc
return|;
block|}
catch|catch
parameter_list|(
name|DocumentStoreException
name|ex
parameter_list|)
block|{
comment|// may have failed due to a race condition; try update instead
comment|// this is an edge case, so it's ok to bypass the cache
comment|// (avoiding a race condition where the DB is already updated
comment|// but the cache is not)
name|oldDoc
operator|=
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// something else went wrong
name|LOG
operator|.
name|error
argument_list|(
literal|"insert failed, but document "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|" is not present, aborting"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|ex
operator|)
throw|;
block|}
return|return
name|internalUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
name|oldDoc
argument_list|,
name|checkConditions
argument_list|,
name|RETRIES
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|T
name|result
init|=
name|internalUpdate
argument_list|(
name|collection
argument_list|,
name|update
argument_list|,
name|oldDoc
argument_list|,
name|checkConditions
argument_list|,
name|RETRIES
argument_list|)
decl_stmt|;
if|if
condition|(
name|allowCreate
operator|&&
name|result
operator|==
literal|null
condition|)
block|{
comment|// TODO OAK-2655 need to implement some kind of retry
name|LOG
operator|.
name|error
argument_list|(
literal|"update of "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|" failed, race condition?"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"update of "
operator|+
name|update
operator|.
name|getId
argument_list|()
operator|+
literal|" failed, race condition?"
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
block|}
comment|/**      * @return previous version of document or<code>null</code>      */
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|internalUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|UpdateOp
name|update
parameter_list|,
name|T
name|oldDoc
parameter_list|,
name|boolean
name|checkConditions
parameter_list|,
name|int
name|maxRetries
parameter_list|)
block|{
if|if
condition|(
name|checkConditions
operator|&&
operator|!
name|UpdateUtils
operator|.
name|checkConditions
argument_list|(
name|oldDoc
argument_list|,
name|update
operator|.
name|getConditions
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|maintainUpdateStats
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|addUpdateCounters
argument_list|(
name|update
argument_list|)
expr_stmt|;
name|T
name|doc
init|=
name|createNewDocument
argument_list|(
name|collection
argument_list|,
name|oldDoc
argument_list|,
name|update
argument_list|)
decl_stmt|;
name|Lock
name|l
init|=
name|locks
operator|.
name|acquire
argument_list|(
name|update
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|int
name|retries
init|=
name|maxRetries
decl_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|success
operator|&&
name|retries
operator|>
literal|0
condition|)
block|{
name|long
name|lastmodcount
init|=
name|modcountOf
argument_list|(
name|oldDoc
argument_list|)
decl_stmt|;
name|success
operator|=
name|updateDocument
argument_list|(
name|collection
argument_list|,
name|doc
argument_list|,
name|update
argument_list|,
name|lastmodcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|retries
operator|-=
literal|1
expr_stmt|;
name|oldDoc
operator|=
name|readDocumentCached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldDoc
operator|!=
literal|null
condition|)
block|{
name|long
name|newmodcount
init|=
name|modcountOf
argument_list|(
name|oldDoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastmodcount
operator|==
name|newmodcount
condition|)
block|{
comment|// cached copy did not change so it probably was
comment|// updated by a different instance, get a fresh one
name|oldDoc
operator|=
name|readDocumentUncached
argument_list|(
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldDoc
operator|==
literal|null
condition|)
block|{
comment|// document was there but is now gone
name|LOG
operator|.
name|debug
argument_list|(
literal|"failed to apply update because document is gone in the meantime: "
operator|+
name|update
operator|.
name|getId
argument_list|()
argument_list|,
operator|new
name|Exception
argument_list|(
literal|"call stack"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|checkConditions
operator|&&
operator|!
name|UpdateUtils
operator|.
name|checkConditions
argument_list|(
name|oldDoc
argument_list|,
name|update
operator|.
name|getConditions
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|addUpdateCounters
argument_list|(
name|update
argument_list|)
expr_stmt|;
name|doc
operator|=
name|createNewDocument
argument_list|(
name|collection
argument_list|,
name|oldDoc
argument_list|,
name|update
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|nodesCache
operator|.
name|replaceCachedDocument
argument_list|(
operator|(
name|NodeDocument
operator|)
name|oldDoc
argument_list|,
operator|(
name|NodeDocument
operator|)
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
literal|"failed update of "
operator|+
name|doc
operator|.
name|getId
argument_list|()
operator|+
literal|" (race?) after "
operator|+
name|maxRetries
operator|+
literal|" retries"
argument_list|)
throw|;
block|}
return|return
name|oldDoc
return|;
block|}
finally|finally
block|{
name|l
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|int
name|numOfAttempts
init|=
name|maxRetries
operator|-
name|retries
operator|-
literal|1
decl_stmt|;
name|stats
operator|.
name|doneFindAndModify
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|update
operator|.
name|getId
argument_list|()
argument_list|,
literal|false
argument_list|,
name|success
argument_list|,
name|numOfAttempts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Nonnull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|createNewDocument
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|T
name|oldDoc
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
name|T
name|doc
init|=
name|collection
operator|.
name|newDocument
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|oldDoc
operator|.
name|deepCopy
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|UpdateUtils
operator|.
name|applyChanges
argument_list|(
name|doc
argument_list|,
name|update
argument_list|)
expr_stmt|;
name|doc
operator|.
name|seal
argument_list|()
expr_stmt|;
return|return
name|doc
return|;
block|}
specifier|private
specifier|static
name|void
name|addUpdateCounters
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
if|if
condition|(
name|hasChangesToCollisions
argument_list|(
name|update
argument_list|)
condition|)
block|{
name|update
operator|.
name|increment
argument_list|(
name|COLLISIONSMODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|increment
argument_list|(
name|MODCOUNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|internalUpdate
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|,
name|UpdateOp
name|update
parameter_list|)
block|{
if|if
condition|(
name|isAppendableUpdate
argument_list|(
name|update
argument_list|,
literal|true
argument_list|)
operator|&&
operator|!
name|requiresPreviousState
argument_list|(
name|update
argument_list|)
condition|)
block|{
name|Operation
name|modOperation
init|=
name|update
operator|.
name|getChanges
argument_list|()
operator|.
name|get
argument_list|(
name|MODIFIEDKEY
argument_list|)
decl_stmt|;
name|long
name|modified
init|=
name|getModifiedFromOperation
argument_list|(
name|modOperation
argument_list|)
decl_stmt|;
name|boolean
name|modifiedIsConditional
init|=
name|modOperation
operator|==
literal|null
operator|||
name|modOperation
operator|.
name|type
operator|!=
name|UpdateOp
operator|.
name|Operation
operator|.
name|Type
operator|.
name|SET
decl_stmt|;
name|String
name|appendData
init|=
name|ser
operator|.
name|asString
argument_list|(
name|update
argument_list|)
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|chunkedIds
range|:
name|Lists
operator|.
name|partition
argument_list|(
name|ids
argument_list|,
name|CHUNKSIZE
argument_list|)
control|)
block|{
name|Set
argument_list|<
name|QueryContext
argument_list|>
name|seenQueryContext
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|NodeDocument
argument_list|>
name|cachedDocs
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
comment|// remember what we already have in the cache
name|cachedDocs
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|NodeDocument
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|key
range|:
name|chunkedIds
control|)
block|{
name|cachedDocs
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// keep concurrently running queries from updating
comment|// the cache entry for this key
name|seenQueryContext
operator|=
operator|new
name|HashSet
argument_list|<
name|QueryContext
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|QueryContext
name|qc
range|:
name|qmap
operator|.
name|values
argument_list|()
control|)
block|{
name|qc
operator|.
name|addKeys
argument_list|(
name|chunkedIds
argument_list|)
expr_stmt|;
name|seenQueryContext
operator|.
name|add
argument_list|(
name|qc
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|id
range|:
name|chunkedIds
control|)
block|{
name|nodesCache
operator|.
name|invalidate
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|success
operator|=
name|db
operator|.
name|batchedAppendingUpdate
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|chunkedIds
argument_list|,
name|modified
argument_list|,
name|modifiedIsConditional
argument_list|,
name|appendData
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
comment|//Internally 'db' would make multiple calls and number of those
comment|//remote calls would not be captured
name|stats
operator|.
name|doneUpdate
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|chunkedIds
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
comment|// keep concurrently running queries from updating
comment|// the cache entry for this key
for|for
control|(
name|QueryContext
name|qc
range|:
name|qmap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|seenQueryContext
operator|.
name|contains
argument_list|(
name|qc
argument_list|)
condition|)
block|{
name|qc
operator|.
name|addKeys
argument_list|(
name|chunkedIds
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|id
range|:
name|chunkedIds
control|)
block|{
name|nodesCache
operator|.
name|invalidate
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|String
name|id
range|:
name|chunkedIds
control|)
block|{
name|UpdateOp
name|up
init|=
name|update
operator|.
name|copy
argument_list|()
decl_stmt|;
name|up
operator|=
name|up
operator|.
name|shallowCopy
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|up
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
name|UpdateOp
name|up
init|=
name|update
operator|.
name|copy
argument_list|()
decl_stmt|;
name|up
operator|=
name|up
operator|.
name|shallowCopy
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|internalCreateOrUpdate
argument_list|(
name|collection
argument_list|,
name|up
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Class used to track which documents may have been updated since the start      * of the query and thus may not put into the cache.      */
specifier|private
class|class
name|QueryContext
block|{
specifier|private
specifier|static
specifier|final
name|double
name|FPP
init|=
literal|0.01d
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ENTRIES_SCOPED
init|=
literal|1000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ENTRIES_OPEN
init|=
literal|10000
decl_stmt|;
specifier|private
specifier|final
name|String
name|fromKey
decl_stmt|,
name|toKey
decl_stmt|;
specifier|private
specifier|volatile
name|BloomFilter
argument_list|<
name|String
argument_list|>
name|filter
init|=
literal|null
decl_stmt|;
specifier|private
name|BloomFilter
argument_list|<
name|String
argument_list|>
name|getFilter
parameter_list|()
block|{
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
name|filter
operator|=
name|BloomFilter
operator|.
name|create
argument_list|(
operator|new
name|Funnel
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|7114267990225941161L
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|funnel
parameter_list|(
name|String
name|from
parameter_list|,
name|PrimitiveSink
name|into
parameter_list|)
block|{
name|into
operator|.
name|putUnencodedChars
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|toKey
operator|.
name|equals
argument_list|(
name|NodeDocument
operator|.
name|MAX_ID_VALUE
argument_list|)
condition|?
name|ENTRIES_OPEN
else|:
name|ENTRIES_SCOPED
argument_list|,
name|FPP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|filter
return|;
block|}
specifier|public
name|QueryContext
parameter_list|(
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|)
block|{
name|this
operator|.
name|fromKey
operator|=
name|fromKey
expr_stmt|;
name|this
operator|.
name|toKey
operator|=
name|toKey
expr_stmt|;
block|}
specifier|public
name|void
name|addKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|fromKey
operator|.
name|compareTo
argument_list|(
name|key
argument_list|)
operator|<
literal|0
operator|&&
name|toKey
operator|.
name|compareTo
argument_list|(
name|key
argument_list|)
operator|>
literal|0
condition|)
block|{
name|getFilter
argument_list|()
operator|.
name|put
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|addKeys
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|keys
parameter_list|)
block|{
for|for
control|(
name|String
name|key
range|:
name|keys
control|)
block|{
name|addKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|mayUpdate
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|filter
operator|==
literal|null
condition|?
literal|true
else|:
operator|!
name|getFilter
argument_list|()
operator|.
name|mightContain
argument_list|(
name|key
argument_list|)
return|;
block|}
specifier|synchronized
specifier|public
name|void
name|dispose
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Disposing QueryContext for range "
operator|+
name|fromKey
operator|+
literal|"..."
operator|+
name|toKey
operator|+
literal|" - filter fpp was: "
operator|+
name|filter
operator|.
name|expectedFpp
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Disposing QueryContext for range "
operator|+
name|fromKey
operator|+
literal|"..."
operator|+
name|toKey
operator|+
literal|" - no filter was needed"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|Map
argument_list|<
name|Thread
argument_list|,
name|QueryContext
argument_list|>
name|qmap
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|Thread
argument_list|,
name|QueryContext
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|internalQuery
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|fromKey
parameter_list|,
name|String
name|toKey
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|excludeKeyPatterns
parameter_list|,
name|List
argument_list|<
name|QueryCondition
argument_list|>
name|conditions
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
for|for
control|(
name|QueryCondition
name|cond
range|:
name|conditions
control|)
block|{
if|if
condition|(
operator|!
name|INDEXEDPROPERTIES
operator|.
name|contains
argument_list|(
name|cond
operator|.
name|getPropertyName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"indexed property "
operator|+
name|cond
operator|.
name|getPropertyName
argument_list|()
operator|+
literal|" not supported, query was '"
operator|+
name|cond
operator|.
name|getOperator
argument_list|()
operator|+
literal|"'"
operator|+
name|cond
operator|.
name|getValue
argument_list|()
operator|+
literal|"'; supported properties are "
operator|+
name|INDEXEDPROPERTIES
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
specifier|final
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
name|int
name|resultSize
init|=
literal|0
decl_stmt|;
try|try
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|QueryContext
name|qp
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|NODES
condition|)
block|{
name|qp
operator|=
operator|new
name|QueryContext
argument_list|(
name|fromKey
argument_list|,
name|toKey
argument_list|)
expr_stmt|;
name|qmap
operator|.
name|put
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getROConnection
argument_list|()
expr_stmt|;
name|String
name|from
init|=
name|collection
operator|==
name|Collection
operator|.
name|NODES
operator|&&
name|NodeDocument
operator|.
name|MIN_ID_VALUE
operator|.
name|equals
argument_list|(
name|fromKey
argument_list|)
condition|?
literal|null
else|:
name|fromKey
decl_stmt|;
name|String
name|to
init|=
name|collection
operator|==
name|Collection
operator|.
name|NODES
operator|&&
name|NodeDocument
operator|.
name|MAX_ID_VALUE
operator|.
name|equals
argument_list|(
name|toKey
argument_list|)
condition|?
literal|null
else|:
name|toKey
decl_stmt|;
name|List
argument_list|<
name|RDBRow
argument_list|>
name|dbresult
init|=
name|db
operator|.
name|query
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|excludeKeyPatterns
argument_list|,
name|conditions
argument_list|,
name|limit
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
name|int
name|size
init|=
name|dbresult
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|(
name|size
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|RDBRow
name|row
init|=
name|dbresult
operator|.
name|set
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// free RDBRow ASAP
name|T
name|doc
init|=
name|runThroughCache
argument_list|(
name|collection
argument_list|,
name|row
argument_list|,
name|now
argument_list|,
name|qp
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|resultSize
operator|=
name|result
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|qp
operator|!=
literal|null
condition|)
block|{
name|qp
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"SQL exception on query"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|qmap
operator|.
name|remove
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|stats
operator|.
name|doneQuery
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|fromKey
argument_list|,
name|toKey
argument_list|,
operator|!
name|conditions
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|resultSize
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Nonnull
specifier|protected
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|RDBTableMetaData
name|getTable
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|)
block|{
name|RDBTableMetaData
name|tmd
init|=
name|this
operator|.
name|tableMeta
operator|.
name|get
argument_list|(
name|collection
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmd
operator|!=
literal|null
condition|)
block|{
return|return
name|tmd
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown collection: "
operator|+
name|collection
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|CheckForNull
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|readDocumentUncached
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|,
name|NodeDocument
name|cachedDoc
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
specifier|final
name|Stopwatch
name|watch
init|=
name|startWatch
argument_list|()
decl_stmt|;
name|boolean
name|docFound
init|=
literal|true
decl_stmt|;
try|try
block|{
name|long
name|lastmodcount
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|cachedDoc
operator|!=
literal|null
condition|)
block|{
name|lastmodcount
operator|=
name|modcountOf
argument_list|(
name|cachedDoc
argument_list|)
expr_stmt|;
block|}
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getROConnection
argument_list|()
expr_stmt|;
name|RDBRow
name|row
init|=
name|db
operator|.
name|read
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|id
argument_list|,
name|lastmodcount
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
name|docFound
operator|=
literal|false
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
if|if
condition|(
name|lastmodcount
operator|==
name|row
operator|.
name|getModcount
argument_list|()
condition|)
block|{
comment|// we can re-use the cached document
name|cachedDoc
operator|.
name|markUpToDate
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|castAsT
argument_list|(
name|cachedDoc
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|convertFromDBObject
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|stats
operator|.
name|doneFindUncached
argument_list|(
name|watch
operator|.
name|elapsed
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|,
name|collection
argument_list|,
name|id
argument_list|,
name|docFound
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|void
name|delete
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|String
name|id
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|db
operator|.
name|delete
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|int
name|delete
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
block|{
name|int
name|numDeleted
init|=
literal|0
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|sublist
range|:
name|Lists
operator|.
name|partition
argument_list|(
name|ids
argument_list|,
literal|64
argument_list|)
control|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|numDeleted
operator|+=
name|db
operator|.
name|delete
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|sublist
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|numDeleted
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|int
name|delete
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
name|toRemove
parameter_list|)
block|{
name|int
name|numDeleted
init|=
literal|0
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
name|subMap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
argument_list|>
name|it
init|=
name|toRemove
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Key
argument_list|,
name|Condition
argument_list|>
argument_list|>
name|entry
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|subMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|subMap
operator|.
name|size
argument_list|()
operator|==
literal|64
operator|||
operator|!
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|numDeleted
operator|+=
name|db
operator|.
name|delete
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|subMap
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
name|DocumentStoreException
operator|.
name|convert
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
name|subMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|numDeleted
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|updateDocument
parameter_list|(
annotation|@
name|Nonnull
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
annotation|@
name|Nonnull
name|T
name|document
parameter_list|,
annotation|@
name|Nonnull
name|UpdateOp
name|update
parameter_list|,
name|Long
name|oldmodcount
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
name|String
name|data
init|=
literal|null
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|Operation
name|modOperation
init|=
name|update
operator|.
name|getChanges
argument_list|()
operator|.
name|get
argument_list|(
name|MODIFIEDKEY
argument_list|)
decl_stmt|;
name|long
name|modified
init|=
name|getModifiedFromOperation
argument_list|(
name|modOperation
argument_list|)
decl_stmt|;
name|boolean
name|modifiedIsConditional
init|=
name|modOperation
operator|==
literal|null
operator|||
name|modOperation
operator|.
name|type
operator|!=
name|UpdateOp
operator|.
name|Operation
operator|.
name|Type
operator|.
name|SET
decl_stmt|;
name|Number
name|flagB
init|=
operator|(
name|Number
operator|)
name|document
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
argument_list|)
decl_stmt|;
name|Boolean
name|hasBinary
init|=
name|flagB
operator|!=
literal|null
operator|&&
name|flagB
operator|.
name|intValue
argument_list|()
operator|==
name|NodeDocument
operator|.
name|HAS_BINARY_VAL
decl_stmt|;
name|Boolean
name|flagD
init|=
operator|(
name|Boolean
operator|)
name|document
operator|.
name|get
argument_list|(
name|NodeDocument
operator|.
name|DELETED_ONCE
argument_list|)
decl_stmt|;
name|Boolean
name|deletedOnce
init|=
name|flagD
operator|!=
literal|null
operator|&&
name|flagD
operator|.
name|booleanValue
argument_list|()
decl_stmt|;
name|Long
name|modcount
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|MODCOUNT
argument_list|)
decl_stmt|;
name|Long
name|cmodcount
init|=
operator|(
name|Long
operator|)
name|document
operator|.
name|get
argument_list|(
name|COLLISIONSMODCOUNT
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|boolean
name|shouldRetry
init|=
literal|true
decl_stmt|;
comment|// every 16th update is a full rewrite
if|if
condition|(
name|isAppendableUpdate
argument_list|(
name|update
argument_list|,
literal|false
argument_list|)
operator|&&
name|modcount
operator|%
literal|16
operator|!=
literal|0
condition|)
block|{
name|String
name|appendData
init|=
name|ser
operator|.
name|asString
argument_list|(
name|update
argument_list|)
decl_stmt|;
if|if
condition|(
name|appendData
operator|.
name|length
argument_list|()
operator|<
name|tmd
operator|.
name|getDataLimitInOctets
argument_list|()
operator|/
name|CHAR2OCTETRATIO
condition|)
block|{
try|try
block|{
name|success
operator|=
name|db
operator|.
name|appendingUpdate
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|modified
argument_list|,
name|modifiedIsConditional
argument_list|,
name|hasBinary
argument_list|,
name|deletedOnce
argument_list|,
name|modcount
argument_list|,
name|cmodcount
argument_list|,
name|oldmodcount
argument_list|,
name|appendData
argument_list|)
expr_stmt|;
comment|// if we get here, a retry is not going to help (the SQL
comment|// operation succeeded but simply did not select a row
comment|// that could be updated, likely because of the check on
comment|// MODCOUNT
name|shouldRetry
operator|=
literal|false
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|continueIfStringOverflow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|success
operator|&&
name|shouldRetry
condition|)
block|{
name|data
operator|=
name|ser
operator|.
name|asString
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|success
operator|=
name|db
operator|.
name|update
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|modified
argument_list|,
name|hasBinary
argument_list|,
name|deletedOnce
argument_list|,
name|modcount
argument_list|,
name|cmodcount
argument_list|,
name|oldmodcount
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|String
name|addDiags
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|RDBJDBCTools
operator|.
name|matchesSQLState
argument_list|(
name|ex
argument_list|,
literal|"22"
argument_list|,
literal|"72"
argument_list|)
condition|)
block|{
name|byte
index|[]
name|bytes
init|=
name|asBytes
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|addDiags
operator|=
name|String
operator|.
name|format
argument_list|(
literal|" (DATA size in Java characters: %d, in octets: %d, computed character limit: %d)"
argument_list|,
name|data
operator|.
name|length
argument_list|()
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
name|tmd
operator|.
name|getDataLimitInOctets
argument_list|()
operator|/
name|CHAR2OCTETRATIO
argument_list|)
expr_stmt|;
block|}
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Update for %s failed%s"
argument_list|,
name|document
operator|.
name|getId
argument_list|()
argument_list|,
name|addDiags
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|message
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|message
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|continueIfStringOverflow
parameter_list|(
name|SQLException
name|ex
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|state
init|=
name|ex
operator|.
name|getSQLState
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"22001"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
comment|/* everybody */
operator|||
operator|(
literal|"72000"
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|&&
literal|1489
operator|==
name|ex
operator|.
name|getErrorCode
argument_list|()
operator|)
comment|/* Oracle */
condition|)
block|{
comment|// ok
block|}
else|else
block|{
throw|throw
operator|(
name|ex
operator|)
throw|;
block|}
block|}
comment|// set of properties not serialized and not handled specifically by update code
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|Key
argument_list|>
name|UNHANDLEDPROPS
init|=
operator|new
name|HashSet
argument_list|<
name|Key
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Key
index|[]
block|{
operator|new
name|Key
argument_list|(
name|NodeDocument
operator|.
name|HAS_BINARY_FLAG
argument_list|,
literal|null
argument_list|)
block|,
operator|new
name|Key
argument_list|(
name|NodeDocument
operator|.
name|DELETED_ONCE
argument_list|,
literal|null
argument_list|)
block|}
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|boolean
name|isAppendableUpdate
parameter_list|(
name|UpdateOp
name|update
parameter_list|,
name|boolean
name|batched
parameter_list|)
block|{
if|if
condition|(
name|batched
condition|)
block|{
comment|// Detect update operations not supported when doing batch updates
for|for
control|(
name|Key
name|key
range|:
name|update
operator|.
name|getChanges
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|UNHANDLEDPROPS
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/*      * check whether this update operation requires knowledge about the previous      * state      */
specifier|private
specifier|static
name|boolean
name|requiresPreviousState
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
return|return
operator|!
name|update
operator|.
name|getConditions
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|long
name|getModifiedFromOperation
parameter_list|(
name|Operation
name|op
parameter_list|)
block|{
return|return
name|op
operator|==
literal|null
condition|?
literal|0L
else|:
name|Long
operator|.
name|parseLong
argument_list|(
name|op
operator|.
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|boolean
name|insertDocuments
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|documents
parameter_list|)
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|RDBTableMetaData
name|tmd
init|=
name|getTable
argument_list|(
name|collection
argument_list|)
decl_stmt|;
try|try
block|{
name|connection
operator|=
name|this
operator|.
name|ch
operator|.
name|getRWConnection
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|insertedKeys
init|=
name|db
operator|.
name|insert
argument_list|(
name|connection
argument_list|,
name|tmd
argument_list|,
name|documents
argument_list|)
decl_stmt|;
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
name|insertedKeys
operator|.
name|size
argument_list|()
operator|==
name|documents
operator|.
name|size
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ch
operator|.
name|rollbackConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|doc
range|:
name|documents
control|)
block|{
name|ids
operator|.
name|add
argument_list|(
name|doc
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"insert of %s failed"
argument_list|,
name|ids
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|message
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// collect additional exceptions
name|String
name|messages
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|?
name|RDBJDBCTools
operator|.
name|getAdditionalMessages
argument_list|(
name|ex
argument_list|)
else|:
literal|""
decl_stmt|;
comment|// see whether a DATA error was involved
name|boolean
name|dataRelated
init|=
literal|false
decl_stmt|;
name|SQLException
name|walk
init|=
name|ex
decl_stmt|;
while|while
condition|(
name|walk
operator|!=
literal|null
operator|&&
operator|!
name|dataRelated
condition|)
block|{
name|dataRelated
operator|=
name|RDBJDBCTools
operator|.
name|matchesSQLState
argument_list|(
name|walk
argument_list|,
literal|"22"
argument_list|,
literal|"72"
argument_list|)
expr_stmt|;
name|walk
operator|=
name|walk
operator|.
name|getNextException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dataRelated
condition|)
block|{
name|String
name|id
init|=
literal|null
decl_stmt|;
name|int
name|longest
init|=
literal|0
decl_stmt|,
name|longestChars
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Document
name|d
range|:
name|documents
control|)
block|{
name|String
name|data
init|=
name|ser
operator|.
name|asString
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|byte
name|bytes
index|[]
init|=
name|asBytes
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|.
name|length
operator|>
name|longest
condition|)
block|{
name|longest
operator|=
name|bytes
operator|.
name|length
expr_stmt|;
name|longestChars
operator|=
name|data
operator|.
name|length
argument_list|()
expr_stmt|;
name|id
operator|=
name|d
operator|.
name|getId
argument_list|()
expr_stmt|;
block|}
block|}
name|String
name|m
init|=
name|String
operator|.
name|format
argument_list|(
literal|" (potential cause: long data for ID %s - longest octet DATA size in Java characters: %d, in octets: %d, computed character limit: %d)"
argument_list|,
name|id
argument_list|,
name|longest
argument_list|,
name|longestChars
argument_list|,
name|tmd
operator|.
name|getDataLimitInOctets
argument_list|()
operator|/
name|CHAR2OCTETRATIO
argument_list|)
decl_stmt|;
name|messages
operator|+=
name|m
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|messages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"additional diagnostics: "
operator|+
name|messages
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|message
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|this
operator|.
name|ch
operator|.
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
comment|// configuration
comment|// Whether to use GZIP compression
specifier|private
specifier|static
specifier|final
name|boolean
name|NOGZIP
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.NOGZIP"
argument_list|)
decl_stmt|;
comment|// Number of documents to insert at once for batch create
specifier|private
specifier|static
specifier|final
name|int
name|CHUNKSIZE
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.CHUNKSIZE"
argument_list|,
literal|64
argument_list|)
decl_stmt|;
comment|// Number of query hits above which a diagnostic warning is generated
specifier|private
specifier|static
specifier|final
name|int
name|QUERYHITSLIMIT
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.QUERYHITSLIMIT"
argument_list|,
literal|4096
argument_list|)
decl_stmt|;
comment|// Number of elapsed ms in a query above which a diagnostic warning is generated
specifier|private
specifier|static
specifier|final
name|int
name|QUERYTIMELIMIT
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.QUERYTIMELIMIT"
argument_list|,
literal|10000
argument_list|)
decl_stmt|;
comment|// Whether to use JDBC batch commands for the createOrUpdate (default: true).
specifier|private
specifier|static
specifier|final
name|boolean
name|BATCHUPDATES
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"org.apache.jackrabbit.oak.plugins.document.rdb.RDBDocumentStore.BATCHUPDATES"
argument_list|,
literal|"true"
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|byte
index|[]
name|asBytes
parameter_list|(
name|String
name|data
parameter_list|)
block|{
name|byte
index|[]
name|bytes
decl_stmt|;
try|try
block|{
name|bytes
operator|=
name|data
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"UTF-8 not supported??"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
if|if
condition|(
name|NOGZIP
condition|)
block|{
return|return
name|bytes
return|;
block|}
else|else
block|{
try|try
block|{
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|data
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|GZIPOutputStream
name|gos
init|=
operator|new
name|GZIPOutputStream
argument_list|(
name|bos
argument_list|)
block|{
block|{
comment|// TODO: make this configurable
name|this
operator|.
name|def
operator|.
name|setLevel
parameter_list|(
name|Deflater
operator|.
name|BEST_SPEED
parameter_list|)
constructor_decl|;
block|}
block|}
decl_stmt|;
name|gos
operator|.
name|write
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|gos
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|bos
operator|.
name|toByteArray
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while gzipping contents"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setReadWriteMode
parameter_list|(
name|String
name|readWriteMode
parameter_list|)
block|{
comment|// ignored
block|}
specifier|public
name|void
name|setStatsCollector
parameter_list|(
name|DocumentStoreStatsCollector
name|stats
parameter_list|)
block|{
name|this
operator|.
name|stats
operator|=
name|stats
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|castAsT
parameter_list|(
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
operator|(
name|T
operator|)
name|doc
return|;
block|}
specifier|private
name|NodeDocumentCache
name|nodesCache
decl_stmt|;
specifier|private
name|NodeDocumentLocks
name|locks
decl_stmt|;
annotation|@
name|CheckForNull
specifier|private
specifier|static
name|NodeDocument
name|unwrap
parameter_list|(
annotation|@
name|Nonnull
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|==
name|NodeDocument
operator|.
name|NULL
condition|?
literal|null
else|:
name|doc
return|;
block|}
annotation|@
name|Nonnull
specifier|private
specifier|static
name|NodeDocument
name|wrap
parameter_list|(
annotation|@
name|CheckForNull
name|NodeDocument
name|doc
parameter_list|)
block|{
return|return
name|doc
operator|==
literal|null
condition|?
name|NodeDocument
operator|.
name|NULL
else|:
name|doc
return|;
block|}
annotation|@
name|Nonnull
specifier|private
specifier|static
name|String
name|idOf
parameter_list|(
annotation|@
name|Nonnull
name|Document
name|doc
parameter_list|)
block|{
name|String
name|id
init|=
name|doc
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"non-null ID expected"
argument_list|)
throw|;
block|}
return|return
name|id
return|;
block|}
specifier|private
specifier|static
name|long
name|modcountOf
parameter_list|(
annotation|@
name|Nonnull
name|Document
name|doc
parameter_list|)
block|{
name|Long
name|n
init|=
name|doc
operator|.
name|getModCount
argument_list|()
decl_stmt|;
return|return
name|n
operator|!=
literal|null
condition|?
name|n
else|:
operator|-
literal|1
return|;
block|}
annotation|@
name|Nonnull
specifier|protected
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|convertFromDBObject
parameter_list|(
annotation|@
name|Nonnull
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
annotation|@
name|Nonnull
name|RDBRow
name|row
parameter_list|)
block|{
comment|// this method is present here in order to facilitate unit testing for OAK-3566
return|return
name|ser
operator|.
name|fromRow
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Document
parameter_list|>
name|T
name|runThroughCache
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|RDBRow
name|row
parameter_list|,
name|long
name|now
parameter_list|,
name|QueryContext
name|qp
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|!=
name|Collection
operator|.
name|NODES
condition|)
block|{
comment|// not in the cache anyway
return|return
name|convertFromDBObject
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
return|;
block|}
name|String
name|id
init|=
name|row
operator|.
name|getId
argument_list|()
decl_stmt|;
name|NodeDocument
name|inCache
init|=
name|nodesCache
operator|.
name|getIfPresent
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|Long
name|modCount
init|=
name|row
operator|.
name|getModcount
argument_list|()
decl_stmt|;
comment|// do not overwrite document in cache if the
comment|// existing one in the cache is newer
if|if
condition|(
name|inCache
operator|!=
literal|null
operator|&&
name|inCache
operator|!=
name|NodeDocument
operator|.
name|NULL
condition|)
block|{
comment|// check mod count
name|Long
name|cachedModCount
init|=
name|inCache
operator|.
name|getModCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|cachedModCount
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Missing "
operator|+
name|Document
operator|.
name|MOD_COUNT
argument_list|)
throw|;
block|}
if|if
condition|(
name|modCount
operator|<=
name|cachedModCount
condition|)
block|{
comment|// we can use the cached document
name|inCache
operator|.
name|markUpToDate
argument_list|(
name|now
argument_list|)
expr_stmt|;
return|return
name|castAsT
argument_list|(
name|inCache
argument_list|)
return|;
block|}
block|}
name|NodeDocument
name|fresh
init|=
operator|(
name|NodeDocument
operator|)
name|convertFromDBObject
argument_list|(
name|collection
argument_list|,
name|row
argument_list|)
decl_stmt|;
name|fresh
operator|.
name|seal
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|.
name|mayUpdate
argument_list|(
name|id
argument_list|)
condition|)
block|{
return|return
name|castAsT
argument_list|(
name|fresh
argument_list|)
return|;
block|}
name|nodesCache
operator|.
name|putIfNewer
argument_list|(
name|fresh
argument_list|)
expr_stmt|;
return|return
name|castAsT
argument_list|(
name|fresh
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|hasChangesToCollisions
parameter_list|(
name|UpdateOp
name|update
parameter_list|)
block|{
if|if
condition|(
operator|!
name|USECMODCOUNT
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
for|for
control|(
name|Entry
argument_list|<
name|Key
argument_list|,
name|Operation
argument_list|>
name|e
range|:
name|checkNotNull
argument_list|(
name|update
argument_list|)
operator|.
name|getChanges
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Key
name|k
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Operation
name|op
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|type
operator|==
name|Operation
operator|.
name|Type
operator|.
name|SET_MAP_ENTRY
condition|)
block|{
if|if
condition|(
name|NodeDocument
operator|.
name|COLLISIONS
operator|.
name|equals
argument_list|(
name|k
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
comment|// keeping track of CLUSTER_NODES updates
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|cnUpdates
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|void
name|maintainUpdateStats
parameter_list|(
name|Collection
name|collection
parameter_list|,
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
name|Collection
operator|.
name|CLUSTER_NODES
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|Long
name|old
init|=
name|cnUpdates
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|old
operator|=
name|old
operator|==
literal|null
condition|?
name|Long
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|)
else|:
name|old
operator|+
literal|1
expr_stmt|;
name|cnUpdates
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|String
name|getCnStats
parameter_list|()
block|{
if|if
condition|(
name|cnUpdates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|""
return|;
block|}
else|else
block|{
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|tmp
init|=
operator|new
name|ArrayList
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|tmp
operator|.
name|addAll
argument_list|(
name|cnUpdates
operator|.
name|entrySet
argument_list|()
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|tmp
argument_list|,
operator|new
name|Comparator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|o1
parameter_list|,
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|getKey
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getKey
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
literal|" (Cluster Node updates: "
operator|+
name|tmp
operator|.
name|toString
argument_list|()
operator|+
literal|")"
return|;
block|}
block|}
specifier|private
name|Stopwatch
name|startWatch
parameter_list|()
block|{
return|return
name|Stopwatch
operator|.
name|createStarted
argument_list|()
return|;
block|}
specifier|protected
name|NodeDocumentCache
name|getNodeDocumentCache
parameter_list|()
block|{
return|return
name|nodesCache
return|;
block|}
comment|// slightly extended query support
specifier|protected
specifier|static
class|class
name|QueryCondition
block|{
specifier|private
specifier|final
name|String
name|propertyName
decl_stmt|,
name|operator
decl_stmt|;
specifier|private
specifier|final
name|long
name|value
decl_stmt|;
specifier|public
name|QueryCondition
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|operator
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|this
operator|.
name|propertyName
operator|=
name|propertyName
expr_stmt|;
name|this
operator|.
name|operator
operator|=
name|operator
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
specifier|public
name|String
name|getPropertyName
parameter_list|()
block|{
return|return
name|propertyName
return|;
block|}
specifier|public
name|String
name|getOperator
parameter_list|()
block|{
return|return
name|operator
return|;
block|}
specifier|public
name|long
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s %s %d"
argument_list|,
name|propertyName
argument_list|,
name|operator
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

