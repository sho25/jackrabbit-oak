begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|AdditionalAnswers
operator|.
name|delegatesTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Matchers
operator|.
name|anyInt
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Matchers
operator|.
name|anyObject
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Matchers
operator|.
name|anyString
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|mock
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|times
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|verify
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|when
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|PropertyType
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|ValueFormatException
import|;
end_import

begin_import
import|import
name|junitx
operator|.
name|util
operator|.
name|PrivateAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|CommitFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Descriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|json
operator|.
name|JsonObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|json
operator|.
name|JsopTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|junit
operator|.
name|LogDumper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|junit
operator|.
name|LogLevelModifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|memory
operator|.
name|MemoryDocumentStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|util
operator|.
name|MongoConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|blob
operator|.
name|BlobStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|blob
operator|.
name|MemoryBlobStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|commit
operator|.
name|CommitInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|commit
operator|.
name|EmptyHook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|invocation
operator|.
name|InvocationOnMock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|stubbing
operator|.
name|Answer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|BundleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|ServiceRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|mongodb
operator|.
name|DB
import|;
end_import

begin_comment
comment|/**  * Tests for the DocumentDiscoveryLiteService  */
end_comment

begin_class
specifier|public
class|class
name|DocumentDiscoveryLiteServiceTest
block|{
comment|/**      * container for what should represent an instance, but is not a complete      * one, hence 'simplified'. it contains most importantly the      * DocuemntNodeStore and the discoveryLite service      */
class|class
name|SimplifiedInstance
block|{
specifier|private
name|DocumentDiscoveryLiteService
name|service
decl_stmt|;
specifier|private
name|DocumentNodeStore
name|ns
decl_stmt|;
specifier|private
specifier|final
name|Descriptors
name|descriptors
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|registeredServices
decl_stmt|;
specifier|private
specifier|final
name|long
name|lastRevInterval
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|lastRevStopped
init|=
literal|false
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|writeSimulationStopped
init|=
literal|false
decl_stmt|;
specifier|private
name|Thread
name|lastRevThread
decl_stmt|;
specifier|private
name|Thread
name|writeSimulationThread
decl_stmt|;
specifier|public
name|String
name|workingDir
decl_stmt|;
name|SimplifiedInstance
parameter_list|(
name|DocumentDiscoveryLiteService
name|service
parameter_list|,
name|DocumentNodeStore
name|ns
parameter_list|,
name|Descriptors
name|descriptors
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|registeredServices
parameter_list|,
name|long
name|lastRevInterval
parameter_list|,
name|String
name|workingDir
parameter_list|)
block|{
name|this
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|ns
operator|=
name|ns
expr_stmt|;
name|this
operator|.
name|workingDir
operator|=
name|workingDir
expr_stmt|;
name|this
operator|.
name|descriptors
operator|=
name|descriptors
expr_stmt|;
name|this
operator|.
name|registeredServices
operator|=
name|registeredServices
expr_stmt|;
name|this
operator|.
name|lastRevInterval
operator|=
name|lastRevInterval
expr_stmt|;
if|if
condition|(
name|lastRevInterval
operator|>
literal|0
condition|)
block|{
name|startLastRevThread
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"SimplifiedInstance[cid="
operator|+
name|ns
operator|.
name|getClusterId
argument_list|()
operator|+
literal|"]"
return|;
block|}
specifier|private
name|void
name|startLastRevThread
parameter_list|()
block|{
name|lastRevStopped
operator|=
literal|false
expr_stmt|;
name|lastRevThread
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|lastRevStopped
condition|)
block|{
name|SimplifiedInstance
operator|.
name|this
operator|.
name|ns
operator|.
name|getLastRevRecoveryAgent
argument_list|()
operator|.
name|performRecoveryIfNeeded
argument_list|()
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|SimplifiedInstance
operator|.
name|this
operator|.
name|lastRevInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|lastRevThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|lastRevThread
operator|.
name|setName
argument_list|(
literal|"lastRevThread[cid="
operator|+
name|ns
operator|.
name|getClusterId
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|lastRevThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|void
name|stopLastRevThread
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|lastRevStopped
operator|=
literal|true
expr_stmt|;
name|lastRevThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
name|boolean
name|isFinal
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|JsonObject
name|clusterViewObj
init|=
name|getClusterViewObj
argument_list|()
decl_stmt|;
if|if
condition|(
name|clusterViewObj
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"should always have that final flag set"
argument_list|)
throw|;
block|}
name|String
name|finalStr
init|=
name|clusterViewObj
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
literal|"final"
argument_list|)
decl_stmt|;
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|finalStr
argument_list|)
return|;
block|}
name|boolean
name|hasActiveIds
parameter_list|(
name|String
name|clusterViewStr
parameter_list|,
name|int
modifier|...
name|expected
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|hasIds
argument_list|(
name|clusterViewStr
argument_list|,
literal|"active"
argument_list|,
name|expected
argument_list|)
return|;
block|}
name|boolean
name|hasDeactivatingIds
parameter_list|(
name|String
name|clusterViewStr
parameter_list|,
name|int
modifier|...
name|expected
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|hasIds
argument_list|(
name|clusterViewStr
argument_list|,
literal|"deactivating"
argument_list|,
name|expected
argument_list|)
return|;
block|}
name|boolean
name|hasInactiveIds
parameter_list|(
name|String
name|clusterViewStr
parameter_list|,
name|int
modifier|...
name|expected
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|hasIds
argument_list|(
name|clusterViewStr
argument_list|,
literal|"inactive"
argument_list|,
name|expected
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|hasIds
parameter_list|(
specifier|final
name|String
name|clusterViewStr
parameter_list|,
specifier|final
name|String
name|key
parameter_list|,
name|int
modifier|...
name|expectedIds
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|JsonObject
name|clusterViewObj
init|=
name|asJsonObject
argument_list|(
name|clusterViewStr
argument_list|)
decl_stmt|;
name|String
name|actualIdsStr
init|=
name|clusterViewObj
operator|==
literal|null
condition|?
literal|null
else|:
name|clusterViewObj
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|boolean
name|actualEmpty
init|=
name|actualIdsStr
operator|==
literal|null
operator|||
name|actualIdsStr
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|actualIdsStr
operator|.
name|equals
argument_list|(
literal|"[]"
argument_list|)
decl_stmt|;
name|boolean
name|expectedEmpty
init|=
name|expectedIds
operator|==
literal|null
operator|||
name|expectedIds
operator|.
name|length
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|actualEmpty
operator|&&
name|expectedEmpty
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|actualEmpty
operator|!=
name|expectedEmpty
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|actualList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|ClusterViewDocument
operator|.
name|csvToIntegerArray
argument_list|(
name|actualIdsStr
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|actualIdsStr
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedIds
operator|.
name|length
operator|!=
name|actualList
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expectedIds
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|anExpectedId
init|=
name|expectedIds
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|actualList
operator|.
name|contains
argument_list|(
name|anExpectedId
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
name|JsonObject
name|getClusterViewObj
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|json
init|=
name|getClusterViewStr
argument_list|()
decl_stmt|;
return|return
name|asJsonObject
argument_list|(
name|json
argument_list|)
return|;
block|}
specifier|private
name|JsonObject
name|asJsonObject
parameter_list|(
specifier|final
name|String
name|json
parameter_list|)
block|{
if|if
condition|(
name|json
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|json
argument_list|)
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|JsonObject
name|o
init|=
name|JsonObject
operator|.
name|create
argument_list|(
name|t
argument_list|)
decl_stmt|;
return|return
name|o
return|;
block|}
name|String
name|getClusterViewStr
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|getDescriptor
argument_list|(
name|DocumentDiscoveryLiteService
operator|.
name|OAK_DISCOVERYLITE_CLUSTERVIEW
argument_list|)
return|;
block|}
name|String
name|getDescriptor
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|Value
name|value
init|=
name|descriptors
operator|.
name|getValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|value
operator|.
name|getType
argument_list|()
operator|!=
name|PropertyType
operator|.
name|STRING
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
return|return
name|value
operator|.
name|getString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ValueFormatException
name|vfe
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|void
name|dispose
parameter_list|()
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Disposing "
operator|+
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|stopSimulatingWrites
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|fail
argument_list|(
literal|"interrupted"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastRevThread
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|stopLastRevThread
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ok
parameter_list|)
block|{
name|fail
argument_list|(
literal|"interrupted"
argument_list|)
expr_stmt|;
block|}
name|lastRevThread
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|service
operator|!=
literal|null
condition|)
block|{
name|service
operator|.
name|deactivate
argument_list|()
expr_stmt|;
name|service
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
name|ns
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|ns
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|registeredServices
operator|!=
literal|null
condition|)
block|{
name|registeredServices
operator|.
name|clear
argument_list|()
expr_stmt|;
name|registeredServices
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**          * shutdown simulates the normal, graceful, shutdown          *           * @throws InterruptedException          */
specifier|public
name|void
name|shutdown
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|stopSimulatingWrites
argument_list|()
expr_stmt|;
name|stopLastRevThread
argument_list|()
expr_stmt|;
name|ns
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|service
operator|.
name|deactivate
argument_list|()
expr_stmt|;
block|}
comment|/**          * crash simulates a kill -9, sort of          *           * @throws Throwable          */
specifier|public
name|void
name|crash
parameter_list|()
throws|throws
name|Throwable
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"crash: stopping simulating writes..."
argument_list|)
expr_stmt|;
name|stopSimulatingWrites
argument_list|()
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"crash: stopping lastrev thread..."
argument_list|)
expr_stmt|;
name|stopLastRevThread
argument_list|()
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"crash: stopped lastrev thread, now setting least to end within 1 sec"
argument_list|)
expr_stmt|;
name|boolean
name|renewed
init|=
name|setLeaseTime
argument_list|(
literal|1000
comment|/* 1 sec */
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|renewed
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"halt"
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"did not renew clusterid lease"
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|info
argument_list|(
literal|"crash: now stopping background read/update"
argument_list|)
expr_stmt|;
name|stopAllBackgroundThreads
argument_list|()
expr_stmt|;
comment|// but don't do the following from DocumentNodeStore.dispose():
comment|// * don't do the last internalRunBackgroundUpdateOperations - as
comment|// we're trying to simulate a crash here
comment|// * don't dispose clusterNodeInfo to leave the node in active state
comment|// the DocumentDiscoveryLiteService currently can simply be
comment|// deactivated, doesn't differ much from crashing
name|service
operator|.
name|deactivate
argument_list|()
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"crash: crash simulation done."
argument_list|)
expr_stmt|;
block|}
comment|/**          * very hacky way of doing the following: make sure this instance's          * clusterNodes entry is marked with a very short (1 sec off) lease end          * time so that the crash detection doesn't take a minute (as it would          * by default)          */
specifier|private
name|boolean
name|setLeaseTime
parameter_list|(
specifier|final
name|int
name|leaseTime
parameter_list|)
throws|throws
name|NoSuchFieldException
block|{
name|ns
operator|.
name|getClusterInfo
argument_list|()
operator|.
name|setLeaseTime
argument_list|(
name|leaseTime
argument_list|)
expr_stmt|;
name|PrivateAccessor
operator|.
name|setField
argument_list|(
name|ns
operator|.
name|getClusterInfo
argument_list|()
argument_list|,
literal|"leaseEndTime"
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
operator|(
name|leaseTime
operator|/
literal|3
operator|)
operator|-
literal|10
comment|/* 10ms safety margin */
argument_list|)
expr_stmt|;
name|boolean
name|renewed
init|=
name|ns
operator|.
name|renewClusterIdLease
argument_list|()
decl_stmt|;
return|return
name|renewed
return|;
block|}
specifier|private
name|AtomicBoolean
name|getIsDisposed
parameter_list|()
throws|throws
name|NoSuchFieldException
block|{
name|AtomicBoolean
name|isDisposed
init|=
operator|(
name|AtomicBoolean
operator|)
name|PrivateAccessor
operator|.
name|getField
argument_list|(
name|ns
argument_list|,
literal|"isDisposed"
argument_list|)
decl_stmt|;
return|return
name|isDisposed
return|;
block|}
specifier|private
name|void
name|stopAllBackgroundThreads
parameter_list|()
throws|throws
name|NoSuchFieldException
block|{
comment|// get all those background threads...
name|Thread
name|backgroundReadThread
init|=
operator|(
name|Thread
operator|)
name|PrivateAccessor
operator|.
name|getField
argument_list|(
name|ns
argument_list|,
literal|"backgroundReadThread"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|backgroundReadThread
argument_list|)
expr_stmt|;
name|Thread
name|backgroundUpdateThread
init|=
operator|(
name|Thread
operator|)
name|PrivateAccessor
operator|.
name|getField
argument_list|(
name|ns
argument_list|,
literal|"backgroundUpdateThread"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|backgroundUpdateThread
argument_list|)
expr_stmt|;
name|Thread
name|leaseUpdateThread
init|=
operator|(
name|Thread
operator|)
name|PrivateAccessor
operator|.
name|getField
argument_list|(
name|ns
argument_list|,
literal|"leaseUpdateThread"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|leaseUpdateThread
argument_list|)
expr_stmt|;
comment|// start doing what DocumentNodeStore.dispose() would do - except do
comment|// it very fine controlled, basically:
comment|// make sure to stop backgroundReadThread, backgroundUpdateThread
comment|// and leaseUpdateThread
comment|// but then nothing else.
specifier|final
name|AtomicBoolean
name|isDisposed
init|=
name|getIsDisposed
argument_list|()
decl_stmt|;
name|assertFalse
argument_list|(
name|isDisposed
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// notify background threads waiting on isDisposed
synchronized|synchronized
init|(
name|isDisposed
init|)
block|{
name|isDisposed
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|backgroundReadThread
operator|.
name|join
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|backgroundReadThread
operator|.
name|isAlive
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
try|try
block|{
name|backgroundUpdateThread
operator|.
name|join
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|backgroundUpdateThread
operator|.
name|isAlive
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
try|try
block|{
name|leaseUpdateThread
operator|.
name|join
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|leaseUpdateThread
operator|.
name|isAlive
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
specifier|public
name|void
name|stopBgReadThread
parameter_list|()
throws|throws
name|NoSuchFieldException
block|{
specifier|final
name|Thread
name|backgroundReadThread
init|=
operator|(
name|Thread
operator|)
name|PrivateAccessor
operator|.
name|getField
argument_list|(
name|ns
argument_list|,
literal|"backgroundReadThread"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|backgroundReadThread
argument_list|)
expr_stmt|;
specifier|final
name|Runnable
name|bgReadRunnable
init|=
operator|(
name|Runnable
operator|)
name|PrivateAccessor
operator|.
name|getField
argument_list|(
name|backgroundReadThread
argument_list|,
literal|"target"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|bgReadRunnable
argument_list|)
expr_stmt|;
specifier|final
name|AtomicBoolean
name|bgReadIsDisposed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|PrivateAccessor
operator|.
name|setField
argument_list|(
name|bgReadRunnable
argument_list|,
literal|"isDisposed"
argument_list|,
name|bgReadIsDisposed
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|bgReadIsDisposed
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|backgroundReadThread
operator|.
name|join
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|backgroundReadThread
operator|.
name|isAlive
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
comment|// big of heavy work, but now the backgroundReadThread is stopped
comment|// and all the others are still running
block|}
specifier|public
name|void
name|addNode
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|CommitFailedException
block|{
name|NodeBuilder
name|root
init|=
name|ns
operator|.
name|getRoot
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
name|NodeBuilder
name|child
init|=
name|root
decl_stmt|;
name|String
index|[]
name|split
init|=
name|path
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|split
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|child
operator|.
name|child
argument_list|(
name|split
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|info
argument_list|(
literal|"addNode: "
operator|+
name|ns
operator|.
name|getClusterId
argument_list|()
operator|+
literal|" is merging path "
operator|+
name|path
argument_list|)
expr_stmt|;
name|ns
operator|.
name|merge
argument_list|(
name|root
argument_list|,
name|EmptyHook
operator|.
name|INSTANCE
argument_list|,
name|CommitInfo
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setProperty
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|CommitFailedException
block|{
name|NodeBuilder
name|root
init|=
name|ns
operator|.
name|getRoot
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
name|NodeBuilder
name|child
init|=
name|root
decl_stmt|;
name|String
index|[]
name|split
init|=
name|path
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|split
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|child
operator|.
name|child
argument_list|(
name|split
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|child
operator|.
name|setProperty
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"setProperty: "
operator|+
name|ns
operator|.
name|getClusterId
argument_list|()
operator|+
literal|" is merging path/property "
operator|+
name|path
operator|+
literal|", key="
operator|+
name|key
operator|+
literal|", value="
operator|+
name|value
argument_list|)
expr_stmt|;
name|ns
operator|.
name|merge
argument_list|(
name|root
argument_list|,
name|EmptyHook
operator|.
name|INSTANCE
argument_list|,
name|CommitInfo
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setLeastTimeout
parameter_list|(
name|long
name|timeoutInMs
parameter_list|)
throws|throws
name|NoSuchFieldException
block|{
name|ns
operator|.
name|getClusterInfo
argument_list|()
operator|.
name|setLeaseTime
argument_list|(
name|timeoutInMs
argument_list|)
expr_stmt|;
name|PrivateAccessor
operator|.
name|setField
argument_list|(
name|ns
operator|.
name|getClusterInfo
argument_list|()
argument_list|,
literal|"leaseEndTime"
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
literal|1000
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|startSimulatingWrites
parameter_list|(
specifier|final
name|long
name|writeInterval
parameter_list|)
block|{
name|writeSimulationStopped
operator|=
literal|false
expr_stmt|;
name|writeSimulationThread
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|writeSimulationStopped
condition|)
block|{
try|try
block|{
name|writeSomething
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|SimplifiedInstance
operator|.
name|this
operator|.
name|lastRevInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|writeSomething
parameter_list|()
throws|throws
name|CommitFailedException
block|{
specifier|final
name|String
name|path
init|=
literal|"/"
operator|+
name|ns
operator|.
name|getClusterId
argument_list|()
operator|+
literal|"/"
operator|+
name|random
operator|.
name|nextInt
argument_list|(
literal|100
argument_list|)
operator|+
literal|"/"
operator|+
name|random
operator|.
name|nextInt
argument_list|(
literal|100
argument_list|)
operator|+
literal|"/"
operator|+
name|random
operator|.
name|nextInt
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Writing ["
operator|+
name|ns
operator|.
name|getClusterId
argument_list|()
operator|+
literal|"]"
operator|+
name|path
argument_list|)
expr_stmt|;
name|addNode
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|writeSimulationThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writeSimulationThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|void
name|stopSimulatingWrites
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|writeSimulationStopped
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|writeSimulationThread
operator|!=
literal|null
condition|)
block|{
name|writeSimulationThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** OAK-3292 : when on a machine without a mac address, the 'random:' prefix is used and instances          * that have timed out are automagially removed by ClusterNodeInfo.createInstance - that poses          * a problem to testing - so this method exposes whether the instance has such a 'random:' prefix          * and thus allows to take appropriate action          */
specifier|public
name|boolean
name|hasRandomMachineId
parameter_list|()
block|{
comment|//TODO: this might not be the most stable way - but avoids having to change ClusterNodeInfo
return|return
name|ns
operator|.
name|getClusterInfo
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
literal|"random:"
argument_list|)
return|;
block|}
block|}
interface|interface
name|Expectation
block|{
comment|/**          * check if the expectation is fulfilled, return true if it is, return a          * descriptive error msg if not          **/
name|String
name|fulfilled
parameter_list|()
throws|throws
name|Exception
function_decl|;
block|}
class|class
name|ViewExpectation
implements|implements
name|Expectation
block|{
specifier|private
name|int
index|[]
name|activeIds
decl_stmt|;
specifier|private
name|int
index|[]
name|deactivatingIds
decl_stmt|;
specifier|private
name|int
index|[]
name|inactiveIds
decl_stmt|;
specifier|private
specifier|final
name|SimplifiedInstance
name|discoveryLiteCombo
decl_stmt|;
specifier|private
name|boolean
name|isFinal
init|=
literal|true
decl_stmt|;
name|ViewExpectation
parameter_list|(
name|SimplifiedInstance
name|discoveryLiteCombo
parameter_list|)
block|{
name|this
operator|.
name|discoveryLiteCombo
operator|=
name|discoveryLiteCombo
expr_stmt|;
block|}
specifier|private
name|int
index|[]
name|asIntArray
parameter_list|(
name|Integer
index|[]
name|arr
parameter_list|)
block|{
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
name|arr
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arr
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|arr
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
name|void
name|setActiveIds
parameter_list|(
name|Integer
index|[]
name|activeIds
parameter_list|)
block|{
name|this
operator|.
name|activeIds
operator|=
name|asIntArray
argument_list|(
name|activeIds
argument_list|)
expr_stmt|;
block|}
name|void
name|setActiveIds
parameter_list|(
name|int
modifier|...
name|activeIds
parameter_list|)
block|{
name|this
operator|.
name|activeIds
operator|=
name|activeIds
expr_stmt|;
block|}
name|void
name|setDeactivatingIds
parameter_list|(
name|int
modifier|...
name|deactivatingIds
parameter_list|)
block|{
name|this
operator|.
name|deactivatingIds
operator|=
name|deactivatingIds
expr_stmt|;
block|}
name|void
name|setInactiveIds
parameter_list|(
name|Integer
index|[]
name|inactiveIds
parameter_list|)
block|{
name|this
operator|.
name|inactiveIds
operator|=
name|asIntArray
argument_list|(
name|inactiveIds
argument_list|)
expr_stmt|;
block|}
name|void
name|setInactiveIds
parameter_list|(
name|int
modifier|...
name|inaactiveIds
parameter_list|)
block|{
name|this
operator|.
name|inactiveIds
operator|=
name|inaactiveIds
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|fulfilled
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|clusterViewStr
init|=
name|discoveryLiteCombo
operator|.
name|getClusterViewStr
argument_list|()
decl_stmt|;
if|if
condition|(
name|clusterViewStr
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|activeIds
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
return|return
literal|"no clusterView, but expected activeIds: "
operator|+
name|beautify
argument_list|(
name|activeIds
argument_list|)
return|;
block|}
if|if
condition|(
name|deactivatingIds
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
return|return
literal|"no clusterView, but expected deactivatingIds: "
operator|+
name|beautify
argument_list|(
name|deactivatingIds
argument_list|)
return|;
block|}
if|if
condition|(
name|inactiveIds
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
return|return
literal|"no clusterView, but expected inactiveIds: "
operator|+
name|beautify
argument_list|(
name|inactiveIds
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|discoveryLiteCombo
operator|.
name|hasActiveIds
argument_list|(
name|clusterViewStr
argument_list|,
name|activeIds
argument_list|)
condition|)
block|{
return|return
literal|"activeIds dont match, expected: "
operator|+
name|beautify
argument_list|(
name|activeIds
argument_list|)
operator|+
literal|", got clusterView: "
operator|+
name|clusterViewStr
return|;
block|}
if|if
condition|(
operator|!
name|discoveryLiteCombo
operator|.
name|hasDeactivatingIds
argument_list|(
name|clusterViewStr
argument_list|,
name|deactivatingIds
argument_list|)
condition|)
block|{
return|return
literal|"deactivatingIds dont match, expected: "
operator|+
name|beautify
argument_list|(
name|deactivatingIds
argument_list|)
operator|+
literal|", got clusterView: "
operator|+
name|clusterViewStr
return|;
block|}
if|if
condition|(
operator|!
name|discoveryLiteCombo
operator|.
name|hasInactiveIds
argument_list|(
name|clusterViewStr
argument_list|,
name|inactiveIds
argument_list|)
condition|)
block|{
return|return
literal|"inactiveIds dont match, expected: "
operator|+
name|beautify
argument_list|(
name|inactiveIds
argument_list|)
operator|+
literal|", got clusterView: "
operator|+
name|clusterViewStr
return|;
block|}
if|if
condition|(
name|discoveryLiteCombo
operator|.
name|isFinal
argument_list|()
operator|!=
name|isFinal
condition|)
block|{
return|return
literal|"final flag does not match. expected: "
operator|+
name|isFinal
operator|+
literal|", but is: "
operator|+
name|discoveryLiteCombo
operator|.
name|isFinal
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|String
name|beautify
parameter_list|(
name|int
index|[]
name|ids
parameter_list|)
block|{
if|if
condition|(
name|ids
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ids
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|ids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|void
name|setFinal
parameter_list|(
name|boolean
name|isFinal
parameter_list|)
block|{
name|this
operator|.
name|isFinal
operator|=
name|isFinal
expr_stmt|;
block|}
block|}
comment|//    private static final boolean MONGO_DB = true;
specifier|private
specifier|static
specifier|final
name|boolean
name|MONGO_DB
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SEED
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
name|DocumentDiscoveryLiteServiceTest
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"-seed"
argument_list|,
operator|new
name|Random
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
name|List
argument_list|<
name|DocumentMK
argument_list|>
name|mks
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|private
name|MemoryDocumentStore
name|ds
decl_stmt|;
specifier|private
name|MemoryBlobStore
name|bs
decl_stmt|;
specifier|final
name|Logger
name|logger
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
name|List
argument_list|<
name|SimplifiedInstance
argument_list|>
name|allInstances
init|=
operator|new
name|LinkedList
argument_list|<
name|SimplifiedInstance
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Rule
specifier|public
name|TestRule
name|logDumper
init|=
operator|new
name|LogDumper
argument_list|(
literal|50000
argument_list|)
decl_stmt|;
annotation|@
name|Rule
specifier|public
name|TestRule
name|logLevelModifier
init|=
operator|new
name|LogLevelModifier
argument_list|()
operator|.
name|newConsoleAppender
argument_list|(
literal|"console"
argument_list|)
operator|.
name|addAppenderFilter
argument_list|(
literal|"console"
argument_list|,
literal|"info"
argument_list|)
operator|.
name|addAppenderFilter
argument_list|(
literal|"file"
argument_list|,
literal|"info"
argument_list|)
operator|.
name|setLoggerLevel
argument_list|(
literal|"org.apache.jackrabbit.oak"
argument_list|,
literal|"debug"
argument_list|)
decl_stmt|;
annotation|@
name|Test
specifier|public
name|void
name|testActivateDeactivate
parameter_list|()
throws|throws
name|Exception
block|{
comment|// then test normal start with a DocumentNodeStore
name|DocumentMK
name|mk1
init|=
name|createMK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|DocumentDiscoveryLiteService
name|discoveryLite
init|=
operator|new
name|DocumentDiscoveryLiteService
argument_list|()
decl_stmt|;
name|PrivateAccessor
operator|.
name|setField
argument_list|(
name|discoveryLite
argument_list|,
literal|"nodeStore"
argument_list|,
name|mk1
operator|.
name|nodeStore
argument_list|)
expr_stmt|;
name|BundleContext
name|bc
init|=
name|mock
argument_list|(
name|BundleContext
operator|.
name|class
argument_list|)
decl_stmt|;
name|ComponentContext
name|c
init|=
name|mock
argument_list|(
name|ComponentContext
operator|.
name|class
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|c
operator|.
name|getBundleContext
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|bc
argument_list|)
expr_stmt|;
name|discoveryLite
operator|.
name|activate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|c
argument_list|,
name|times
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|disableComponent
argument_list|(
name|DocumentDiscoveryLiteService
operator|.
name|COMPONENT_NAME
argument_list|)
expr_stmt|;
name|discoveryLite
operator|.
name|deactivate
argument_list|()
expr_stmt|;
block|}
comment|/**      * Borrowed from      * http://stackoverflow.com/questions/3301635/change-private-static-final-      * field-using-java-reflection      */
specifier|static
name|void
name|setFinalStatic
parameter_list|(
name|Field
name|field
parameter_list|,
name|Object
name|newValue
parameter_list|)
throws|throws
name|Exception
block|{
name|field
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Field
name|modifiersField
init|=
name|Field
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"modifiers"
argument_list|)
decl_stmt|;
name|modifiersField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|modifiersField
operator|.
name|setInt
argument_list|(
name|field
argument_list|,
name|field
operator|.
name|getModifiers
argument_list|()
operator|&
operator|~
name|Modifier
operator|.
name|FINAL
argument_list|)
expr_stmt|;
name|field
operator|.
name|set
argument_list|(
literal|null
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
comment|// subsequent tests should get a DocumentDiscoveryLiteService setup from the
comment|// start
specifier|private
name|DocumentNodeStore
name|createNodeStore
parameter_list|(
name|String
name|workingDir
parameter_list|)
throws|throws
name|SecurityException
throws|,
name|Exception
block|{
comment|// ensure that we always get a fresh cluster[node]id
name|setFinalStatic
argument_list|(
name|ClusterNodeInfo
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"WORKING_DIR"
argument_list|)
argument_list|,
name|workingDir
argument_list|)
expr_stmt|;
comment|// then create the DocumentNodeStore
name|DocumentMK
name|mk1
init|=
name|createMK
argument_list|(
literal|0
comment|/* to make sure the clusterNodes collection is used **/
argument_list|,
literal|500
comment|/* asyncDelay: background interval */
argument_list|)
decl_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"createNodeStore: created DocumentNodeStore with cid="
operator|+
name|mk1
operator|.
name|nodeStore
operator|.
name|getClusterId
argument_list|()
operator|+
literal|", workingDir="
operator|+
name|workingDir
argument_list|)
expr_stmt|;
return|return
name|mk1
operator|.
name|nodeStore
return|;
block|}
specifier|private
name|SimplifiedInstance
name|createInstance
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|workingDir
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
return|return
name|createInstance
argument_list|(
name|workingDir
argument_list|)
return|;
block|}
specifier|private
name|SimplifiedInstance
name|createInstance
parameter_list|(
name|String
name|workingDir
parameter_list|)
throws|throws
name|SecurityException
throws|,
name|Exception
block|{
name|DocumentNodeStore
name|ns
init|=
name|createNodeStore
argument_list|(
name|workingDir
argument_list|)
decl_stmt|;
return|return
name|createInstance
argument_list|(
name|ns
argument_list|,
name|workingDir
argument_list|)
return|;
block|}
specifier|private
name|SimplifiedInstance
name|createInstance
parameter_list|(
name|DocumentNodeStore
name|ns
parameter_list|,
name|String
name|workingDir
parameter_list|)
throws|throws
name|NoSuchFieldException
block|{
name|DocumentDiscoveryLiteService
name|discoveryLite
init|=
operator|new
name|DocumentDiscoveryLiteService
argument_list|()
decl_stmt|;
name|PrivateAccessor
operator|.
name|setField
argument_list|(
name|discoveryLite
argument_list|,
literal|"nodeStore"
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|BundleContext
name|bc
init|=
name|mock
argument_list|(
name|BundleContext
operator|.
name|class
argument_list|)
decl_stmt|;
name|ComponentContext
name|c
init|=
name|mock
argument_list|(
name|ComponentContext
operator|.
name|class
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|c
operator|.
name|getBundleContext
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|bc
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|registeredServices
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|when
argument_list|(
name|bc
operator|.
name|registerService
argument_list|(
name|anyString
argument_list|()
argument_list|,
name|anyObject
argument_list|()
argument_list|,
operator|(
name|Properties
operator|)
name|anyObject
argument_list|()
argument_list|)
argument_list|)
operator|.
name|then
argument_list|(
operator|new
name|Answer
argument_list|<
name|ServiceRegistration
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ServiceRegistration
name|answer
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|)
block|{
name|registeredServices
operator|.
name|put
argument_list|(
operator|(
name|String
operator|)
name|invocation
operator|.
name|getArguments
argument_list|()
index|[
literal|0
index|]
argument_list|,
name|invocation
operator|.
name|getArguments
argument_list|()
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|discoveryLite
operator|.
name|activate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|Descriptors
name|d
init|=
operator|(
name|Descriptors
operator|)
name|registeredServices
operator|.
name|get
argument_list|(
name|Descriptors
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SimplifiedInstance
name|result
init|=
operator|new
name|SimplifiedInstance
argument_list|(
name|discoveryLite
argument_list|,
name|ns
argument_list|,
name|d
argument_list|,
name|registeredServices
argument_list|,
literal|500
argument_list|,
name|workingDir
argument_list|)
decl_stmt|;
name|allInstances
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Created "
operator|+
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|void
name|waitFor
parameter_list|(
name|Expectation
name|expectation
parameter_list|,
name|int
name|timeout
parameter_list|,
name|String
name|msg
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|long
name|tooLate
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|timeout
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|String
name|fulfillmentResult
init|=
name|expectation
operator|.
name|fulfilled
argument_list|()
decl_stmt|;
if|if
condition|(
name|fulfillmentResult
operator|==
literal|null
condition|)
block|{
comment|// everything's fine
return|return;
block|}
if|if
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|>
name|tooLate
condition|)
block|{
name|fail
argument_list|(
literal|"expectation not fulfilled within "
operator|+
name|timeout
operator|+
literal|"ms: "
operator|+
name|msg
operator|+
literal|", fulfillment result: "
operator|+
name|fulfillmentResult
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOneNode
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|SimplifiedInstance
name|s1
init|=
name|createInstance
argument_list|()
decl_stmt|;
specifier|final
name|ViewExpectation
name|expectation
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s1
argument_list|)
decl_stmt|;
name|expectation
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectation
argument_list|,
literal|2000
argument_list|,
literal|"see myself as active"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTwoNodesWithCleanShutdown
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|SimplifiedInstance
name|s1
init|=
name|createInstance
argument_list|()
decl_stmt|;
specifier|final
name|SimplifiedInstance
name|s2
init|=
name|createInstance
argument_list|()
decl_stmt|;
specifier|final
name|ViewExpectation
name|expectation1
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s1
argument_list|)
decl_stmt|;
specifier|final
name|ViewExpectation
name|expectation2
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s2
argument_list|)
decl_stmt|;
name|expectation1
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|expectation2
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectation1
argument_list|,
literal|2000
argument_list|,
literal|"first should see both as active"
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectation2
argument_list|,
literal|2000
argument_list|,
literal|"second should see both as active"
argument_list|)
expr_stmt|;
name|s2
operator|.
name|shutdown
argument_list|()
expr_stmt|;
specifier|final
name|ViewExpectation
name|expectation1AfterShutdown
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s1
argument_list|)
decl_stmt|;
name|expectation1AfterShutdown
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|expectation1AfterShutdown
operator|.
name|setInactiveIds
argument_list|(
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectation1AfterShutdown
argument_list|,
literal|2000
argument_list|,
literal|"first should only see itself after shutdown"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTwoNodesWithCrash
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|SimplifiedInstance
name|s1
init|=
name|createInstance
argument_list|()
decl_stmt|;
specifier|final
name|SimplifiedInstance
name|s2
init|=
name|createInstance
argument_list|()
decl_stmt|;
specifier|final
name|ViewExpectation
name|expectation1
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s1
argument_list|)
decl_stmt|;
specifier|final
name|ViewExpectation
name|expectation2
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s2
argument_list|)
decl_stmt|;
name|expectation1
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|expectation2
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectation1
argument_list|,
literal|2000
argument_list|,
literal|"first should see both as active"
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectation2
argument_list|,
literal|2000
argument_list|,
literal|"second should see both as active"
argument_list|)
expr_stmt|;
name|s2
operator|.
name|crash
argument_list|()
expr_stmt|;
specifier|final
name|ViewExpectation
name|expectation1AfterShutdown
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s1
argument_list|)
decl_stmt|;
name|expectation1AfterShutdown
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|expectation1AfterShutdown
operator|.
name|setInactiveIds
argument_list|(
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectation1AfterShutdown
argument_list|,
literal|2000
argument_list|,
literal|"first should only see itself after shutdown"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTwoNodesWithCrashAndLongduringRecovery
parameter_list|()
throws|throws
name|Throwable
block|{
name|doTestTwoNodesWithCrashAndLongduringDeactivation
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTwoNodesWithCrashAndLongduringRecoveryAndBacklog
parameter_list|()
throws|throws
name|Throwable
block|{
name|doTestTwoNodesWithCrashAndLongduringDeactivation
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|void
name|doTestTwoNodesWithCrashAndLongduringDeactivation
parameter_list|(
name|boolean
name|withBacklog
parameter_list|)
throws|throws
name|Throwable
block|{
specifier|final
name|int
name|TEST_WAIT_TIMEOUT
init|=
literal|10000
decl_stmt|;
specifier|final
name|SimplifiedInstance
name|s1
init|=
name|createInstance
argument_list|()
decl_stmt|;
specifier|final
name|SimplifiedInstance
name|s2
init|=
name|createInstance
argument_list|()
decl_stmt|;
specifier|final
name|ViewExpectation
name|expectation1
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s1
argument_list|)
decl_stmt|;
specifier|final
name|ViewExpectation
name|expectation2
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s2
argument_list|)
decl_stmt|;
name|expectation1
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|expectation2
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectation1
argument_list|,
name|TEST_WAIT_TIMEOUT
argument_list|,
literal|"first should see both as active"
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectation2
argument_list|,
name|TEST_WAIT_TIMEOUT
argument_list|,
literal|"second should see both as active"
argument_list|)
expr_stmt|;
comment|// before crashing s2, make sure that s1's lastRevRecovery thread
comment|// doesn't run
name|s1
operator|.
name|stopLastRevThread
argument_list|()
expr_stmt|;
if|if
condition|(
name|withBacklog
condition|)
block|{
comment|// plus also stop s1's backgroundReadThread - in case we want to
comment|// test backlog handling
name|s1
operator|.
name|stopBgReadThread
argument_list|()
expr_stmt|;
comment|// and then, if we want to do backlog testing, then s2 should write
comment|// something
comment|// before it crashes, so here it comes:
name|s2
operator|.
name|addNode
argument_list|(
literal|"/foo/bar"
argument_list|)
expr_stmt|;
name|s2
operator|.
name|setProperty
argument_list|(
literal|"/foo/bar"
argument_list|,
literal|"prop"
argument_list|,
literal|"value"
argument_list|)
expr_stmt|;
block|}
comment|// then crash s2
name|s2
operator|.
name|crash
argument_list|()
expr_stmt|;
comment|// then wait 2 sec
name|Thread
operator|.
name|sleep
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
comment|// at this stage, while s2 has crashed, we have stopped s1's
comment|// lastRevRecoveryThread, so we should still see both as active
name|logger
operator|.
name|info
argument_list|(
name|s1
operator|.
name|getClusterViewStr
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|ViewExpectation
name|expectation1AfterCrashBeforeLastRevRecovery
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s1
argument_list|)
decl_stmt|;
name|expectation1AfterCrashBeforeLastRevRecovery
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectation1AfterCrashBeforeLastRevRecovery
argument_list|,
name|TEST_WAIT_TIMEOUT
argument_list|,
literal|"first should still see both as active"
argument_list|)
expr_stmt|;
comment|// the next part is a bit tricky: we want to fine-control the
comment|// lastRevRecoveryThread's acquire/release locking.
comment|// the chosen way to do this is to make heavy use of mockito and two
comment|// semaphores:
comment|// when acquireRecoveryLock is called, that thread should wait for the
comment|// waitBeforeLocking semaphore to be released
specifier|final
name|MissingLastRevSeeker
name|missingLastRevUtil
init|=
operator|(
name|MissingLastRevSeeker
operator|)
name|PrivateAccessor
operator|.
name|getField
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getLastRevRecoveryAgent
argument_list|()
argument_list|,
literal|"missingLastRevUtil"
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|missingLastRevUtil
argument_list|)
expr_stmt|;
name|MissingLastRevSeeker
name|mockedLongduringMissingLastRevUtil
init|=
name|mock
argument_list|(
name|MissingLastRevSeeker
operator|.
name|class
argument_list|,
name|delegatesTo
argument_list|(
name|missingLastRevUtil
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Semaphore
name|waitBeforeLocking
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|mockedLongduringMissingLastRevUtil
operator|.
name|acquireRecoveryLock
argument_list|(
name|anyInt
argument_list|()
argument_list|)
argument_list|)
operator|.
name|then
argument_list|(
operator|new
name|Answer
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|answer
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|)
throws|throws
name|Throwable
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"going to waitBeforeLocking"
argument_list|)
expr_stmt|;
name|waitBeforeLocking
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"done with waitBeforeLocking"
argument_list|)
expr_stmt|;
return|return
name|missingLastRevUtil
operator|.
name|acquireRecoveryLock
argument_list|(
operator|(
name|Integer
operator|)
name|invocation
operator|.
name|getArguments
argument_list|()
index|[
literal|0
index|]
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|PrivateAccessor
operator|.
name|setField
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getLastRevRecoveryAgent
argument_list|()
argument_list|,
literal|"missingLastRevUtil"
argument_list|,
name|mockedLongduringMissingLastRevUtil
argument_list|)
expr_stmt|;
comment|// so let's start the lastRevThread again and wait for that
comment|// waitBeforeLocking semaphore to be hit
name|s1
operator|.
name|startLastRevThread
argument_list|()
expr_stmt|;
name|waitFor
argument_list|(
operator|new
name|Expectation
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|fulfilled
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|waitBeforeLocking
operator|.
name|hasQueuedThreads
argument_list|()
condition|)
block|{
return|return
literal|"no thread queued"
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|,
name|TEST_WAIT_TIMEOUT
argument_list|,
literal|"lastRevRecoveryThread should acquire a lock"
argument_list|)
expr_stmt|;
comment|// at this stage the crashed s2 is still not in recovery mode, so let's
comment|// check:
name|logger
operator|.
name|info
argument_list|(
name|s1
operator|.
name|getClusterViewStr
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|ViewExpectation
name|expectation1AfterCrashBeforeLastRevRecoveryLocking
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s1
argument_list|)
decl_stmt|;
name|expectation1AfterCrashBeforeLastRevRecoveryLocking
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectation1AfterCrashBeforeLastRevRecoveryLocking
argument_list|,
name|TEST_WAIT_TIMEOUT
argument_list|,
literal|"first should still see both as active"
argument_list|)
expr_stmt|;
comment|// one thing, before we let the waitBeforeLocking go, setup the release
comment|// semaphore/mock:
specifier|final
name|Semaphore
name|waitBeforeUnlocking
init|=
operator|new
name|Semaphore
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|doAnswer
argument_list|(
operator|new
name|Answer
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|answer
parameter_list|(
name|InvocationOnMock
name|invocation
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Going to waitBeforeUnlocking"
argument_list|)
expr_stmt|;
name|waitBeforeUnlocking
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Done with waitBeforeUnlocking"
argument_list|)
expr_stmt|;
name|missingLastRevUtil
operator|.
name|releaseRecoveryLock
argument_list|(
operator|(
name|Integer
operator|)
name|invocation
operator|.
name|getArguments
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
operator|.
name|when
argument_list|(
name|mockedLongduringMissingLastRevUtil
argument_list|)
operator|.
name|releaseRecoveryLock
argument_list|(
name|anyInt
argument_list|()
argument_list|)
expr_stmt|;
comment|// let go (or tschaedere loh)
name|waitBeforeLocking
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// then, right after we let the waitBeforeLocking semaphore go, we
comment|// should see s2 in recovery mode
specifier|final
name|ViewExpectation
name|expectation1AfterCrashWhileLastRevRecoveryLocking
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s1
argument_list|)
decl_stmt|;
name|expectation1AfterCrashWhileLastRevRecoveryLocking
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|expectation1AfterCrashWhileLastRevRecoveryLocking
operator|.
name|setDeactivatingIds
argument_list|(
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectation1AfterCrashWhileLastRevRecoveryLocking
argument_list|,
name|TEST_WAIT_TIMEOUT
argument_list|,
literal|"first should still see s2 as recovering"
argument_list|)
expr_stmt|;
comment|// ok, meanwhile, the lastRevRecoveryAgent should have hit the ot
name|waitFor
argument_list|(
operator|new
name|Expectation
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|fulfilled
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|waitBeforeUnlocking
operator|.
name|hasQueuedThreads
argument_list|()
condition|)
block|{
return|return
literal|"no thread queued"
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|,
name|TEST_WAIT_TIMEOUT
argument_list|,
literal|"lastRevRecoveryThread should want to release a lock"
argument_list|)
expr_stmt|;
comment|// so then, we should still see the same state
name|waitFor
argument_list|(
name|expectation1AfterCrashWhileLastRevRecoveryLocking
argument_list|,
name|TEST_WAIT_TIMEOUT
argument_list|,
literal|"first should still see s2 as recovering"
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Waiting 1,5sec"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1500
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Waiting done"
argument_list|)
expr_stmt|;
comment|// first, lets check to see what the view looks like - should be
comment|// unchanged:
name|waitFor
argument_list|(
name|expectation1AfterCrashWhileLastRevRecoveryLocking
argument_list|,
name|TEST_WAIT_TIMEOUT
argument_list|,
literal|"first should still see s2 as recovering"
argument_list|)
expr_stmt|;
comment|// let waitBeforeUnlocking go
name|logger
operator|.
name|info
argument_list|(
literal|"releasing waitBeforeUnlocking, state: "
operator|+
name|s1
operator|.
name|getClusterViewStr
argument_list|()
argument_list|)
expr_stmt|;
name|waitBeforeUnlocking
operator|.
name|release
argument_list|()
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"released waitBeforeUnlocking"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|withBacklog
condition|)
block|{
specifier|final
name|ViewExpectation
name|expectationWithoutBacklog
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s1
argument_list|)
decl_stmt|;
name|expectationWithoutBacklog
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|expectationWithoutBacklog
operator|.
name|setInactiveIds
argument_list|(
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectationWithoutBacklog
argument_list|,
name|TEST_WAIT_TIMEOUT
argument_list|,
literal|"finally we should see s2 as completely inactive"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// wait just 2 sec to see if the bgReadThread is really stopped
name|logger
operator|.
name|info
argument_list|(
literal|"sleeping 2 sec"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"sleeping 2 sec done, state: "
operator|+
name|s1
operator|.
name|getClusterViewStr
argument_list|()
argument_list|)
expr_stmt|;
comment|// when that's the case, check the view - it should now be in a
comment|// special 'final=false' mode
specifier|final
name|ViewExpectation
name|expectationBeforeBgRead
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s1
argument_list|)
decl_stmt|;
name|expectationBeforeBgRead
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|expectationBeforeBgRead
operator|.
name|setDeactivatingIds
argument_list|(
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|expectationBeforeBgRead
operator|.
name|setFinal
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectationBeforeBgRead
argument_list|,
name|TEST_WAIT_TIMEOUT
argument_list|,
literal|"first should only see itself after shutdown"
argument_list|)
expr_stmt|;
comment|// ook, now we explicitly do a background read to get out of the
comment|// backlog situation
name|s1
operator|.
name|ns
operator|.
name|runBackgroundReadOperations
argument_list|()
expr_stmt|;
specifier|final
name|ViewExpectation
name|expectationAfterBgRead
init|=
operator|new
name|ViewExpectation
argument_list|(
name|s1
argument_list|)
decl_stmt|;
name|expectationAfterBgRead
operator|.
name|setActiveIds
argument_list|(
name|s1
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|expectationAfterBgRead
operator|.
name|setInactiveIds
argument_list|(
name|s2
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|expectationAfterBgRead
argument_list|,
name|TEST_WAIT_TIMEOUT
argument_list|,
literal|"finally we should see s2 as completely inactive"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This test creates a large number of documentnodestores which it starts,      * runs, stops in a random fashion, always testing to make sure the      * clusterView is correct      */
annotation|@
name|Test
specifier|public
name|void
name|testLargeStartStopFiesta
parameter_list|()
throws|throws
name|Throwable
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"testLargeStartStopFiesta: start, seed="
operator|+
name|SEED
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|SimplifiedInstance
argument_list|>
name|instances
init|=
operator|new
name|LinkedList
argument_list|<
name|SimplifiedInstance
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|inactiveIds
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|SEED
argument_list|)
decl_stmt|;
specifier|final
name|int
name|LOOP_CNT
init|=
literal|50
decl_stmt|;
comment|// with too many loops have also seen mongo
comment|// connections becoming starved thus test
comment|// failed
specifier|final
name|int
name|CHECK_EVERY
init|=
literal|3
decl_stmt|;
specifier|final
name|int
name|MAX_NUM_INSTANCES
init|=
literal|8
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LOOP_CNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
name|CHECK_EVERY
operator|==
literal|0
condition|)
block|{
name|checkFiestaState
argument_list|(
name|instances
argument_list|,
name|inactiveIds
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|nextInt
init|=
name|random
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
decl_stmt|;
comment|// logger.info("testLargeStartStopFiesta: iteration "+i+" with case
comment|// "+nextInt);
name|String
name|workingDir
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|nextInt
condition|)
block|{
case|case
literal|0
case|:
block|{
comment|// increase likelihood of creating instances..
comment|// but reuse an inactive one if possible
if|if
condition|(
name|inactiveIds
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Case 0 - reactivating an instance..."
argument_list|)
expr_stmt|;
specifier|final
name|int
name|n
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|inactiveIds
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Integer
name|cid
init|=
operator|new
name|LinkedList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|inactiveIds
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|get
argument_list|(
name|n
argument_list|)
decl_stmt|;
specifier|final
name|String
name|reactivatedWorkingDir
init|=
name|inactiveIds
operator|.
name|remove
argument_list|(
name|cid
argument_list|)
decl_stmt|;
if|if
condition|(
name|reactivatedWorkingDir
operator|==
literal|null
condition|)
block|{
name|fail
argument_list|(
literal|"reactivatedWorkingDir null for n="
operator|+
name|n
operator|+
literal|", cid="
operator|+
name|cid
operator|+
literal|", other inactives: "
operator|+
name|inactiveIds
argument_list|)
expr_stmt|;
block|}
name|assertNotNull
argument_list|(
name|reactivatedWorkingDir
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Case 0 - reactivated instance "
operator|+
name|cid
operator|+
literal|", workingDir="
operator|+
name|reactivatedWorkingDir
argument_list|)
expr_stmt|;
name|workingDir
operator|=
name|reactivatedWorkingDir
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Case 0: creating instance"
argument_list|)
expr_stmt|;
specifier|final
name|SimplifiedInstance
name|newInstance
init|=
name|createInstance
argument_list|(
name|workingDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|newInstance
operator|.
name|hasRandomMachineId
argument_list|()
condition|)
block|{
comment|// OAK-3292 : on an instance which has no networkInterface with a mac address,
comment|// the machineId chosen by ClusterNodeInfo will be 'random:'.. and
comment|// ClusterNodeInfo.createInstance will feel free to remove it when the lease
comment|// has timed out
comment|// that really renders it very difficult to continue testing here,
comment|// since this test is all about keeping track who became inactive etc
comment|// and ClusterNodeInfo.createInstance removing it 'at a certain point' is difficult
comment|// and not very useful to test..
comment|//
comment|// so: stop testing at this point:
return|return;
block|}
name|newInstance
operator|.
name|setLeastTimeout
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|newInstance
operator|.
name|startSimulatingWrites
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Case 0: created instance: "
operator|+
name|newInstance
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newInstance
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
operator|!=
name|cid
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Case 0: reactivated instance did not take over cid - probably a testing artifact. expected cid: {}, actual cid: {}"
argument_list|,
name|cid
argument_list|,
name|newInstance
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|inactiveIds
operator|.
name|put
argument_list|(
name|cid
argument_list|,
name|reactivatedWorkingDir
argument_list|)
expr_stmt|;
comment|// remove the newly reactivated from the inactives -
comment|// although it shouldn't be there, it might!
name|inactiveIds
operator|.
name|remove
argument_list|(
name|newInstance
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|instances
operator|.
name|add
argument_list|(
name|newInstance
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|1
case|:
block|{
comment|// creates a new instance
if|if
condition|(
name|instances
operator|.
name|size
argument_list|()
operator|<
name|MAX_NUM_INSTANCES
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Case 1: creating instance"
argument_list|)
expr_stmt|;
specifier|final
name|SimplifiedInstance
name|newInstance
init|=
name|createInstance
argument_list|(
name|workingDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|newInstance
operator|.
name|hasRandomMachineId
argument_list|()
condition|)
block|{
comment|// OAK-3292 : on an instance which has no networkInterface with a mac address,
comment|// the machineId chosen by ClusterNodeInfo will be 'random:'.. and
comment|// ClusterNodeInfo.createInstance will feel free to remove it when the lease
comment|// has timed out
comment|// that really renders it very difficult to continue testing here,
comment|// since this test is all about keeping track who became inactive etc
comment|// and ClusterNodeInfo.createInstance removing it 'at a certain point' is difficult
comment|// and not very useful to test..
comment|//
comment|// so: stop testing at this point:
return|return;
block|}
name|newInstance
operator|.
name|setLeastTimeout
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|newInstance
operator|.
name|startSimulatingWrites
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Case 1: created instance: "
operator|+
name|newInstance
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|instances
operator|.
name|add
argument_list|(
name|newInstance
argument_list|)
expr_stmt|;
comment|// OAK-3292 : in case a previously crashed or shut-down instance is created again here
comment|//            make sure to remove it from inactive (if it in the inactive list at all)
name|inactiveIds
operator|.
name|remove
argument_list|(
name|newInstance
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
comment|// do nothing
break|break;
block|}
case|case
literal|3
case|:
block|{
comment|// shutdown instance
if|if
condition|(
name|instances
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// before shutting down: make sure we have a stable view
comment|// (we could otherwise not correctly startup too)
name|checkFiestaState
argument_list|(
name|instances
argument_list|,
name|inactiveIds
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SimplifiedInstance
name|instance
init|=
name|instances
operator|.
name|remove
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|instances
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|instance
operator|.
name|workingDir
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Case 3: Shutdown instance: "
operator|+
name|instance
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|inactiveIds
operator|.
name|put
argument_list|(
name|instance
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|instance
operator|.
name|workingDir
argument_list|)
expr_stmt|;
name|instance
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|4
case|:
block|{
comment|// crash instance
if|if
condition|(
name|instances
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// before crashing make sure we have a stable view (we
comment|// could otherwise not correctly startup too)
name|checkFiestaState
argument_list|(
name|instances
argument_list|,
name|inactiveIds
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SimplifiedInstance
name|instance
init|=
name|instances
operator|.
name|remove
argument_list|(
name|random
operator|.
name|nextInt
argument_list|(
name|instances
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|instance
operator|.
name|workingDir
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Case 4: Crashing instance: "
operator|+
name|instance
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|inactiveIds
operator|.
name|put
argument_list|(
name|instance
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|instance
operator|.
name|workingDir
argument_list|)
expr_stmt|;
name|instance
operator|.
name|addNode
argument_list|(
literal|"/"
operator|+
name|instance
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
operator|+
literal|"/stuffForRecovery/"
operator|+
name|random
operator|.
name|nextInt
argument_list|(
literal|10000
argument_list|)
argument_list|)
expr_stmt|;
name|instance
operator|.
name|crash
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|dumpChildren
parameter_list|(
name|DocumentNodeState
name|root
parameter_list|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"testEmptyParentRecovery: root: "
operator|+
name|root
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|root
operator|.
name|getChildNodeNames
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|n
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"testEmptyParentRecovery: a child: '"
operator|+
name|n
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkFiestaState
parameter_list|(
specifier|final
name|List
argument_list|<
name|SimplifiedInstance
argument_list|>
name|instances
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|inactiveIds
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|activeIds
init|=
operator|new
name|LinkedList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|SimplifiedInstance
argument_list|>
name|it
init|=
name|instances
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SimplifiedInstance
name|anInstance
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|activeIds
operator|.
name|add
argument_list|(
name|anInstance
operator|.
name|ns
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|info
argument_list|(
literal|"checkFiestaState: checking state. expected active: "
operator|+
name|activeIds
operator|+
literal|", inactive: "
operator|+
name|inactiveIds
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|SimplifiedInstance
argument_list|>
name|it
init|=
name|instances
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SimplifiedInstance
name|anInstance
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|ViewExpectation
name|e
init|=
operator|new
name|ViewExpectation
argument_list|(
name|anInstance
argument_list|)
decl_stmt|;
name|e
operator|.
name|setActiveIds
argument_list|(
name|activeIds
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
name|activeIds
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|setInactiveIds
argument_list|(
name|inactiveIds
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
name|inactiveIds
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|e
argument_list|,
literal|60000
argument_list|,
literal|"checkFiestaState failed for "
operator|+
name|anInstance
operator|+
literal|", with instances: "
operator|+
name|instances
operator|+
literal|", and inactiveIds: "
operator|+
name|inactiveIds
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Before
annotation|@
name|After
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"clear: seed="
operator|+
name|SEED
argument_list|)
expr_stmt|;
for|for
control|(
name|SimplifiedInstance
name|i
range|:
name|allInstances
control|)
block|{
name|i
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|DocumentMK
name|mk
range|:
name|mks
control|)
block|{
name|mk
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
name|mks
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|MONGO_DB
condition|)
block|{
name|MongoConnection
name|connection
init|=
name|MongoUtils
operator|.
name|getConnection
argument_list|()
decl_stmt|;
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
name|DB
name|db
init|=
name|connection
operator|.
name|getDB
argument_list|()
decl_stmt|;
if|if
condition|(
name|db
operator|!=
literal|null
condition|)
block|{
name|MongoUtils
operator|.
name|dropCollections
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|DocumentMK
name|createMK
parameter_list|(
name|int
name|clusterId
parameter_list|,
name|int
name|asyncDelay
parameter_list|)
block|{
if|if
condition|(
name|MONGO_DB
condition|)
block|{
name|DB
name|db
init|=
name|MongoUtils
operator|.
name|getConnection
argument_list|()
operator|.
name|getDB
argument_list|()
decl_stmt|;
return|return
name|register
argument_list|(
operator|new
name|DocumentMK
operator|.
name|Builder
argument_list|()
operator|.
name|setMongoDB
argument_list|(
name|db
argument_list|)
operator|.
name|setLeaseCheck
argument_list|(
literal|false
argument_list|)
operator|.
name|setClusterId
argument_list|(
name|clusterId
argument_list|)
operator|.
name|setAsyncDelay
argument_list|(
name|asyncDelay
argument_list|)
operator|.
name|open
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|ds
operator|==
literal|null
condition|)
block|{
name|ds
operator|=
operator|new
name|MemoryDocumentStore
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bs
operator|==
literal|null
condition|)
block|{
name|bs
operator|=
operator|new
name|MemoryBlobStore
argument_list|()
expr_stmt|;
block|}
return|return
name|createMK
argument_list|(
name|clusterId
argument_list|,
name|asyncDelay
argument_list|,
name|ds
argument_list|,
name|bs
argument_list|)
return|;
block|}
block|}
specifier|private
name|DocumentMK
name|createMK
parameter_list|(
name|int
name|clusterId
parameter_list|,
name|int
name|asyncDelay
parameter_list|,
name|DocumentStore
name|ds
parameter_list|,
name|BlobStore
name|bs
parameter_list|)
block|{
return|return
name|register
argument_list|(
operator|new
name|DocumentMK
operator|.
name|Builder
argument_list|()
operator|.
name|setDocumentStore
argument_list|(
name|ds
argument_list|)
operator|.
name|setBlobStore
argument_list|(
name|bs
argument_list|)
operator|.
name|setClusterId
argument_list|(
name|clusterId
argument_list|)
operator|.
name|setLeaseCheck
argument_list|(
literal|false
argument_list|)
operator|.
name|setAsyncDelay
argument_list|(
name|asyncDelay
argument_list|)
operator|.
name|open
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|DocumentMK
name|register
parameter_list|(
name|DocumentMK
name|mk
parameter_list|)
block|{
name|mks
operator|.
name|add
argument_list|(
name|mk
argument_list|)
expr_stmt|;
return|return
name|mk
return|;
block|}
block|}
end_class

end_unit

