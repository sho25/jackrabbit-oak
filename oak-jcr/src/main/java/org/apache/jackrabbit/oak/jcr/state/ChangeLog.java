begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|jcr
operator|.
name|state
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|model
operator|.
name|ScalarImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|model
operator|.
name|PropertyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|jcr
operator|.
name|util
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|kernel
operator|.
name|KernelPropertyState
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|jcr
operator|.
name|state
operator|.
name|ChangeLog
operator|.
name|Operation
operator|.
name|ID
import|;
end_import

begin_comment
comment|/**  * Instance of this class represent a list of add node, remove node,  * move node, set property and remove property operations.  * The change log is consolidated at any time. That is, a change log  * transforms any valid list of operation into an minimal list of  * operations which is equivalent to the initial list. A list of operation  * is valid, if can be applied to some hierarchy of nodes and properties.  * Two list of operations are equivalent if they have the same effect on  * any hierarchy of node and properties. A list of operations is minimal  * amongst some other list of operations if none of the other lists  * contain more operations.  */
end_comment

begin_class
specifier|public
class|class
name|ChangeLog
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|Operation
argument_list|>
name|operations
init|=
operator|new
name|ArrayList
argument_list|<
name|Operation
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Clear this change log to its empty state      */
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|operations
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * Add a add node operation to this change log      * @param path  path of the added node      */
specifier|public
name|void
name|addNode
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|addOperation
argument_list|(
name|Operation
operator|.
name|addNode
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add remove node operation to this change log      * @param path  path of the removed node      */
specifier|public
name|void
name|removeNode
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|addOperation
argument_list|(
name|Operation
operator|.
name|removeNode
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a move node operation to this change log      * @param from  path of the node to move      * @param to  path of the moves node      */
specifier|public
name|void
name|moveNode
parameter_list|(
name|Path
name|from
parameter_list|,
name|Path
name|to
parameter_list|)
block|{
name|addOperation
argument_list|(
name|Operation
operator|.
name|moveNode
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a set property operation to this change log      * @param parent  parent of the property      * @param state  state of the property      */
specifier|public
name|void
name|setProperty
parameter_list|(
name|Path
name|parent
parameter_list|,
name|PropertyState
name|state
parameter_list|)
block|{
name|addOperation
argument_list|(
name|Operation
operator|.
name|setProperty
argument_list|(
name|parent
argument_list|,
name|state
operator|.
name|getName
argument_list|()
argument_list|,
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a remove property operation to this change log      * @param parent  parent of the property      * @param name  name of the property      */
specifier|public
name|void
name|removeProperty
parameter_list|(
name|Path
name|parent
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|setProperty
argument_list|(
name|parent
argument_list|,
operator|new
name|KernelPropertyState
argument_list|(
name|name
argument_list|,
name|ScalarImpl
operator|.
name|nullScalar
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addOperation
parameter_list|(
name|Operation
name|operation
parameter_list|)
block|{
name|operations
operator|.
name|add
argument_list|(
name|operation
argument_list|)
expr_stmt|;
name|reduce
argument_list|(
name|operations
argument_list|,
name|operations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**      * @return  JSOP representation of the consolidated list of operations      */
specifier|public
name|String
name|toJsop
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Operation
name|op
range|:
name|operations
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|op
operator|.
name|toJsop
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Operation
name|op
range|:
name|operations
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|op
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|//------------------------------------------< private/internal>---
comment|/*       The change log consolidation algorithm implemented in the reduce method       is based on algebraic properties of move operations on paths. The other       operations (add node, remove node and set property) are generalized to       move operations. Consolidation relies on reduction and commutation rules       of move operations.        A move operation resembles a map on a hierarchy (of nodes and properties).       A change log consisting of k move operations m_1 to m_k is thus the composition       of the individual moves: m_1 *, ..., * m_k (using * for function composition:       f(g(x)) = (f * g)(x)).        Some definitions, notation and propositions:        * Let NIL denote a path which never occurs in any hierarchy.        * Order on paths: let p, q be paths.         - p< q iff p != NIL and q != NIL and p is an ancestor of q.         - p<= q iff p< q or p == q != NIL        * Conflict of paths: let p, q be paths.         - p ~ q (p conflicts with q) iff either p<= q or q<= p        * Substitution in paths: let p, q, r be paths.         - [p -> q]r = r if p is not an ancestor of r and         - [p -> q]r = s where s is the path resulting from replacing the ancestor           p in r with q otherwise.        * Let p, q be paths. Then p:q denotes a move operation where the node at         p is moved to a new node at q.        * Valid moves: leq p, q be paths.         - p:q is valid iff p !~ q or p = q         - if p:q is not valid, it is invalid        Invalid moves are exactly those which would result in a node being moved       to an ancestor/descendant of itself.        * Identity on moves: let p, q be paths.         - p:q = ID iff p = q.        * Conflict on moves: let p, q, r, s be paths.         - p:q ~ r:s (p:q conflicts with r:s) iff either p ~ r or p ~ s or q ~ r           or q ~ s.        * Strict commutativity of moves: let m, n be moves.         - m * n = n * m iff m !~ n        * Substitutions in moves: let p, q, r, s be paths.         - [p -> q]r:s = [p -> q]r:[p -> q]s        * Let p be a path and let +p denote an add node operation and let -p         denote a remove node operation for a node at path p.         - +p = NIL:p That is, adding a node is represented by a move from a           unknown source.         - p = p:NIL. That is, removing a node is represented by a move to an           unknown sink.         Let m = p:q, n = r:s with p, q, r, s != NIL be valid moves with m != ID and       n != ID. Then the following reduction and commutation rules apply:        1.  p!~ r:  m * n = n * m       2.  p< r:  illegal (since this implies q<= r which implies p ~ q and thus m invalid)       3.  p = r:  illegal (since this implies q<= r which implies p ~ q and this m invalid)       4.  p> r:  does not commute if q< s. Otherwise m * n = n * [r -> s]m       5.  p!~ s:  m * n = n * m       6.  p< s:  illegal (since this implies p ~ q and thus m invalid)       7.  p = s:  does not commute       8.  p> s:  illegal (since p> s implies there is an s already which will conflict with r:s)       9.  q!~ r:  m * n = n * m       10. q< r:  m * n = [q -> p]n * m       11. q = r:  m * n = p:s (transitivity of moves)       12. q> r:  m * n = n * [r -> s]m       13. q!~ s:  m * n = n * m       14. q< s:  does not commute if p> r. Otherwise m * n = [q -> p]n * m       15. q = s:  illegal (since s conflicts with r:s)       16. q> s:  illegal (since s conflicts with r:s)        Allowing add node and remove node operations the following additional conditions apply:        Let m = p:q, n = r:s be valid moves with m != ID and n != ID. Then the reduction       and commutations rules 1. to 16. apply with extra conditions on 4., 10., 12. and 14.:        4'.  if s = NIL and q = NIL then m * n = -r. Otherwise if s = NIL then m, n do not commute.       10'. illegal if p = NIL       12'. if s = NIL then m * n = -r * -p       14'. if p = NIL: does not commute if the parent of s is q. Illegal otherwise        The cases which are marked illegal cannot occur in valid change logs. That is, if such a       case occurred, the containing change log would be invalid.        Following some examples in JSOP notation for each of the above cases and its respective       special cases.        1.>/a:/b>/c:/d     =>/c:/d>/a:b       2.>/a:/b>/a/b:/c      illegal       3.>/a:/b>/a:/c        illegal       4.>/a/b:/c>/a:/d   =>/a:/d>/d/b:/c       4.>/a/b:/c>/a:/c/d    does not commute  (q< s)       4'.  -/a/b -/a         =  -/a               (s = NIL and q = NIL)       4'.>/a/b:/c -/a      =  does not commute  (s = NIL)       5.>/a:/b>/c:/d     =>/c:/d>/a:b       6.>/a:/b>/c:/a/d      illegal       7.>/a:/b>/c:/a        does not commute       8.>/a/d:/b>/c:/a      illegal       9.>/a:/b>/c:/d     =>/c:/d>/a:b       10.>/a:/b>/b/c:/d   =>/a/c:/d>/a:/b       10'. +/b:{}>/b/c:/d      illegal       11.>/a:/b>/b:/c     =>/a:/c       12.>/a:/b/c>/b:/d   =>/b:/d>/a:/d/c       12'.>/a:/b/c -/b      =  -/b -/a = -/a -/b       13:>/a:/b>/c:/d     =>/c:/d>/a:b       14.>/a:/b>/c:/b/d   =>/c:/a/d>/a:/b       14.>/a/b:/b>/a:/b/d    does not commute  (p> r)       14'. +/b:{}>/c:/b/c      does not commute  (parent of s = q and p = NIL)       14'. +/b:{}>/c:/b/c/d    illegal           (p = NIL)       15.>/a:/b>/c:/b        illegal       16.>/a:/b/d>/c:/b      illegal      */
comment|/**      * Special path element representing source and sink in add node      * and remove node operations, respectively. NIL is not part of      * the {@code leq}, {@code lt} and {@code conflict} relations below.      */
specifier|private
specifier|static
specifier|final
name|Path
name|NIL
init|=
name|Path
operator|.
name|create
argument_list|(
literal|""
argument_list|,
literal|"/*"
argument_list|)
decl_stmt|;
comment|/**      * Partial order on paths: {@code p}<= {@code q} iff {@code p} is an ancestor      * of {@code q} or {@code p} == {@code q}      */
specifier|private
specifier|static
name|boolean
name|leq
parameter_list|(
name|Path
name|p
parameter_list|,
name|Path
name|q
parameter_list|)
block|{
return|return
name|p
operator|!=
name|NIL
operator|&&
name|q
operator|!=
name|NIL
operator|&&
operator|(
name|p
operator|.
name|equals
argument_list|(
name|q
argument_list|)
operator|||
name|p
operator|.
name|isAncestorOf
argument_list|(
name|q
argument_list|)
operator|)
return|;
block|}
comment|/**      * Strict partial order on paths: {@code p}< {@code q} iff {@code p} is an      * ancestor of {@code q}      */
specifier|private
specifier|static
name|boolean
name|lt
parameter_list|(
name|Path
name|p
parameter_list|,
name|Path
name|q
parameter_list|)
block|{
return|return
name|p
operator|!=
name|NIL
operator|&&
name|q
operator|!=
name|NIL
operator|&&
name|p
operator|.
name|isAncestorOf
argument_list|(
name|q
argument_list|)
return|;
block|}
comment|/**      * Conflict of paths: {@code p} and {@code q} conflict iff either      * {@code p}<= {@code q} or {@code p}>= {@code q}      */
specifier|private
specifier|static
name|boolean
name|conflict
parameter_list|(
name|Path
name|p
parameter_list|,
name|Path
name|q
parameter_list|)
block|{
return|return
name|leq
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
operator|||
name|leq
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
return|;
block|}
comment|/**      * Substitution of ancestor path: replaces {@code from} with {@code to}      * in {@code path} if {@code from} is an ancestor of {@code path}      */
specifier|private
specifier|static
name|Path
name|subst
parameter_list|(
name|Path
name|from
parameter_list|,
name|Path
name|to
parameter_list|,
name|Path
name|path
parameter_list|)
block|{
return|return
name|path
operator|==
name|NIL
condition|?
name|path
else|:
name|path
operator|.
name|move
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
return|;
block|}
comment|/**      * Instances of this class represent operations in the change log.      * The underlying abstraction models operations as a moves: remove      * node is represented as move to {@code NIL} and add node and add      * property are represented as move from {@code NIL}. Add property      * operations carry the property state and the property names is      * disambiguated (leading star) in order to avoid conflicts with node      * names.      */
specifier|static
specifier|final
class|class
name|Operation
block|{
specifier|public
specifier|static
specifier|final
name|Operation
name|ID
init|=
operator|new
name|Operation
argument_list|(
name|NIL
argument_list|,
name|NIL
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Path
name|from
decl_stmt|;
specifier|private
specifier|final
name|Path
name|to
decl_stmt|;
specifier|private
specifier|final
name|PropertyState
name|state
decl_stmt|;
specifier|private
name|Operation
parameter_list|(
name|Path
name|from
parameter_list|,
name|Path
name|to
parameter_list|,
name|PropertyState
name|state
parameter_list|)
block|{
if|if
condition|(
name|from
operator|==
literal|null
operator|||
name|to
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"path is null"
argument_list|)
throw|;
block|}
name|this
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|this
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
comment|/**          * Create a new move node operation.          * @param from  source of the move          * @param to  target of the move          * @return  new move node operation or {@code ID} if {@code from} and {@code to}          * are the same path.          * @throws IllegalArgumentException  if {@code from} an {@code to} conflict: moving          * a node to its own ancestor/descendant is not possible.          */
specifier|public
specifier|static
name|Operation
name|moveNode
parameter_list|(
name|Path
name|from
parameter_list|,
name|Path
name|to
parameter_list|)
block|{
if|if
condition|(
name|from
operator|.
name|equals
argument_list|(
name|to
argument_list|)
condition|)
block|{
return|return
name|ID
return|;
block|}
if|if
condition|(
name|conflict
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
block|{
comment|// Cannot move node to own ancestor/descendant
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot move "
operator|+
name|from
operator|+
literal|" to "
operator|+
name|to
argument_list|)
throw|;
block|}
else|else
block|{
return|return
operator|new
name|Operation
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
comment|/**          * Create a new add node operation.          * @param path  path of the node          * @return  new add node operation or {@code ID} if {@code path} is {@code NIL}          */
specifier|public
specifier|static
name|Operation
name|addNode
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
name|path
operator|.
name|equals
argument_list|(
name|NIL
argument_list|)
condition|?
name|ID
else|:
operator|new
name|Operation
argument_list|(
name|NIL
argument_list|,
name|path
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**          * Create a new remove node operation.          * @param path  path of the node          * @return  new remove node operation or {@code ID} if {@code path} is {@code NIL}          */
specifier|public
specifier|static
name|Operation
name|removeNode
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
name|path
operator|.
name|equals
argument_list|(
name|NIL
argument_list|)
condition|?
name|ID
else|:
operator|new
name|Operation
argument_list|(
name|path
argument_list|,
name|NIL
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**          * Create a new set property operation.          * @param parent  parent of the property          * @param name  name of the property          * @param state  state of the property          * @return  new set property operation          */
specifier|public
specifier|static
name|Operation
name|setProperty
parameter_list|(
name|Path
name|parent
parameter_list|,
name|String
name|name
parameter_list|,
name|PropertyState
name|state
parameter_list|)
block|{
return|return
operator|new
name|Operation
argument_list|(
name|NIL
argument_list|,
name|encodeProperty
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
argument_list|,
name|state
argument_list|)
return|;
block|}
comment|/**          * Move this move operation to another ancestor path          * @param source  source path          * @param target  target path          * @return  move operation where {@code target} is substituted for {@code source}          * in both {@code from} and {@code to} of this operation.          */
specifier|public
name|Operation
name|move
parameter_list|(
name|Path
name|source
parameter_list|,
name|Path
name|target
parameter_list|)
block|{
return|return
operator|new
name|Operation
argument_list|(
name|subst
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|from
argument_list|)
argument_list|,
name|subst
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|to
argument_list|)
argument_list|,
name|state
argument_list|)
return|;
block|}
comment|/**          * @return  JSOP representation of this operation          */
specifier|public
name|String
name|toJsop
parameter_list|()
block|{
if|if
condition|(
name|from
operator|==
name|NIL
operator|&&
name|to
operator|==
name|NIL
condition|)
block|{
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
return|return
literal|"^\""
operator|+
name|decodeProperty
argument_list|(
name|to
argument_list|)
operator|.
name|toMkPath
argument_list|()
operator|+
literal|"\":"
operator|+
name|state
operator|.
name|getEncodedValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|from
operator|==
name|NIL
condition|)
block|{
return|return
literal|"+\""
operator|+
name|to
operator|.
name|toMkPath
argument_list|()
operator|+
literal|"\":{}"
return|;
block|}
elseif|else
if|if
condition|(
name|to
operator|==
name|NIL
condition|)
block|{
return|return
literal|"-\""
operator|+
name|from
operator|.
name|toMkPath
argument_list|()
operator|+
literal|'"'
return|;
block|}
else|else
block|{
return|return
literal|">\""
operator|+
name|from
operator|.
name|toMkPath
argument_list|()
operator|+
literal|"\":\""
operator|+
name|to
operator|.
name|toMkPath
argument_list|()
operator|+
literal|'"'
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|other
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|Operation
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Operation
name|that
init|=
operator|(
name|Operation
operator|)
name|other
decl_stmt|;
return|return
name|from
operator|.
name|equals
argument_list|(
name|that
operator|.
name|from
argument_list|)
operator|&&
name|to
operator|.
name|equals
argument_list|(
name|that
operator|.
name|to
argument_list|)
operator|&&
name|state
operator|==
literal|null
condition|?
name|that
operator|.
name|state
operator|==
literal|null
else|:
name|state
operator|.
name|equals
argument_list|(
name|that
operator|.
name|state
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
literal|31
operator|*
operator|(
literal|31
operator|*
name|from
operator|.
name|hashCode
argument_list|()
operator|+
name|to
operator|.
name|hashCode
argument_list|()
operator|)
operator|+
operator|(
name|state
operator|==
literal|null
condition|?
literal|0
else|:
name|state
operator|.
name|hashCode
argument_list|()
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|from
operator|==
name|NIL
operator|&&
name|to
operator|==
name|NIL
condition|)
block|{
return|return
literal|"ID"
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
return|return
literal|'^'
operator|+
name|decodeProperty
argument_list|(
name|to
argument_list|)
operator|.
name|toMkPath
argument_list|()
operator|+
literal|':'
operator|+
name|state
operator|.
name|getEncodedValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|from
operator|==
name|NIL
condition|)
block|{
return|return
literal|'+'
operator|+
name|to
operator|.
name|toMkPath
argument_list|()
operator|+
literal|":{}"
return|;
block|}
elseif|else
if|if
condition|(
name|to
operator|==
name|NIL
condition|)
block|{
return|return
literal|'-'
operator|+
name|from
operator|.
name|toMkPath
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|'>'
operator|+
name|from
operator|.
name|toMkPath
argument_list|()
operator|+
literal|':'
operator|+
name|to
operator|.
name|toMkPath
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
name|Path
name|encodeProperty
parameter_list|(
name|Path
name|parent
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|parent
operator|.
name|concat
argument_list|(
literal|'*'
operator|+
name|name
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Path
name|decodeProperty
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
name|path
operator|.
name|getParent
argument_list|()
operator|.
name|concat
argument_list|(
name|path
operator|.
name|getName
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**      * Try to commute the two operations at {@code index} and {@code index + 1} in      * the list of operations {@code ops}. Commuting operations might result in      * changes to these operations. The list is modified in place.      * @return {@code true} if commuting was successful, {@code false} otherwise.      */
specifier|private
specifier|static
name|boolean
name|commute
parameter_list|(
name|List
argument_list|<
name|Operation
argument_list|>
name|ops
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|Operation
name|m
init|=
name|ops
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Operation
name|n
init|=
name|ops
operator|.
name|get
argument_list|(
name|index
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|conflict
argument_list|(
name|m
operator|.
name|from
argument_list|,
name|n
operator|.
name|from
argument_list|)
operator|&&
operator|!
name|conflict
argument_list|(
name|m
operator|.
name|from
argument_list|,
name|n
operator|.
name|to
argument_list|)
operator|&&
operator|!
name|conflict
argument_list|(
name|m
operator|.
name|to
argument_list|,
name|n
operator|.
name|from
argument_list|)
operator|&&
operator|!
name|conflict
argument_list|(
name|m
operator|.
name|to
argument_list|,
name|n
operator|.
name|to
argument_list|)
condition|)
block|{
comment|// Strict commutativity. See 1., 5., 9., 13.
name|ops
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ops
operator|.
name|set
argument_list|(
name|index
operator|+
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|lt
argument_list|(
name|n
operator|.
name|from
argument_list|,
name|m
operator|.
name|from
argument_list|)
condition|)
block|{
comment|// p> r
comment|// See 4'. The case s = NIL and q = NIL is handled in reduceTuple
if|if
condition|(
name|lt
argument_list|(
name|m
operator|.
name|to
argument_list|,
name|n
operator|.
name|to
argument_list|)
operator|||
name|n
operator|.
name|to
operator|==
name|NIL
condition|)
block|{
comment|// q< s || s == NIL
return|return
literal|false
return|;
block|}
else|else
block|{
name|ops
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ops
operator|.
name|set
argument_list|(
name|index
operator|+
literal|1
argument_list|,
name|m
operator|.
name|move
argument_list|(
name|n
operator|.
name|from
argument_list|,
name|n
operator|.
name|to
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|m
operator|.
name|from
operator|!=
name|NIL
operator|&&
name|m
operator|.
name|from
operator|.
name|equals
argument_list|(
name|n
operator|.
name|to
argument_list|)
condition|)
block|{
comment|// p = s
comment|// See 7.
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|lt
argument_list|(
name|m
operator|.
name|to
argument_list|,
name|n
operator|.
name|from
argument_list|)
condition|)
block|{
comment|// q< r
comment|// See 10'.
if|if
condition|(
name|m
operator|.
name|from
operator|==
name|NIL
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|m
operator|+
literal|", "
operator|+
name|n
argument_list|)
throw|;
block|}
name|ops
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|n
operator|.
name|move
argument_list|(
name|m
operator|.
name|to
argument_list|,
name|m
operator|.
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|ops
operator|.
name|set
argument_list|(
name|index
operator|+
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|.
name|to
operator|.
name|equals
argument_list|(
name|n
operator|.
name|from
argument_list|)
condition|)
block|{
comment|// q = r
comment|// See 11. This case is handled in reduceTuple
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|lt
argument_list|(
name|n
operator|.
name|from
argument_list|,
name|m
operator|.
name|to
argument_list|)
condition|)
block|{
comment|// q> r
comment|// See 12'.
if|if
condition|(
name|n
operator|.
name|to
operator|==
name|NIL
condition|)
block|{
name|ops
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|Operation
operator|.
name|removeNode
argument_list|(
name|m
operator|.
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|ops
operator|.
name|set
argument_list|(
name|index
operator|+
literal|1
argument_list|,
name|Operation
operator|.
name|removeNode
argument_list|(
name|n
operator|.
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|ops
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ops
operator|.
name|set
argument_list|(
name|index
operator|+
literal|1
argument_list|,
name|m
operator|.
name|move
argument_list|(
name|n
operator|.
name|from
argument_list|,
name|n
operator|.
name|to
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|lt
argument_list|(
name|m
operator|.
name|to
argument_list|,
name|n
operator|.
name|to
argument_list|)
condition|)
block|{
comment|// q< s
comment|// See 14'.
if|if
condition|(
name|m
operator|.
name|from
operator|==
name|NIL
condition|)
block|{
name|Path
name|p
init|=
name|n
operator|.
name|to
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|equals
argument_list|(
name|m
operator|.
name|to
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|m
operator|+
literal|", "
operator|+
name|n
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|ops
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|n
operator|.
name|move
argument_list|(
name|m
operator|.
name|to
argument_list|,
name|m
operator|.
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|ops
operator|.
name|set
argument_list|(
name|index
operator|+
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
comment|// See 2., 3., 6., 8., 15. and 16.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|m
operator|+
literal|", "
operator|+
name|n
argument_list|)
throw|;
block|}
block|}
comment|/**      * Try to reduce the single operation at {@code index} in the list of      * operations {@code ops}. The list is modified in place, i.e. reduced      * operations are removed.      * @return  {@code true} if a reduction occurred, {@code false} otherwise      */
specifier|private
specifier|static
name|boolean
name|reduceSingleton
parameter_list|(
name|List
argument_list|<
name|Operation
argument_list|>
name|ops
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|ops
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|==
name|ID
condition|)
block|{
name|ops
operator|.
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Try to reduce the two operations at {@code index} and {@code index + 1}      * in the list of operations {@code ops} to a single operation. The list is      * modified in place, i.e. reduced operations are removed and replaced with      * the result of the reduction.      * @return  index of the operations in {@code ops} which contains the result      * of the reduction or {@code -1} if no reduction occurred.      */
specifier|private
specifier|static
name|int
name|reduceTuple
parameter_list|(
name|List
argument_list|<
name|Operation
argument_list|>
name|ops
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|Operation
name|m
init|=
name|ops
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Operation
name|n
init|=
name|ops
operator|.
name|get
argument_list|(
name|index
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|ID
condition|)
block|{
comment|// left absorption: ID * x = x
name|ops
operator|.
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
name|ID
condition|)
block|{
comment|// right absorption: x * ID = x
name|ops
operator|.
name|remove
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|.
name|to
operator|!=
name|NIL
operator|&&
name|m
operator|.
name|to
operator|.
name|equals
argument_list|(
name|n
operator|.
name|from
argument_list|)
condition|)
block|{
comment|// transitivity: a:b * b:c = a:c  (See 11.)
name|ops
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|Operation
operator|.
name|moveNode
argument_list|(
name|m
operator|.
name|from
argument_list|,
name|n
operator|.
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|ops
operator|.
name|remove
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|.
name|to
operator|==
name|NIL
operator|&&
name|n
operator|.
name|to
operator|==
name|NIL
operator|&&
name|lt
argument_list|(
name|n
operator|.
name|from
argument_list|,
name|m
operator|.
name|from
argument_list|)
condition|)
block|{
comment|// p> r
comment|// remove absorption: -a/b * -a = -a  (See 4'.)
name|ops
operator|.
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|.
name|from
operator|==
name|NIL
operator|&&
name|n
operator|.
name|to
operator|==
name|NIL
operator|&&
name|lt
argument_list|(
name|n
operator|.
name|from
argument_list|,
name|m
operator|.
name|to
argument_list|)
condition|)
block|{
comment|// q> r
comment|// add absorption: +a/b * -a = -a  (See 12'.)
name|ops
operator|.
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|.
name|state
operator|!=
literal|null
operator|&&
name|n
operator|.
name|state
operator|!=
literal|null
operator|&&
name|m
operator|.
name|to
operator|.
name|equals
argument_list|(
name|n
operator|.
name|to
argument_list|)
condition|)
block|{
comment|// set property absorption: ^a:x * ^a:y = ^a:y
name|ops
operator|.
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**      * Reduce a list of operations. Let {@code ops.remove(index)} be      * minimal amongst all its equivalent lists of operations. Then this      * method reduces {@code ops} to a minimal list of operations which      * is equivalent to {@code ops}.      */
specifier|private
specifier|static
name|boolean
name|reduce
parameter_list|(
name|List
argument_list|<
name|Operation
argument_list|>
name|ops
parameter_list|,
name|int
name|index
parameter_list|)
block|{
comment|// If the operation at index can be eliminated, we are done
if|if
condition|(
name|reduceSingleton
argument_list|(
name|ops
argument_list|,
name|index
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|int
name|reduced
init|=
operator|-
literal|1
decl_stmt|;
comment|// Index of the operation resulting from reducing two adjacent operations
comment|// Starting at the new operation, go backward until either a reduction of two
comment|// adjacent operations is found or the two adjacent operations don't commute
name|int
name|k
init|=
name|index
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|--
name|k
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|reduced
operator|=
name|reduceTuple
argument_list|(
name|ops
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|reduced
operator|<
literal|0
operator|&&
name|commute
argument_list|(
name|ops
argument_list|,
name|k
argument_list|)
condition|)
do|;
comment|// If no reduction found so far...
if|if
condition|(
name|reduced
operator|<
literal|0
condition|)
block|{
comment|// ...starting at the new operation, go forward until either a reduction of two
comment|// adjacent operations is found or the two adjacent operations don't commute
name|k
operator|=
name|index
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|++
name|k
operator|>=
name|ops
operator|.
name|size
argument_list|()
condition|)
block|{
break|break;
block|}
name|reduced
operator|=
name|reduceTuple
argument_list|(
name|ops
argument_list|,
name|k
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|reduced
operator|<
literal|0
operator|&&
name|commute
argument_list|(
name|ops
argument_list|,
name|k
operator|-
literal|1
argument_list|)
condition|)
do|;
block|}
comment|// If a reduction has been found, reduce recursively treating the result
comment|// of the reduction as new operation
return|return
name|reduced
operator|>=
literal|0
operator|&&
operator|!
name|ops
operator|.
name|isEmpty
argument_list|()
operator|&&
name|reduce
argument_list|(
name|ops
argument_list|,
name|reduced
argument_list|)
return|;
block|}
block|}
end_class

end_unit

