begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|ExceptionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|api
operator|.
name|MicroKernel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|api
operator|.
name|MicroKernelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|index
operator|.
name|IndexWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|json
operator|.
name|JsopBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|json
operator|.
name|JsopReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|json
operator|.
name|JsopTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|simple
operator|.
name|NodeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|simple
operator|.
name|NodeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|mk
operator|.
name|util
operator|.
name|SimpleLRUCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|index
operator|.
name|PrefixContentIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|index
operator|.
name|PropertyContentIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|QueryIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|QueryIndexProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|query
operator|.
name|Index
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|query
operator|.
name|IndexUtils
import|;
end_import

begin_comment
comment|/**  * A index mechanism. An index is bound to a certain repository, and supports  * one or more indexes.  */
end_comment

begin_class
specifier|public
class|class
name|Indexer
implements|implements
name|QueryIndexProvider
block|{
comment|/**      * The root node of the index definition (configuration) nodes.      */
comment|// TODO OAK-178 discuss where to store index config data
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_CONFIG_PATH
init|=
name|IndexUtils
operator|.
name|DEFAULT_INDEX_HOME
operator|+
literal|"/indexes"
decl_stmt|;
comment|//"/jcr:system/indexes";
comment|/**      * For each index, the index content is stored relative to the index      * definition below this node. There is also such a node just below the      * index definition node, to store the last revision and for temporary data.      */
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_CONTENT
init|=
literal|":data"
decl_stmt|;
comment|/**      * The node name prefix of a prefix index.      */
specifier|public
specifier|static
specifier|final
name|String
name|TYPE_PREFIX
init|=
literal|"prefix@"
decl_stmt|;
comment|/**      * The node name prefix of a property index.      */
comment|// TODO support multi-property indexes
specifier|public
specifier|static
specifier|final
name|String
name|TYPE_PROPERTY
init|=
literal|"property@"
decl_stmt|;
comment|/**      * Marks a unique index.      */
specifier|public
specifier|static
specifier|final
name|String
name|UNIQUE
init|=
literal|"unique"
decl_stmt|;
comment|/**      * The maximum length of the write buffer.      */
specifier|private
specifier|static
specifier|final
name|int
name|MAX_BUFFER_LENGTH
init|=
literal|100000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|DISABLED
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
literal|"mk.indexDisabled"
argument_list|)
decl_stmt|;
specifier|private
name|MicroKernel
name|mk
decl_stmt|;
specifier|private
name|String
name|revision
decl_stmt|;
specifier|private
name|String
name|indexRootNode
init|=
name|INDEX_CONFIG_PATH
decl_stmt|;
specifier|private
name|int
name|indexRootNodeDepth
decl_stmt|;
specifier|private
name|StringBuilder
name|buffer
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|QueryIndex
argument_list|>
name|queryIndexList
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|BTreePage
argument_list|>
name|modified
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BTreePage
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|SimpleLRUCache
argument_list|<
name|String
argument_list|,
name|BTreePage
argument_list|>
name|cache
init|=
name|SimpleLRUCache
operator|.
name|newInstance
argument_list|(
literal|100
argument_list|)
decl_stmt|;
specifier|private
name|String
name|readRevision
decl_stmt|;
specifier|private
name|boolean
name|init
decl_stmt|;
comment|/**      * An index node name to index map.      */
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|PIndex
argument_list|>
name|indexes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|PIndex
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * A prefix to prefix index map.      */
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|PrefixIndex
argument_list|>
name|prefixIndexes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|PrefixIndex
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * A property name to property index map.      */
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|PropertyIndex
argument_list|>
name|propertyIndexes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|PropertyIndex
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|Indexer
parameter_list|(
name|MicroKernel
name|mk
parameter_list|)
block|{
name|this
operator|.
name|mk
operator|=
name|mk
expr_stmt|;
block|}
comment|/**      * Get the indexer for the given MicroKernel. This will either create a new instance,      * or (if the MicroKernel is an IndexWrapper), return the existing indexer.      *      * @param mk the MicroKernel instance      * @return an indexer      */
specifier|public
specifier|static
name|Indexer
name|getInstance
parameter_list|(
name|MicroKernel
name|mk
parameter_list|)
block|{
if|if
condition|(
name|mk
operator|instanceof
name|IndexWrapper
condition|)
block|{
name|Indexer
name|indexer
init|=
operator|(
operator|(
name|IndexWrapper
operator|)
name|mk
operator|)
operator|.
name|getIndexer
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexer
operator|!=
literal|null
condition|)
block|{
return|return
name|indexer
return|;
block|}
block|}
return|return
operator|new
name|Indexer
argument_list|(
name|mk
argument_list|)
return|;
block|}
specifier|public
name|String
name|getIndexRootNode
parameter_list|()
block|{
return|return
name|indexRootNode
return|;
block|}
specifier|public
name|void
name|init
parameter_list|()
block|{
if|if
condition|(
name|init
condition|)
block|{
return|return;
block|}
name|init
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|PathUtils
operator|.
name|isAbsolute
argument_list|(
name|indexRootNode
argument_list|)
condition|)
block|{
name|indexRootNode
operator|=
literal|"/"
operator|+
name|indexRootNode
expr_stmt|;
block|}
name|indexRootNodeDepth
operator|=
name|PathUtils
operator|.
name|getDepth
argument_list|(
name|indexRootNode
argument_list|)
expr_stmt|;
name|revision
operator|=
name|mk
operator|.
name|getHeadRevision
argument_list|()
expr_stmt|;
name|readRevision
operator|=
name|revision
expr_stmt|;
name|boolean
name|exists
init|=
name|mk
operator|.
name|nodeExists
argument_list|(
name|indexRootNode
argument_list|,
name|revision
argument_list|)
decl_stmt|;
name|createNodes
argument_list|(
name|INDEX_CONTENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|String
name|node
init|=
name|mk
operator|.
name|getNodes
argument_list|(
name|indexRootNode
argument_list|,
name|revision
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeMap
name|map
init|=
operator|new
name|NodeMap
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|NodeImpl
name|n
init|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|map
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|String
name|rev
init|=
name|JsopTokenizer
operator|.
name|decodeQuoted
argument_list|(
name|n
operator|.
name|getNode
argument_list|(
name|INDEX_CONTENT
argument_list|)
operator|.
name|getProperty
argument_list|(
literal|"rev"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rev
operator|!=
literal|null
condition|)
block|{
name|readRevision
operator|=
name|rev
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
operator|.
name|getChildNodeCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|k
init|=
name|n
operator|.
name|getChildNodeName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|PropertyIndex
name|prop
init|=
name|PropertyIndex
operator|.
name|fromNodeName
argument_list|(
name|this
argument_list|,
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
name|indexes
operator|.
name|put
argument_list|(
name|prop
operator|.
name|getDefinition
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|prop
argument_list|)
expr_stmt|;
name|propertyIndexes
operator|.
name|put
argument_list|(
name|prop
operator|.
name|getPropertyName
argument_list|()
argument_list|,
name|prop
argument_list|)
expr_stmt|;
name|queryIndexList
operator|=
literal|null
expr_stmt|;
block|}
name|PrefixIndex
name|pref
init|=
name|PrefixIndex
operator|.
name|fromNodeName
argument_list|(
name|this
argument_list|,
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|pref
operator|!=
literal|null
condition|)
block|{
name|indexes
operator|.
name|put
argument_list|(
name|pref
operator|.
name|getDefinition
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|pref
argument_list|)
expr_stmt|;
name|prefixIndexes
operator|.
name|put
argument_list|(
name|pref
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|pref
argument_list|)
expr_stmt|;
name|queryIndexList
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|removePropertyIndex
parameter_list|(
name|String
name|property
parameter_list|,
name|boolean
name|unique
parameter_list|)
block|{
name|PropertyIndex
name|index
init|=
name|propertyIndexes
operator|.
name|remove
argument_list|(
name|property
argument_list|)
decl_stmt|;
name|indexes
operator|.
name|remove
argument_list|(
name|index
operator|.
name|getDefinition
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|queryIndexList
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|PropertyIndex
name|createPropertyIndex
parameter_list|(
name|String
name|property
parameter_list|,
name|boolean
name|unique
parameter_list|)
block|{
name|PropertyIndex
name|existing
init|=
name|propertyIndexes
operator|.
name|get
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|!=
literal|null
condition|)
block|{
return|return
name|existing
return|;
block|}
name|PropertyIndex
name|index
init|=
operator|new
name|PropertyIndex
argument_list|(
name|this
argument_list|,
name|property
argument_list|,
name|unique
argument_list|)
decl_stmt|;
name|buildIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|indexes
operator|.
name|put
argument_list|(
name|index
operator|.
name|getDefinition
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|propertyIndexes
operator|.
name|put
argument_list|(
name|index
operator|.
name|getPropertyName
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|queryIndexList
operator|=
literal|null
expr_stmt|;
return|return
name|index
return|;
block|}
specifier|private
name|void
name|removePrefixIndex
parameter_list|(
name|String
name|prefix
parameter_list|)
block|{
name|PrefixIndex
name|index
init|=
name|prefixIndexes
operator|.
name|remove
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
name|indexes
operator|.
name|remove
argument_list|(
name|index
operator|.
name|getDefinition
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|queryIndexList
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|PrefixIndex
name|createPrefixIndex
parameter_list|(
name|String
name|prefix
parameter_list|)
block|{
name|PrefixIndex
name|existing
init|=
name|prefixIndexes
operator|.
name|get
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|!=
literal|null
condition|)
block|{
return|return
name|existing
return|;
block|}
name|PrefixIndex
name|index
init|=
operator|new
name|PrefixIndex
argument_list|(
name|this
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
name|buildIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|indexes
operator|.
name|put
argument_list|(
name|index
operator|.
name|getDefinition
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|prefixIndexes
operator|.
name|put
argument_list|(
name|index
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|queryIndexList
operator|=
literal|null
expr_stmt|;
return|return
name|index
return|;
block|}
name|boolean
name|nodeExists
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|revision
operator|=
name|mk
operator|.
name|getHeadRevision
argument_list|()
expr_stmt|;
return|return
name|mk
operator|.
name|nodeExists
argument_list|(
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRootNode
argument_list|,
name|name
argument_list|)
argument_list|,
name|revision
argument_list|)
return|;
block|}
specifier|public
name|void
name|createNodes
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|String
name|rev
init|=
name|mk
operator|.
name|getHeadRevision
argument_list|()
decl_stmt|;
name|JsopBuilder
name|jsop
init|=
operator|new
name|JsopBuilder
argument_list|()
decl_stmt|;
name|String
name|p
init|=
literal|"/"
decl_stmt|;
name|path
operator|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRootNode
argument_list|,
name|path
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|e
range|:
name|PathUtils
operator|.
name|elements
argument_list|(
name|path
argument_list|)
control|)
block|{
name|p
operator|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|p
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mk
operator|.
name|nodeExists
argument_list|(
name|p
argument_list|,
name|rev
argument_list|)
condition|)
block|{
name|jsop
operator|.
name|tag
argument_list|(
literal|'+'
argument_list|)
operator|.
name|key
argument_list|(
name|PathUtils
operator|.
name|relativize
argument_list|(
literal|"/"
argument_list|,
name|p
argument_list|)
argument_list|)
operator|.
name|object
argument_list|()
operator|.
name|endObject
argument_list|()
operator|.
name|newline
argument_list|()
expr_stmt|;
block|}
block|}
name|revision
operator|=
name|mk
operator|.
name|commit
argument_list|(
literal|"/"
argument_list|,
name|jsop
operator|.
name|toString
argument_list|()
argument_list|,
name|rev
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|void
name|commit
parameter_list|(
name|String
name|jsop
parameter_list|)
block|{
name|revision
operator|=
name|mk
operator|.
name|commit
argument_list|(
name|indexRootNode
argument_list|,
name|jsop
argument_list|,
name|revision
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BTreePage
name|getPageIfCached
parameter_list|(
name|BTree
name|tree
parameter_list|,
name|BTreeNode
name|parent
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|String
name|p
init|=
name|getPath
argument_list|(
name|tree
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
return|return
name|modified
operator|.
name|get
argument_list|(
name|p
argument_list|)
return|;
block|}
specifier|private
name|String
name|getPath
parameter_list|(
name|BTree
name|tree
parameter_list|,
name|BTreeNode
name|parent
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|String
name|p
init|=
name|parent
operator|==
literal|null
condition|?
name|name
else|:
name|PathUtils
operator|.
name|concat
argument_list|(
name|parent
operator|.
name|getPath
argument_list|()
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|String
name|indexRoot
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRootNode
argument_list|,
name|tree
operator|.
name|getName
argument_list|()
argument_list|,
name|INDEX_CONTENT
argument_list|)
decl_stmt|;
return|return
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRoot
argument_list|,
name|p
argument_list|)
return|;
block|}
specifier|public
name|BTreePage
name|getPage
parameter_list|(
name|BTree
name|tree
parameter_list|,
name|BTreeNode
name|parent
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|String
name|p
init|=
name|getPath
argument_list|(
name|tree
argument_list|,
name|parent
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|BTreePage
name|page
decl_stmt|;
name|page
operator|=
name|modified
operator|.
name|get
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
return|return
name|page
return|;
block|}
name|String
name|cacheId
init|=
name|p
operator|+
literal|"@"
operator|+
name|revision
decl_stmt|;
name|page
operator|=
name|cache
operator|.
name|get
argument_list|(
name|cacheId
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
return|return
name|page
return|;
block|}
name|String
name|json
init|=
name|mk
operator|.
name|getNodes
argument_list|(
name|p
argument_list|,
name|revision
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|json
operator|==
literal|null
condition|)
block|{
name|page
operator|=
operator|new
name|BTreeLeaf
argument_list|(
name|tree
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
operator|new
name|String
index|[
literal|0
index|]
argument_list|,
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NodeImpl
name|n
init|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|json
argument_list|)
decl_stmt|;
name|String
name|keys
init|=
name|n
operator|.
name|getProperty
argument_list|(
literal|"keys"
argument_list|)
decl_stmt|;
name|String
name|values
init|=
name|n
operator|.
name|getProperty
argument_list|(
literal|"values"
argument_list|)
decl_stmt|;
name|String
name|children
init|=
name|n
operator|.
name|getProperty
argument_list|(
literal|"children"
argument_list|)
decl_stmt|;
if|if
condition|(
name|children
operator|!=
literal|null
condition|)
block|{
name|BTreeNode
name|node
init|=
operator|new
name|BTreeNode
argument_list|(
name|tree
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|readArray
argument_list|(
name|keys
argument_list|)
argument_list|,
name|readArray
argument_list|(
name|values
argument_list|)
argument_list|,
name|readArray
argument_list|(
name|children
argument_list|)
argument_list|)
decl_stmt|;
name|page
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|BTreeLeaf
name|leaf
init|=
operator|new
name|BTreeLeaf
argument_list|(
name|tree
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|readArray
argument_list|(
name|keys
argument_list|)
argument_list|,
name|readArray
argument_list|(
name|values
argument_list|)
argument_list|)
decl_stmt|;
name|page
operator|=
name|leaf
expr_stmt|;
block|}
block|}
name|cache
operator|.
name|put
argument_list|(
name|cacheId
argument_list|,
name|page
argument_list|)
expr_stmt|;
return|return
name|page
return|;
block|}
specifier|private
specifier|static
name|String
index|[]
name|readArray
parameter_list|(
name|String
name|json
parameter_list|)
block|{
if|if
condition|(
name|json
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|dataList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|json
argument_list|)
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|matches
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
do|do
block|{
name|dataList
operator|.
name|add
argument_list|(
name|t
operator|.
name|readString
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|','
argument_list|)
condition|)
do|;
name|t
operator|.
name|read
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|data
init|=
operator|new
name|String
index|[
name|dataList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|dataList
operator|.
name|toArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
specifier|public
name|void
name|buffer
parameter_list|(
name|String
name|diff
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|==
literal|null
condition|)
block|{
name|buffer
operator|=
operator|new
name|StringBuilder
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer
operator|.
name|append
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|modified
parameter_list|(
name|BTree
name|tree
parameter_list|,
name|BTreePage
name|page
parameter_list|,
name|boolean
name|deleted
parameter_list|)
block|{
name|String
name|indexRoot
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRootNode
argument_list|,
name|tree
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|p
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRoot
argument_list|,
name|INDEX_CONTENT
argument_list|,
name|page
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|deleted
condition|)
block|{
name|modified
operator|.
name|remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|modified
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|moveCache
parameter_list|(
name|BTree
name|tree
parameter_list|,
name|String
name|oldPath
parameter_list|)
block|{
name|String
name|indexRoot
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRootNode
argument_list|,
name|tree
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|o
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRoot
argument_list|,
name|INDEX_CONTENT
argument_list|,
name|oldPath
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|BTreePage
argument_list|>
name|moved
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BTreePage
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|BTreePage
argument_list|>
name|e
range|:
name|modified
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|startsWith
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|moved
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|s
range|:
name|moved
operator|.
name|keySet
argument_list|()
control|)
block|{
name|modified
operator|.
name|remove
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BTreePage
name|p
range|:
name|moved
operator|.
name|values
argument_list|()
control|)
block|{
name|String
name|n
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|indexRoot
argument_list|,
name|INDEX_CONTENT
argument_list|,
name|p
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|modified
operator|.
name|put
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|commitChanges
parameter_list|()
block|{
if|if
condition|(
name|buffer
operator|!=
literal|null
condition|)
block|{
name|String
name|jsop
init|=
name|buffer
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// System.out.println(jsop);
name|revision
operator|=
name|mk
operator|.
name|commit
argument_list|(
name|indexRootNode
argument_list|,
name|jsop
argument_list|,
name|revision
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|buffer
operator|=
literal|null
expr_stmt|;
name|modified
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|synchronized
specifier|public
name|void
name|updateUntil
parameter_list|(
name|String
name|toRevision
parameter_list|)
block|{
if|if
condition|(
name|DISABLED
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|toRevision
operator|.
name|equals
argument_list|(
name|readRevision
argument_list|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|toRevision
operator|=
name|mk
operator|.
name|getHeadRevision
argument_list|()
expr_stmt|;
block|}
name|String
name|journal
init|=
name|mk
operator|.
name|getJournal
argument_list|(
name|readRevision
argument_list|,
name|toRevision
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|journal
argument_list|)
decl_stmt|;
name|String
name|lastRevision
init|=
name|readRevision
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
name|readRevision
operator|=
name|toRevision
expr_stmt|;
comment|// nothing to update
return|return;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
do|do
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
do|do
block|{
name|String
name|key
init|=
name|t
operator|.
name|readString
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|t
operator|.
name|read
argument_list|()
expr_stmt|;
name|String
name|value
init|=
name|t
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|','
argument_list|)
condition|)
do|;
name|String
name|rev
init|=
name|map
operator|.
name|get
argument_list|(
literal|"id"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rev
operator|.
name|equals
argument_list|(
name|readRevision
argument_list|)
condition|)
block|{
name|String
name|jsop
init|=
name|map
operator|.
name|get
argument_list|(
literal|"changes"
argument_list|)
decl_stmt|;
name|JsopTokenizer
name|tokenizer
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|jsop
argument_list|)
decl_stmt|;
name|updateIndex
argument_list|(
literal|""
argument_list|,
name|tokenizer
argument_list|,
name|lastRevision
argument_list|)
expr_stmt|;
block|}
name|lastRevision
operator|=
name|rev
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
literal|null
operator|&&
name|buffer
operator|.
name|length
argument_list|()
operator|>
name|MAX_BUFFER_LENGTH
condition|)
block|{
name|updateEnd
argument_list|(
name|rev
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|','
argument_list|)
condition|)
do|;
name|updateEnd
argument_list|(
name|toRevision
argument_list|)
expr_stmt|;
block|}
comment|/**      * Finish updating the index.      *      * @param toRevision the new index revision      * @return the new head revision      */
specifier|public
name|String
name|updateEnd
parameter_list|(
name|String
name|toRevision
parameter_list|)
block|{
name|readRevision
operator|=
name|toRevision
expr_stmt|;
name|JsopBuilder
name|jsop
init|=
operator|new
name|JsopBuilder
argument_list|()
decl_stmt|;
name|jsop
operator|.
name|tag
argument_list|(
literal|'^'
argument_list|)
operator|.
name|key
argument_list|(
name|PathUtils
operator|.
name|concat
argument_list|(
name|INDEX_CONTENT
argument_list|,
literal|"rev"
argument_list|)
argument_list|)
operator|.
name|value
argument_list|(
name|readRevision
argument_list|)
expr_stmt|;
name|buffer
argument_list|(
name|jsop
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|flushBuffer
argument_list|()
expr_stmt|;
return|return
name|revision
return|;
block|}
specifier|private
name|void
name|flushBuffer
parameter_list|()
block|{
try|try
block|{
name|commitChanges
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MicroKernelException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mk
operator|.
name|nodeExists
argument_list|(
name|indexRootNode
argument_list|,
name|revision
argument_list|)
condition|)
block|{
comment|// the index node itself was removed, which is
comment|// unexpected but possible
comment|// this will cause all indexes to be removed, so
comment|// it can be ignored here
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**      * Update the index with the given changes.      *      * @param rootPath the root path      * @param t the changes      * @param lastRevision      */
specifier|public
name|void
name|updateIndex
parameter_list|(
name|String
name|rootPath
parameter_list|,
name|JsopReader
name|t
parameter_list|,
name|String
name|lastRevision
parameter_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|r
init|=
name|t
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|JsopReader
operator|.
name|END
condition|)
block|{
break|break;
block|}
name|String
name|path
init|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|rootPath
argument_list|,
name|t
operator|.
name|readString
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|target
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|'+'
case|:
block|{
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|NodeMap
name|map
init|=
operator|new
name|NodeMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
name|NodeImpl
name|n
init|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|map
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|addOrRemoveRecursive
argument_list|(
name|n
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|value
init|=
name|t
operator|.
name|readRawValue
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|nodePath
init|=
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|NodeImpl
name|node
init|=
operator|new
name|NodeImpl
argument_list|(
name|map
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|node
operator|.
name|setPath
argument_list|(
name|nodePath
argument_list|)
expr_stmt|;
name|String
name|propertyName
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|node
operator|.
name|cloneAndSetProperty
argument_list|(
name|propertyName
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addOrRemoveRecursive
argument_list|(
name|node
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'*'
case|:
comment|// TODO support and test copy operation ("*"),
comment|// specially in combination with other operations
comment|// possibly split up the commit in this case
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|target
operator|=
name|t
operator|.
name|readString
argument_list|()
expr_stmt|;
name|moveOrCopyNode
argument_list|(
name|path
argument_list|,
literal|false
argument_list|,
name|target
argument_list|,
name|lastRevision
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|moveOrCopyNode
argument_list|(
name|path
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|lastRevision
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
block|{
name|removeProperty
argument_list|(
name|path
argument_list|,
name|lastRevision
argument_list|)
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|matches
argument_list|(
name|JsopReader
operator|.
name|NULL
argument_list|)
condition|)
block|{
comment|// ignore
block|}
else|else
block|{
name|String
name|value
init|=
name|t
operator|.
name|readRawValue
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|addProperty
argument_list|(
name|path
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'>'
case|:
comment|// TODO does move work correctly
comment|// in combination with other operations?
comment|// possibly split up the commit in this case
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|String
name|position
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|matches
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
name|position
operator|=
name|t
operator|.
name|readString
argument_list|()
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|target
operator|=
name|t
operator|.
name|readString
argument_list|()
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|position
operator|=
literal|null
expr_stmt|;
name|target
operator|=
name|t
operator|.
name|readString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
literal|"last"
operator|.
name|equals
argument_list|(
name|position
argument_list|)
operator|||
literal|"first"
operator|.
name|equals
argument_list|(
name|position
argument_list|)
condition|)
block|{
name|target
operator|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|target
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"before"
operator|.
name|equals
argument_list|(
name|position
argument_list|)
operator|||
literal|"after"
operator|.
name|equals
argument_list|(
name|position
argument_list|)
condition|)
block|{
name|target
operator|=
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|target
operator|=
name|PathUtils
operator|.
name|concat
argument_list|(
name|target
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|position
operator|==
literal|null
condition|)
block|{
comment|// move
block|}
else|else
block|{
throw|throw
name|ExceptionFactory
operator|.
name|get
argument_list|(
literal|"position: "
operator|+
name|position
argument_list|)
throw|;
block|}
name|moveOrCopyNode
argument_list|(
name|path
argument_list|,
literal|true
argument_list|,
name|target
argument_list|,
name|lastRevision
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"token: "
operator|+
operator|(
name|char
operator|)
name|t
operator|.
name|getTokenType
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|addOrRemoveRecursive
parameter_list|(
name|NodeImpl
name|n
parameter_list|,
name|boolean
name|remove
parameter_list|,
name|boolean
name|add
parameter_list|)
block|{
name|String
name|path
init|=
name|n
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|isInIndex
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|addOrRemoveIndex
argument_list|(
name|path
argument_list|,
name|remove
argument_list|,
name|add
argument_list|)
expr_stmt|;
comment|// don't index the index data itself
return|return;
block|}
for|for
control|(
name|PIndex
name|index
range|:
name|indexes
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|remove
condition|)
block|{
name|index
operator|.
name|addOrRemoveNode
argument_list|(
name|n
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|add
condition|)
block|{
name|index
operator|.
name|addOrRemoveNode
argument_list|(
name|n
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|n
operator|.
name|getChildNodeNames
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|addOrRemoveRecursive
argument_list|(
name|n
operator|.
name|getNode
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
argument_list|,
name|remove
argument_list|,
name|add
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addOrRemoveIndex
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|remove
parameter_list|,
name|boolean
name|add
parameter_list|)
block|{
comment|// check the depth first for speed
comment|// TODO allow creating multiple indexes in one step
comment|// (buffer indexes to be created; traverse the repository only once)
comment|// TODO allow filters (only index a certain path; exclude a list of paths)
if|if
condition|(
name|PathUtils
operator|.
name|getDepth
argument_list|(
name|path
argument_list|)
operator|==
name|indexRootNodeDepth
operator|+
literal|1
condition|)
block|{
comment|// actually not required, just to make sure
if|if
condition|(
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|path
argument_list|)
operator|.
name|equals
argument_list|(
name|indexRootNode
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|Indexer
operator|.
name|TYPE_PREFIX
argument_list|)
condition|)
block|{
name|String
name|prefix
init|=
name|name
operator|.
name|substring
argument_list|(
name|Indexer
operator|.
name|TYPE_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|remove
condition|)
block|{
name|removePrefixIndex
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|add
condition|)
block|{
name|createPrefixIndex
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|Indexer
operator|.
name|TYPE_PROPERTY
argument_list|)
condition|)
block|{
name|String
name|property
init|=
name|name
operator|.
name|substring
argument_list|(
name|Indexer
operator|.
name|TYPE_PROPERTY
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|unique
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|property
operator|.
name|endsWith
argument_list|(
literal|","
operator|+
name|Indexer
operator|.
name|UNIQUE
argument_list|)
condition|)
block|{
name|unique
operator|=
literal|true
expr_stmt|;
name|property
operator|=
name|property
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|property
operator|.
name|length
argument_list|()
operator|-
name|Indexer
operator|.
name|UNIQUE
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remove
condition|)
block|{
name|removePropertyIndex
argument_list|(
name|property
argument_list|,
name|unique
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|add
condition|)
block|{
name|createPropertyIndex
argument_list|(
name|property
argument_list|,
name|unique
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|private
name|boolean
name|isInIndex
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|PathUtils
operator|.
name|isAncestor
argument_list|(
name|indexRootNode
argument_list|,
name|path
argument_list|)
operator|||
name|indexRootNode
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|removeProperty
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|lastRevision
parameter_list|)
block|{
if|if
condition|(
name|isInIndex
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|// don't index the index data itself
return|return;
block|}
name|String
name|nodePath
init|=
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|String
name|property
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mk
operator|.
name|nodeExists
argument_list|(
name|nodePath
argument_list|,
name|lastRevision
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// TODO remove: support large trees
name|String
name|node
init|=
name|mk
operator|.
name|getNodes
argument_list|(
name|nodePath
argument_list|,
name|lastRevision
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeMap
name|map
init|=
operator|new
name|NodeMap
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|NodeImpl
name|n
init|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|map
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|.
name|hasProperty
argument_list|(
name|property
argument_list|)
condition|)
block|{
name|n
operator|.
name|setPath
argument_list|(
name|nodePath
argument_list|)
expr_stmt|;
for|for
control|(
name|PIndex
name|index
range|:
name|indexes
operator|.
name|values
argument_list|()
control|)
block|{
name|index
operator|.
name|addOrRemoveProperty
argument_list|(
name|nodePath
argument_list|,
name|property
argument_list|,
name|n
operator|.
name|getProperty
argument_list|(
name|property
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|addProperty
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|isInIndex
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|// don't index the index data itself
return|return;
block|}
name|String
name|nodePath
init|=
name|PathUtils
operator|.
name|getParentPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|String
name|property
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|path
argument_list|)
decl_stmt|;
for|for
control|(
name|PIndex
name|index
range|:
name|indexes
operator|.
name|values
argument_list|()
control|)
block|{
name|index
operator|.
name|addOrRemoveProperty
argument_list|(
name|nodePath
argument_list|,
name|property
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|moveOrCopyNode
parameter_list|(
name|String
name|sourcePath
parameter_list|,
name|boolean
name|remove
parameter_list|,
name|String
name|targetPath
parameter_list|,
name|String
name|lastRevision
parameter_list|)
block|{
if|if
condition|(
name|isInIndex
argument_list|(
name|sourcePath
argument_list|)
condition|)
block|{
if|if
condition|(
name|remove
condition|)
block|{
name|addOrRemoveIndex
argument_list|(
name|sourcePath
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetPath
operator|!=
literal|null
condition|)
block|{
name|addOrRemoveIndex
argument_list|(
name|targetPath
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// don't index the index data itself
return|return;
block|}
if|if
condition|(
operator|!
name|mk
operator|.
name|nodeExists
argument_list|(
name|sourcePath
argument_list|,
name|lastRevision
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// TODO move: support large trees
name|String
name|node
init|=
name|mk
operator|.
name|getNodes
argument_list|(
name|sourcePath
argument_list|,
name|lastRevision
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeMap
name|map
init|=
operator|new
name|NodeMap
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|NodeImpl
name|n
init|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|map
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|sourcePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|remove
condition|)
block|{
name|addOrRemoveRecursive
argument_list|(
name|n
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetPath
operator|!=
literal|null
condition|)
block|{
name|t
operator|=
operator|new
name|JsopTokenizer
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|map
operator|=
operator|new
name|NodeMap
argument_list|()
expr_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|n
operator|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|map
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|targetPath
argument_list|)
expr_stmt|;
name|addOrRemoveRecursive
argument_list|(
name|n
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|buildIndex
parameter_list|(
name|PIndex
name|index
parameter_list|)
block|{
comment|// TODO index: add ability to start / stop / restart indexing; log the progress
name|addRecursive
argument_list|(
name|index
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addRecursive
parameter_list|(
name|PIndex
name|index
parameter_list|,
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|isInIndex
argument_list|(
name|path
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// TODO add: support large child node lists
name|String
name|node
init|=
name|mk
operator|.
name|getNodes
argument_list|(
name|path
argument_list|,
name|readRevision
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|JsopTokenizer
name|t
init|=
operator|new
name|JsopTokenizer
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NodeMap
name|map
init|=
operator|new
name|NodeMap
argument_list|()
decl_stmt|;
name|t
operator|.
name|read
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|NodeImpl
name|n
init|=
name|NodeImpl
operator|.
name|parse
argument_list|(
name|map
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|index
operator|.
name|addOrRemoveNode
argument_list|(
name|n
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|n
operator|.
name|getChildNodeNames
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|addRecursive
argument_list|(
name|index
argument_list|,
name|PathUtils
operator|.
name|concat
argument_list|(
name|path
argument_list|,
name|it
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needFlush
argument_list|()
condition|)
block|{
name|flushBuffer
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|needFlush
parameter_list|()
block|{
return|return
name|buffer
operator|!=
literal|null
operator|&&
name|buffer
operator|.
name|length
argument_list|()
operator|>
name|MAX_BUFFER_LENGTH
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|QueryIndex
argument_list|>
name|getQueryIndexes
parameter_list|(
name|MicroKernel
name|mk
parameter_list|)
block|{
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryIndexList
operator|==
literal|null
condition|)
block|{
name|queryIndexList
operator|=
operator|new
name|ArrayList
argument_list|<
name|QueryIndex
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Index
name|index
range|:
name|indexes
operator|.
name|values
argument_list|()
control|)
block|{
name|QueryIndex
name|qi
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|index
operator|instanceof
name|PropertyIndex
condition|)
block|{
name|qi
operator|=
operator|new
name|PropertyContentIndex
argument_list|(
operator|(
name|PropertyIndex
operator|)
name|index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|index
operator|instanceof
name|PrefixIndex
condition|)
block|{
name|qi
operator|=
operator|new
name|PrefixContentIndex
argument_list|(
operator|(
name|PrefixIndex
operator|)
name|index
argument_list|)
expr_stmt|;
block|}
name|queryIndexList
operator|.
name|add
argument_list|(
name|qi
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|queryIndexList
return|;
block|}
specifier|public
name|PrefixIndex
name|getPrefixIndex
parameter_list|(
name|String
name|prefix
parameter_list|)
block|{
return|return
name|prefixIndexes
operator|.
name|get
argument_list|(
name|prefix
argument_list|)
return|;
block|}
specifier|public
name|PropertyIndex
name|getPropertyIndex
parameter_list|(
name|String
name|property
parameter_list|)
block|{
return|return
name|propertyIndexes
operator|.
name|get
argument_list|(
name|property
argument_list|)
return|;
block|}
block|}
end_class

end_unit

