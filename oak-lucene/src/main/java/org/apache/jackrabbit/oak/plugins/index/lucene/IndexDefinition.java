begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|CheckForNull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|PropertyType
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|RepositoryException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|nodetype
operator|.
name|NodeTypeIterator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|JcrConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|PropertyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|namepath
operator|.
name|NamePathMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|util
operator|.
name|TokenizerChain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|PropertyStates
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|nodetype
operator|.
name|ReadOnlyNodeTypeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|tree
operator|.
name|TreeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|query
operator|.
name|QueryIndex
operator|.
name|OrderEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|ChildNodeEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|util
operator|.
name|TreeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
operator|.
name|PerFieldAnalyzerWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|path
operator|.
name|PathHierarchyTokenizerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|Codec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
operator|.
name|newArrayList
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
operator|.
name|newArrayListWithCapacity
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|newHashMap
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
operator|.
name|newHashSet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|JcrConstants
operator|.
name|JCR_SCORE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|JcrConstants
operator|.
name|NT_BASE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Type
operator|.
name|NAMES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
operator|.
name|getParentPath
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
operator|.
name|isAbsolute
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|IndexConstants
operator|.
name|DECLARING_NODE_TYPES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|IndexConstants
operator|.
name|ENTRY_COUNT_PROPERTY_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|IndexConstants
operator|.
name|REINDEX_COUNT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|BLOB_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|COMPAT_MODE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|EVALUATE_PATH_RESTRICTION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|EXCLUDE_PROPERTY_NAMES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|EXPERIMENTAL_STORAGE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|FIELD_BOOST
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|FULL_TEXT_ENABLED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|INCLUDE_PROPERTY_NAMES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|INCLUDE_PROPERTY_TYPES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|INDEX_DATA_CHILD_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|ORDERED_PROP_NAMES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|PROP_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|LuceneIndexConstants
operator|.
name|PROP_NODE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|PropertyDefinition
operator|.
name|DEFAULT_BOOST
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|lucene
operator|.
name|util
operator|.
name|ConfigUtil
operator|.
name|getOptionalValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|EmptyNodeState
operator|.
name|EMPTY_NODE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|nodetype
operator|.
name|NodeTypeConstants
operator|.
name|NODE_TYPES_PATH
import|;
end_import

begin_class
class|class
name|IndexDefinition
implements|implements
name|Aggregate
operator|.
name|AggregateMapper
block|{
comment|/**      * Name of the internal property that contains the child order defined in      * org.apache.jackrabbit.oak.plugins.tree.impl.TreeConstants      */
specifier|private
specifier|static
specifier|final
name|String
name|OAK_CHILD_ORDER
init|=
literal|":childOrder"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|IndexDefinition
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Blob size to use by default. To avoid issues in OAK-2105 the size should not      * be power of 2.      */
specifier|static
specifier|final
name|int
name|DEFAULT_BLOB_SIZE
init|=
literal|1024
operator|*
literal|1024
operator|-
literal|1024
decl_stmt|;
comment|/**      * Default entry count to keep estimated entry count low.      */
specifier|static
specifier|final
name|long
name|DEFAULT_ENTRY_COUNT
init|=
literal|1000
decl_stmt|;
comment|/**      * System managed hidden property to record the current index version      */
specifier|static
specifier|final
name|String
name|INDEX_VERSION
init|=
literal|":version"
decl_stmt|;
specifier|private
specifier|static
name|String
name|TYPES_ALLOW_ALL_NAME
init|=
literal|"all"
decl_stmt|;
specifier|static
specifier|final
name|int
name|TYPES_ALLOW_NONE
init|=
name|PropertyType
operator|.
name|UNDEFINED
decl_stmt|;
specifier|static
specifier|final
name|int
name|TYPES_ALLOW_ALL
init|=
operator|-
literal|1
decl_stmt|;
comment|/**      * native sort order      */
specifier|static
specifier|final
name|OrderEntry
name|NATIVE_SORT_ORDER
init|=
operator|new
name|OrderEntry
argument_list|(
name|JCR_SCORE
argument_list|,
name|Type
operator|.
name|UNDEFINED
argument_list|,
name|OrderEntry
operator|.
name|Order
operator|.
name|DESCENDING
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|fullTextEnabled
decl_stmt|;
specifier|private
specifier|final
name|NodeState
name|definition
decl_stmt|;
specifier|private
specifier|final
name|NodeState
name|root
decl_stmt|;
specifier|private
specifier|final
name|String
name|funcName
decl_stmt|;
specifier|private
specifier|final
name|int
name|blobSize
decl_stmt|;
specifier|private
specifier|final
name|Codec
name|codec
decl_stmt|;
comment|/**      * Defines the maximum estimated entry count configured.      * Defaults to {#DEFAULT_ENTRY_COUNT}      */
specifier|private
specifier|final
name|long
name|entryCount
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|entryCountDefined
decl_stmt|;
specifier|private
specifier|final
name|double
name|costPerEntry
decl_stmt|;
specifier|private
specifier|final
name|double
name|costPerExecution
decl_stmt|;
comment|/**      * The {@link IndexingRule}s inside this configuration. Keys being the NodeType names      */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|IndexingRule
argument_list|>
argument_list|>
name|indexRules
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|IndexingRule
argument_list|>
name|definedRules
decl_stmt|;
specifier|private
specifier|final
name|String
name|indexName
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|testMode
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|evaluatePathRestrictions
decl_stmt|;
specifier|private
specifier|final
name|IndexFormatVersion
name|version
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Aggregate
argument_list|>
name|aggregates
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|indexesAllTypes
decl_stmt|;
specifier|private
specifier|final
name|Analyzer
name|analyzer
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzers
decl_stmt|;
specifier|public
name|IndexDefinition
parameter_list|(
name|NodeState
name|root
parameter_list|,
name|NodeState
name|defn
parameter_list|)
block|{
name|this
argument_list|(
name|root
argument_list|,
name|defn
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IndexDefinition
parameter_list|(
name|NodeState
name|root
parameter_list|,
name|NodeBuilder
name|defn
parameter_list|)
block|{
name|this
argument_list|(
name|root
argument_list|,
name|defn
operator|.
name|getBaseState
argument_list|()
argument_list|,
name|defn
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IndexDefinition
parameter_list|(
name|NodeState
name|root
parameter_list|,
name|NodeState
name|defn
parameter_list|,
annotation|@
name|Nullable
name|String
name|indexPath
parameter_list|)
block|{
name|this
argument_list|(
name|root
argument_list|,
name|defn
argument_list|,
literal|null
argument_list|,
name|indexPath
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IndexDefinition
parameter_list|(
name|NodeState
name|root
parameter_list|,
name|NodeState
name|defn
parameter_list|,
annotation|@
name|Nullable
name|NodeBuilder
name|defnb
parameter_list|,
annotation|@
name|Nullable
name|String
name|indexPath
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|determineIndexFormatVersion
argument_list|(
name|defn
argument_list|,
name|defnb
argument_list|)
expr_stmt|;
name|this
operator|.
name|definition
operator|=
name|defn
expr_stmt|;
name|this
operator|.
name|indexName
operator|=
name|determineIndexName
argument_list|(
name|defn
argument_list|,
name|indexPath
argument_list|)
expr_stmt|;
name|this
operator|.
name|blobSize
operator|=
name|getOptionalValue
argument_list|(
name|defn
argument_list|,
name|BLOB_SIZE
argument_list|,
name|DEFAULT_BLOB_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|testMode
operator|=
name|getOptionalValue
argument_list|(
name|defn
argument_list|,
name|LuceneIndexConstants
operator|.
name|TEST_MODE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|aggregates
operator|=
name|collectAggregates
argument_list|(
name|defn
argument_list|)
expr_stmt|;
name|NodeState
name|rulesState
init|=
name|defn
operator|.
name|getChildNode
argument_list|(
name|LuceneIndexConstants
operator|.
name|INDEX_RULES
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rulesState
operator|.
name|exists
argument_list|()
condition|)
block|{
name|rulesState
operator|=
name|createIndexRules
argument_list|(
name|defn
argument_list|)
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|IndexingRule
argument_list|>
name|definedIndexRules
init|=
name|newArrayList
argument_list|()
decl_stmt|;
name|this
operator|.
name|indexRules
operator|=
name|collectIndexRules
argument_list|(
name|rulesState
argument_list|,
name|definedIndexRules
argument_list|)
expr_stmt|;
name|this
operator|.
name|definedRules
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|definedIndexRules
argument_list|)
expr_stmt|;
name|this
operator|.
name|fullTextEnabled
operator|=
name|hasFulltextEnabledIndexRule
argument_list|(
name|definedIndexRules
argument_list|)
expr_stmt|;
name|this
operator|.
name|evaluatePathRestrictions
operator|=
name|getOptionalValue
argument_list|(
name|defn
argument_list|,
name|EVALUATE_PATH_RESTRICTION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|String
name|functionName
init|=
name|getOptionalValue
argument_list|(
name|defn
argument_list|,
name|LuceneIndexConstants
operator|.
name|FUNC_NAME
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|fullTextEnabled
operator|&&
name|functionName
operator|==
literal|null
condition|)
block|{
name|functionName
operator|=
literal|"lucene"
expr_stmt|;
block|}
name|this
operator|.
name|funcName
operator|=
name|functionName
operator|!=
literal|null
condition|?
literal|"native*"
operator|+
name|functionName
else|:
literal|null
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|createCodec
argument_list|()
expr_stmt|;
if|if
condition|(
name|defn
operator|.
name|hasProperty
argument_list|(
name|ENTRY_COUNT_PROPERTY_NAME
argument_list|)
condition|)
block|{
name|this
operator|.
name|entryCountDefined
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|entryCount
operator|=
name|defn
operator|.
name|getProperty
argument_list|(
name|ENTRY_COUNT_PROPERTY_NAME
argument_list|)
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|LONG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|entryCountDefined
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|entryCount
operator|=
name|DEFAULT_ENTRY_COUNT
expr_stmt|;
block|}
name|this
operator|.
name|costPerEntry
operator|=
name|getOptionalValue
argument_list|(
name|defn
argument_list|,
name|LuceneIndexConstants
operator|.
name|COST_PER_ENTRY
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|this
operator|.
name|costPerExecution
operator|=
name|getOptionalValue
argument_list|(
name|defn
argument_list|,
name|LuceneIndexConstants
operator|.
name|COST_PER_EXECUTION
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexesAllTypes
operator|=
name|areAllTypesIndexed
argument_list|()
expr_stmt|;
name|this
operator|.
name|analyzers
operator|=
name|collectAnalyzers
argument_list|(
name|defn
argument_list|)
expr_stmt|;
name|this
operator|.
name|analyzer
operator|=
name|createAnalyzer
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|isFullTextEnabled
parameter_list|()
block|{
return|return
name|fullTextEnabled
return|;
block|}
specifier|public
name|String
name|getFunctionName
parameter_list|()
block|{
return|return
name|funcName
return|;
block|}
specifier|public
name|boolean
name|hasFunctionDefined
parameter_list|()
block|{
return|return
name|funcName
operator|!=
literal|null
return|;
block|}
comment|/**      * Size in bytes for the blobs created while storing the index content      * @return size in bytes      */
specifier|public
name|int
name|getBlobSize
parameter_list|()
block|{
return|return
name|blobSize
return|;
block|}
specifier|public
name|Codec
name|getCodec
parameter_list|()
block|{
return|return
name|codec
return|;
block|}
specifier|public
name|long
name|getReindexCount
parameter_list|()
block|{
if|if
condition|(
name|definition
operator|.
name|hasProperty
argument_list|(
name|REINDEX_COUNT
argument_list|)
condition|)
block|{
return|return
name|definition
operator|.
name|getProperty
argument_list|(
name|REINDEX_COUNT
argument_list|)
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|LONG
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
specifier|public
name|long
name|getEntryCount
parameter_list|()
block|{
return|return
name|entryCount
return|;
block|}
specifier|public
name|boolean
name|isEntryCountDefined
parameter_list|()
block|{
return|return
name|entryCountDefined
return|;
block|}
specifier|public
name|double
name|getCostPerEntry
parameter_list|()
block|{
return|return
name|costPerEntry
return|;
block|}
specifier|public
name|double
name|getCostPerExecution
parameter_list|()
block|{
return|return
name|costPerExecution
return|;
block|}
specifier|public
name|long
name|getFulltextEntryCount
parameter_list|(
name|long
name|numOfDocs
parameter_list|)
block|{
if|if
condition|(
name|isEntryCountDefined
argument_list|()
condition|)
block|{
return|return
name|Math
operator|.
name|min
argument_list|(
name|getEntryCount
argument_list|()
argument_list|,
name|numOfDocs
argument_list|)
return|;
block|}
return|return
name|numOfDocs
return|;
block|}
specifier|public
name|IndexFormatVersion
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
specifier|public
name|boolean
name|isOfOldFormat
parameter_list|()
block|{
return|return
operator|!
name|hasIndexingRules
argument_list|(
name|definition
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTestMode
parameter_list|()
block|{
return|return
name|testMode
return|;
block|}
specifier|public
name|boolean
name|evaluatePathRestrictions
parameter_list|()
block|{
return|return
name|evaluatePathRestrictions
return|;
block|}
specifier|public
name|boolean
name|indexesAllTypes
parameter_list|()
block|{
return|return
name|indexesAllTypes
return|;
block|}
specifier|public
name|Analyzer
name|getAnalyzer
parameter_list|()
block|{
return|return
name|analyzer
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"IndexDefinition : "
operator|+
name|indexName
return|;
block|}
comment|//~---------------------------------------------------< Analyzer>
specifier|private
name|Analyzer
name|createAnalyzer
parameter_list|()
block|{
name|Analyzer
name|defaultAnalyzer
init|=
name|LuceneIndexConstants
operator|.
name|ANALYZER
decl_stmt|;
if|if
condition|(
name|analyzers
operator|.
name|containsKey
argument_list|(
name|LuceneIndexConstants
operator|.
name|ANL_DEFAULT
argument_list|)
condition|)
block|{
name|defaultAnalyzer
operator|=
name|analyzers
operator|.
name|get
argument_list|(
name|LuceneIndexConstants
operator|.
name|ANL_DEFAULT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|evaluatePathRestrictions
argument_list|()
condition|)
block|{
return|return
name|defaultAnalyzer
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzerMap
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Analyzer
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
name|FieldNames
operator|.
name|ANCESTORS
argument_list|,
operator|new
name|TokenizerChain
argument_list|(
operator|new
name|PathHierarchyTokenizerFactory
argument_list|(
name|Collections
operator|.
expr|<
name|String
argument_list|,
name|String
operator|>
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
return|return
operator|new
name|PerFieldAnalyzerWrapper
argument_list|(
name|defaultAnalyzer
argument_list|,
name|analyzerMap
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|collectAnalyzers
parameter_list|(
name|NodeState
name|defn
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Analyzer
argument_list|>
name|analyzerMap
init|=
name|newHashMap
argument_list|()
decl_stmt|;
name|NodeStateAnalyzerFactory
name|factory
init|=
operator|new
name|NodeStateAnalyzerFactory
argument_list|(
name|LuceneIndexConstants
operator|.
name|VERSION
argument_list|)
decl_stmt|;
for|for
control|(
name|ChildNodeEntry
name|cne
range|:
name|defn
operator|.
name|getChildNode
argument_list|(
name|LuceneIndexConstants
operator|.
name|ANALYZERS
argument_list|)
operator|.
name|getChildNodeEntries
argument_list|()
control|)
block|{
name|Analyzer
name|a
init|=
name|factory
operator|.
name|createInstance
argument_list|(
name|cne
operator|.
name|getNodeState
argument_list|()
argument_list|)
decl_stmt|;
name|analyzerMap
operator|.
name|put
argument_list|(
name|cne
operator|.
name|getName
argument_list|()
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|analyzerMap
argument_list|)
return|;
block|}
comment|//~---------------------------------------------------< Aggregates>
annotation|@
name|CheckForNull
specifier|public
name|Aggregate
name|getAggregate
parameter_list|(
name|String
name|nodeType
parameter_list|)
block|{
name|Aggregate
name|agg
init|=
name|aggregates
operator|.
name|get
argument_list|(
name|nodeType
argument_list|)
decl_stmt|;
return|return
name|agg
operator|!=
literal|null
condition|?
name|agg
else|:
literal|null
return|;
block|}
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Aggregate
argument_list|>
name|collectAggregates
parameter_list|(
name|NodeState
name|defn
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Aggregate
argument_list|>
name|aggregateMap
init|=
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|ChildNodeEntry
name|cne
range|:
name|defn
operator|.
name|getChildNode
argument_list|(
name|LuceneIndexConstants
operator|.
name|AGGREGATES
argument_list|)
operator|.
name|getChildNodeEntries
argument_list|()
control|)
block|{
name|String
name|nodeType
init|=
name|cne
operator|.
name|getName
argument_list|()
decl_stmt|;
name|int
name|recursionLimit
init|=
name|getOptionalValue
argument_list|(
name|cne
operator|.
name|getNodeState
argument_list|()
argument_list|,
name|LuceneIndexConstants
operator|.
name|AGG_RECURSIVE_LIMIT
argument_list|,
name|Aggregate
operator|.
name|RECURSIVE_AGGREGATION_LIMIT_DEFAULT
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Aggregate
operator|.
name|Include
argument_list|>
name|includes
init|=
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|ChildNodeEntry
name|include
range|:
name|cne
operator|.
name|getNodeState
argument_list|()
operator|.
name|getChildNodeEntries
argument_list|()
control|)
block|{
name|NodeState
name|is
init|=
name|include
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|String
name|primaryType
init|=
name|is
operator|.
name|getString
argument_list|(
name|LuceneIndexConstants
operator|.
name|AGG_PRIMARY_TYPE
argument_list|)
decl_stmt|;
name|String
name|path
init|=
name|is
operator|.
name|getString
argument_list|(
name|LuceneIndexConstants
operator|.
name|AGG_PATH
argument_list|)
decl_stmt|;
name|boolean
name|relativeNode
init|=
name|getOptionalValue
argument_list|(
name|is
argument_list|,
name|LuceneIndexConstants
operator|.
name|AGG_RELATIVE_NODE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Aggregate pattern in {} does not have required property [{}]. {} aggregate rule would "
operator|+
literal|"be ignored"
argument_list|,
name|this
argument_list|,
name|LuceneIndexConstants
operator|.
name|AGG_PATH
argument_list|,
name|include
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|includes
operator|.
name|add
argument_list|(
operator|new
name|Aggregate
operator|.
name|NodeInclude
argument_list|(
name|this
argument_list|,
name|primaryType
argument_list|,
name|path
argument_list|,
name|relativeNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|aggregateMap
operator|.
name|put
argument_list|(
name|nodeType
argument_list|,
operator|new
name|Aggregate
argument_list|(
name|nodeType
argument_list|,
name|includes
argument_list|,
name|recursionLimit
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|aggregateMap
argument_list|)
return|;
block|}
comment|//~---------------------------------------------------< IndexRule>
specifier|public
name|List
argument_list|<
name|IndexingRule
argument_list|>
name|getDefinedRules
parameter_list|()
block|{
return|return
name|definedRules
return|;
block|}
annotation|@
name|CheckForNull
specifier|public
name|IndexingRule
name|getApplicableIndexingRule
parameter_list|(
name|String
name|primaryNodeType
parameter_list|)
block|{
comment|//This method would be invoked for every node. So be as
comment|//conservative as possible in object creation
name|List
argument_list|<
name|IndexingRule
argument_list|>
name|rules
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|IndexingRule
argument_list|>
name|r
init|=
name|indexRules
operator|.
name|get
argument_list|(
name|primaryNodeType
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|rules
operator|=
operator|new
name|ArrayList
argument_list|<
name|IndexingRule
argument_list|>
argument_list|()
expr_stmt|;
name|rules
operator|.
name|addAll
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rules
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|IndexingRule
name|rule
range|:
name|rules
control|)
block|{
if|if
condition|(
name|rule
operator|.
name|appliesTo
argument_list|(
name|primaryNodeType
argument_list|)
condition|)
block|{
return|return
name|rule
return|;
block|}
block|}
block|}
comment|// no applicable rule
return|return
literal|null
return|;
block|}
comment|/**      * Returns the first indexing rule that applies to the given node      *<code>state</code>.      *      * @param state a node state.      * @return the indexing rule or<code>null</code> if none applies.      */
annotation|@
name|CheckForNull
specifier|public
name|IndexingRule
name|getApplicableIndexingRule
parameter_list|(
name|Tree
name|state
parameter_list|)
block|{
comment|//This method would be invoked for every node. So be as
comment|//conservative as possible in object creation
name|List
argument_list|<
name|IndexingRule
argument_list|>
name|rules
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|IndexingRule
argument_list|>
name|r
init|=
name|indexRules
operator|.
name|get
argument_list|(
name|getPrimaryTypeName
argument_list|(
name|state
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|rules
operator|=
operator|new
name|ArrayList
argument_list|<
name|IndexingRule
argument_list|>
argument_list|()
expr_stmt|;
name|rules
operator|.
name|addAll
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|name
range|:
name|getMixinTypeNames
argument_list|(
name|state
argument_list|)
control|)
block|{
name|r
operator|=
name|indexRules
operator|.
name|get
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|rules
operator|==
literal|null
condition|)
block|{
name|rules
operator|=
operator|new
name|ArrayList
argument_list|<
name|IndexingRule
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|rules
operator|.
name|addAll
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rules
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|IndexingRule
name|rule
range|:
name|rules
control|)
block|{
if|if
condition|(
name|rule
operator|.
name|appliesTo
argument_list|(
name|state
argument_list|)
condition|)
block|{
return|return
name|rule
return|;
block|}
block|}
block|}
comment|// no applicable rule
return|return
literal|null
return|;
block|}
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|IndexingRule
argument_list|>
argument_list|>
name|collectIndexRules
parameter_list|(
name|NodeState
name|indexRules
parameter_list|,
name|List
argument_list|<
name|IndexingRule
argument_list|>
name|definedIndexRules
parameter_list|)
block|{
comment|//TODO if a rule is defined for nt:base then this map would have entry for each
comment|//registered nodeType in the system
if|if
condition|(
operator|!
name|indexRules
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|hasOrderableChildren
argument_list|(
name|indexRules
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"IndexRule node does not have orderable children in [{}]"
argument_list|,
name|IndexDefinition
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|IndexingRule
argument_list|>
argument_list|>
name|nt2rules
init|=
name|newHashMap
argument_list|()
decl_stmt|;
name|ReadOnlyNodeTypeManager
name|ntReg
init|=
name|createNodeTypeManager
argument_list|(
name|TreeFactory
operator|.
name|createReadOnlyTree
argument_list|(
name|root
argument_list|)
argument_list|)
decl_stmt|;
comment|//Use Tree API to read ordered child nodes
name|Tree
name|ruleTree
init|=
name|TreeFactory
operator|.
name|createReadOnlyTree
argument_list|(
name|indexRules
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|allNames
init|=
name|getAllNodeTypes
argument_list|(
name|ntReg
argument_list|)
decl_stmt|;
for|for
control|(
name|Tree
name|ruleEntry
range|:
name|ruleTree
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|IndexingRule
name|rule
init|=
operator|new
name|IndexingRule
argument_list|(
name|ruleEntry
operator|.
name|getName
argument_list|()
argument_list|,
name|indexRules
operator|.
name|getChildNode
argument_list|(
name|ruleEntry
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|definedIndexRules
operator|.
name|add
argument_list|(
name|rule
argument_list|)
expr_stmt|;
comment|// register under node type and all its sub types
name|log
operator|.
name|trace
argument_list|(
literal|"Found rule '{}' for NodeType '{}'"
argument_list|,
name|rule
argument_list|,
name|rule
operator|.
name|getNodeTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|ntNames
init|=
name|allNames
decl_stmt|;
if|if
condition|(
operator|!
name|rule
operator|.
name|inherited
condition|)
block|{
comment|//Trim the list to rule's nodeType so that inheritance check
comment|//is not performed for other nodeTypes
name|ntNames
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|rule
operator|.
name|getNodeTypeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|ntName
range|:
name|ntNames
control|)
block|{
if|if
condition|(
name|ntReg
operator|.
name|isNodeType
argument_list|(
name|ntName
argument_list|,
name|rule
operator|.
name|getNodeTypeName
argument_list|()
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|IndexingRule
argument_list|>
name|perNtConfig
init|=
name|nt2rules
operator|.
name|get
argument_list|(
name|ntName
argument_list|)
decl_stmt|;
if|if
condition|(
name|perNtConfig
operator|==
literal|null
condition|)
block|{
name|perNtConfig
operator|=
operator|new
name|ArrayList
argument_list|<
name|IndexingRule
argument_list|>
argument_list|()
expr_stmt|;
name|nt2rules
operator|.
name|put
argument_list|(
name|ntName
argument_list|,
name|perNtConfig
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|trace
argument_list|(
literal|"Registering rule '{}' for name '{}'"
argument_list|,
name|rule
argument_list|,
name|ntName
argument_list|)
expr_stmt|;
name|perNtConfig
operator|.
name|add
argument_list|(
operator|new
name|IndexingRule
argument_list|(
name|rule
argument_list|,
name|ntName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|IndexingRule
argument_list|>
argument_list|>
name|e
range|:
name|nt2rules
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|e
operator|.
name|setValue
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|nt2rules
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|areAllTypesIndexed
parameter_list|()
block|{
name|IndexingRule
name|ntBaseRule
init|=
name|getApplicableIndexingRule
argument_list|(
name|NT_BASE
argument_list|)
decl_stmt|;
return|return
name|ntBaseRule
operator|!=
literal|null
return|;
block|}
specifier|public
class|class
name|IndexingRule
block|{
specifier|private
specifier|final
name|String
name|baseNodeType
decl_stmt|;
specifier|private
specifier|final
name|String
name|nodeTypeName
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|PropertyDefinition
argument_list|>
name|propConfigs
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|NamePattern
argument_list|>
name|namePatterns
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|indexesAllNodesOfMatchingType
decl_stmt|;
specifier|final
name|float
name|boost
decl_stmt|;
specifier|final
name|boolean
name|inherited
decl_stmt|;
specifier|final
name|int
name|propertyTypes
decl_stmt|;
specifier|final
name|boolean
name|fulltextEnabled
decl_stmt|;
specifier|final
name|boolean
name|propertyIndexEnabled
decl_stmt|;
specifier|final
name|Aggregate
name|aggregate
decl_stmt|;
specifier|final
name|Aggregate
name|propAggregate
decl_stmt|;
name|IndexingRule
parameter_list|(
name|String
name|nodeTypeName
parameter_list|,
name|NodeState
name|config
parameter_list|)
block|{
name|this
operator|.
name|nodeTypeName
operator|=
name|nodeTypeName
expr_stmt|;
name|this
operator|.
name|baseNodeType
operator|=
name|nodeTypeName
expr_stmt|;
name|this
operator|.
name|boost
operator|=
name|getOptionalValue
argument_list|(
name|config
argument_list|,
name|FIELD_BOOST
argument_list|,
name|DEFAULT_BOOST
argument_list|)
expr_stmt|;
name|this
operator|.
name|inherited
operator|=
name|getOptionalValue
argument_list|(
name|config
argument_list|,
name|LuceneIndexConstants
operator|.
name|RULE_INHERITED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|propertyTypes
operator|=
name|getSupportedTypes
argument_list|(
name|config
argument_list|,
name|INCLUDE_PROPERTY_TYPES
argument_list|,
name|TYPES_ALLOW_ALL
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|NamePattern
argument_list|>
name|namePatterns
init|=
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Aggregate
operator|.
name|Include
argument_list|>
name|propIncludes
init|=
name|newArrayList
argument_list|()
decl_stmt|;
name|this
operator|.
name|propConfigs
operator|=
name|collectPropConfigs
argument_list|(
name|config
argument_list|,
name|namePatterns
argument_list|,
name|propIncludes
argument_list|)
expr_stmt|;
name|this
operator|.
name|propAggregate
operator|=
operator|new
name|Aggregate
argument_list|(
name|nodeTypeName
argument_list|,
name|propIncludes
argument_list|)
expr_stmt|;
name|this
operator|.
name|aggregate
operator|=
name|combine
argument_list|(
name|propAggregate
argument_list|,
name|nodeTypeName
argument_list|)
expr_stmt|;
name|this
operator|.
name|namePatterns
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|namePatterns
argument_list|)
expr_stmt|;
name|this
operator|.
name|fulltextEnabled
operator|=
name|aggregate
operator|.
name|hasNodeAggregates
argument_list|()
operator|||
name|hasAnyFullTextEnabledProperty
argument_list|()
expr_stmt|;
name|this
operator|.
name|propertyIndexEnabled
operator|=
name|hasAnyPropertyIndexConfigured
argument_list|()
expr_stmt|;
name|this
operator|.
name|indexesAllNodesOfMatchingType
operator|=
name|allMatchingNodeByTypeIndexed
argument_list|()
expr_stmt|;
block|}
comment|/**          * Creates a new indexing rule base on an existing one, but for a          * different node type name.          *          * @param original the existing rule.          * @param nodeTypeName the node type name for the rule.          */
name|IndexingRule
parameter_list|(
name|IndexingRule
name|original
parameter_list|,
name|String
name|nodeTypeName
parameter_list|)
block|{
name|this
operator|.
name|nodeTypeName
operator|=
name|nodeTypeName
expr_stmt|;
name|this
operator|.
name|baseNodeType
operator|=
name|original
operator|.
name|getNodeTypeName
argument_list|()
expr_stmt|;
name|this
operator|.
name|propConfigs
operator|=
name|original
operator|.
name|propConfigs
expr_stmt|;
name|this
operator|.
name|namePatterns
operator|=
name|original
operator|.
name|namePatterns
expr_stmt|;
name|this
operator|.
name|boost
operator|=
name|original
operator|.
name|boost
expr_stmt|;
name|this
operator|.
name|inherited
operator|=
name|original
operator|.
name|inherited
expr_stmt|;
name|this
operator|.
name|propertyTypes
operator|=
name|original
operator|.
name|propertyTypes
expr_stmt|;
name|this
operator|.
name|propertyIndexEnabled
operator|=
name|original
operator|.
name|propertyIndexEnabled
expr_stmt|;
name|this
operator|.
name|propAggregate
operator|=
name|original
operator|.
name|propAggregate
expr_stmt|;
name|this
operator|.
name|aggregate
operator|=
name|combine
argument_list|(
name|propAggregate
argument_list|,
name|nodeTypeName
argument_list|)
expr_stmt|;
name|this
operator|.
name|fulltextEnabled
operator|=
name|aggregate
operator|.
name|hasNodeAggregates
argument_list|()
operator|||
name|original
operator|.
name|fulltextEnabled
expr_stmt|;
name|this
operator|.
name|indexesAllNodesOfMatchingType
operator|=
name|allMatchingNodeByTypeIndexed
argument_list|()
expr_stmt|;
block|}
comment|/**          * Returns<code>true</code> if the property with the given name is          * indexed according to this rule.          *          * @param propertyName the name of a property.          * @return<code>true</code> if the property is indexed;          *<code>false</code> otherwise.          */
specifier|public
name|boolean
name|isIndexed
parameter_list|(
name|String
name|propertyName
parameter_list|)
block|{
return|return
name|getConfig
argument_list|(
name|propertyName
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**          * Returns the name of the node type where this rule applies to.          *          * @return name of the node type.          */
specifier|public
name|String
name|getNodeTypeName
parameter_list|()
block|{
return|return
name|nodeTypeName
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|str
init|=
literal|"IndexRule: "
operator|+
name|nodeTypeName
decl_stmt|;
if|if
condition|(
operator|!
name|baseNodeType
operator|.
name|equals
argument_list|(
name|nodeTypeName
argument_list|)
condition|)
block|{
name|str
operator|+=
literal|"("
operator|+
name|baseNodeType
operator|+
literal|")"
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
specifier|public
name|boolean
name|isAggregated
parameter_list|(
name|String
name|nodePath
parameter_list|)
block|{
return|return
name|aggregate
operator|.
name|hasRelativeNodeInclude
argument_list|(
name|nodePath
argument_list|)
return|;
block|}
comment|/**          * Returns<code>true</code> if this rule applies to the given node          *<code>state</code>.          *          * @param state the state to check.          * @return<code>true</code> the rule applies to the given node;          *<code>false</code> otherwise.          */
specifier|public
name|boolean
name|appliesTo
parameter_list|(
name|Tree
name|state
parameter_list|)
block|{
if|if
condition|(
operator|!
name|nodeTypeName
operator|.
name|equals
argument_list|(
name|getPrimaryTypeName
argument_list|(
name|state
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//TODO Add support for condition
comment|//return condition == null || condition.evaluate(state);
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|appliesTo
parameter_list|(
name|String
name|nodeTypeName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|nodeTypeName
operator|.
name|equals
argument_list|(
name|nodeTypeName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//TODO Once condition support is done return false
comment|//return condition == null || condition.evaluate(state);
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|isFulltextEnabled
parameter_list|()
block|{
return|return
name|fulltextEnabled
return|;
block|}
comment|/**          * @param propertyName name of a property.          * @return the property configuration or<code>null</code> if this          *         indexing rule does not contain a configuration for the given          *         property.          */
annotation|@
name|CheckForNull
specifier|public
name|PropertyDefinition
name|getConfig
parameter_list|(
name|String
name|propertyName
parameter_list|)
block|{
name|PropertyDefinition
name|config
init|=
name|propConfigs
operator|.
name|get
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
block|{
return|return
name|config
return|;
block|}
elseif|else
if|if
condition|(
name|namePatterns
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// check patterns
for|for
control|(
name|NamePattern
name|np
range|:
name|namePatterns
control|)
block|{
if|if
condition|(
name|np
operator|.
name|matches
argument_list|(
name|propertyName
argument_list|)
condition|)
block|{
return|return
name|np
operator|.
name|getConfig
argument_list|()
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|boolean
name|includePropertyType
parameter_list|(
name|int
name|type
parameter_list|)
block|{
return|return
name|IndexDefinition
operator|.
name|includePropertyType
argument_list|(
name|propertyTypes
argument_list|,
name|type
argument_list|)
return|;
block|}
specifier|public
name|Aggregate
name|getAggregate
parameter_list|()
block|{
return|return
name|aggregate
return|;
block|}
comment|/**          * Flag to determine weather current index rule definition allows indexing of all          * node of type as covered by the current rule. For example if the rule only indexes          * certain property 'foo' for node type 'app:Asset' then index would only have          * entries for those assets where foo is defined. Such an index cannot claim that          * it has entries for all assets.           * @return true in case all matching node types are covered by this rule          */
specifier|public
name|boolean
name|indexesAllNodesOfMatchingType
parameter_list|()
block|{
return|return
name|indexesAllNodesOfMatchingType
return|;
block|}
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|PropertyDefinition
argument_list|>
name|collectPropConfigs
parameter_list|(
name|NodeState
name|config
parameter_list|,
name|List
argument_list|<
name|NamePattern
argument_list|>
name|patterns
parameter_list|,
name|List
argument_list|<
name|Aggregate
operator|.
name|Include
argument_list|>
name|propAggregate
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|PropertyDefinition
argument_list|>
name|propDefns
init|=
name|newHashMap
argument_list|()
decl_stmt|;
name|NodeState
name|propNode
init|=
name|config
operator|.
name|getChildNode
argument_list|(
name|LuceneIndexConstants
operator|.
name|PROP_NODE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|propNode
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|hasOrderableChildren
argument_list|(
name|propNode
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Properties node for [{}] does not have orderable "
operator|+
literal|"children in [{}]"
argument_list|,
name|this
argument_list|,
name|IndexDefinition
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
comment|//Include all immediate child nodes to 'properties' node by default
name|Tree
name|propTree
init|=
name|TreeFactory
operator|.
name|createReadOnlyTree
argument_list|(
name|propNode
argument_list|)
decl_stmt|;
for|for
control|(
name|Tree
name|prop
range|:
name|propTree
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|String
name|propName
init|=
name|prop
operator|.
name|getName
argument_list|()
decl_stmt|;
name|NodeState
name|propDefnNode
init|=
name|propNode
operator|.
name|getChildNode
argument_list|(
name|propName
argument_list|)
decl_stmt|;
if|if
condition|(
name|propDefnNode
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|propDefns
operator|.
name|containsKey
argument_list|(
name|propName
argument_list|)
condition|)
block|{
name|PropertyDefinition
name|pd
init|=
operator|new
name|PropertyDefinition
argument_list|(
name|this
argument_list|,
name|propName
argument_list|,
name|propDefnNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|pd
operator|.
name|isRegexp
condition|)
block|{
name|patterns
operator|.
name|add
argument_list|(
operator|new
name|NamePattern
argument_list|(
name|pd
operator|.
name|name
argument_list|,
name|pd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|propDefns
operator|.
name|put
argument_list|(
name|pd
operator|.
name|name
argument_list|,
name|pd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isRelativeProperty
argument_list|(
name|pd
operator|.
name|name
argument_list|)
condition|)
block|{
name|propAggregate
operator|.
name|add
argument_list|(
operator|new
name|Aggregate
operator|.
name|PropertyInclude
argument_list|(
name|pd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|propDefns
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|hasAnyFullTextEnabledProperty
parameter_list|()
block|{
for|for
control|(
name|PropertyDefinition
name|pd
range|:
name|propConfigs
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|pd
operator|.
name|fulltextEnabled
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
for|for
control|(
name|NamePattern
name|np
range|:
name|namePatterns
control|)
block|{
if|if
condition|(
name|np
operator|.
name|getConfig
argument_list|()
operator|.
name|fulltextEnabled
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|hasAnyPropertyIndexConfigured
parameter_list|()
block|{
for|for
control|(
name|PropertyDefinition
name|pd
range|:
name|propConfigs
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|pd
operator|.
name|propertyIndex
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
for|for
control|(
name|NamePattern
name|np
range|:
name|namePatterns
control|)
block|{
if|if
condition|(
name|np
operator|.
name|getConfig
argument_list|()
operator|.
name|propertyIndex
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|allMatchingNodeByTypeIndexed
parameter_list|()
block|{
comment|//Incase of fulltext all nodes matching this rule type would be indexed
comment|//and would have entry in the index
if|if
condition|(
name|fulltextEnabled
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|//jcr:primaryType is present on all node. So if such a property
comment|//is indexed then it would mean all nodes covered by this index rule
comment|//are indexed
if|if
condition|(
name|getConfig
argument_list|(
name|JcrConstants
operator|.
name|JCR_PRIMARYTYPE
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|Aggregate
name|combine
parameter_list|(
name|Aggregate
name|propAggregate
parameter_list|,
name|String
name|nodeTypeName
parameter_list|)
block|{
name|Aggregate
name|nodeTypeAgg
init|=
name|IndexDefinition
operator|.
name|this
operator|.
name|getAggregate
argument_list|(
name|nodeTypeName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Aggregate
operator|.
name|Include
argument_list|>
name|includes
init|=
name|newArrayList
argument_list|()
decl_stmt|;
name|includes
operator|.
name|addAll
argument_list|(
name|propAggregate
operator|.
name|getIncludes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeTypeAgg
operator|!=
literal|null
condition|)
block|{
name|includes
operator|.
name|addAll
argument_list|(
name|nodeTypeAgg
operator|.
name|getIncludes
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Aggregate
argument_list|(
name|nodeTypeName
argument_list|,
name|includes
argument_list|)
return|;
block|}
block|}
comment|/**      * A property name pattern.      */
specifier|private
specifier|static
specifier|final
class|class
name|NamePattern
block|{
specifier|private
specifier|final
name|String
name|parentPath
decl_stmt|;
comment|/**          * The pattern to match.          */
specifier|private
specifier|final
name|Pattern
name|pattern
decl_stmt|;
comment|/**          * The associated configuration.          */
specifier|private
specifier|final
name|PropertyDefinition
name|config
decl_stmt|;
comment|/**          * Creates a new name pattern.          *          * @param pattern the pattern as defined by the property definition          * @param config the associated configuration.          */
specifier|private
name|NamePattern
parameter_list|(
name|String
name|pattern
parameter_list|,
name|PropertyDefinition
name|config
parameter_list|)
block|{
comment|//Special handling for all props regex as its already being used
comment|//and use of '/' in regex would confuse the parent path calculation
comment|//logic
if|if
condition|(
name|LuceneIndexConstants
operator|.
name|REGEX_ALL_PROPS
operator|.
name|equals
argument_list|(
name|pattern
argument_list|)
condition|)
block|{
name|this
operator|.
name|parentPath
operator|=
literal|""
expr_stmt|;
name|this
operator|.
name|pattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|parentPath
operator|=
name|getParentPath
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|this
operator|.
name|pattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|PathUtils
operator|.
name|getName
argument_list|(
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
block|}
comment|/**          * @param propertyPath property name to match          * @return<code>true</code> if<code>property name</code> matches this name          *         pattern;<code>false</code> otherwise.          */
name|boolean
name|matches
parameter_list|(
name|String
name|propertyPath
parameter_list|)
block|{
name|String
name|parentPath
init|=
name|getParentPath
argument_list|(
name|propertyPath
argument_list|)
decl_stmt|;
name|String
name|propertyName
init|=
name|PathUtils
operator|.
name|getName
argument_list|(
name|propertyPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|parentPath
operator|.
name|equals
argument_list|(
name|parentPath
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|pattern
operator|.
name|matcher
argument_list|(
name|propertyName
argument_list|)
operator|.
name|matches
argument_list|()
return|;
block|}
name|PropertyDefinition
name|getConfig
parameter_list|()
block|{
return|return
name|config
return|;
block|}
block|}
comment|//~---------------------------------------------< compatibility>
specifier|public
specifier|static
name|NodeBuilder
name|updateDefinition
parameter_list|(
name|NodeBuilder
name|indexDefn
parameter_list|)
block|{
name|NodeState
name|defn
init|=
name|indexDefn
operator|.
name|getBaseState
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hasIndexingRules
argument_list|(
name|defn
argument_list|)
condition|)
block|{
name|NodeState
name|rulesState
init|=
name|createIndexRules
argument_list|(
name|defn
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|indexDefn
operator|.
name|setChildNode
argument_list|(
name|LuceneIndexConstants
operator|.
name|INDEX_RULES
argument_list|,
name|rulesState
argument_list|)
expr_stmt|;
name|indexDefn
operator|.
name|setProperty
argument_list|(
name|INDEX_VERSION
argument_list|,
name|determineIndexFormatVersion
argument_list|(
name|defn
argument_list|,
name|indexDefn
argument_list|)
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|indexDefn
operator|.
name|removeProperty
argument_list|(
name|DECLARING_NODE_TYPES
argument_list|)
expr_stmt|;
name|indexDefn
operator|.
name|removeProperty
argument_list|(
name|INCLUDE_PROPERTY_NAMES
argument_list|)
expr_stmt|;
name|indexDefn
operator|.
name|removeProperty
argument_list|(
name|EXCLUDE_PROPERTY_NAMES
argument_list|)
expr_stmt|;
name|indexDefn
operator|.
name|removeProperty
argument_list|(
name|ORDERED_PROP_NAMES
argument_list|)
expr_stmt|;
name|indexDefn
operator|.
name|removeProperty
argument_list|(
name|FULL_TEXT_ENABLED
argument_list|)
expr_stmt|;
name|indexDefn
operator|.
name|child
argument_list|(
name|PROP_NODE
argument_list|)
operator|.
name|remove
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Updated index definition for {}"
argument_list|,
name|determineIndexName
argument_list|(
name|defn
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|indexDefn
return|;
block|}
comment|/**      * Constructs IndexingRule based on earlier format of index configuration      */
specifier|private
specifier|static
name|NodeBuilder
name|createIndexRules
parameter_list|(
name|NodeState
name|defn
parameter_list|)
block|{
name|NodeBuilder
name|builder
init|=
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|declaringNodeTypes
init|=
name|getMultiProperty
argument_list|(
name|defn
argument_list|,
name|DECLARING_NODE_TYPES
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|includes
init|=
name|getMultiProperty
argument_list|(
name|defn
argument_list|,
name|INCLUDE_PROPERTY_NAMES
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|excludes
init|=
name|toLowerCase
argument_list|(
name|getMultiProperty
argument_list|(
name|defn
argument_list|,
name|EXCLUDE_PROPERTY_NAMES
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|orderedProps
init|=
name|getMultiProperty
argument_list|(
name|defn
argument_list|,
name|ORDERED_PROP_NAMES
argument_list|)
decl_stmt|;
name|boolean
name|fullTextEnabled
init|=
name|getOptionalValue
argument_list|(
name|defn
argument_list|,
name|FULL_TEXT_ENABLED
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|boolean
name|storageEnabled
init|=
name|getOptionalValue
argument_list|(
name|defn
argument_list|,
name|EXPERIMENTAL_STORAGE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|NodeState
name|propNodeState
init|=
name|defn
operator|.
name|getChildNode
argument_list|(
name|LuceneIndexConstants
operator|.
name|PROP_NODE
argument_list|)
decl_stmt|;
comment|//If no explicit nodeType defined then all config applies for nt:base
if|if
condition|(
name|declaringNodeTypes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|declaringNodeTypes
operator|=
name|Collections
operator|.
name|singleton
argument_list|(
name|NT_BASE
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|propNamesSet
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|propNamesSet
operator|.
name|addAll
argument_list|(
name|includes
argument_list|)
expr_stmt|;
name|propNamesSet
operator|.
name|addAll
argument_list|(
name|excludes
argument_list|)
expr_stmt|;
name|propNamesSet
operator|.
name|addAll
argument_list|(
name|orderedProps
argument_list|)
expr_stmt|;
comment|//Also include all immediate leaf propNode names
for|for
control|(
name|ChildNodeEntry
name|cne
range|:
name|propNodeState
operator|.
name|getChildNodeEntries
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|propNamesSet
operator|.
name|contains
argument_list|(
name|cne
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|Iterables
operator|.
name|isEmpty
argument_list|(
name|cne
operator|.
name|getNodeState
argument_list|()
operator|.
name|getChildNodeNames
argument_list|()
argument_list|)
condition|)
block|{
name|propNamesSet
operator|.
name|add
argument_list|(
name|cne
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|propNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|propNamesSet
argument_list|)
decl_stmt|;
specifier|final
name|String
name|includeAllProp
init|=
name|LuceneIndexConstants
operator|.
name|REGEX_ALL_PROPS
decl_stmt|;
if|if
condition|(
name|fullTextEnabled
operator|&&
name|includes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//Add the regEx for including all properties at the end
comment|//for fulltext index and when no explicit includes are defined
name|propNames
operator|.
name|add
argument_list|(
name|includeAllProp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|typeName
range|:
name|declaringNodeTypes
control|)
block|{
name|NodeBuilder
name|rule
init|=
name|builder
operator|.
name|child
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
name|markAsNtUnstructured
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|propNodeNames
init|=
name|newArrayListWithCapacity
argument_list|(
name|propNamesSet
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|NodeBuilder
name|propNodes
init|=
name|rule
operator|.
name|child
argument_list|(
name|PROP_NODE
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|propName
range|:
name|propNames
control|)
block|{
name|String
name|propNodeName
init|=
name|propName
decl_stmt|;
comment|//For proper propName use the propName as childNode name
if|if
condition|(
name|isRelativeProperty
argument_list|(
name|propName
argument_list|)
operator|||
name|propName
operator|.
name|equals
argument_list|(
name|includeAllProp
argument_list|)
condition|)
block|{
name|propNodeName
operator|=
literal|"prop"
operator|+
name|i
operator|++
expr_stmt|;
block|}
name|propNodeNames
operator|.
name|add
argument_list|(
name|propNodeName
argument_list|)
expr_stmt|;
name|NodeBuilder
name|prop
init|=
name|propNodes
operator|.
name|child
argument_list|(
name|propNodeName
argument_list|)
decl_stmt|;
name|markAsNtUnstructured
argument_list|(
name|prop
argument_list|)
expr_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
name|LuceneIndexConstants
operator|.
name|PROP_NAME
argument_list|,
name|propName
argument_list|)
expr_stmt|;
if|if
condition|(
name|excludes
operator|.
name|contains
argument_list|(
name|propName
argument_list|)
condition|)
block|{
name|prop
operator|.
name|setProperty
argument_list|(
name|LuceneIndexConstants
operator|.
name|PROP_INDEX
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullTextEnabled
condition|)
block|{
name|prop
operator|.
name|setProperty
argument_list|(
name|LuceneIndexConstants
operator|.
name|PROP_ANALYZED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
name|LuceneIndexConstants
operator|.
name|PROP_NODE_SCOPE_INDEX
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
name|LuceneIndexConstants
operator|.
name|PROP_USE_IN_EXCERPT
argument_list|,
name|storageEnabled
argument_list|)
expr_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
name|LuceneIndexConstants
operator|.
name|PROP_PROPERTY_INDEX
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prop
operator|.
name|setProperty
argument_list|(
name|LuceneIndexConstants
operator|.
name|PROP_PROPERTY_INDEX
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|orderedProps
operator|.
name|contains
argument_list|(
name|propName
argument_list|)
condition|)
block|{
name|prop
operator|.
name|setProperty
argument_list|(
name|LuceneIndexConstants
operator|.
name|PROP_ORDERED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|propName
operator|.
name|equals
argument_list|(
name|includeAllProp
argument_list|)
condition|)
block|{
name|prop
operator|.
name|setProperty
argument_list|(
name|LuceneIndexConstants
operator|.
name|PROP_IS_REGEX
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|//Copy over the property configuration
name|NodeState
name|propDefNode
init|=
name|getPropDefnNode
argument_list|(
name|defn
argument_list|,
name|propName
argument_list|)
decl_stmt|;
if|if
condition|(
name|propDefNode
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|PropertyState
name|ps
range|:
name|propDefNode
operator|.
name|getProperties
argument_list|()
control|)
block|{
name|prop
operator|.
name|setProperty
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//If no propertyType defined then default to UNKNOWN such that none
comment|//of the properties get indexed
name|PropertyState
name|supportedTypes
init|=
name|defn
operator|.
name|getProperty
argument_list|(
name|INCLUDE_PROPERTY_TYPES
argument_list|)
decl_stmt|;
if|if
condition|(
name|supportedTypes
operator|==
literal|null
condition|)
block|{
name|supportedTypes
operator|=
name|PropertyStates
operator|.
name|createProperty
argument_list|(
name|INCLUDE_PROPERTY_TYPES
argument_list|,
name|TYPES_ALLOW_ALL_NAME
argument_list|)
expr_stmt|;
block|}
name|rule
operator|.
name|setProperty
argument_list|(
name|supportedTypes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NT_BASE
operator|.
name|equals
argument_list|(
name|typeName
argument_list|)
condition|)
block|{
name|rule
operator|.
name|setProperty
argument_list|(
name|LuceneIndexConstants
operator|.
name|RULE_INHERITED
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|propNodes
operator|.
name|setProperty
argument_list|(
name|OAK_CHILD_ORDER
argument_list|,
name|propNodeNames
argument_list|,
name|NAMES
argument_list|)
expr_stmt|;
name|markAsNtUnstructured
argument_list|(
name|propNodes
argument_list|)
expr_stmt|;
block|}
name|markAsNtUnstructured
argument_list|(
name|builder
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setProperty
argument_list|(
name|OAK_CHILD_ORDER
argument_list|,
name|declaringNodeTypes
argument_list|,
name|NAMES
argument_list|)
expr_stmt|;
return|return
name|builder
return|;
block|}
specifier|private
specifier|static
name|NodeState
name|getPropDefnNode
parameter_list|(
name|NodeState
name|defn
parameter_list|,
name|String
name|propName
parameter_list|)
block|{
name|NodeState
name|propNode
init|=
name|defn
operator|.
name|getChildNode
argument_list|(
name|LuceneIndexConstants
operator|.
name|PROP_NODE
argument_list|)
decl_stmt|;
name|NodeState
name|propDefNode
decl_stmt|;
if|if
condition|(
name|isRelativeProperty
argument_list|(
name|propName
argument_list|)
condition|)
block|{
name|NodeState
name|result
init|=
name|propNode
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|PathUtils
operator|.
name|elements
argument_list|(
name|propName
argument_list|)
control|)
block|{
name|result
operator|=
name|result
operator|.
name|getChildNode
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|propDefNode
operator|=
name|result
expr_stmt|;
block|}
else|else
block|{
name|propDefNode
operator|=
name|propNode
operator|.
name|getChildNode
argument_list|(
name|propName
argument_list|)
expr_stmt|;
block|}
return|return
name|propDefNode
operator|.
name|exists
argument_list|()
condition|?
name|propDefNode
else|:
literal|null
return|;
block|}
comment|//~---------------------------------------------< utility>
specifier|private
name|Codec
name|createCodec
parameter_list|()
block|{
name|String
name|codecName
init|=
name|getOptionalValue
argument_list|(
name|definition
argument_list|,
name|LuceneIndexConstants
operator|.
name|CODEC_NAME
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Codec
name|codec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|codecName
operator|!=
literal|null
condition|)
block|{
name|codec
operator|=
name|Codec
operator|.
name|forName
argument_list|(
name|codecName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullTextEnabled
condition|)
block|{
name|codec
operator|=
operator|new
name|OakCodec
argument_list|()
expr_stmt|;
block|}
return|return
name|codec
return|;
block|}
specifier|private
specifier|static
name|String
name|determineIndexName
parameter_list|(
name|NodeState
name|defn
parameter_list|,
name|String
name|indexPath
parameter_list|)
block|{
name|String
name|indexName
init|=
name|defn
operator|.
name|getString
argument_list|(
name|PROP_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexName
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|indexPath
operator|!=
literal|null
condition|)
block|{
return|return
name|indexPath
return|;
block|}
return|return
literal|"<No 'name' property defined>"
return|;
block|}
if|if
condition|(
name|indexPath
operator|!=
literal|null
condition|)
block|{
return|return
name|indexName
operator|+
literal|"("
operator|+
name|indexPath
operator|+
literal|")"
return|;
block|}
return|return
name|indexName
return|;
block|}
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|getMultiProperty
parameter_list|(
name|NodeState
name|definition
parameter_list|,
name|String
name|propName
parameter_list|)
block|{
name|PropertyState
name|pse
init|=
name|definition
operator|.
name|getProperty
argument_list|(
name|propName
argument_list|)
decl_stmt|;
return|return
name|pse
operator|!=
literal|null
condition|?
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|pse
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|STRINGS
argument_list|)
argument_list|)
else|:
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptySet
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|toLowerCase
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|values
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|result
init|=
name|newHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|val
range|:
name|values
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|val
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|result
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|getAllNodeTypes
parameter_list|(
name|ReadOnlyNodeTypeManager
name|ntReg
parameter_list|)
block|{
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|typeNames
init|=
name|newArrayList
argument_list|()
decl_stmt|;
name|NodeTypeIterator
name|ntItr
init|=
name|ntReg
operator|.
name|getAllNodeTypes
argument_list|()
decl_stmt|;
while|while
condition|(
name|ntItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|typeNames
operator|.
name|add
argument_list|(
name|ntItr
operator|.
name|nextNodeType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|typeNames
return|;
block|}
catch|catch
parameter_list|(
name|RepositoryException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|ReadOnlyNodeTypeManager
name|createNodeTypeManager
parameter_list|(
specifier|final
name|Tree
name|root
parameter_list|)
block|{
return|return
operator|new
name|ReadOnlyNodeTypeManager
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Tree
name|getTypes
parameter_list|()
block|{
return|return
name|TreeUtil
operator|.
name|getTree
argument_list|(
name|root
argument_list|,
name|NODE_TYPES_PATH
argument_list|)
return|;
block|}
annotation|@
name|Nonnull
annotation|@
name|Override
specifier|protected
name|NamePathMapper
name|getNamePathMapper
parameter_list|()
block|{
return|return
name|NamePathMapper
operator|.
name|DEFAULT
return|;
block|}
block|}
return|;
block|}
specifier|private
specifier|static
name|String
name|getPrimaryTypeName
parameter_list|(
name|Tree
name|state
parameter_list|)
block|{
name|String
name|primaryType
init|=
name|TreeUtil
operator|.
name|getPrimaryTypeName
argument_list|(
name|state
argument_list|)
decl_stmt|;
comment|//In case not a proper JCR assume nt:base TODO return null and ignore indexing such nodes
comment|//at all
return|return
name|primaryType
operator|!=
literal|null
condition|?
name|primaryType
else|:
literal|"nt:base"
return|;
block|}
specifier|private
specifier|static
name|Iterable
argument_list|<
name|String
argument_list|>
name|getMixinTypeNames
parameter_list|(
name|Tree
name|tree
parameter_list|)
block|{
name|PropertyState
name|property
init|=
name|tree
operator|.
name|getProperty
argument_list|(
name|JcrConstants
operator|.
name|JCR_MIMETYPE
argument_list|)
decl_stmt|;
return|return
name|property
operator|!=
literal|null
condition|?
name|property
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|NAMES
argument_list|)
else|:
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptyList
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|boolean
name|hasOrderableChildren
parameter_list|(
name|NodeState
name|state
parameter_list|)
block|{
return|return
name|state
operator|.
name|hasProperty
argument_list|(
name|OAK_CHILD_ORDER
argument_list|)
return|;
block|}
specifier|static
name|int
name|getSupportedTypes
parameter_list|(
name|NodeState
name|defn
parameter_list|,
name|String
name|typePropertyName
parameter_list|,
name|int
name|defaultVal
parameter_list|)
block|{
name|PropertyState
name|pst
init|=
name|defn
operator|.
name|getProperty
argument_list|(
name|typePropertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pst
operator|!=
literal|null
condition|)
block|{
name|int
name|types
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|inc
range|:
name|pst
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|STRINGS
argument_list|)
control|)
block|{
if|if
condition|(
name|TYPES_ALLOW_ALL_NAME
operator|.
name|equals
argument_list|(
name|inc
argument_list|)
condition|)
block|{
return|return
name|TYPES_ALLOW_ALL
return|;
block|}
try|try
block|{
name|types
operator||=
literal|1
operator|<<
name|PropertyType
operator|.
name|valueFromName
argument_list|(
name|inc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unknown property type: "
operator|+
name|inc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|types
return|;
block|}
return|return
name|defaultVal
return|;
block|}
specifier|static
name|boolean
name|includePropertyType
parameter_list|(
name|int
name|includedPropertyTypes
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|includedPropertyTypes
operator|==
name|TYPES_ALLOW_ALL
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|includedPropertyTypes
operator|==
name|TYPES_ALLOW_NONE
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|(
name|includedPropertyTypes
operator|&
operator|(
literal|1
operator|<<
name|type
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
specifier|private
specifier|static
name|boolean
name|hasFulltextEnabledIndexRule
parameter_list|(
name|List
argument_list|<
name|IndexingRule
argument_list|>
name|rules
parameter_list|)
block|{
for|for
control|(
name|IndexingRule
name|rule
range|:
name|rules
control|)
block|{
if|if
condition|(
name|rule
operator|.
name|fulltextEnabled
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
specifier|static
name|void
name|markAsNtUnstructured
parameter_list|(
name|NodeBuilder
name|nb
parameter_list|)
block|{
name|nb
operator|.
name|setProperty
argument_list|(
name|JcrConstants
operator|.
name|JCR_PRIMARYTYPE
argument_list|,
name|JcrConstants
operator|.
name|NT_UNSTRUCTURED
argument_list|,
name|Type
operator|.
name|NAME
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|IndexFormatVersion
name|determineIndexFormatVersion
parameter_list|(
name|NodeState
name|defn
parameter_list|,
name|NodeBuilder
name|defnb
parameter_list|)
block|{
if|if
condition|(
name|defnb
operator|!=
literal|null
operator|&&
operator|!
name|defnb
operator|.
name|getChildNode
argument_list|(
name|INDEX_DATA_CHILD_NAME
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
name|determineVersionForFreshIndex
argument_list|(
name|defnb
argument_list|)
return|;
block|}
comment|//Compat mode version if specified has highest priority
if|if
condition|(
name|defn
operator|.
name|hasProperty
argument_list|(
name|COMPAT_MODE
argument_list|)
condition|)
block|{
return|return
name|versionFrom
argument_list|(
name|defn
operator|.
name|getProperty
argument_list|(
name|COMPAT_MODE
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|defn
operator|.
name|hasProperty
argument_list|(
name|INDEX_VERSION
argument_list|)
condition|)
block|{
return|return
name|versionFrom
argument_list|(
name|defn
operator|.
name|getProperty
argument_list|(
name|INDEX_VERSION
argument_list|)
argument_list|)
return|;
block|}
comment|//No existing index data i.e. reindex or fresh index
if|if
condition|(
operator|!
name|defn
operator|.
name|getChildNode
argument_list|(
name|INDEX_DATA_CHILD_NAME
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
name|determineVersionForFreshIndex
argument_list|(
name|defn
argument_list|)
return|;
block|}
name|boolean
name|fullTextEnabled
init|=
name|getOptionalValue
argument_list|(
name|defn
argument_list|,
name|FULL_TEXT_ENABLED
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|//A fulltext index with old indexing format confirms to V1. However
comment|//a propertyIndex with old indexing format confirms to V2
return|return
name|fullTextEnabled
condition|?
name|IndexFormatVersion
operator|.
name|V1
else|:
name|IndexFormatVersion
operator|.
name|V2
return|;
block|}
specifier|static
name|IndexFormatVersion
name|determineVersionForFreshIndex
parameter_list|(
name|NodeState
name|defn
parameter_list|)
block|{
return|return
name|determineVersionForFreshIndex
argument_list|(
name|defn
operator|.
name|getProperty
argument_list|(
name|FULL_TEXT_ENABLED
argument_list|)
argument_list|,
name|defn
operator|.
name|getProperty
argument_list|(
name|COMPAT_MODE
argument_list|)
argument_list|,
name|defn
operator|.
name|getProperty
argument_list|(
name|INDEX_VERSION
argument_list|)
argument_list|)
return|;
block|}
specifier|static
name|IndexFormatVersion
name|determineVersionForFreshIndex
parameter_list|(
name|NodeBuilder
name|defnb
parameter_list|)
block|{
return|return
name|determineVersionForFreshIndex
argument_list|(
name|defnb
operator|.
name|getProperty
argument_list|(
name|FULL_TEXT_ENABLED
argument_list|)
argument_list|,
name|defnb
operator|.
name|getProperty
argument_list|(
name|COMPAT_MODE
argument_list|)
argument_list|,
name|defnb
operator|.
name|getProperty
argument_list|(
name|INDEX_VERSION
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|IndexFormatVersion
name|determineVersionForFreshIndex
parameter_list|(
name|PropertyState
name|fulltext
parameter_list|,
name|PropertyState
name|compat
parameter_list|,
name|PropertyState
name|version
parameter_list|)
block|{
if|if
condition|(
name|compat
operator|!=
literal|null
condition|)
block|{
return|return
name|versionFrom
argument_list|(
name|compat
argument_list|)
return|;
block|}
name|IndexFormatVersion
name|defaultToUse
init|=
name|IndexFormatVersion
operator|.
name|getDefault
argument_list|()
decl_stmt|;
name|IndexFormatVersion
name|existing
init|=
name|version
operator|!=
literal|null
condition|?
name|versionFrom
argument_list|(
name|version
argument_list|)
else|:
literal|null
decl_stmt|;
comment|//As per OAK-2290 current might be less than current used version. So
comment|//set to current only if it is greater than existing
comment|//Per setting use default configured
name|IndexFormatVersion
name|result
init|=
name|defaultToUse
decl_stmt|;
comment|//If default configured is lesser than existing then prefer existing
if|if
condition|(
name|existing
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|IndexFormatVersion
operator|.
name|max
argument_list|(
name|result
argument_list|,
name|existing
argument_list|)
expr_stmt|;
block|}
comment|//Check if fulltext is false which indicates its a property index and
comment|//hence confirm to V2 or above
if|if
condition|(
name|fulltext
operator|!=
literal|null
operator|&&
operator|!
name|fulltext
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|BOOLEAN
argument_list|)
condition|)
block|{
return|return
name|IndexFormatVersion
operator|.
name|max
argument_list|(
name|result
argument_list|,
name|IndexFormatVersion
operator|.
name|V2
argument_list|)
return|;
block|}
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|IndexFormatVersion
name|versionFrom
parameter_list|(
name|PropertyState
name|ps
parameter_list|)
block|{
return|return
name|IndexFormatVersion
operator|.
name|getVersion
argument_list|(
name|Ints
operator|.
name|checkedCast
argument_list|(
name|ps
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|LONG
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|hasIndexingRules
parameter_list|(
name|NodeState
name|defn
parameter_list|)
block|{
return|return
name|defn
operator|.
name|getChildNode
argument_list|(
name|LuceneIndexConstants
operator|.
name|INDEX_RULES
argument_list|)
operator|.
name|exists
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isRelativeProperty
parameter_list|(
name|String
name|propertyName
parameter_list|)
block|{
return|return
operator|!
name|isAbsolute
argument_list|(
name|propertyName
argument_list|)
operator|&&
name|PathUtils
operator|.
name|getNextSlash
argument_list|(
name|propertyName
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
return|;
block|}
block|}
end_class

end_unit

