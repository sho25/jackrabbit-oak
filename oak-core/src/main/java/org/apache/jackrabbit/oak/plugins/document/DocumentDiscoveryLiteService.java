begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Activate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Deactivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ReferenceCardinality
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ReferencePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|commons
operator|.
name|SimpleValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Descriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|osgi
operator|.
name|OsgiWhiteboard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|commit
operator|.
name|CommitInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|commit
operator|.
name|Observer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * The DocumentDiscoveryLiteService is taking care of providing a repository  * descriptor that contains the current cluster-view details.  *<p>  * The clusterView is provided via a repository descriptor (see  * OAK_DISCOVERYLITE_CLUSTERVIEW)  *<p>  * The cluster-view lists all instances (ever) known in the cluster in one of  * the following states:  *<ul>  *<li>active: the instance is currently running and has an up-to-date lease  *</li>  *<li>deactivating: the instance failed to update the lease recently thus a  * recovery is happening - or it has just finished and the local instance is yet  * to do a backgroundRead before it has finished reading the crashed/shutdown  * instance's last changes</li>  *<li>inactive: the instance is currently not running and all its changes have  * been seen by the local instance</li>  *</ul>  *<p>  * Additionally, the cluster-view is assigned a monotonically increasing  * sequence number to. This sequence number is persisted, thus all instances in  * the cluster will show the same sequence number for a particular cluster-view  * in time.  *<p>  * Note that the 'deactivating' state might be hiding some complexity that is  * deliberately not shown: for the documentNS the state 'deactivating' consists  * of two substates: 'recovering' as in _lastRevs are updated, and 'backlog  * processing' for a pending backgroundRead to get the latest head state of a  * crashed/shutdown instance. So when an instance is in 'deactivating' state, it  * is not indicated via the cluster-view whether it is recovering or has backlog  * to process. However, the fact that an instance has to yet do a backgroundRead  * to get changes is a per-instance story: other instances might already have  * done the backgroundRead and thus no longer have a backlog for the instance(s)  * that left. Even though 'deactivating' therefore is dependent on the instance  * you get the information from, the cluster-view must have a sequence number  * that uniquely identifies it in the cluster. These two constraints conflict.  * As a simple solution to handle this case nevertheless, the 'final' flag has  * been introduced: the cluster-view has this flag 'final' set to true when the  * view is final and nothing will be changed in this sequence number anymore. If  * the 'final' flag is false however it indicates that the cluster-view with  * this particular sequence number might still experience a change (more  * concretely: the deactivating instances might change). Note that there  * alternatives to this 'final' flag have been discussed, such as using  * vector-counters, but there was no obvious gain achieve using an alternative  * approach.  *<p>  * In other words: whenever the 'final' flag is false, the view must be  * interpreted as 'in flux' wrt the deactivating/inactive instances and any  * action that depends on stable deactivating/inactive instances must not yet be  * done until the 'final' flag becomes true.  *<p>  * Underneath, the DocumentDiscoveryLiteService uses the clusterNodes collection  * to derive the clusterView, which it stores in the settings collection.  * Whenever it updates the clusterView it increments the sequence number by 1.  *<p>  * While this new 'clusterView' document in the settings collection sounds like  * redundant data (since it is just derived from the clusterNodes), it actually  * is not. By persisting the clusterView it becomes the new source of truth wrt  * what the clusterView looks like. And no two instances in the same cluster can  * make different conclusions based eg on different clocks they have or based on  * reading the clusterNodes in a slightly different moment etc. Also, the  * clusterView allows to store the currently two additional attributes: the  * clusterViewId (which is the permanent id for this cluster similar to the  * slingId being a permanent id for an instance) as well as the sequence number  * (which allows the instances to make reference to the same clusterView, and be  * able to simply detect whether anything has changed)  *<p>  * Prerequisites that the clusterView mechanism is stable:  *<ul>  *<li>the machine clocks are reasonably in sync - that is, they should be off  * by magnitudes less than the lease updateFrequency/timeout</li>  *<li>the write-delays from any instance to the mongo server where the  * clusterNodes and settings collections are stored should be very fast - at  * least orders of magnitudes lower again than the lease timeout</li>  *<li>when this instance notices that others have kicked it out of the  * clusterView (which it can find out when either its clusterNodes document is  * set to recovering or it is not in the clusterView anymore, although it just  * was - ie not just because of a fresh start), then this instance must step  * back gracefully. The exact definition is to be applied elsewhere - but it  * should include: stopping to update its own lease, waiting for the view to  * have stabilized - waiting for recovery of its own instance by the remaining  * instances in the cluster to have finished - and then probably waiting for  * another gracePeriod until it might rejoin the cluster. In between, any commit  * should fail with BannedFromClusterException</li>  *</ul>  *   * @see #OAK_DISCOVERYLITE_CLUSTERVIEW  */
end_comment

begin_class
annotation|@
name|Component
argument_list|(
name|immediate
operator|=
literal|true
argument_list|,
name|name
operator|=
name|DocumentDiscoveryLiteService
operator|.
name|COMPONENT_NAME
argument_list|)
annotation|@
name|Service
argument_list|(
name|value
operator|=
block|{
name|DocumentDiscoveryLiteService
operator|.
name|class
block|,
name|Observer
operator|.
name|class
block|}
argument_list|)
specifier|public
class|class
name|DocumentDiscoveryLiteService
implements|implements
name|ClusterStateChangeListener
implements|,
name|Observer
block|{
specifier|static
specifier|final
name|String
name|COMPONENT_NAME
init|=
literal|"org.apache.jackrabbit.oak.plugins.document.DocumentDiscoveryLiteService"
decl_stmt|;
comment|/**      * Name of the repository descriptor via which the clusterView is published      * - which is the raison d'etre of the DocumentDiscoveryLiteService      **/
specifier|public
specifier|static
specifier|final
name|String
name|OAK_DISCOVERYLITE_CLUSTERVIEW
init|=
literal|"oak.discoverylite.clusterview"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DocumentDiscoveryLiteService
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** describes the reason why the BackgroundWorker should be woken up **/
specifier|private
specifier|static
enum|enum
name|WakeupReason
block|{
name|CLUSTER_STATE_CHANGED
block|,
name|BACKGROUND_READ_FINISHED
block|}
comment|/**      * The BackgroundWorker is taking care of regularly invoking checkView -      * which in turn will detect if anything changed      **/
specifier|private
class|class
name|BackgroundWorker
implements|implements
name|Runnable
block|{
specifier|final
name|Random
name|random
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|boolean
name|stopped
init|=
literal|false
decl_stmt|;
specifier|private
name|void
name|stop
parameter_list|()
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"stop: start"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|BackgroundWorker
operator|.
name|this
init|)
block|{
name|stopped
operator|=
literal|true
expr_stmt|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"stop: end"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"BackgroundWorker.run: start"
argument_list|)
expr_stmt|;
try|try
block|{
name|doRun
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"BackgroundWorker.run: end {finally}"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|doRun
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopped
condition|)
block|{
try|try
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"BackgroundWorker.doRun: going to call checkView"
argument_list|)
expr_stmt|;
name|boolean
name|shortSleep
init|=
name|checkView
argument_list|()
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"BackgroundWorker.doRun: checkView terminated with {} (=shortSleep)"
argument_list|,
name|shortSleep
argument_list|)
expr_stmt|;
name|long
name|sleepMillis
init|=
name|shortSleep
condition|?
operator|(
literal|50
operator|+
name|random
operator|.
name|nextInt
argument_list|(
literal|450
argument_list|)
operator|)
else|:
literal|5000
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"BackgroundWorker.doRun: sleeping {}ms"
argument_list|,
name|sleepMillis
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|BackgroundWorker
operator|.
name|this
init|)
block|{
if|if
condition|(
name|stopped
condition|)
return|return;
name|BackgroundWorker
operator|.
name|this
operator|.
name|wait
argument_list|(
name|sleepMillis
argument_list|)
expr_stmt|;
if|if
condition|(
name|stopped
condition|)
return|return;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"BackgorundWorker.doRun: done sleeping, looping"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"doRun: got an exception: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e2
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"doRun: got an exception while sleeping due to another exception: "
operator|+
name|e2
argument_list|,
name|e2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/** This provides the 'clusterView' repository descriptors **/
specifier|private
class|class
name|DiscoveryLiteDescriptor
implements|implements
name|Descriptors
block|{
specifier|final
name|SimpleValueFactory
name|factory
init|=
operator|new
name|SimpleValueFactory
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
index|[]
name|getKeys
parameter_list|()
block|{
return|return
operator|new
name|String
index|[]
block|{
name|OAK_DISCOVERYLITE_CLUSTERVIEW
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStandardDescriptor
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|OAK_DISCOVERYLITE_CLUSTERVIEW
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isSingleValueDescriptor
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|OAK_DISCOVERYLITE_CLUSTERVIEW
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|Value
name|getValue
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|OAK_DISCOVERYLITE_CLUSTERVIEW
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|factory
operator|.
name|createValue
argument_list|(
name|getClusterViewAsDescriptorValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Value
index|[]
name|getValues
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|OAK_DISCOVERYLITE_CLUSTERVIEW
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|Value
index|[]
block|{
name|getValue
argument_list|(
name|key
argument_list|)
block|}
return|;
block|}
block|}
comment|/** DocumentNodeStore's (hence local) clusterId **/
specifier|private
name|int
name|clusterNodeId
init|=
operator|-
literal|1
decl_stmt|;
comment|/**      * the DocumentNodeStore - used to get the active/inactive cluster ids from      **/
specifier|private
name|DocumentNodeStore
name|documentNodeStore
decl_stmt|;
comment|/**      * background job that periodically verifies and updates the clusterView      **/
specifier|private
name|BackgroundWorker
name|backgroundWorker
decl_stmt|;
comment|/** the ClusterViewDocument which was used in the last checkView run **/
specifier|private
name|ClusterViewDocument
name|previousClusterViewDocument
decl_stmt|;
comment|/**      * the ClusterView that was valid as a result of the previous checkView run      **/
specifier|private
name|ClusterView
name|previousClusterView
decl_stmt|;
comment|/**      * kept volatile as this is frequently read in contentChanged which is      * better kept unsynchronized as long as possible      **/
specifier|private
specifier|volatile
name|boolean
name|hasInstancesWithBacklog
decl_stmt|;
comment|/**      * Require a static reference to the NodeStore. Note that this implies the      * service is only active for documentNS      **/
annotation|@
name|Reference
argument_list|(
name|cardinality
operator|=
name|ReferenceCardinality
operator|.
name|MANDATORY_UNARY
argument_list|,
name|policy
operator|=
name|ReferencePolicy
operator|.
name|STATIC
argument_list|)
specifier|private
specifier|volatile
name|DocumentNodeStore
name|nodeStore
decl_stmt|;
comment|/**      * inactive nodes that have been so for a while, ie they have no backlog      * anymore, so no need to check for backlog every time      **/
specifier|private
name|Set
argument_list|<
name|Integer
argument_list|>
name|longTimeInactives
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * returns the clusterView as a json value for it to be provided via the      * repository descriptor      **/
specifier|private
name|String
name|getClusterViewAsDescriptorValue
parameter_list|()
block|{
if|if
condition|(
name|previousClusterView
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|previousClusterView
operator|.
name|asDescriptorValue
argument_list|()
return|;
block|}
block|}
comment|/**      * On activate the DocumentDiscoveryLiteService tries to start the      * background job      */
annotation|@
name|Activate
specifier|public
name|void
name|activate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"activate: start"
argument_list|)
expr_stmt|;
comment|// set the ClusterStateChangeListener with the DocumentNodeStore
name|this
operator|.
name|documentNodeStore
operator|=
operator|(
name|DocumentNodeStore
operator|)
name|nodeStore
expr_stmt|;
name|documentNodeStore
operator|.
name|setClusterStateChangeListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// retrieve the clusterId
name|clusterNodeId
operator|=
name|documentNodeStore
operator|.
name|getClusterId
argument_list|()
expr_stmt|;
comment|// start the background worker
name|backgroundWorker
operator|=
operator|new
name|BackgroundWorker
argument_list|()
expr_stmt|;
name|Thread
name|th
init|=
operator|new
name|Thread
argument_list|(
name|backgroundWorker
argument_list|,
literal|"DocumentDiscoveryLiteService-BackgroundWorker-["
operator|+
name|clusterNodeId
operator|+
literal|"]"
argument_list|)
decl_stmt|;
name|th
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|th
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// register the Descriptors - for Oak to pass it upwards
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
name|OsgiWhiteboard
name|whiteboard
init|=
operator|new
name|OsgiWhiteboard
argument_list|(
name|context
operator|.
name|getBundleContext
argument_list|()
argument_list|)
decl_stmt|;
name|whiteboard
operator|.
name|register
argument_list|(
name|Descriptors
operator|.
name|class
argument_list|,
operator|new
name|DiscoveryLiteDescriptor
argument_list|()
argument_list|,
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"activate: end"
argument_list|)
expr_stmt|;
block|}
comment|/**      * On deactivate the background job is stopped - if it was running at all      **/
annotation|@
name|Deactivate
specifier|protected
name|void
name|deactivate
parameter_list|()
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"deactivate: deactivated"
argument_list|)
expr_stmt|;
if|if
condition|(
name|backgroundWorker
operator|!=
literal|null
condition|)
block|{
name|backgroundWorker
operator|.
name|stop
argument_list|()
expr_stmt|;
name|backgroundWorker
operator|=
literal|null
expr_stmt|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"deactivate: end"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Checks if anything changed in the current view and updates the service      * fields accordingly.      *       * @return true if anything changed or is about to be changed (eg      *         recovery/backlog), false if the view is stable      */
specifier|private
name|boolean
name|checkView
parameter_list|()
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"checkView: start"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ClusterNodeInfoDocument
argument_list|>
name|allClusterNodes
init|=
name|ClusterNodeInfoDocument
operator|.
name|all
argument_list|(
name|documentNodeStore
operator|.
name|getDocumentStore
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
name|allNodeIds
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
name|activeNotTimedOutNodes
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
name|activeButTimedOutNodes
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
name|recoveringNodes
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
name|backlogNodes
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
name|inactiveNoBacklogNodes
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|ClusterNodeInfoDocument
argument_list|>
name|it
init|=
name|allClusterNodes
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ClusterNodeInfoDocument
name|clusterNode
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|allNodeIds
operator|.
name|put
argument_list|(
name|clusterNode
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|clusterNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|clusterNode
operator|.
name|isBeingRecovered
argument_list|()
condition|)
block|{
name|recoveringNodes
operator|.
name|put
argument_list|(
name|clusterNode
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|clusterNode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|clusterNode
operator|.
name|isActive
argument_list|()
condition|)
block|{
if|if
condition|(
name|hasBacklog
argument_list|(
name|clusterNode
argument_list|)
condition|)
block|{
name|backlogNodes
operator|.
name|put
argument_list|(
name|clusterNode
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|clusterNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inactiveNoBacklogNodes
operator|.
name|put
argument_list|(
name|clusterNode
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|clusterNode
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|clusterNode
operator|.
name|getLeaseEndTime
argument_list|()
operator|<
name|System
operator|.
name|currentTimeMillis
argument_list|()
condition|)
block|{
name|activeButTimedOutNodes
operator|.
name|put
argument_list|(
name|clusterNode
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|clusterNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|activeNotTimedOutNodes
operator|.
name|put
argument_list|(
name|clusterNode
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|clusterNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|// the current view should now consist of:
comment|// activeNotTimedOutNodes and activeButTimedOutNodes!
comment|// (reason for including the timedout: they will yet have to
comment|// switch to recovering or inactive - but we DONT KNOW yet.. that's
comment|// predicting the future - so so far we have to stick with
comment|// including them in the view)
name|Map
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
name|allActives
decl_stmt|;
name|allActives
operator|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ClusterNodeInfoDocument
argument_list|>
argument_list|(
name|activeNotTimedOutNodes
argument_list|)
expr_stmt|;
name|allActives
operator|.
name|putAll
argument_list|(
name|activeButTimedOutNodes
argument_list|)
expr_stmt|;
comment|// terminology:
comment|// 'inactivating' are nodes that are either 'recovering' or 'backlog'
comment|// ones
comment|// 'recovering' are nodes for which one node is doing the recover() of
comment|// lastRevs
comment|// 'backlog' ones are nodes that are no longer active, that have
comment|// finished the
comment|// recover() but for which a backgroundRead is still pending to read
comment|// the latest root changes.
name|logger
operator|.
name|debug
argument_list|(
literal|"checkView: active nodes: {}, timed out nodes: {}, recovering nodes: {}, backlog nodes: {}, inactive nodes: {}, total: {}, hence view nodes: {}"
argument_list|,
name|activeNotTimedOutNodes
operator|.
name|size
argument_list|()
argument_list|,
name|activeButTimedOutNodes
operator|.
name|size
argument_list|()
argument_list|,
name|recoveringNodes
operator|.
name|size
argument_list|()
argument_list|,
name|backlogNodes
operator|.
name|size
argument_list|()
argument_list|,
name|inactiveNoBacklogNodes
operator|.
name|size
argument_list|()
argument_list|,
name|allNodeIds
operator|.
name|size
argument_list|()
argument_list|,
name|allActives
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ClusterViewDocument
name|originalView
init|=
name|previousClusterViewDocument
decl_stmt|;
name|ClusterViewDocument
name|newView
init|=
name|doCheckView
argument_list|(
name|allActives
operator|.
name|keySet
argument_list|()
argument_list|,
name|recoveringNodes
operator|.
name|keySet
argument_list|()
argument_list|,
name|backlogNodes
operator|.
name|keySet
argument_list|()
argument_list|,
name|inactiveNoBacklogNodes
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newView
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"checkView: end. newView: null"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|boolean
name|newHasInstancesWithBacklog
init|=
name|recoveringNodes
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|||
name|backlogNodes
operator|.
name|size
argument_list|()
operator|>
literal|0
decl_stmt|;
name|boolean
name|changed
init|=
name|originalView
operator|==
literal|null
operator|||
operator|(
name|newView
operator|.
name|getViewSeqNum
argument_list|()
operator|!=
name|originalView
operator|.
name|getViewSeqNum
argument_list|()
operator|)
operator|||
operator|(
name|newHasInstancesWithBacklog
operator|!=
name|hasInstancesWithBacklog
operator|)
decl_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"checkView: viewFine: {}, changed: {}, originalView: {}, newView: {}"
argument_list|,
name|newView
operator|!=
literal|null
argument_list|,
name|changed
argument_list|,
name|originalView
argument_list|,
name|newView
argument_list|)
expr_stmt|;
if|if
condition|(
name|longTimeInactives
operator|.
name|addAll
argument_list|(
name|inactiveNoBacklogNodes
operator|.
name|keySet
argument_list|()
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"checkView: updated longTimeInactives to {} (inactiveNoBacklogNodes: {})"
argument_list|,
name|longTimeInactives
argument_list|,
name|inactiveNoBacklogNodes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
block|{
name|ClusterView
name|v
init|=
name|ClusterView
operator|.
name|fromDocument
argument_list|(
name|clusterNodeId
argument_list|,
name|newView
argument_list|,
name|backlogNodes
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|ClusterView
name|previousView
init|=
name|previousClusterView
decl_stmt|;
name|previousClusterView
operator|=
name|v
expr_stmt|;
name|hasInstancesWithBacklog
operator|=
name|newHasInstancesWithBacklog
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"checkView: view changed from: "
operator|+
name|previousView
operator|+
literal|", to: "
operator|+
name|v
operator|+
literal|", hasInstancesWithBacklog: "
operator|+
name|hasInstancesWithBacklog
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"checkView: no changes whatsoever, still at view: "
operator|+
name|previousClusterView
argument_list|)
expr_stmt|;
return|return
name|hasInstancesWithBacklog
return|;
block|}
block|}
specifier|private
name|Revision
name|getLastKnownRevision
parameter_list|(
name|int
name|clusterNodeId
parameter_list|)
block|{
name|String
index|[]
name|lastKnownRevisions
init|=
name|documentNodeStore
operator|.
name|getMBean
argument_list|()
operator|.
name|getLastKnownRevisions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lastKnownRevisions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|aLastKnownRevisionStr
init|=
name|lastKnownRevisions
index|[
name|i
index|]
decl_stmt|;
name|String
index|[]
name|split
init|=
name|aLastKnownRevisionStr
operator|.
name|split
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|.
name|length
operator|==
literal|2
condition|)
block|{
try|try
block|{
name|Integer
name|id
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|split
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|clusterNodeId
condition|)
block|{
specifier|final
name|Revision
name|lastKnownRev
init|=
name|Revision
operator|.
name|fromString
argument_list|(
name|split
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"getLastKnownRevision: end. clusterNode: {}, lastKnownRevision: {}"
argument_list|,
name|clusterNodeId
argument_list|,
name|lastKnownRev
argument_list|)
expr_stmt|;
return|return
name|lastKnownRev
return|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"getLastKnownRevision: could not parse integer '"
operator|+
name|split
index|[
literal|0
index|]
operator|+
literal|"': "
operator|+
name|nfe
argument_list|,
name|nfe
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"getLastKnownRevision: cannot parse lastKnownRevision: "
operator|+
name|aLastKnownRevisionStr
argument_list|)
expr_stmt|;
block|}
block|}
name|logger
operator|.
name|warn
argument_list|(
literal|"getLastKnownRevision: no lastKnownRevision found for "
operator|+
name|clusterNodeId
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|private
name|boolean
name|hasBacklog
parameter_list|(
name|ClusterNodeInfoDocument
name|clusterNode
parameter_list|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"hasBacklog: start. clusterNodeId: {}"
argument_list|,
name|clusterNode
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Revision
name|lastKnownRevision
init|=
name|getLastKnownRevision
argument_list|(
name|clusterNode
operator|.
name|getClusterId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastKnownRevision
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"hasBacklog: no lastKnownRevision found, hence cannot determine backlog for node "
operator|+
name|clusterNode
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// The lastKnownRevision is what the local instance has last read/seen
comment|// from another instance.
comment|// This must be compared to what the other instance *actually* has
comment|// written as the very last thing.
comment|// Now the knowledge what the other instance has last written (after
comment|// recovery) would sit
comment|// in the root document - so that could in theory be used. But reading
comment|// the root document
comment|// would have to be done *uncached*. And that's quite a change to what
comment|// the original
comment|// idea was: that the root document would only be read every second, to
comment|// avoid contention.
comment|// So this 'what the other instance has last written' information is
comment|// retrieved via
comment|// a new, dedicated property in the clusterNodes collection: the
comment|// 'lastWrittenRootRev'.
comment|// The 'lastWrittenRootRev' is written by 'UnsavedModifications' during
comment|// backgroundUpdate
comment|// and retrieved here quite regularly (but it should not be a big deal,
comment|// as the
comment|// discovery-lite is the only one reading this field so frequently and
comment|// it does not
comment|// interfere with normal (jcr) nodes at all).
name|String
name|lastWrittenRootRevStr
init|=
name|clusterNode
operator|.
name|getLastWrittenRootRev
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastWrittenRootRevStr
operator|==
literal|null
condition|)
block|{
name|boolean
name|warn
init|=
literal|false
decl_stmt|;
name|Object
name|oakVersion
init|=
name|clusterNode
operator|.
name|get
argument_list|(
name|ClusterNodeInfo
operator|.
name|OAK_VERSION_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|oakVersion
operator|!=
literal|null
operator|&&
operator|(
name|oakVersion
operator|instanceof
name|String
operator|)
condition|)
block|{
try|try
block|{
name|Version
name|actual
init|=
name|Version
operator|.
name|parseVersion
argument_list|(
operator|(
name|String
operator|)
name|oakVersion
argument_list|)
decl_stmt|;
name|Version
name|introduced
init|=
name|Version
operator|.
name|parseVersion
argument_list|(
literal|"1.3.5"
argument_list|)
decl_stmt|;
if|if
condition|(
name|actual
operator|.
name|compareTo
argument_list|(
name|introduced
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|warn
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"hasBacklog: couldn't parse version "
operator|+
name|oakVersion
operator|+
literal|" : "
operator|+
name|e
argument_list|)
expr_stmt|;
name|warn
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|warn
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"hasBacklog: node has lastWrittenRootRev=null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"hasBacklog: node has lastWrittenRootRev=null"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|Revision
name|lastWrittenRootRev
init|=
name|Revision
operator|.
name|fromString
argument_list|(
name|lastWrittenRootRevStr
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastWrittenRootRev
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"hasBacklog: node has no lastWrittenRootRev: "
operator|+
name|clusterNode
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|boolean
name|hasBacklog
init|=
name|Revision
operator|.
name|getTimestampDifference
argument_list|(
name|lastKnownRevision
argument_list|,
name|lastWrittenRootRev
argument_list|)
operator|<
literal|0
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"hasBacklog: clusterNodeId: {}, lastKnownRevision: {}, lastWrittenRootRev: {}, hasBacklog: {}"
argument_list|,
name|clusterNode
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|lastKnownRevision
argument_list|,
name|lastWrittenRootRev
argument_list|,
name|hasBacklog
argument_list|)
expr_stmt|;
block|}
return|return
name|hasBacklog
return|;
block|}
specifier|private
name|ClusterViewDocument
name|doCheckView
parameter_list|(
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|activeNodes
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|recoveringNodes
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|backlogNodes
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|inactiveNodes
parameter_list|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"doCheckView: start: activeNodes: {}, recoveringNodes: {}, backlogNodes: {}, inactiveNodes: {}"
argument_list|,
name|activeNodes
argument_list|,
name|recoveringNodes
argument_list|,
name|backlogNodes
argument_list|,
name|inactiveNodes
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|allInactives
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|allInactives
operator|.
name|addAll
argument_list|(
name|inactiveNodes
argument_list|)
expr_stmt|;
name|allInactives
operator|.
name|addAll
argument_list|(
name|backlogNodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|activeNodes
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// then we have zero active nodes - that's nothing expected as that
comment|// includes our own node not to be active
comment|// hence handle with care - ie wait until we get an active node
name|logger
operator|.
name|warn
argument_list|(
literal|"doCheckView: empty active ids. activeNodes:{}, recoveringNodes:{}, inactiveNodes:{}"
argument_list|,
name|activeNodes
argument_list|,
name|recoveringNodes
argument_list|,
name|inactiveNodes
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|ClusterViewDocument
name|newViewOrNull
decl_stmt|;
try|try
block|{
name|newViewOrNull
operator|=
name|ClusterViewDocument
operator|.
name|readOrUpdate
argument_list|(
name|documentNodeStore
argument_list|,
name|activeNodes
argument_list|,
name|recoveringNodes
argument_list|,
name|allInactives
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|re
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"doCheckView: RuntimeException: re: "
operator|+
name|re
argument_list|,
name|re
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Error
name|er
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"doCheckView: Error: er: "
operator|+
name|er
argument_list|,
name|er
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"doChckView: readOrUpdate result: {}"
argument_list|,
name|newViewOrNull
argument_list|)
expr_stmt|;
comment|// and now for some verbose documentation and logging:
if|if
condition|(
name|newViewOrNull
operator|==
literal|null
condition|)
block|{
comment|// then there was a concurrent update of the clusterView
comment|// and we should do some quick backoff sleeping
name|logger
operator|.
name|debug
argument_list|(
literal|"doCheckView: newViewOrNull is null: "
operator|+
name|newViewOrNull
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
comment|// otherwise we now hold the newly valid view
comment|// it could be the same or different to the previous one, let's
comment|// check
if|if
condition|(
name|previousClusterViewDocument
operator|==
literal|null
condition|)
block|{
comment|// oh ok, this is the very first one
name|previousClusterViewDocument
operator|=
name|newViewOrNull
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"doCheckView: end. first ever view: {}"
argument_list|,
name|newViewOrNull
argument_list|)
expr_stmt|;
return|return
name|newViewOrNull
return|;
block|}
elseif|else
if|if
condition|(
name|previousClusterViewDocument
operator|.
name|getViewSeqNum
argument_list|()
operator|==
name|newViewOrNull
operator|.
name|getViewSeqNum
argument_list|()
condition|)
block|{
comment|// that's the normal case: the viewId matches, nothing has
comment|// changed, we've already
comment|// processed the previousClusterView, so:
name|logger
operator|.
name|debug
argument_list|(
literal|"doCheckView: end. seqNum did not change. view: {}"
argument_list|,
name|newViewOrNull
argument_list|)
expr_stmt|;
return|return
name|newViewOrNull
return|;
block|}
else|else
block|{
comment|// otherwise the view has changed
name|logger
operator|.
name|info
argument_list|(
literal|"doCheckView: view has changed from: {} to: {} - sending event..."
argument_list|,
name|previousClusterViewDocument
argument_list|,
name|newViewOrNull
argument_list|)
expr_stmt|;
name|previousClusterViewDocument
operator|=
name|newViewOrNull
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"doCheckView: end. changed view: {}"
argument_list|,
name|newViewOrNull
argument_list|)
expr_stmt|;
return|return
name|newViewOrNull
return|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleClusterStateChange
parameter_list|()
block|{
comment|// handleClusterStateChange is needed to learn about any state change in
comment|// the clusternodes
comment|// collection asap and being able to react on it - so this will wake up
comment|// the
comment|// backgroundWorker which in turn will - in a separate thread - check
comment|// the view
comment|// and send out events accordingly
name|wakeupBackgroundWorker
argument_list|(
name|WakeupReason
operator|.
name|CLUSTER_STATE_CHANGED
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|wakeupBackgroundWorker
parameter_list|(
name|WakeupReason
name|wakeupReason
parameter_list|)
block|{
specifier|final
name|BackgroundWorker
name|bw
init|=
name|backgroundWorker
decl_stmt|;
if|if
condition|(
name|bw
operator|!=
literal|null
condition|)
block|{
comment|// get a copy of this.hasInstancesWithBacklog for just the code-part
comment|// in this synchronized
name|boolean
name|hasInstancesWithBacklog
init|=
name|this
operator|.
name|hasInstancesWithBacklog
decl_stmt|;
if|if
condition|(
name|wakeupReason
operator|==
name|WakeupReason
operator|.
name|BACKGROUND_READ_FINISHED
condition|)
block|{
comment|// then only forward the notify if' hasInstancesWithBacklog'
comment|// ie, we have anything we could be waiting for - otherwise
comment|// we dont need to wakeup the background thread
if|if
condition|(
operator|!
name|hasInstancesWithBacklog
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"wakeupBackgroundWorker: not waking up backgroundWorker, as we do not have any instances with backlog"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"wakeupBackgroundWorker: waking up backgroundWorker, reason: {} (hasInstancesWithBacklog: {})"
argument_list|,
name|wakeupReason
argument_list|,
name|hasInstancesWithBacklog
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|bw
init|)
block|{
name|bw
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      *<p>      * Additionally the DocumentDiscoveryLiteService must be notified when the      * background-read has finished - as it could be waiting for a crashed      * node's recovery to finish - which it can only do by checking the      * lastKnownRevision of the crashed instance - and that check is best done      * after the background read is just finished (it could optinoally do that      * just purely time based as well, but going via a listener is more timely,      * that's why this approach has been chosen).      */
annotation|@
name|Override
specifier|public
name|void
name|contentChanged
parameter_list|(
name|NodeState
name|root
parameter_list|,
name|CommitInfo
name|info
parameter_list|)
block|{
comment|// contentChanged is only used to react as quickly as possible
comment|// when we have instances that have a 'backlog' - ie when instances
comment|// crashed
comment|// and are being recovered - then we must wait until the recovery is
comment|// finished
comment|// AND until the subsequent background read actually reads that
comment|// instance'
comment|// last changes. To catch that moment as quickly as possible,
comment|// this contentChanged is used.
comment|// Now from the above it also results that this only wakes up the
comment|// backgroundWorker if we have any pending 'backlogy instances'
comment|// otherwise this is a no-op
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
comment|// then ignore this as this is likely an external change
comment|// note: it could be a compacted change, in which case we should
comment|// probably still process it - but we have a 5sec fallback
comment|// in the BackgroundWorker to handle that case too,
comment|// so:
name|logger
operator|.
name|trace
argument_list|(
literal|"contentChanged: ignoring content change due to commit info being null"
argument_list|)
expr_stmt|;
return|return;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"contentChanged: handling content changed by waking up worker if necessary"
argument_list|)
expr_stmt|;
name|wakeupBackgroundWorker
argument_list|(
name|WakeupReason
operator|.
name|BACKGROUND_READ_FINISHED
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

