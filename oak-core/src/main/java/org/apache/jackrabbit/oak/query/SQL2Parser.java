begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|newHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|PropertyType
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|RepositoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|PropertyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|QueryEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|api
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|namepath
operator|.
name|NamePathMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|QueryOptions
operator|.
name|Traversal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|AstElementFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|BindVariableValueImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|ColumnImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|ConstraintImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|DynamicOperandImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|JoinConditionImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|JoinType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|LiteralImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|NodeTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|NodeTypeInfoProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|OrderingImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|PropertyExistenceImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|PropertyInexistenceImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|PropertyValueImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|SelectorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|SourceImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|query
operator|.
name|ast
operator|.
name|StaticOperandImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|PropertyValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|query
operator|.
name|QueryEngineSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|query
operator|.
name|QueryConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * The SQL2 parser can convert a JCR-SQL2 query to a query. The 'old' SQL query  * language (here named SQL-1) is also supported.  */
end_comment

begin_class
specifier|public
class|class
name|SQL2Parser
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SQL2Parser
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Character types, used during the tokenizer phase
specifier|private
specifier|static
specifier|final
name|int
name|CHAR_END
init|=
operator|-
literal|1
decl_stmt|,
name|CHAR_IGNORE
init|=
literal|0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CHAR_VALUE
init|=
literal|2
decl_stmt|,
name|CHAR_QUOTED
init|=
literal|3
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CHAR_NAME
init|=
literal|4
decl_stmt|,
name|CHAR_SPECIAL_1
init|=
literal|5
decl_stmt|,
name|CHAR_SPECIAL_2
init|=
literal|6
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CHAR_STRING
init|=
literal|7
decl_stmt|,
name|CHAR_DECIMAL
init|=
literal|8
decl_stmt|,
name|CHAR_BRACKETED
init|=
literal|9
decl_stmt|;
comment|// Token types
specifier|private
specifier|static
specifier|final
name|int
name|KEYWORD
init|=
literal|1
decl_stmt|,
name|IDENTIFIER
init|=
literal|2
decl_stmt|,
name|PARAMETER
init|=
literal|3
decl_stmt|,
name|END
init|=
literal|4
decl_stmt|,
name|VALUE
init|=
literal|5
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MINUS
init|=
literal|12
decl_stmt|,
name|PLUS
init|=
literal|13
decl_stmt|,
name|OPEN
init|=
literal|14
decl_stmt|,
name|CLOSE
init|=
literal|15
decl_stmt|;
specifier|private
specifier|final
name|NodeTypeInfoProvider
name|nodeTypes
decl_stmt|;
comment|// The query as an array of characters and character types
specifier|private
name|String
name|statement
decl_stmt|;
specifier|private
name|char
index|[]
name|statementChars
decl_stmt|;
specifier|private
name|int
index|[]
name|characterTypes
decl_stmt|;
comment|// The current state of the parser
specifier|private
name|int
name|parseIndex
decl_stmt|;
specifier|private
name|int
name|currentTokenType
decl_stmt|;
specifier|private
name|String
name|currentToken
decl_stmt|;
specifier|private
name|boolean
name|currentTokenQuoted
decl_stmt|;
specifier|private
name|PropertyValue
name|currentValue
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|String
argument_list|>
name|expected
decl_stmt|;
comment|// The bind variables
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|BindVariableValueImpl
argument_list|>
name|bindVariables
decl_stmt|;
comment|// The list of selectors of this query
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SelectorImpl
argument_list|>
name|selectors
init|=
name|newHashMap
argument_list|()
decl_stmt|;
comment|// SQL injection protection: if disabled, literals are not allowed
specifier|private
name|boolean
name|allowTextLiterals
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|allowNumberLiterals
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|includeSelectorNameInWildcardColumns
init|=
literal|true
decl_stmt|;
specifier|private
specifier|final
name|AstElementFactory
name|factory
init|=
operator|new
name|AstElementFactory
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|supportSQL1
decl_stmt|;
specifier|private
name|NamePathMapper
name|namePathMapper
decl_stmt|;
specifier|private
specifier|final
name|QueryEngineSettings
name|settings
decl_stmt|;
specifier|private
name|boolean
name|literalUsageLogged
decl_stmt|;
comment|/**      * Create a new parser. A parser can be re-used, but it is not thread safe.      *       * @param namePathMapper the name-path mapper to use      * @param nodeTypes the nodetypes      * @param settings the query engine settings      */
specifier|public
name|SQL2Parser
parameter_list|(
name|NamePathMapper
name|namePathMapper
parameter_list|,
name|NodeTypeInfoProvider
name|nodeTypes
parameter_list|,
name|QueryEngineSettings
name|settings
parameter_list|)
block|{
name|this
operator|.
name|namePathMapper
operator|=
name|namePathMapper
expr_stmt|;
name|this
operator|.
name|nodeTypes
operator|=
name|checkNotNull
argument_list|(
name|nodeTypes
argument_list|)
expr_stmt|;
name|this
operator|.
name|settings
operator|=
name|checkNotNull
argument_list|(
name|settings
argument_list|)
expr_stmt|;
block|}
comment|/**      * Parse the statement and return the query.      *      * @param query the query string      * @param initialise if performing the query init ({@code true}) or not ({@code false})      * @return the query      * @throws ParseException if parsing fails      */
specifier|public
name|Query
name|parse
parameter_list|(
specifier|final
name|String
name|query
parameter_list|,
specifier|final
name|boolean
name|initialise
parameter_list|)
throws|throws
name|ParseException
block|{
comment|// TODO possibly support union,... as available at
comment|// http://docs.jboss.org/modeshape/latest/manuals/reference/html/jcr-query-and-search.html
name|initialize
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|selectors
operator|.
name|clear
argument_list|()
expr_stmt|;
name|expected
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|bindVariables
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BindVariableValueImpl
argument_list|>
argument_list|()
expr_stmt|;
name|read
argument_list|()
expr_stmt|;
name|boolean
name|explain
init|=
literal|false
decl_stmt|,
name|measure
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"EXPLAIN"
argument_list|)
condition|)
block|{
name|explain
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|readIf
argument_list|(
literal|"MEASURE"
argument_list|)
condition|)
block|{
name|measure
operator|=
literal|true
expr_stmt|;
block|}
name|Query
name|q
init|=
name|parseSelect
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|readIf
argument_list|(
literal|"UNION"
argument_list|)
condition|)
block|{
break|break;
block|}
name|boolean
name|unionAll
init|=
name|readIf
argument_list|(
literal|"ALL"
argument_list|)
decl_stmt|;
name|QueryImpl
name|q2
init|=
name|parseSelect
argument_list|()
decl_stmt|;
name|q
operator|=
operator|new
name|UnionQueryImpl
argument_list|(
name|unionAll
argument_list|,
name|q
argument_list|,
name|q2
argument_list|,
name|settings
argument_list|)
expr_stmt|;
block|}
name|OrderingImpl
index|[]
name|orderings
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"ORDER"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|"BY"
argument_list|)
expr_stmt|;
name|orderings
operator|=
name|parseOrder
argument_list|()
expr_stmt|;
block|}
name|QueryOptions
name|options
init|=
operator|new
name|QueryOptions
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"OPTION"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"TRAVERSAL"
argument_list|)
condition|)
block|{
name|String
name|n
init|=
name|readName
argument_list|()
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
decl_stmt|;
name|options
operator|.
name|traversal
operator|=
name|Traversal
operator|.
name|valueOf
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"INDEX"
argument_list|)
condition|)
block|{
name|String
name|n
init|=
name|readName
argument_list|()
decl_stmt|;
name|options
operator|.
name|indexName
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|readIf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|currentToken
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"<end>"
argument_list|)
throw|;
block|}
name|q
operator|.
name|setOrderings
argument_list|(
name|orderings
argument_list|)
expr_stmt|;
name|q
operator|.
name|setExplain
argument_list|(
name|explain
argument_list|)
expr_stmt|;
name|q
operator|.
name|setMeasure
argument_list|(
name|measure
argument_list|)
expr_stmt|;
name|q
operator|.
name|setInternal
argument_list|(
name|isInternal
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|.
name|setQueryOptions
argument_list|(
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialise
condition|)
block|{
try|try
block|{
name|q
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|ParseException
name|e2
init|=
operator|new
name|ParseException
argument_list|(
name|statement
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|e2
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e2
throw|;
block|}
block|}
return|return
name|q
return|;
block|}
comment|/**      * as {@link #parse(String, boolean)} by providing {@code true} to the initialisation flag.      *       * @param query      * @return the parsed query      * @throws ParseException      */
specifier|public
name|Query
name|parse
parameter_list|(
specifier|final
name|String
name|query
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
name|parse
argument_list|(
name|query
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
name|QueryImpl
name|parseSelect
parameter_list|()
throws|throws
name|ParseException
block|{
name|read
argument_list|(
literal|"SELECT"
argument_list|)
expr_stmt|;
name|boolean
name|distinct
init|=
name|readIf
argument_list|(
literal|"DISTINCT"
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnOrWildcard
argument_list|>
name|list
init|=
name|parseColumns
argument_list|()
decl_stmt|;
if|if
condition|(
name|supportSQL1
condition|)
block|{
name|addColumnIfNecessary
argument_list|(
name|list
argument_list|,
name|QueryConstants
operator|.
name|JCR_PATH
argument_list|,
name|QueryConstants
operator|.
name|JCR_PATH
argument_list|)
expr_stmt|;
name|addColumnIfNecessary
argument_list|(
name|list
argument_list|,
name|QueryConstants
operator|.
name|JCR_SCORE
argument_list|,
name|QueryConstants
operator|.
name|JCR_SCORE
argument_list|)
expr_stmt|;
block|}
name|read
argument_list|(
literal|"FROM"
argument_list|)
expr_stmt|;
name|SourceImpl
name|source
init|=
name|parseSource
argument_list|()
decl_stmt|;
name|ColumnImpl
index|[]
name|columnArray
init|=
name|resolveColumns
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|ConstraintImpl
name|constraint
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"WHERE"
argument_list|)
condition|)
block|{
name|constraint
operator|=
name|parseConstraint
argument_list|()
expr_stmt|;
block|}
name|QueryImpl
name|q
init|=
operator|new
name|QueryImpl
argument_list|(
name|statement
argument_list|,
name|source
argument_list|,
name|constraint
argument_list|,
name|columnArray
argument_list|,
name|namePathMapper
argument_list|,
name|settings
argument_list|)
decl_stmt|;
name|q
operator|.
name|setDistinct
argument_list|(
name|distinct
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
specifier|private
specifier|static
name|void
name|addColumnIfNecessary
parameter_list|(
name|ArrayList
argument_list|<
name|ColumnOrWildcard
argument_list|>
name|list
parameter_list|,
name|String
name|columnName
parameter_list|,
name|String
name|propertyName
parameter_list|)
block|{
for|for
control|(
name|ColumnOrWildcard
name|c
range|:
name|list
control|)
block|{
name|String
name|col
init|=
name|c
operator|.
name|columnName
decl_stmt|;
if|if
condition|(
name|columnName
operator|.
name|equals
argument_list|(
name|col
argument_list|)
condition|)
block|{
comment|// it already exists
return|return;
block|}
block|}
name|ColumnOrWildcard
name|column
init|=
operator|new
name|ColumnOrWildcard
argument_list|()
decl_stmt|;
name|column
operator|.
name|columnName
operator|=
name|columnName
expr_stmt|;
name|column
operator|.
name|propertyName
operator|=
name|propertyName
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
comment|/**      * Enable or disable support for SQL-1 queries.      *      * @param sql1 the new value      */
specifier|public
name|void
name|setSupportSQL1
parameter_list|(
name|boolean
name|sql1
parameter_list|)
block|{
name|this
operator|.
name|supportSQL1
operator|=
name|sql1
expr_stmt|;
block|}
specifier|private
name|SelectorImpl
name|parseSelector
parameter_list|()
throws|throws
name|ParseException
block|{
name|String
name|nodeTypeName
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|namePathMapper
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|nodeTypeName
operator|=
name|namePathMapper
operator|.
name|getOakName
argument_list|(
name|nodeTypeName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RepositoryException
name|e
parameter_list|)
block|{
name|ParseException
name|e2
init|=
name|getSyntaxError
argument_list|(
literal|"could not convert node type name "
operator|+
name|nodeTypeName
argument_list|)
decl_stmt|;
name|e2
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e2
throw|;
block|}
block|}
name|NodeTypeInfo
name|nodeTypeInfo
init|=
name|nodeTypes
operator|.
name|getNodeTypeInfo
argument_list|(
name|nodeTypeName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nodeTypeInfo
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"unknown node type"
argument_list|)
throw|;
block|}
name|String
name|selectorName
init|=
name|nodeTypeName
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"AS"
argument_list|)
condition|)
block|{
name|selectorName
operator|=
name|readName
argument_list|()
expr_stmt|;
block|}
return|return
name|factory
operator|.
name|selector
argument_list|(
name|nodeTypeInfo
argument_list|,
name|selectorName
argument_list|)
return|;
block|}
specifier|private
name|String
name|readName
parameter_list|()
throws|throws
name|ParseException
block|{
if|if
condition|(
name|currentTokenType
operator|==
name|END
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"a token"
argument_list|)
throw|;
block|}
name|String
name|s
decl_stmt|;
if|if
condition|(
name|currentTokenType
operator|==
name|VALUE
condition|)
block|{
name|s
operator|=
name|currentValue
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|STRING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|currentToken
expr_stmt|;
block|}
name|read
argument_list|()
expr_stmt|;
return|return
name|s
return|;
block|}
specifier|private
name|SourceImpl
name|parseSource
parameter_list|()
throws|throws
name|ParseException
block|{
name|SelectorImpl
name|selector
init|=
name|parseSelector
argument_list|()
decl_stmt|;
name|selectors
operator|.
name|put
argument_list|(
name|selector
operator|.
name|getSelectorName
argument_list|()
argument_list|,
name|selector
argument_list|)
expr_stmt|;
name|SourceImpl
name|source
init|=
name|selector
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|JoinType
name|joinType
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"RIGHT"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|"OUTER"
argument_list|)
expr_stmt|;
name|joinType
operator|=
name|JoinType
operator|.
name|RIGHT_OUTER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"LEFT"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|"OUTER"
argument_list|)
expr_stmt|;
name|joinType
operator|=
name|JoinType
operator|.
name|LEFT_OUTER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"INNER"
argument_list|)
condition|)
block|{
name|joinType
operator|=
name|JoinType
operator|.
name|INNER
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|read
argument_list|(
literal|"JOIN"
argument_list|)
expr_stmt|;
name|selector
operator|=
name|parseSelector
argument_list|()
expr_stmt|;
name|selectors
operator|.
name|put
argument_list|(
name|selector
operator|.
name|getSelectorName
argument_list|()
argument_list|,
name|selector
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|"ON"
argument_list|)
expr_stmt|;
name|JoinConditionImpl
name|on
init|=
name|parseJoinCondition
argument_list|()
decl_stmt|;
name|source
operator|=
name|factory
operator|.
name|join
argument_list|(
name|source
argument_list|,
name|selector
argument_list|,
name|joinType
argument_list|,
name|on
argument_list|)
expr_stmt|;
block|}
return|return
name|source
return|;
block|}
specifier|private
name|JoinConditionImpl
name|parseJoinCondition
parameter_list|()
throws|throws
name|ParseException
block|{
name|boolean
name|identifier
init|=
name|currentTokenType
operator|==
name|IDENTIFIER
decl_stmt|;
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
name|JoinConditionImpl
name|c
decl_stmt|;
if|if
condition|(
name|identifier
operator|&&
name|readIf
argument_list|(
literal|"("
argument_list|)
condition|)
block|{
if|if
condition|(
literal|"ISSAMENODE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|selector1
init|=
name|readName
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|String
name|selector2
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|sameNodeJoinCondition
argument_list|(
name|selector1
argument_list|,
name|selector2
argument_list|,
name|readPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|factory
operator|.
name|sameNodeJoinCondition
argument_list|(
name|selector1
argument_list|,
name|selector2
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"ISCHILDNODE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|childSelector
init|=
name|readName
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|childNodeJoinCondition
argument_list|(
name|childSelector
argument_list|,
name|readName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"ISDESCENDANTNODE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|descendantSelector
init|=
name|readName
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|descendantNodeJoinCondition
argument_list|(
name|descendantSelector
argument_list|,
name|readName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"ISSAMENODE, ISCHILDNODE, or ISDESCENDANTNODE"
argument_list|)
throw|;
block|}
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
else|else
block|{
name|String
name|selector1
init|=
name|name
decl_stmt|;
name|read
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|String
name|property1
init|=
name|readName
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|String
name|selector2
init|=
name|readName
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
return|return
name|factory
operator|.
name|equiJoinCondition
argument_list|(
name|selector1
argument_list|,
name|property1
argument_list|,
name|selector2
argument_list|,
name|readName
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|private
name|ConstraintImpl
name|parseConstraint
parameter_list|()
throws|throws
name|ParseException
block|{
name|ConstraintImpl
name|a
init|=
name|parseAnd
argument_list|()
decl_stmt|;
while|while
condition|(
name|readIf
argument_list|(
literal|"OR"
argument_list|)
condition|)
block|{
name|a
operator|=
name|factory
operator|.
name|or
argument_list|(
name|a
argument_list|,
name|parseAnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
specifier|private
name|ConstraintImpl
name|parseAnd
parameter_list|()
throws|throws
name|ParseException
block|{
name|ConstraintImpl
name|a
init|=
name|parseCondition
argument_list|()
decl_stmt|;
while|while
condition|(
name|readIf
argument_list|(
literal|"AND"
argument_list|)
condition|)
block|{
name|a
operator|=
name|factory
operator|.
name|and
argument_list|(
name|a
argument_list|,
name|parseCondition
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
specifier|private
name|ConstraintImpl
name|parseCondition
parameter_list|()
throws|throws
name|ParseException
block|{
name|ConstraintImpl
name|a
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"NOT"
argument_list|)
condition|)
block|{
name|a
operator|=
name|factory
operator|.
name|not
argument_list|(
name|parseCondition
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"("
argument_list|)
condition|)
block|{
name|a
operator|=
name|parseConstraint
argument_list|()
expr_stmt|;
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentTokenType
operator|==
name|IDENTIFIER
condition|)
block|{
name|String
name|identifier
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"("
argument_list|)
condition|)
block|{
name|a
operator|=
name|parseConditionFunctionIf
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|null
condition|)
block|{
name|DynamicOperandImpl
name|op
init|=
name|parseExpressionFunction
argument_list|(
name|identifier
argument_list|)
decl_stmt|;
name|a
operator|=
name|parseCondition
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|a
operator|=
name|parseCondition
argument_list|(
name|factory
operator|.
name|propertyValue
argument_list|(
name|identifier
argument_list|,
name|readName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|parseCondition
argument_list|(
name|factory
operator|.
name|propertyValue
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"["
operator|.
name|equals
argument_list|(
name|currentToken
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|a
operator|=
name|parseCondition
argument_list|(
name|factory
operator|.
name|propertyValue
argument_list|(
name|name
argument_list|,
name|readName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|parseCondition
argument_list|(
name|factory
operator|.
name|propertyValue
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|supportSQL1
condition|)
block|{
name|StaticOperandImpl
name|left
init|=
name|parseStaticOperand
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"IN"
argument_list|)
condition|)
block|{
name|DynamicOperandImpl
name|right
init|=
name|parseDynamicOperand
argument_list|()
decl_stmt|;
name|ConstraintImpl
name|c
init|=
name|factory
operator|.
name|comparison
argument_list|(
name|right
argument_list|,
name|Operator
operator|.
name|EQUAL
argument_list|,
name|left
argument_list|)
decl_stmt|;
return|return
name|c
return|;
block|}
else|else
block|{
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
block|}
else|else
block|{
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
return|return
name|a
return|;
block|}
specifier|private
name|ConstraintImpl
name|parseCondition
parameter_list|(
name|DynamicOperandImpl
name|left
parameter_list|)
throws|throws
name|ParseException
block|{
name|ConstraintImpl
name|c
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"="
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|EQUAL
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"<>"
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|NOT_EQUAL
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|LESS_THAN
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|">"
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|GREATER_THAN
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"<="
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|LESS_OR_EQUAL
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|">="
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|GREATER_OR_EQUAL
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"LIKE"
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|LIKE
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|supportSQL1
condition|)
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"ESCAPE"
argument_list|)
condition|)
block|{
name|StaticOperandImpl
name|esc
init|=
name|parseStaticOperand
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|esc
operator|instanceof
name|LiteralImpl
operator|)
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"only ESCAPE '\' is supported"
argument_list|)
throw|;
block|}
name|PropertyValue
name|v
init|=
operator|(
operator|(
name|LiteralImpl
operator|)
name|esc
operator|)
operator|.
name|getLiteralValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|v
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|STRING
argument_list|)
operator|.
name|equals
argument_list|(
literal|"\\"
argument_list|)
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"only ESCAPE '\' is supported"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"IN"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|StaticOperandImpl
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|StaticOperandImpl
argument_list|>
argument_list|()
decl_stmt|;
do|do
block|{
name|StaticOperandImpl
name|x
init|=
name|parseStaticOperand
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
do|;
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|in
argument_list|(
name|left
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"IS"
argument_list|)
condition|)
block|{
name|boolean
name|not
init|=
name|readIf
argument_list|(
literal|"NOT"
argument_list|)
decl_stmt|;
name|read
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|left
operator|instanceof
name|PropertyValueImpl
operator|)
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"propertyName (NOT NULL is only supported for properties)"
argument_list|)
throw|;
block|}
name|PropertyValueImpl
name|p
init|=
operator|(
name|PropertyValueImpl
operator|)
name|left
decl_stmt|;
if|if
condition|(
name|not
condition|)
block|{
name|c
operator|=
name|getPropertyExistence
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|getPropertyInexistence
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"NOT"
argument_list|)
condition|)
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"IS"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|left
operator|instanceof
name|PropertyValueImpl
operator|)
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Only property values can be tested for NOT IS NULL; got: "
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|parseIndex
argument_list|)
throw|;
block|}
name|PropertyValueImpl
name|pv
init|=
operator|(
name|PropertyValueImpl
operator|)
name|left
decl_stmt|;
name|c
operator|=
name|getPropertyExistence
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|read
argument_list|(
literal|"LIKE"
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|comparison
argument_list|(
name|left
argument_list|,
name|Operator
operator|.
name|LIKE
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|not
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
return|return
name|c
return|;
block|}
specifier|private
name|PropertyExistenceImpl
name|getPropertyExistence
parameter_list|(
name|PropertyValueImpl
name|p
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
name|factory
operator|.
name|propertyExistence
argument_list|(
name|p
operator|.
name|getSelectorName
argument_list|()
argument_list|,
name|p
operator|.
name|getPropertyName
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|PropertyInexistenceImpl
name|getPropertyInexistence
parameter_list|(
name|PropertyValueImpl
name|p
parameter_list|)
throws|throws
name|ParseException
block|{
return|return
name|factory
operator|.
name|propertyInexistence
argument_list|(
name|p
operator|.
name|getSelectorName
argument_list|()
argument_list|,
name|p
operator|.
name|getPropertyName
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|ConstraintImpl
name|parseConditionFunctionIf
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|ParseException
block|{
name|ConstraintImpl
name|c
decl_stmt|;
if|if
condition|(
literal|"CONTAINS"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
comment|// strictly speaking, CONTAINS(*, ...) is not supported
comment|// according to the spec:
comment|// "If only one selector exists in this query, explicit
comment|// specification of the selectorName preceding the
comment|// propertyName is optional"
comment|// but we anyway support it
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|fullTextSearch
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
literal|null
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|supportSQL1
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"selector name, property name, or *"
argument_list|)
throw|;
block|}
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|fullTextSearch
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
literal|null
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|fullTextSearch
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|selector
init|=
name|name
decl_stmt|;
name|name
operator|=
name|readName
argument_list|()
expr_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|fullTextSearch
argument_list|(
name|selector
argument_list|,
name|name
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|fullTextSearch
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
literal|"ISSAMENODE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|sameNode
argument_list|(
name|name
argument_list|,
name|readAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|factory
operator|.
name|sameNode
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"ISCHILDNODE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|childNode
argument_list|(
name|name
argument_list|,
name|readAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|factory
operator|.
name|childNode
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"ISDESCENDANTNODE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
block|{
name|c
operator|=
name|factory
operator|.
name|descendantNode
argument_list|(
name|name
argument_list|,
name|readAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|factory
operator|.
name|descendantNode
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"SIMILAR"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
operator|||
name|readIf
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|similar
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
literal|null
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|fullTextSearch
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|selector
init|=
name|name
decl_stmt|;
name|name
operator|=
name|readName
argument_list|()
expr_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|fullTextSearch
argument_list|(
name|selector
argument_list|,
name|name
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|fullTextSearch
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
literal|"NATIVE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|String
name|selectorName
decl_stmt|;
if|if
condition|(
name|currentTokenType
operator|==
name|IDENTIFIER
condition|)
block|{
name|selectorName
operator|=
name|readName
argument_list|()
expr_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selectorName
operator|=
name|getOnlySelectorName
argument_list|()
expr_stmt|;
block|}
name|String
name|language
init|=
name|readString
argument_list|()
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|STRING
argument_list|)
decl_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|c
operator|=
name|factory
operator|.
name|nativeFunction
argument_list|(
name|selectorName
argument_list|,
name|language
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"SPELLCHECK"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|String
name|selectorName
decl_stmt|;
if|if
condition|(
name|currentTokenType
operator|==
name|IDENTIFIER
condition|)
block|{
name|selectorName
operator|=
name|readName
argument_list|()
expr_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selectorName
operator|=
name|getOnlySelectorName
argument_list|()
expr_stmt|;
block|}
name|c
operator|=
name|factory
operator|.
name|spellcheck
argument_list|(
name|selectorName
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"SUGGEST"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|String
name|selectorName
decl_stmt|;
if|if
condition|(
name|currentTokenType
operator|==
name|IDENTIFIER
condition|)
block|{
name|selectorName
operator|=
name|readName
argument_list|()
expr_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selectorName
operator|=
name|getOnlySelectorName
argument_list|()
expr_stmt|;
block|}
name|c
operator|=
name|factory
operator|.
name|suggest
argument_list|(
name|selectorName
argument_list|,
name|parseStaticOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
specifier|private
name|String
name|readAbsolutePath
parameter_list|()
throws|throws
name|ParseException
block|{
name|String
name|path
init|=
name|readPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|PathUtils
operator|.
name|isAbsolute
argument_list|(
name|path
argument_list|)
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"absolute path"
argument_list|)
throw|;
block|}
return|return
name|path
return|;
block|}
specifier|private
name|String
name|readPath
parameter_list|()
throws|throws
name|ParseException
block|{
return|return
name|readName
argument_list|()
return|;
block|}
specifier|private
name|DynamicOperandImpl
name|parseDynamicOperand
parameter_list|()
throws|throws
name|ParseException
block|{
name|boolean
name|identifier
init|=
name|currentTokenType
operator|==
name|IDENTIFIER
decl_stmt|;
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|identifier
operator|&&
name|readIf
argument_list|(
literal|"("
argument_list|)
condition|)
block|{
return|return
name|parseExpressionFunction
argument_list|(
name|name
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|parsePropertyValue
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
specifier|private
name|DynamicOperandImpl
name|parseExpressionFunction
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|ParseException
block|{
name|DynamicOperandImpl
name|op
decl_stmt|;
if|if
condition|(
literal|"LENGTH"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|op
operator|=
name|factory
operator|.
name|length
argument_list|(
name|parseDynamicOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"NAME"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
if|if
condition|(
name|isToken
argument_list|(
literal|")"
argument_list|)
condition|)
block|{
name|op
operator|=
name|factory
operator|.
name|nodeName
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|factory
operator|.
name|nodeName
argument_list|(
name|readName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"LOCALNAME"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
if|if
condition|(
name|isToken
argument_list|(
literal|")"
argument_list|)
condition|)
block|{
name|op
operator|=
name|factory
operator|.
name|nodeLocalName
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|factory
operator|.
name|nodeLocalName
argument_list|(
name|readName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"SCORE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
if|if
condition|(
name|isToken
argument_list|(
literal|")"
argument_list|)
condition|)
block|{
name|op
operator|=
name|factory
operator|.
name|fullTextSearchScore
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|factory
operator|.
name|fullTextSearchScore
argument_list|(
name|readName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"LOWER"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|op
operator|=
name|factory
operator|.
name|lowerCase
argument_list|(
name|parseDynamicOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"UPPER"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|op
operator|=
name|factory
operator|.
name|upperCase
argument_list|(
name|parseDynamicOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"PROPERTY"
operator|.
name|equalsIgnoreCase
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|PropertyValueImpl
name|pv
init|=
name|parsePropertyValue
argument_list|(
name|readName
argument_list|()
argument_list|)
decl_stmt|;
name|read
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|op
operator|=
name|factory
operator|.
name|propertyValue
argument_list|(
name|pv
operator|.
name|getSelectorName
argument_list|()
argument_list|,
name|pv
operator|.
name|getPropertyName
argument_list|()
argument_list|,
name|readString
argument_list|()
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|STRING
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"LENGTH, NAME, LOCALNAME, SCORE, LOWER, UPPER, or PROPERTY"
argument_list|)
throw|;
block|}
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
specifier|private
name|PropertyValueImpl
name|parsePropertyValue
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
return|return
name|factory
operator|.
name|propertyValue
argument_list|(
name|name
argument_list|,
name|readName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|factory
operator|.
name|propertyValue
argument_list|(
name|getOnlySelectorName
argument_list|()
argument_list|,
name|name
argument_list|)
return|;
block|}
block|}
specifier|private
name|StaticOperandImpl
name|parseStaticOperand
parameter_list|()
throws|throws
name|ParseException
block|{
if|if
condition|(
name|currentTokenType
operator|==
name|PLUS
condition|)
block|{
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentTokenType
operator|!=
name|VALUE
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"number"
argument_list|)
throw|;
block|}
name|int
name|valueType
init|=
name|currentValue
operator|.
name|getType
argument_list|()
operator|.
name|tag
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|valueType
condition|)
block|{
case|case
name|PropertyType
operator|.
name|LONG
case|:
name|currentValue
operator|=
name|PropertyValues
operator|.
name|newLong
argument_list|(
name|currentValue
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|LONG
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PropertyType
operator|.
name|DOUBLE
case|:
name|currentValue
operator|=
name|PropertyValues
operator|.
name|newDouble
argument_list|(
name|currentValue
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|DOUBLE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PropertyType
operator|.
name|DECIMAL
case|:
name|currentValue
operator|=
name|PropertyValues
operator|.
name|newDecimal
argument_list|(
name|currentValue
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|DECIMAL
argument_list|)
operator|.
name|negate
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|getSyntaxError
argument_list|(
literal|"Illegal operation: + "
operator|+
name|currentValue
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|currentTokenType
operator|==
name|MINUS
condition|)
block|{
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentTokenType
operator|!=
name|VALUE
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"number"
argument_list|)
throw|;
block|}
name|int
name|valueType
init|=
name|currentValue
operator|.
name|getType
argument_list|()
operator|.
name|tag
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|valueType
condition|)
block|{
case|case
name|PropertyType
operator|.
name|LONG
case|:
name|currentValue
operator|=
name|PropertyValues
operator|.
name|newLong
argument_list|(
operator|-
name|currentValue
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|LONG
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PropertyType
operator|.
name|DOUBLE
case|:
name|currentValue
operator|=
name|PropertyValues
operator|.
name|newDouble
argument_list|(
operator|-
name|currentValue
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|DOUBLE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PropertyType
operator|.
name|BOOLEAN
case|:
name|currentValue
operator|=
name|PropertyValues
operator|.
name|newBoolean
argument_list|(
operator|!
name|currentValue
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PropertyType
operator|.
name|DECIMAL
case|:
name|currentValue
operator|=
name|PropertyValues
operator|.
name|newDecimal
argument_list|(
name|currentValue
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|DECIMAL
argument_list|)
operator|.
name|negate
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|getSyntaxError
argument_list|(
literal|"Illegal operation: -"
operator|+
name|currentValue
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|currentTokenType
operator|==
name|VALUE
condition|)
block|{
name|LiteralImpl
name|literal
init|=
name|getUncastLiteral
argument_list|(
name|currentValue
argument_list|)
decl_stmt|;
name|read
argument_list|()
expr_stmt|;
return|return
name|literal
return|;
block|}
elseif|else
if|if
condition|(
name|currentTokenType
operator|==
name|PARAMETER
condition|)
block|{
name|read
argument_list|()
expr_stmt|;
name|String
name|name
init|=
name|readName
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|":"
argument_list|)
condition|)
block|{
name|name
operator|=
name|name
operator|+
literal|':'
operator|+
name|readName
argument_list|()
expr_stmt|;
block|}
name|BindVariableValueImpl
name|var
init|=
name|bindVariables
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|var
operator|==
literal|null
condition|)
block|{
name|var
operator|=
name|factory
operator|.
name|bindVariable
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|bindVariables
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
return|return
name|var
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"TRUE"
argument_list|)
condition|)
block|{
name|LiteralImpl
name|literal
init|=
name|getUncastLiteral
argument_list|(
name|PropertyValues
operator|.
name|newBoolean
argument_list|(
literal|true
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|literal
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"FALSE"
argument_list|)
condition|)
block|{
name|LiteralImpl
name|literal
init|=
name|getUncastLiteral
argument_list|(
name|PropertyValues
operator|.
name|newBoolean
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|literal
return|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"CAST"
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|StaticOperandImpl
name|op
init|=
name|parseStaticOperand
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|op
operator|instanceof
name|LiteralImpl
operator|)
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"literal"
argument_list|)
throw|;
block|}
name|LiteralImpl
name|literal
init|=
operator|(
name|LiteralImpl
operator|)
name|op
decl_stmt|;
name|PropertyValue
name|value
init|=
name|literal
operator|.
name|getLiteralValue
argument_list|()
decl_stmt|;
name|read
argument_list|(
literal|"AS"
argument_list|)
expr_stmt|;
name|value
operator|=
name|parseCastAs
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
comment|// CastLiteral
name|literal
operator|=
name|factory
operator|.
name|literal
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|literal
return|;
block|}
else|else
block|{
if|if
condition|(
name|supportSQL1
condition|)
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"TIMESTAMP"
argument_list|)
condition|)
block|{
name|StaticOperandImpl
name|op
init|=
name|parseStaticOperand
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|op
operator|instanceof
name|LiteralImpl
operator|)
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"literal"
argument_list|)
throw|;
block|}
name|LiteralImpl
name|literal
init|=
operator|(
name|LiteralImpl
operator|)
name|op
decl_stmt|;
name|PropertyValue
name|value
init|=
name|literal
operator|.
name|getLiteralValue
argument_list|()
decl_stmt|;
name|value
operator|=
name|PropertyValues
operator|.
name|newDate
argument_list|(
name|value
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|DATE
argument_list|)
argument_list|)
expr_stmt|;
name|literal
operator|=
name|factory
operator|.
name|literal
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|literal
return|;
block|}
block|}
throw|throw
name|getSyntaxError
argument_list|(
literal|"static operand"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Create a literal from a parsed value.      *      * @param value the original value      * @return the literal      */
specifier|private
name|LiteralImpl
name|getUncastLiteral
parameter_list|(
name|PropertyValue
name|value
parameter_list|)
block|{
return|return
name|factory
operator|.
name|literal
argument_list|(
name|value
argument_list|)
return|;
block|}
specifier|private
name|PropertyValue
name|parseCastAs
parameter_list|(
name|PropertyValue
name|value
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|currentTokenQuoted
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"data type (STRING|BINARY|...)"
argument_list|)
throw|;
block|}
name|int
name|propertyType
init|=
name|getPropertyTypeFromName
argument_list|(
name|currentToken
argument_list|)
decl_stmt|;
name|read
argument_list|()
expr_stmt|;
name|PropertyValue
name|v
init|=
name|ValueConverter
operator|.
name|convert
argument_list|(
name|value
argument_list|,
name|propertyType
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"data type (STRING|BINARY|...)"
argument_list|)
throw|;
block|}
return|return
name|v
return|;
block|}
comment|/**      * Get the property type from the given case insensitive name.      *      * @param name the property type name (case insensitive)      * @return the type, or {@code PropertyType.UNDEFINED} if unknown      */
specifier|public
specifier|static
name|int
name|getPropertyTypeFromName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|matchesPropertyType
argument_list|(
name|PropertyType
operator|.
name|STRING
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|PropertyType
operator|.
name|STRING
return|;
block|}
elseif|else
if|if
condition|(
name|matchesPropertyType
argument_list|(
name|PropertyType
operator|.
name|BINARY
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|PropertyType
operator|.
name|BINARY
return|;
block|}
elseif|else
if|if
condition|(
name|matchesPropertyType
argument_list|(
name|PropertyType
operator|.
name|DATE
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|PropertyType
operator|.
name|DATE
return|;
block|}
elseif|else
if|if
condition|(
name|matchesPropertyType
argument_list|(
name|PropertyType
operator|.
name|LONG
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|PropertyType
operator|.
name|LONG
return|;
block|}
elseif|else
if|if
condition|(
name|matchesPropertyType
argument_list|(
name|PropertyType
operator|.
name|DOUBLE
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|PropertyType
operator|.
name|DOUBLE
return|;
block|}
elseif|else
if|if
condition|(
name|matchesPropertyType
argument_list|(
name|PropertyType
operator|.
name|DECIMAL
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|PropertyType
operator|.
name|DECIMAL
return|;
block|}
elseif|else
if|if
condition|(
name|matchesPropertyType
argument_list|(
name|PropertyType
operator|.
name|BOOLEAN
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|PropertyType
operator|.
name|BOOLEAN
return|;
block|}
elseif|else
if|if
condition|(
name|matchesPropertyType
argument_list|(
name|PropertyType
operator|.
name|NAME
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|PropertyType
operator|.
name|NAME
return|;
block|}
elseif|else
if|if
condition|(
name|matchesPropertyType
argument_list|(
name|PropertyType
operator|.
name|PATH
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|PropertyType
operator|.
name|PATH
return|;
block|}
elseif|else
if|if
condition|(
name|matchesPropertyType
argument_list|(
name|PropertyType
operator|.
name|REFERENCE
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|PropertyType
operator|.
name|REFERENCE
return|;
block|}
elseif|else
if|if
condition|(
name|matchesPropertyType
argument_list|(
name|PropertyType
operator|.
name|WEAKREFERENCE
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|PropertyType
operator|.
name|WEAKREFERENCE
return|;
block|}
elseif|else
if|if
condition|(
name|matchesPropertyType
argument_list|(
name|PropertyType
operator|.
name|URI
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|PropertyType
operator|.
name|URI
return|;
block|}
return|return
name|PropertyType
operator|.
name|UNDEFINED
return|;
block|}
specifier|private
specifier|static
name|boolean
name|matchesPropertyType
parameter_list|(
name|int
name|propertyType
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|String
name|typeName
init|=
name|PropertyType
operator|.
name|nameFromValue
argument_list|(
name|propertyType
argument_list|)
decl_stmt|;
return|return
name|typeName
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
return|;
block|}
specifier|private
name|OrderingImpl
index|[]
name|parseOrder
parameter_list|()
throws|throws
name|ParseException
block|{
name|ArrayList
argument_list|<
name|OrderingImpl
argument_list|>
name|orderList
init|=
operator|new
name|ArrayList
argument_list|<
name|OrderingImpl
argument_list|>
argument_list|()
decl_stmt|;
do|do
block|{
name|OrderingImpl
name|ordering
decl_stmt|;
name|DynamicOperandImpl
name|op
init|=
name|parseDynamicOperand
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"DESC"
argument_list|)
condition|)
block|{
name|ordering
operator|=
name|factory
operator|.
name|descending
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|readIf
argument_list|(
literal|"ASC"
argument_list|)
expr_stmt|;
name|ordering
operator|=
name|factory
operator|.
name|ascending
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
name|orderList
operator|.
name|add
argument_list|(
name|ordering
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
do|;
name|OrderingImpl
index|[]
name|orderings
init|=
operator|new
name|OrderingImpl
index|[
name|orderList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|orderList
operator|.
name|toArray
argument_list|(
name|orderings
argument_list|)
expr_stmt|;
return|return
name|orderings
return|;
block|}
specifier|private
name|ArrayList
argument_list|<
name|ColumnOrWildcard
argument_list|>
name|parseColumns
parameter_list|()
throws|throws
name|ParseException
block|{
name|ArrayList
argument_list|<
name|ColumnOrWildcard
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnOrWildcard
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
operator|new
name|ColumnOrWildcard
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|ColumnOrWildcard
name|column
init|=
operator|new
name|ColumnOrWildcard
argument_list|()
decl_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|column
operator|.
name|propertyName
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"EXCERPT"
argument_list|)
condition|)
block|{
name|column
operator|.
name|propertyName
operator|=
literal|"rep:excerpt"
expr_stmt|;
name|read
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readIf
argument_list|(
literal|")"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|column
operator|.
name|selectorName
operator|=
name|readName
argument_list|()
expr_stmt|;
block|}
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|readOptionalAlias
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|column
operator|.
name|propertyName
operator|=
name|readName
argument_list|()
expr_stmt|;
if|if
condition|(
name|column
operator|.
name|propertyName
operator|.
name|equals
argument_list|(
literal|"rep:spellcheck"
argument_list|)
condition|)
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"("
argument_list|)
condition|)
block|{
name|read
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|column
operator|.
name|propertyName
operator|=
literal|":spellcheck"
expr_stmt|;
block|}
name|readOptionalAlias
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readIf
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|column
operator|.
name|selectorName
operator|=
name|column
operator|.
name|propertyName
expr_stmt|;
if|if
condition|(
name|readIf
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|column
operator|.
name|propertyName
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|column
operator|.
name|propertyName
operator|=
name|readName
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|readOptionalAlias
argument_list|(
name|column
argument_list|)
condition|)
block|{
name|column
operator|.
name|columnName
operator|=
name|column
operator|.
name|selectorName
operator|+
literal|"."
operator|+
name|column
operator|.
name|propertyName
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|readOptionalAlias
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
block|}
name|list
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|readIf
argument_list|(
literal|","
argument_list|)
condition|)
do|;
block|}
return|return
name|list
return|;
block|}
specifier|private
name|boolean
name|readOptionalAlias
parameter_list|(
name|ColumnOrWildcard
name|column
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|readIf
argument_list|(
literal|"AS"
argument_list|)
condition|)
block|{
name|column
operator|.
name|columnName
operator|=
name|readName
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|ColumnImpl
index|[]
name|resolveColumns
parameter_list|(
name|ArrayList
argument_list|<
name|ColumnOrWildcard
argument_list|>
name|list
parameter_list|)
throws|throws
name|ParseException
block|{
name|ArrayList
argument_list|<
name|ColumnImpl
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnImpl
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnOrWildcard
name|c
range|:
name|list
control|)
block|{
if|if
condition|(
name|c
operator|.
name|propertyName
operator|==
literal|null
condition|)
block|{
name|addWildcardColumns
argument_list|(
name|columns
argument_list|,
name|c
operator|.
name|selectorName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|selectorName
init|=
name|c
operator|.
name|selectorName
decl_stmt|;
if|if
condition|(
name|selectorName
operator|==
literal|null
condition|)
block|{
name|selectorName
operator|=
name|getOnlySelectorName
argument_list|()
expr_stmt|;
block|}
name|String
name|columnName
init|=
name|c
operator|.
name|columnName
decl_stmt|;
if|if
condition|(
name|columnName
operator|==
literal|null
condition|)
block|{
name|columnName
operator|=
name|c
operator|.
name|propertyName
expr_stmt|;
block|}
name|columns
operator|.
name|add
argument_list|(
name|factory
operator|.
name|column
argument_list|(
name|selectorName
argument_list|,
name|c
operator|.
name|propertyName
argument_list|,
name|columnName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ColumnImpl
index|[]
name|array
init|=
operator|new
name|ColumnImpl
index|[
name|columns
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|columns
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
specifier|private
name|void
name|addWildcardColumns
parameter_list|(
name|Collection
argument_list|<
name|ColumnImpl
argument_list|>
name|columns
parameter_list|,
name|String
name|selectorName
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|selectorName
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|SelectorImpl
name|selector
range|:
name|selectors
operator|.
name|values
argument_list|()
control|)
block|{
name|addWildcardColumns
argument_list|(
name|columns
argument_list|,
name|selector
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SelectorImpl
name|selector
init|=
name|selectors
operator|.
name|get
argument_list|(
name|selectorName
argument_list|)
decl_stmt|;
if|if
condition|(
name|selector
operator|!=
literal|null
condition|)
block|{
name|addWildcardColumns
argument_list|(
name|columns
argument_list|,
name|selector
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"Unknown selector: "
operator|+
name|selectorName
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|addWildcardColumns
parameter_list|(
name|Collection
argument_list|<
name|ColumnImpl
argument_list|>
name|columns
parameter_list|,
name|SelectorImpl
name|selector
parameter_list|)
block|{
name|String
name|selectorName
init|=
name|selector
operator|.
name|getSelectorName
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|propertyName
range|:
name|selector
operator|.
name|getWildcardColumns
argument_list|()
control|)
block|{
if|if
condition|(
name|namePathMapper
operator|!=
literal|null
condition|)
block|{
name|propertyName
operator|=
name|namePathMapper
operator|.
name|getJcrName
argument_list|(
name|propertyName
argument_list|)
expr_stmt|;
block|}
name|String
name|columnName
decl_stmt|;
if|if
condition|(
name|includeSelectorNameInWildcardColumns
condition|)
block|{
name|columnName
operator|=
name|selectorName
operator|+
literal|"."
operator|+
name|propertyName
expr_stmt|;
block|}
else|else
block|{
name|columnName
operator|=
name|propertyName
expr_stmt|;
block|}
name|columns
operator|.
name|add
argument_list|(
name|factory
operator|.
name|column
argument_list|(
name|selectorName
argument_list|,
name|propertyName
argument_list|,
name|columnName
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|columns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// OAK-1354, inject the selector name
name|columns
operator|.
name|add
argument_list|(
name|factory
operator|.
name|column
argument_list|(
name|selectorName
argument_list|,
name|selectorName
argument_list|,
name|selectorName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|readIf
parameter_list|(
name|String
name|token
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|isToken
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|read
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|isToken
parameter_list|(
name|String
name|token
parameter_list|)
block|{
name|boolean
name|result
init|=
name|token
operator|.
name|equalsIgnoreCase
argument_list|(
name|currentToken
argument_list|)
operator|&&
operator|!
name|currentTokenQuoted
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
return|return
literal|true
return|;
block|}
name|addExpected
argument_list|(
name|token
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|read
parameter_list|(
name|String
name|expected
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
operator|!
name|expected
operator|.
name|equalsIgnoreCase
argument_list|(
name|currentToken
argument_list|)
operator|||
name|currentTokenQuoted
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
name|expected
argument_list|)
throw|;
block|}
name|read
argument_list|()
expr_stmt|;
block|}
specifier|private
name|PropertyValue
name|readString
parameter_list|()
throws|throws
name|ParseException
block|{
if|if
condition|(
name|currentTokenType
operator|!=
name|VALUE
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"string value"
argument_list|)
throw|;
block|}
name|PropertyValue
name|value
init|=
name|currentValue
decl_stmt|;
name|read
argument_list|()
expr_stmt|;
return|return
name|value
return|;
block|}
specifier|private
name|void
name|addExpected
parameter_list|(
name|String
name|token
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|!=
literal|null
condition|)
block|{
name|expected
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|initialize
parameter_list|(
name|String
name|query
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|query
operator|==
literal|null
condition|)
block|{
name|query
operator|=
literal|""
expr_stmt|;
block|}
name|statement
operator|=
name|query
expr_stmt|;
name|int
name|len
init|=
name|query
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
name|char
index|[]
name|command
init|=
operator|new
name|char
index|[
name|len
index|]
decl_stmt|;
name|int
index|[]
name|types
init|=
operator|new
name|int
index|[
name|len
index|]
decl_stmt|;
name|len
operator|--
expr_stmt|;
name|query
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|len
argument_list|,
name|command
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|command
index|[
name|len
index|]
operator|=
literal|' '
expr_stmt|;
name|int
name|startLoop
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|command
index|[
name|i
index|]
decl_stmt|;
name|int
name|type
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'-'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|'*'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
case|case
literal|'+'
case|:
case|case
literal|'%'
case|:
case|case
literal|'?'
case|:
case|case
literal|'$'
case|:
name|type
operator|=
name|CHAR_SPECIAL_1
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'|'
case|:
case|case
literal|'='
case|:
case|case
literal|':'
case|:
name|type
operator|=
name|CHAR_SPECIAL_2
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|type
operator|=
name|CHAR_DECIMAL
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|command
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|'*'
condition|)
block|{
name|type
operator|=
name|CHAR_SPECIAL_1
expr_stmt|;
break|break;
block|}
name|types
index|[
name|i
index|]
operator|=
name|type
operator|=
name|CHAR_IGNORE
expr_stmt|;
name|startLoop
operator|=
name|i
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
name|checkRunOver
argument_list|(
name|i
argument_list|,
name|len
argument_list|,
name|startLoop
argument_list|)
expr_stmt|;
while|while
condition|(
name|command
index|[
name|i
index|]
operator|!=
literal|'*'
operator|||
name|command
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|checkRunOver
argument_list|(
name|i
argument_list|,
name|len
argument_list|,
name|startLoop
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|types
index|[
name|i
index|]
operator|=
name|type
operator|=
name|CHAR_BRACKETED
expr_stmt|;
name|startLoop
operator|=
name|i
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
while|while
condition|(
name|command
index|[
operator|++
name|i
index|]
operator|!=
literal|']'
condition|)
block|{
name|checkRunOver
argument_list|(
name|i
argument_list|,
name|len
argument_list|,
name|startLoop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|len
operator|-
literal|1
operator|||
name|command
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
name|types
index|[
name|i
index|]
operator|=
name|type
operator|=
name|CHAR_STRING
expr_stmt|;
name|startLoop
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|command
index|[
operator|++
name|i
index|]
operator|!=
literal|'\''
condition|)
block|{
name|checkRunOver
argument_list|(
name|i
argument_list|,
name|len
argument_list|,
name|startLoop
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
name|types
index|[
name|i
index|]
operator|=
name|type
operator|=
name|CHAR_QUOTED
expr_stmt|;
name|startLoop
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|command
index|[
operator|++
name|i
index|]
operator|!=
literal|'\"'
condition|)
block|{
name|checkRunOver
argument_list|(
name|i
argument_list|,
name|len
argument_list|,
name|startLoop
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'_'
case|:
name|type
operator|=
name|CHAR_NAME
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
block|{
name|type
operator|=
name|CHAR_NAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
block|{
name|type
operator|=
name|CHAR_NAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|type
operator|=
name|CHAR_VALUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|type
operator|=
name|CHAR_NAME
expr_stmt|;
block|}
block|}
block|}
name|types
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|type
expr_stmt|;
block|}
name|statementChars
operator|=
name|command
expr_stmt|;
name|types
index|[
name|len
index|]
operator|=
name|CHAR_END
expr_stmt|;
name|characterTypes
operator|=
name|types
expr_stmt|;
name|parseIndex
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
name|void
name|checkRunOver
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|startLoop
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|i
operator|>=
name|len
condition|)
block|{
name|parseIndex
operator|=
name|startLoop
expr_stmt|;
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
block|}
specifier|private
name|void
name|read
parameter_list|()
throws|throws
name|ParseException
block|{
if|if
condition|(
name|parseIndex
operator|>=
name|characterTypes
operator|.
name|length
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
name|currentTokenQuoted
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|expected
operator|!=
literal|null
condition|)
block|{
name|expected
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|int
index|[]
name|types
init|=
name|characterTypes
decl_stmt|;
name|int
name|i
init|=
name|parseIndex
decl_stmt|;
name|int
name|type
init|=
name|types
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|types
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
name|int
name|start
init|=
name|i
decl_stmt|;
name|char
index|[]
name|chars
init|=
name|statementChars
decl_stmt|;
name|char
name|c
init|=
name|chars
index|[
name|i
operator|++
index|]
decl_stmt|;
name|currentToken
operator|=
literal|""
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CHAR_NAME
case|:
while|while
condition|(
literal|true
condition|)
block|{
name|type
operator|=
name|types
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|CHAR_NAME
operator|&&
name|type
operator|!=
name|CHAR_VALUE
condition|)
block|{
name|c
operator|=
name|chars
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|supportSQL1
operator|&&
name|c
operator|==
literal|':'
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|currentToken
operator|=
name|statement
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentToken
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
name|currentTokenType
operator|=
name|IDENTIFIER
expr_stmt|;
name|parseIndex
operator|=
name|i
expr_stmt|;
return|return;
case|case
name|CHAR_SPECIAL_2
case|:
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
name|CHAR_SPECIAL_2
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
name|currentToken
operator|=
name|statement
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|currentTokenType
operator|=
name|KEYWORD
expr_stmt|;
name|parseIndex
operator|=
name|i
expr_stmt|;
return|return;
case|case
name|CHAR_SPECIAL_1
case|:
name|currentToken
operator|=
name|statement
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'$'
case|:
name|currentTokenType
operator|=
name|PARAMETER
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|currentTokenType
operator|=
name|PLUS
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|currentTokenType
operator|=
name|MINUS
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|currentTokenType
operator|=
name|OPEN
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|currentTokenType
operator|=
name|CLOSE
expr_stmt|;
break|break;
default|default:
name|currentTokenType
operator|=
name|KEYWORD
expr_stmt|;
block|}
name|parseIndex
operator|=
name|i
expr_stmt|;
return|return;
case|case
name|CHAR_VALUE
case|:
name|long
name|number
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|c
operator|=
name|chars
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
argument_list|<
literal|'0'
operator|||
name|c
argument_list|>
literal|'9'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|readDecimal
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'e'
condition|)
block|{
name|readDecimal
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|checkLiterals
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|currentValue
operator|=
name|PropertyValues
operator|.
name|newLong
argument_list|(
name|number
argument_list|)
expr_stmt|;
name|currentTokenType
operator|=
name|VALUE
expr_stmt|;
name|currentToken
operator|=
literal|"0"
expr_stmt|;
name|parseIndex
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|number
operator|=
name|number
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|number
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|readDecimal
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return;
case|case
name|CHAR_DECIMAL
case|:
if|if
condition|(
name|types
index|[
name|i
index|]
operator|!=
name|CHAR_VALUE
condition|)
block|{
name|currentTokenType
operator|=
name|KEYWORD
expr_stmt|;
name|currentToken
operator|=
literal|"."
expr_stmt|;
name|parseIndex
operator|=
name|i
expr_stmt|;
return|return;
block|}
name|readDecimal
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
name|CHAR_BRACKETED
case|:
name|currentTokenQuoted
operator|=
literal|true
expr_stmt|;
name|readString
argument_list|(
name|i
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
name|currentTokenType
operator|=
name|IDENTIFIER
expr_stmt|;
name|currentToken
operator|=
name|currentValue
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|STRING
argument_list|)
expr_stmt|;
return|return;
case|case
name|CHAR_STRING
case|:
name|currentTokenQuoted
operator|=
literal|true
expr_stmt|;
name|readString
argument_list|(
name|i
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
return|return;
case|case
name|CHAR_QUOTED
case|:
name|currentTokenQuoted
operator|=
literal|true
expr_stmt|;
name|readString
argument_list|(
name|i
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|supportSQL1
condition|)
block|{
comment|// for SQL-2, this is a literal, as defined in
comment|// the JCR 2.0 spec, 6.7.34 Literal - UncastLiteral
comment|// but for compatibility with Jackrabbit 2.x, for
comment|// SQL-1, this is an identifier, as in ANSI SQL
comment|// (not in the JCR 1.0 spec)
comment|// (confusing isn't it?)
name|currentTokenType
operator|=
name|IDENTIFIER
expr_stmt|;
name|currentToken
operator|=
name|currentValue
operator|.
name|getValue
argument_list|(
name|Type
operator|.
name|STRING
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|CHAR_END
case|:
name|currentToken
operator|=
literal|""
expr_stmt|;
name|currentTokenType
operator|=
name|END
expr_stmt|;
name|parseIndex
operator|=
name|i
expr_stmt|;
return|return;
default|default:
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
block|}
specifier|private
name|void
name|readString
parameter_list|(
name|int
name|i
parameter_list|,
name|char
name|end
parameter_list|)
throws|throws
name|ParseException
block|{
name|char
index|[]
name|chars
init|=
name|statementChars
decl_stmt|;
name|String
name|result
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
for|for
control|(
name|int
name|begin
init|=
name|i
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chars
index|[
name|i
index|]
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|statement
operator|.
name|substring
argument_list|(
name|begin
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|+=
name|statement
operator|.
name|substring
argument_list|(
name|begin
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|chars
index|[
operator|++
name|i
index|]
operator|!=
name|end
condition|)
block|{
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|currentToken
operator|=
literal|"'"
expr_stmt|;
if|if
condition|(
name|end
operator|!=
literal|']'
condition|)
block|{
name|checkLiterals
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|currentValue
operator|=
name|PropertyValues
operator|.
name|newString
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|parseIndex
operator|=
name|i
expr_stmt|;
name|currentTokenType
operator|=
name|VALUE
expr_stmt|;
block|}
specifier|private
name|void
name|checkLiterals
parameter_list|(
name|boolean
name|text
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
operator|&&
operator|!
name|literalUsageLogged
condition|)
block|{
name|literalUsageLogged
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Literal used"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|text
operator|&&
operator|!
name|allowTextLiterals
operator|||
operator|!
name|text
operator|&&
operator|!
name|allowNumberLiterals
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"bind variable (literals of this type not allowed)"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|readDecimal
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|i
parameter_list|)
throws|throws
name|ParseException
block|{
name|char
index|[]
name|chars
init|=
name|statementChars
decl_stmt|;
name|int
index|[]
name|types
init|=
name|characterTypes
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|t
init|=
name|types
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|CHAR_DECIMAL
operator|&&
name|t
operator|!=
name|CHAR_VALUE
condition|)
block|{
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chars
index|[
name|i
index|]
operator|==
literal|'E'
operator|||
name|chars
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|chars
index|[
name|i
index|]
operator|==
literal|'+'
operator|||
name|chars
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|types
index|[
name|i
index|]
operator|!=
name|CHAR_VALUE
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|()
throw|;
block|}
while|while
condition|(
name|types
index|[
operator|++
name|i
index|]
operator|==
name|CHAR_VALUE
condition|)
block|{
comment|// go until the first non-number
block|}
block|}
name|parseIndex
operator|=
name|i
expr_stmt|;
name|String
name|sub
init|=
name|statement
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|BigDecimal
name|bd
decl_stmt|;
try|try
block|{
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Data conversion error converting "
operator|+
name|sub
operator|+
literal|" to BigDecimal: "
operator|+
name|e
argument_list|,
name|parseIndex
argument_list|)
throw|;
block|}
name|checkLiterals
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|currentValue
operator|=
name|PropertyValues
operator|.
name|newDecimal
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|currentTokenType
operator|=
name|VALUE
expr_stmt|;
block|}
specifier|private
name|ParseException
name|getSyntaxError
parameter_list|()
block|{
if|if
condition|(
name|expected
operator|==
literal|null
operator|||
name|expected
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|getSyntaxError
argument_list|(
literal|null
argument_list|)
return|;
block|}
else|else
block|{
name|StringBuilder
name|buff
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|exp
range|:
name|expected
control|)
block|{
if|if
condition|(
name|buff
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|buff
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|buff
operator|.
name|append
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
name|getSyntaxError
argument_list|(
name|buff
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|private
name|ParseException
name|getSyntaxError
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
name|int
name|index
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|parseIndex
argument_list|,
name|statement
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|query
init|=
name|statement
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
operator|+
literal|"(*)"
operator|+
name|statement
operator|.
name|substring
argument_list|(
name|index
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|expected
operator|!=
literal|null
condition|)
block|{
name|query
operator|+=
literal|"; expected: "
operator|+
name|expected
expr_stmt|;
block|}
return|return
operator|new
name|ParseException
argument_list|(
literal|"Query: "
operator|+
name|query
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/**      * Represents a column or a wildcard in a SQL expression.      * This class is temporarily used during parsing.      */
specifier|static
class|class
name|ColumnOrWildcard
block|{
name|String
name|selectorName
decl_stmt|;
name|String
name|propertyName
decl_stmt|;
name|String
name|columnName
decl_stmt|;
block|}
comment|/**      * Get the selector name if only one selector exists in the query.      * If more than one selector exists, an exception is thrown.      *      * @return the selector name      */
specifier|private
name|String
name|getOnlySelectorName
parameter_list|()
throws|throws
name|ParseException
block|{
if|if
condition|(
name|selectors
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
name|getSyntaxError
argument_list|(
literal|"Need to specify the selector name because the query contains more than one selector."
argument_list|)
throw|;
block|}
return|return
name|selectors
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getSelectorName
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|String
name|escapeStringLiteral
parameter_list|(
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|.
name|indexOf
argument_list|(
literal|'\''
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|value
operator|=
name|value
operator|.
name|replace
argument_list|(
literal|"'"
argument_list|,
literal|"''"
argument_list|)
expr_stmt|;
block|}
return|return
literal|'\''
operator|+
name|value
operator|+
literal|'\''
return|;
block|}
comment|/**      * Enable or disable support for text literals in queries. The default is enabled.      *      * @param allowTextLiterals      */
specifier|public
name|void
name|setAllowTextLiterals
parameter_list|(
name|boolean
name|allowTextLiterals
parameter_list|)
block|{
name|this
operator|.
name|allowTextLiterals
operator|=
name|allowTextLiterals
expr_stmt|;
block|}
specifier|public
name|void
name|setAllowNumberLiterals
parameter_list|(
name|boolean
name|allowNumberLiterals
parameter_list|)
block|{
name|this
operator|.
name|allowNumberLiterals
operator|=
name|allowNumberLiterals
expr_stmt|;
block|}
specifier|public
name|void
name|setIncludeSelectorNameInWildcardColumns
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|this
operator|.
name|includeSelectorNameInWildcardColumns
operator|=
name|value
expr_stmt|;
block|}
comment|/**      * Whether the given statement is an internal query.      *        * @param statement the statement      * @return true for an internal query      */
specifier|public
specifier|static
name|boolean
name|isInternal
parameter_list|(
name|String
name|statement
parameter_list|)
block|{
return|return
name|statement
operator|.
name|indexOf
argument_list|(
name|QueryEngine
operator|.
name|INTERNAL_SQL2_QUERY
argument_list|)
operator|>=
literal|0
return|;
block|}
block|}
end_class

end_unit

