begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|property
operator|.
name|strategy
package|;
end_package

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
operator|.
name|newHashSet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|property
operator|.
name|strategy
operator|.
name|OrderedContentMirrorStoreStrategy
operator|.
name|NEXT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|property
operator|.
name|strategy
operator|.
name|OrderedContentMirrorStoreStrategy
operator|.
name|START
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DecimalFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jcr
operator|.
name|RepositoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|commons
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|IndexConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|IndexUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|property
operator|.
name|OrderedIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|index
operator|.
name|property
operator|.
name|OrderedIndex
operator|.
name|OrderDirection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|memory
operator|.
name|EmptyNodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|query
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|query
operator|.
name|PropertyValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|ChildNodeEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|spi
operator|.
name|state
operator|.
name|NodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterators
import|;
end_import

begin_comment
comment|/**  *  */
end_comment

begin_class
specifier|public
class|class
name|OrderedContentMirrorStorageStrategyTest
block|{
comment|/**      * ascending ordered set of keys. Useful for testing      */
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|KEYS
init|=
operator|new
name|String
index|[]
block|{
literal|"donald"
block|,
literal|"goofy"
block|,
literal|"mickey"
block|,
literal|"minnie"
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|EMPTY_KEY_SET
init|=
name|newHashSet
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|NumberFormat
name|NF
init|=
operator|new
name|DecimalFormat
argument_list|(
literal|"00000"
argument_list|)
decl_stmt|;
comment|/**      * checks that the fist item/key is inserted with an empty property 'next'      *      * expected structure:      *      *<code>      * :index : {      *    :start : { :next=n0 },      *    n0 : {      *       :next=,      *       foo : {      *          bar: { match=true}      *       }      *    }      * }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|firstAndOnlyItem
parameter_list|()
block|{
specifier|final
name|String
name|path
init|=
literal|"/foo/bar"
decl_stmt|;
specifier|final
name|String
index|[]
name|pathNodes
init|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|path
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|String
name|no
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|NodeBuilder
name|node
init|=
literal|null
decl_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|no
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|":index should be left alone with not changes"
argument_list|,
name|index
operator|.
name|hasProperty
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|":index should have the :start node"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n0"
argument_list|,
name|no
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|no
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should exists in the index"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n0 should point nowhere as it's the last (and only) element"
argument_list|,
literal|""
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
comment|// checking content structure below n0
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|pathNodes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should contain 'foo'"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|pathNodes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"'foo' should contain 'bar'"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"the 'foo' node should have 'match=true'"
argument_list|,
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the saving of 2 new keys that comes already ordered      *      * final state of the index will be      *      *<code>      *    :index : {      *       :start : { :next=n0 },      *       n0 : { :next=n1 },      *       n1 : { :next= }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|first2newKeysAlreadyOrdered
parameter_list|()
block|{
specifier|final
name|String
name|path
init|=
literal|"/foo/bar"
decl_stmt|;
specifier|final
name|String
name|n0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|n1
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|NodeBuilder
name|node
init|=
literal|null
decl_stmt|;
comment|// first node arrives
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|":index should have :start"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n0"
argument_list|,
name|n0
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|":index should have n0"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n0 should point nowhere at this stage"
argument_list|,
literal|""
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
comment|// second node arrives
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|":index should still have :start"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should still point to n0"
argument_list|,
name|n0
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should still exists"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n0 should point to n1"
argument_list|,
name|n1
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n1 should exists"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n1 should point nowhere"
argument_list|,
literal|""
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Test the iteration of an empty index      */
annotation|@
name|Test
specifier|public
name|void
name|childNodeEntriesEmptyIndex
parameter_list|()
block|{
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeState
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
name|children
init|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"A returned Iterable cannot be null"
argument_list|,
name|children
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the iteration of the index with 2 shuffled items      *      *<code>      *    :index : {      *       :start : { :next=n1 },      *       n0 : { :next= },      *       n1 : { :next=n0 }      *    }      *</code>      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|childNodeEntriesACoupleOfMixedItems
parameter_list|()
block|{
specifier|final
name|String
name|n0
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|String
name|n1
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|NodeState
name|node0
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
literal|""
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
specifier|final
name|NodeState
name|node1
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|n0
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// setting-up the index structure
name|index
operator|.
name|child
argument_list|(
name|START
argument_list|)
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|n0
argument_list|,
name|node0
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|n1
argument_list|,
name|node1
argument_list|)
expr_stmt|;
name|NodeState
name|indexState
init|=
name|index
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
name|children
init|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"The iterable cannot be null"
argument_list|,
name|children
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Expecting 2 items in the index"
argument_list|,
literal|2
argument_list|,
name|Iterators
operator|.
name|size
argument_list|(
name|children
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensuring the right sequence
name|ChildNodeEntry
name|entry
init|=
literal|null
decl_stmt|;
name|children
operator|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|ChildNodeEntry
argument_list|>
name|it
init|=
name|children
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"We should have 2 elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The first element should be n1"
argument_list|,
name|n1
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|node1
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"We should have 1 elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The second element should be n0"
argument_list|,
name|n0
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|node0
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"We should have be at the end of the list"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the iteration of the index with 2 shuffled items without the :start      * node      *      *<code>      *    :index : {      *       :start : { :next=n1 },      *       n0 : { :next= },      *       n1 : { :next=n0 }      *    }      *</code>      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|childNodeEntriesACoupleOfMixedItemsNoStart
parameter_list|()
block|{
specifier|final
name|String
name|n0
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|String
name|n1
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|NodeState
name|node0
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
literal|""
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
specifier|final
name|NodeState
name|node1
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|n0
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// setting-up the index structure
name|index
operator|.
name|child
argument_list|(
name|START
argument_list|)
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|n0
argument_list|,
name|node0
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|n1
argument_list|,
name|node1
argument_list|)
expr_stmt|;
name|NodeState
name|indexState
init|=
name|index
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
name|children
init|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"The iterable cannot be null"
argument_list|,
name|children
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Expecting 2 items in the index"
argument_list|,
literal|2
argument_list|,
name|Iterators
operator|.
name|size
argument_list|(
name|children
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensuring the right sequence
name|ChildNodeEntry
name|entry
init|=
literal|null
decl_stmt|;
name|children
operator|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|ChildNodeEntry
argument_list|>
name|it
init|=
name|children
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"We should have 2 elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The first element should be n1"
argument_list|,
name|n1
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|node1
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"We should have 1 elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The second element should be n0"
argument_list|,
name|n0
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|node0
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"We should have be at the end of the list"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the iteration of the index with 2 shuffled items including the      * :start node as first      *      *<code>      *    :index : {      *       :start : { :next=n1 },      *       n0 : { :next= },      *       n1 : { :next=n0 }      *    }      *</code>      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|childNodeEntriesACoupleOfMixedItemsWithStart
parameter_list|()
block|{
specifier|final
name|String
name|n0
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|String
name|n1
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|NodeState
name|nodeStart
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|n1
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
specifier|final
name|NodeState
name|node0
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
literal|""
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
specifier|final
name|NodeState
name|node1
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|n0
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// setting-up the index structure
name|index
operator|.
name|setChildNode
argument_list|(
name|START
argument_list|,
name|nodeStart
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|n0
argument_list|,
name|node0
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|n1
argument_list|,
name|node1
argument_list|)
expr_stmt|;
name|NodeState
name|indexState
init|=
name|index
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
name|children
init|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"The iterable cannot be null"
argument_list|,
name|children
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Expecting 3 items in the index"
argument_list|,
literal|3
argument_list|,
name|Iterators
operator|.
name|size
argument_list|(
name|children
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensuring the right sequence
name|ChildNodeEntry
name|entry
init|=
literal|null
decl_stmt|;
name|children
operator|=
operator|(
name|Iterable
argument_list|<
name|ChildNodeEntry
argument_list|>
operator|)
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|ChildNodeEntry
argument_list|>
name|it
init|=
name|children
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"We should still have elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The first element should be :start"
argument_list|,
name|START
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|nodeStart
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"We should still have elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The second element should be n1"
argument_list|,
name|n1
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|node1
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"We should still have elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The third element should be n0"
argument_list|,
name|n0
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|node0
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"We should be at the end of the list"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the iteration over an empty list when the :start is required. In      * this case :start should always be returned      *      *<code>      *    :index : {      *       :start : { :next= }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|childNodeEntriesNoItemsWithStart
parameter_list|()
block|{
name|NodeState
name|nodeStart
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
literal|""
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
comment|// setting-up the index
name|index
operator|.
name|setChildNode
argument_list|(
name|START
argument_list|,
name|nodeStart
argument_list|)
expr_stmt|;
name|Iterable
argument_list|<
name|?
extends|extends
name|ChildNodeEntry
argument_list|>
name|children
init|=
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|index
operator|.
name|getNodeState
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong size of Iterable"
argument_list|,
literal|1
argument_list|,
name|Iterators
operator|.
name|size
argument_list|(
name|children
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|?
extends|extends
name|ChildNodeEntry
argument_list|>
name|it
init|=
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|index
operator|.
name|getNodeState
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"We should have at least 1 element"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|ChildNodeEntry
name|entry
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|":start is expected"
argument_list|,
name|START
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"wrong node returned"
argument_list|,
name|nodeStart
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"We should be at the end of the list"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the case where we want an iterator for the children of a brand new      * index. In this case :start doesn't exists but if we ask for it we should      * return it.      */
annotation|@
name|Test
specifier|public
name|void
name|childNodeEntriesNewIndexWithStart
parameter_list|()
block|{
name|NodeState
name|nodeStart
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
literal|""
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|?
extends|extends
name|ChildNodeEntry
argument_list|>
name|children
init|=
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|index
operator|.
name|getNodeState
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong number of children"
argument_list|,
literal|1
argument_list|,
name|Iterators
operator|.
name|size
argument_list|(
name|children
argument_list|)
argument_list|)
expr_stmt|;
name|children
operator|=
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|index
operator|.
name|getNodeState
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"at least one item expected"
argument_list|,
name|children
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|ChildNodeEntry
name|child
init|=
name|children
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|START
argument_list|,
name|child
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|nodeStart
argument_list|,
name|child
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|children
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the insert of two shuffled items      *      * Building final a structure like      *      *<code>      *    :index : {      *       :start : { :next=n1 },      *       n0 : { :next= },      *       n1 : { :next=n0 }      *    }      *</code>      *      * where:      *      *<code>      *    Stage 1      *    =======      *      *    :index : {      *       :start : { :next = n0 },      *       n0 : {      *          :next =      *       }      *    }      *      *    Stage 2      *    =======      *      *    :index : {      *       :start : { :next = n1 },      *       n0 : {      *          :next =      *       },      *       n1 : {      *          :next = n0      *       }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|twoShuffledItems
parameter_list|()
block|{
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeState
name|root
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|root
operator|.
name|builder
argument_list|()
decl_stmt|;
name|String
name|key1st
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|String
name|key2nd
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
name|NodeState
name|ns
init|=
literal|null
decl_stmt|;
comment|// Stage 1
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/foo/bar"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|key1st
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start is expected to point to the 1st node"
argument_list|,
name|key1st
argument_list|,
name|ns
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|key1st
argument_list|)
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"At Stage 1 the first node is expected to point nowhere as it's the last"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|ns
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/foo/bar"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|key2nd
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start is expected to point to the 2nd node"
argument_list|,
name|key2nd
argument_list|,
name|ns
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|key1st
argument_list|)
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"At stage 2 the first element should point nowhere as it's the last"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|ns
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|key2nd
argument_list|)
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"At Stage 2 the second element should point to the first one"
argument_list|,
name|key1st
argument_list|,
name|ns
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the insert of shuffled items      *      * Building a final structure like      *      *<code>      *    {      *       :start : { :next = n1 },      *       n0 : {      *          :next = ""      *       },      *       n1 : {      *          :next = n2      *       },      *       n2 : {      *          :next = n0      *       }      *    }      *</code>      *      * where:      *      *<code>      *    Stage 1      *    =======      *      *    {      *       :start : { :next = n0 },      *       n0 : {      *          :next =      *       }      *    }      *      *    Stage 2      *    =======      *      *    {      *       :start : { :next = n1 },      *       n0 : { :next = },      *       n1 : { :next = n0 }      *    }      *      *    Stage 3      *    =======      *      *    {      *       :start : { :next = n1 },      *       n0 : { :next = },      *       n1 : { :next = n2 },      *       n2 : { :next = n0 }      *    }      *      *    Stage 4      *    =======      *      *    {      *       :start : { :next = n1 },      *       n0 : { :next = n3 },      *       n1 : { :next = n2 },      *       n2 : { :next = n0 },      *       n3 : { :next = }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|fourShuffledElements
parameter_list|()
block|{
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|String
name|n0
init|=
name|KEYS
index|[
literal|2
index|]
decl_stmt|;
name|String
name|n1
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
name|String
name|n2
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|String
name|n3
init|=
name|KEYS
index|[
literal|3
index|]
decl_stmt|;
comment|// Stage 1
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to the first node"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"the first node should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n1"
argument_list|,
name|n1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"'n1' should point to 'n0'"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should still be point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 3
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n1"
argument_list|,
name|n1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n1 should be pointing to n2"
argument_list|,
name|n2
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n2 should be pointing to n0"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n2
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should still be the last item of the list"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 4
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n3
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n1"
argument_list|,
name|n1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n1 should be pointing to n2"
argument_list|,
name|n2
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n2 should be pointing to n0"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n2
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n0 should be pointing to n3"
argument_list|,
name|n3
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n3 should be the last element"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n3
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * perform a test where the index gets updated if an already existent      * node/key gets updated by changing the key and the key contains only 1      * item.      *      * Where the second key is greater than the first.      *      *<code>      *    Stage 1      *    =======      *      *    :index : {      *       :start { :next = n0 },      *       n0 : {      *          :next =,      *          content : {      *             foobar : {      *                match = true      *             }      *          }      *       }      *    }      *      *    Stage 2      *    =======      *      *    :index : {      *       :start : { :next = n1 },      *       n1 : {      *          :next =,      *          content : {      *             foobar : {      *                match = true      *             }      *          }      *       }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|singleKeyUpdate
parameter_list|()
block|{
specifier|final
name|String
name|n0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|n1
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|String
name|path
init|=
literal|"/content/foobar"
decl_stmt|;
specifier|final
name|String
index|[]
name|nodes
init|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|path
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|NodeBuilder
name|node
init|=
literal|null
decl_stmt|;
comment|// Stage 1
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|":start should exists"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n0"
argument_list|,
name|n0
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|":index should have n0"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|nodes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should have /content"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|nodes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"/content should contain /foobar"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"/foobar should have match=true"
argument_list|,
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|,
name|newHashSet
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should now point to n1"
argument_list|,
name|n1
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n1 should exists"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n1 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|nodes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n1 should have /content"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|nodes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"/content should contain /foobar"
argument_list|,
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"/foobar should have match=true"
argument_list|,
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      *<p>      * find a previous item given a key in an index with 1 element only      *</p>      *      *<p>      *<i>it relies on the functionality of the store.update() for creating the      * index</i>      *</p>      *      *<code>      *    :index {      *       :start : { :next=n0 },      *       n0 = { :next= }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|findPrevious1ItemIndex
parameter_list|()
block|{
specifier|final
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
specifier|final
name|String
name|n0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|NodeState
name|nodeStart
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
name|n0
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
specifier|final
name|NodeState
name|node0
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
operator|.
name|setProperty
argument_list|(
name|NEXT
argument_list|,
literal|""
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
specifier|final
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|START
argument_list|,
name|nodeStart
argument_list|)
expr_stmt|;
name|index
operator|.
name|setChildNode
argument_list|(
name|n0
argument_list|,
name|node0
argument_list|)
expr_stmt|;
name|NodeState
name|indexState
init|=
name|index
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|ChildNodeEntry
name|previous
init|=
name|store
operator|.
name|findPrevious
argument_list|(
name|indexState
argument_list|,
name|node0
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|previous
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"the :start node is expected"
argument_list|,
name|nodeStart
argument_list|,
name|previous
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the use case where a document change the indexed property. For      * example document that change author.      *      *<p>      *<i>it relies on the functionality of the store.update() for creating the      * index</i>      *</p>      *      *<code>      *    Stage 1      *    =======      *      *    :index : {      *       :start : { :next = n0 },      *       n0 : {      *          :next = ,      *          content : {      *             one { match=true },      *             two { match=true }      *          }      *       }      *    }      *      *    Stage 2      *    =======      *      *    :index : {      *       :start : { :next = n0 },      *       n0 : {      *          :next = n1,      *          content : {      *             one : { match = true }      *          }      *       },      *       n1 : {      *          :next = ,      *          content : {      *             two : { match = true }      *          }      *       }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|documentChangingKey
parameter_list|()
block|{
specifier|final
name|String
name|path0
init|=
literal|"/content/one"
decl_stmt|;
specifier|final
name|String
name|path1
init|=
literal|"/content/two"
decl_stmt|;
specifier|final
name|String
name|n0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|n1
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
comment|// Stage 1 - initialising the index
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path0
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path1
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensuring the right structure
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|START
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|NodeBuilder
name|node
init|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|":start pointing to wrong node"
argument_list|,
name|n0
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should go nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// checking the first document
name|String
index|[]
name|path
init|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|path0
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|path0
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path1
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|,
name|newHashSet
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|START
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start pointing to wrong node"
argument_list|,
name|n0
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|n1
argument_list|,
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|path0
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|path1
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// we know both the documents share the same /content
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"/content/two should no longer be under n0"
argument_list|,
name|node
operator|.
name|hasChildNode
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n1 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|node
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|path1
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getChildNode
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|node
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test when a document is deleted and is the only one under the indexed key      *      *<p>      *<i>it relies on the functionality of the store.update() for creating the      * index</i>      *</p>      *      *<code>      *    Stage 1      *    =======      *      *    :index : {      *       :start : { :next = n0 },      *       n0 : {      *          :next = ,      *          sampledoc : { match = true }      *       }      *    }      *      *    Stage 2      *    =======      *      *    :index : {      *       :start : { :next = }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|deleteTheOnlyDocument
parameter_list|()
block|{
specifier|final
name|String
name|n0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|path
init|=
literal|"/sampledoc"
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
comment|// Stage 1 - initialising the index
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
comment|// we assume it works and therefore not checking the status of the index
comment|// let's go straight to Stage 2
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|,
name|EMPTY_KEY_SET
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"The node should have been removed"
argument_list|,
name|index
operator|.
name|hasChildNode
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"as the index should be empty, :start should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test when the document is deleted but there're still some documents left      * under the indexed key      *      *<p>      *<i>it relies on the functionality of the store.update() for creating the      * index</i>      *</p>      *      *<code>      *    Stage 1      *    =======      *      *    :index : {      *       :start : { :next = n0 },      *       n0 : {      *          :next = ,      *          doc1 : { match=true },      *          doc2 : { match=true }      *       }      *    }      *      *    Stage 2      *    =======      *      *    :index : {      *       :start : { :next = n0 },      *       n0 : {      *          :next  =,      *          doc2 : { match = true }      *       }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|deleteOneOfTheDocuments
parameter_list|()
block|{
specifier|final
name|String
name|n0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|doc1
init|=
literal|"doc1"
decl_stmt|;
specifier|final
name|String
name|doc2
init|=
literal|"doc2"
decl_stmt|;
specifier|final
name|String
name|path1
init|=
literal|"/"
operator|+
name|doc1
decl_stmt|;
specifier|final
name|String
name|path2
init|=
literal|"/"
operator|+
name|doc2
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path1
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path2
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
comment|// we trust the store at this point and skip a double-check. Let's move
comment|// to Stage 2!
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path1
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|,
name|EMPTY_KEY_SET
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|START
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should still point to n0"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|hasChildNode
argument_list|(
name|doc1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|hasChildNode
argument_list|(
name|doc2
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|doc2
argument_list|)
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test when the only document is deleted from an indexed key but there're      * still some keys left in the index      *      *<p>      *<i>it relies on the functionality of the store.update() for creating the      * index</i>      *</p>      *      *<code>      *    Stage 1      *    =======      *      *    :index : {      *       :start : { :next = n1 },      *       n0 : {      *          :next = ,      *          content : {      *             doc0 : { match = true }      *          }      *       },      *       n1 : {      *          :next = n2,      *          content : {      *             doc1 : { match = true }      *          }      *       }      *       n2 : {      *          :next = n0,      *          content : {      *             doc2 : { match = true }      *          }      *       }      *    }      *      *    Stage 2      *    =======      *      *    :index : {      *       :start : { :next = n1 },      *       n0 : {      *          :next = ,      *          content : {      *             doc0 : { match = true }      *          }      *       },      *       n1 : {      *          :next = n0,      *          content : {      *             doc1 : { match = true }      *          }      *       }      *    }      *      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|deleteTheOnlyDocumentInMultiKeysIndex
parameter_list|()
block|{
specifier|final
name|String
name|path0
init|=
literal|"/content/doc0"
decl_stmt|;
specifier|final
name|String
name|path1
init|=
literal|"/content/doc1"
decl_stmt|;
specifier|final
name|String
name|path2
init|=
literal|"/content/doc2"
decl_stmt|;
specifier|final
name|String
name|n0
init|=
name|KEYS
index|[
literal|2
index|]
decl_stmt|;
specifier|final
name|String
name|n1
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|n2
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
comment|// Stage 1
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path0
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path1
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path2
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n2
argument_list|)
argument_list|)
expr_stmt|;
comment|// as we trust the store we skip the check and goes straight to Stage 2.
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
name|path2
argument_list|,
name|newHashSet
argument_list|(
name|n2
argument_list|)
argument_list|,
name|EMPTY_KEY_SET
argument_list|)
expr_stmt|;
comment|// checking key nodes
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|START
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|index
operator|.
name|hasChildNode
argument_list|(
name|n2
argument_list|)
argument_list|)
expr_stmt|;
comment|// checking pointers
name|assertEquals
argument_list|(
name|n1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// checking sub-nodes
name|String
index|[]
name|subNodes
init|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|path0
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|hasChildNode
argument_list|(
name|subNodes
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|subNodes
index|[
literal|0
index|]
argument_list|)
operator|.
name|hasChildNode
argument_list|(
name|subNodes
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|subNodes
index|[
literal|0
index|]
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|subNodes
index|[
literal|1
index|]
argument_list|)
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
name|subNodes
operator|=
name|Iterables
operator|.
name|toArray
argument_list|(
name|PathUtils
operator|.
name|elements
argument_list|(
name|path1
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|hasChildNode
argument_list|(
name|subNodes
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|subNodes
index|[
literal|0
index|]
argument_list|)
operator|.
name|hasChildNode
argument_list|(
name|subNodes
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|subNodes
index|[
literal|0
index|]
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|subNodes
index|[
literal|1
index|]
argument_list|)
operator|.
name|getBoolean
argument_list|(
literal|"match"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      *<p>test the insertion of 2 already ordered items</p>      *      *<p>expected</p>      *      *<code>      *      :index : {      *          :start : { :next=n0 },      *          n0 : { :next=n1 },      *          n1 : { :next=}      *      }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|descendingOrderInsert2itemsAlreadyOrdered
parameter_list|()
block|{
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|(
name|OrderDirection
operator|.
name|DESC
argument_list|)
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|String
name|n0
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|String
name|n1
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to the first node"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n0 should point to n1"
argument_list|,
name|n1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n1 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests the insert of 4 items that will always have to be added at the beginning of the list.      * Just to simulate the use-case of lastModified DESC.      *      *<code>      *      Stage 1      *      =======      *      *      :index : {      *          :start : { :next=n0 },      *          n0 : { :next= }      *      }      *      *      Stage 2      *      =======      *      *      :index : {      *          :start : { :next=n1 },      *          n0 : { :next= },      *          n1 : { :next=n0 }      *      }      *      *      Stage 3      *      =======      *      *      :index : {      *          :start : { :next=n2 },      *          n0 : { :next= },      *          n1 : { :next=n0 },      *          n2 : { :next=n1 }      *      }      *      *      Stage 4      *      =======      *      *      :index : {      *          :start : { :next=n3 },      *          n0 : { :next= },      *          n1 : { :next=n0 },      *          n2 : { :next=n1 },      *          n3 : { :next=n2 }      *      }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|descendingOrder4StagedInsertsAlwaysGreater
parameter_list|()
block|{
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|(
name|OrderDirection
operator|.
name|DESC
argument_list|)
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|String
name|n0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
name|String
name|n1
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|String
name|n2
init|=
name|KEYS
index|[
literal|2
index|]
decl_stmt|;
name|String
name|n3
init|=
name|KEYS
index|[
literal|3
index|]
decl_stmt|;
comment|// Stage 1
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n0"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n1"
argument_list|,
name|n1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n1 should point to n0"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 3
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n2"
argument_list|,
name|n2
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n2 should point to n1"
argument_list|,
name|n1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n2
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n1 should point to n0"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stage 4
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n3
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n3"
argument_list|,
name|n3
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n3 should point to n2"
argument_list|,
name|n2
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n3
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n2 should point to n1"
argument_list|,
name|n1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n2
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n1 should point to n0"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n0 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test finding a previous item in a descending ordered index.      *      *<code>      *      Stage 1      *      =======      *      *      :index {      *          :start : { :next=n0 },      *          n0 : { :next= }      *      }      *      *      findPrevious(n0)=:start      *      *      Stage 2      *      =======      *      *      :index {      *          :start : { :next=n1 },      *          n0 : { :next= }      *          n1 : { :next=n0 }      *      }      *      *      findPrevious(n0)=n1;      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|descendingOrderFindPrevious
parameter_list|()
block|{
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|(
name|OrderDirection
operator|.
name|DESC
argument_list|)
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|String
name|n0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
name|String
name|n1
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|NodeState
name|indexState
decl_stmt|;
name|NodeState
name|previous
decl_stmt|;
name|NodeState
name|node
decl_stmt|;
comment|//Stage 1
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|indexState
operator|=
name|index
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
name|node
operator|=
name|indexState
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
expr_stmt|;
name|previous
operator|=
name|indexState
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|previous
argument_list|,
name|store
operator|.
name|findPrevious
argument_list|(
name|indexState
argument_list|,
name|node
argument_list|)
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
comment|//Stage 2
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|indexState
operator|=
name|index
operator|.
name|getNodeState
argument_list|()
expr_stmt|;
name|node
operator|=
name|indexState
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
expr_stmt|;
name|previous
operator|=
name|indexState
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|previous
argument_list|,
name|store
operator|.
name|findPrevious
argument_list|(
name|indexState
argument_list|,
name|node
argument_list|)
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the insert of 1 item in a descending order index. it should not really matter but just      * checking we don't break anything      *      * expecting      *      *<code>      *  :index : {      *      :start : { :next = n0 },      *      n0 : { :next = }      *  }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|descendingOrderInsert1item
parameter_list|()
block|{
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|(
name|OrderDirection
operator|.
name|DESC
argument_list|)
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|String
name|n0
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to the first node"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"the first node should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the insert of 4 shuffled items in a descending ordered index      *      * expected:      *      *<code>      *      :index : {      *          :start : { :next= n1},      *          n0 : { :next= n3},      *          n1 : { :next= n2},      *          n2: { :next= n0},      *          n3 : { :next= },      *      }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|descendingOrderInsert4ShuffledItems
parameter_list|()
block|{
name|IndexStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|(
name|OrderDirection
operator|.
name|DESC
argument_list|)
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|String
name|n0
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
name|String
name|n1
init|=
name|KEYS
index|[
literal|3
index|]
decl_stmt|;
name|String
name|n2
init|=
name|KEYS
index|[
literal|2
index|]
decl_stmt|;
name|String
name|n3
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n2
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n3
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|":start should point to n1"
argument_list|,
name|n1
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|START
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n0 should point to n3"
argument_list|,
name|n3
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n1 should point to n2"
argument_list|,
name|n2
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"n2 should point to n1"
argument_list|,
name|n0
argument_list|,
name|index
operator|.
name|getChildNode
argument_list|(
name|n2
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"n3 should point nowhere"
argument_list|,
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|index
operator|.
name|getChildNode
argument_list|(
name|n3
argument_list|)
operator|.
name|getString
argument_list|(
name|NEXT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * test the iteration of the descending index with 2 shuffled items      *      *<code>      *    :index : {      *       :start : { :next=n1 },      *       n0 : { :next= },      *       n1 : { :next=n0 }      *    }      *</code>      */
annotation|@
name|Test
specifier|public
name|void
name|descendingOrderChildNodeEntriesACoupleOfMixedItems
parameter_list|()
block|{
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|(
name|OrderDirection
operator|.
name|DESC
argument_list|)
decl_stmt|;
name|NodeBuilder
name|index
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|String
name|n0
init|=
name|KEYS
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
name|n1
init|=
name|KEYS
index|[
literal|1
index|]
decl_stmt|;
comment|// setting-up the index structure
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n0
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|update
argument_list|(
name|index
argument_list|,
literal|"/a/b"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|NodeState
name|indexState
init|=
name|index
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|NodeState
name|node0
init|=
name|indexState
operator|.
name|getChildNode
argument_list|(
name|n0
argument_list|)
decl_stmt|;
name|NodeState
name|node1
init|=
name|indexState
operator|.
name|getChildNode
argument_list|(
name|n1
argument_list|)
decl_stmt|;
name|Iterable
argument_list|<
name|?
extends|extends
name|ChildNodeEntry
argument_list|>
name|children
init|=
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"The iterable cannot be null"
argument_list|,
name|children
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Expecting 2 items in the index"
argument_list|,
literal|2
argument_list|,
name|Iterators
operator|.
name|size
argument_list|(
name|children
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// ensuring the right sequence
name|ChildNodeEntry
name|entry
init|=
literal|null
decl_stmt|;
name|children
operator|=
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|indexState
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|?
extends|extends
name|ChildNodeEntry
argument_list|>
name|it
init|=
name|children
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"We should have 2 elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The first element should be n1"
argument_list|,
name|n1
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|node1
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"We should have 1 elements left to loop through"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The second element should be n0"
argument_list|,
name|n0
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong entry returned"
argument_list|,
name|node0
argument_list|,
name|entry
operator|.
name|getNodeState
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"We should have be at the end of the list"
argument_list|,
name|it
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|count
parameter_list|()
throws|throws
name|IllegalArgumentException
throws|,
name|RepositoryException
block|{
name|OrderedContentMirrorStoreStrategy
name|store
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|()
decl_stmt|;
name|OrderedContentMirrorStoreStrategy
name|descendingStore
init|=
operator|new
name|OrderedContentMirrorStoreStrategy
argument_list|(
name|OrderDirection
operator|.
name|DESC
argument_list|)
decl_stmt|;
specifier|final
name|String
name|orderedProperty
init|=
literal|"fooprop"
decl_stmt|;
specifier|final
name|String
name|testAscendingName
init|=
literal|"testascending"
decl_stmt|;
specifier|final
name|String
name|testDescendingName
init|=
literal|"testdescending"
decl_stmt|;
specifier|final
name|int
name|numberOfNodes
init|=
literal|1000
decl_stmt|;
specifier|final
name|int
name|maxNodeCount
init|=
literal|100
decl_stmt|;
name|NodeBuilder
name|builder
init|=
name|EmptyNodeState
operator|.
name|EMPTY_NODE
operator|.
name|builder
argument_list|()
decl_stmt|;
name|IndexUtils
operator|.
name|createIndexDefinition
argument_list|(
name|builder
operator|.
name|child
argument_list|(
name|IndexConstants
operator|.
name|INDEX_DEFINITIONS_NAME
argument_list|)
argument_list|,
name|testAscendingName
argument_list|,
literal|false
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|orderedProperty
argument_list|)
argument_list|,
literal|null
argument_list|,
name|OrderedIndex
operator|.
name|TYPE
argument_list|,
name|ImmutableMap
operator|.
expr|<
name|String
argument_list|,
name|String
operator|>
name|of
argument_list|()
argument_list|)
expr_stmt|;
name|IndexUtils
operator|.
name|createIndexDefinition
argument_list|(
name|builder
operator|.
name|child
argument_list|(
name|IndexConstants
operator|.
name|INDEX_DEFINITIONS_NAME
argument_list|)
argument_list|,
name|testDescendingName
argument_list|,
literal|false
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|orderedProperty
argument_list|)
argument_list|,
literal|null
argument_list|,
name|OrderedIndex
operator|.
name|TYPE
argument_list|,
name|ImmutableMap
operator|.
expr|<
name|String
argument_list|,
name|String
operator|>
name|of
argument_list|(
name|OrderedIndex
operator|.
name|DIRECTION
argument_list|,
name|OrderDirection
operator|.
name|DESC
operator|.
name|getDirection
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|NodeBuilder
name|ascendingContent
init|=
name|builder
operator|.
name|getChildNode
argument_list|(
name|IndexConstants
operator|.
name|INDEX_DEFINITIONS_NAME
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|testAscendingName
argument_list|)
operator|.
name|child
argument_list|(
name|IndexConstants
operator|.
name|INDEX_CONTENT_NODE_NAME
argument_list|)
decl_stmt|;
name|NodeBuilder
name|descendingContent
init|=
name|builder
operator|.
name|getChildNode
argument_list|(
name|IndexConstants
operator|.
name|INDEX_DEFINITIONS_NAME
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|testDescendingName
argument_list|)
operator|.
name|child
argument_list|(
name|IndexConstants
operator|.
name|INDEX_CONTENT_NODE_NAME
argument_list|)
decl_stmt|;
comment|// adding some content under the index
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfNodes
condition|;
name|i
operator|++
control|)
block|{
name|store
operator|.
name|update
argument_list|(
name|ascendingContent
argument_list|,
literal|"/foo/bar"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
literal|"x"
operator|+
name|NF
operator|.
name|format
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|descendingStore
operator|.
name|update
argument_list|(
name|descendingContent
argument_list|,
literal|"/foo/bar"
argument_list|,
name|EMPTY_KEY_SET
argument_list|,
name|newHashSet
argument_list|(
literal|"x"
operator|+
name|NF
operator|.
name|format
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"wrong number of nodes encountered"
argument_list|,
name|numberOfNodes
argument_list|,
name|Iterables
operator|.
name|size
argument_list|(
name|store
operator|.
name|getChildNodeEntries
argument_list|(
name|ascendingContent
operator|.
name|getNodeState
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"wrong number of nodes encountered"
argument_list|,
name|numberOfNodes
argument_list|,
name|Iterables
operator|.
name|size
argument_list|(
name|descendingStore
operator|.
name|getChildNodeEntries
argument_list|(
name|descendingContent
operator|.
name|getNodeState
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|NodeState
name|ascendingMeta
init|=
name|builder
operator|.
name|getChildNode
argument_list|(
name|IndexConstants
operator|.
name|INDEX_DEFINITIONS_NAME
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|testAscendingName
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|NodeState
name|descendingMeta
init|=
name|builder
operator|.
name|getChildNode
argument_list|(
name|IndexConstants
operator|.
name|INDEX_DEFINITIONS_NAME
argument_list|)
operator|.
name|getChildNode
argument_list|(
name|testDescendingName
argument_list|)
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
name|Filter
operator|.
name|PropertyRestriction
name|pr
init|=
literal|null
decl_stmt|;
comment|// equality
name|String
name|value
init|=
literal|"x"
operator|+
name|NF
operator|.
name|format
argument_list|(
literal|11
argument_list|)
decl_stmt|;
name|pr
operator|=
operator|new
name|Filter
operator|.
name|PropertyRestriction
argument_list|()
expr_stmt|;
name|pr
operator|.
name|first
operator|=
name|PropertyValues
operator|.
name|newString
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|pr
operator|.
name|last
operator|=
name|PropertyValues
operator|.
name|newString
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|pr
operator|.
name|firstIncluding
operator|=
literal|true
expr_stmt|;
name|pr
operator|.
name|lastIncluding
operator|=
literal|true
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|store
operator|.
name|count
argument_list|(
name|ascendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|descendingStore
operator|.
name|count
argument_list|(
name|descendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
argument_list|)
expr_stmt|;
comment|// property not null
name|pr
operator|=
operator|new
name|Filter
operator|.
name|PropertyRestriction
argument_list|()
expr_stmt|;
name|pr
operator|.
name|first
operator|=
literal|null
expr_stmt|;
name|pr
operator|.
name|last
operator|=
literal|null
expr_stmt|;
name|pr
operator|.
name|firstIncluding
operator|=
literal|false
expr_stmt|;
name|pr
operator|.
name|lastIncluding
operator|=
literal|false
expr_stmt|;
comment|// don't care about the actual results as long as we have something. We're reusing existing
comment|// code
name|assertTrue
argument_list|(
name|store
operator|.
name|count
argument_list|(
name|ascendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|store
operator|.
name|count
argument_list|(
name|ascendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
argument_list|,
name|descendingStore
operator|.
name|count
argument_list|(
name|descendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
argument_list|)
expr_stmt|;
comment|// '>'
name|pr
operator|=
operator|new
name|Filter
operator|.
name|PropertyRestriction
argument_list|()
expr_stmt|;
name|pr
operator|.
name|first
operator|=
name|PropertyValues
operator|.
name|newString
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|pr
operator|.
name|last
operator|=
literal|null
expr_stmt|;
name|pr
operator|.
name|firstIncluding
operator|=
literal|false
expr_stmt|;
name|pr
operator|.
name|lastIncluding
operator|=
literal|false
expr_stmt|;
comment|// don't care about the actual results as long as we have something. We're reusing existing
comment|// code
name|assertTrue
argument_list|(
name|store
operator|.
name|count
argument_list|(
name|ascendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|descendingStore
operator|.
name|count
argument_list|(
name|descendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
argument_list|)
expr_stmt|;
comment|// '>='
name|pr
operator|=
operator|new
name|Filter
operator|.
name|PropertyRestriction
argument_list|()
expr_stmt|;
name|pr
operator|.
name|first
operator|=
name|PropertyValues
operator|.
name|newString
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|pr
operator|.
name|last
operator|=
literal|null
expr_stmt|;
name|pr
operator|.
name|firstIncluding
operator|=
literal|true
expr_stmt|;
name|pr
operator|.
name|lastIncluding
operator|=
literal|false
expr_stmt|;
comment|// don't care about the actual results as long as we have something. We're reusing existing
comment|// code
name|assertTrue
argument_list|(
name|store
operator|.
name|count
argument_list|(
name|ascendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|descendingStore
operator|.
name|count
argument_list|(
name|descendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
argument_list|)
expr_stmt|;
comment|// '<'
name|pr
operator|=
operator|new
name|Filter
operator|.
name|PropertyRestriction
argument_list|()
expr_stmt|;
name|pr
operator|.
name|first
operator|=
literal|null
expr_stmt|;
name|pr
operator|.
name|last
operator|=
name|PropertyValues
operator|.
name|newString
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|pr
operator|.
name|firstIncluding
operator|=
literal|false
expr_stmt|;
name|pr
operator|.
name|lastIncluding
operator|=
literal|false
expr_stmt|;
comment|// don't care about the actual results as long as we have something. We're reusing existing
comment|// code
name|assertTrue
argument_list|(
name|descendingStore
operator|.
name|count
argument_list|(
name|descendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|store
operator|.
name|count
argument_list|(
name|ascendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
argument_list|)
expr_stmt|;
comment|// when no conditions has been asked but just an ORDER BY
name|pr
operator|=
literal|null
expr_stmt|;
name|assertTrue
argument_list|(
name|store
operator|.
name|count
argument_list|(
name|ascendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|store
operator|.
name|count
argument_list|(
name|ascendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
argument_list|,
name|descendingStore
operator|.
name|count
argument_list|(
name|descendingMeta
argument_list|,
name|pr
argument_list|,
name|maxNodeCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

