begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ComparisonChain
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|jackrabbit
operator|.
name|oak
operator|.
name|plugins
operator|.
name|document
operator|.
name|Collection
operator|.
name|SETTINGS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jetbrains
operator|.
name|annotations
operator|.
name|NotNull
import|;
end_import

begin_comment
comment|/**  * The format version currently in use by the DocumentNodeStore and written  * to the underlying DocumentStore. A version {@link #canRead} the current or  * older versions.  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|FormatVersion
implements|implements
name|Comparable
argument_list|<
name|FormatVersion
argument_list|>
block|{
comment|/**      * A dummy version when none is available.      */
specifier|static
specifier|final
name|FormatVersion
name|V0
init|=
operator|new
name|FormatVersion
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/**      * Format version for Oak 1.0.      */
specifier|static
specifier|final
name|FormatVersion
name|V1_0
init|=
operator|new
name|FormatVersion
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/**      * Format version for Oak 1.2.      *<p>      * Changes introduced with this version:      *<ul>      *<li>_lastRev entries are only updated for implicit changes (OAK-2131)</li>      *</ul>      */
specifier|static
specifier|final
name|FormatVersion
name|V1_2
init|=
operator|new
name|FormatVersion
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/**      * Format version for Oak 1.4.      *<p>      * Changes introduced with this version:      *<ul>      *<li>journalGC in settings collection (OAK-4528)</li>      *<li>startTime in clusterNode entries, revision vector in checkpoint (OAK-3646)</li>      *<li>discovery lite with clusterView in settings collection (OAK-2844)</li>      *</ul>      */
specifier|static
specifier|final
name|FormatVersion
name|V1_4
init|=
operator|new
name|FormatVersion
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/**      * Format version for Oak 1.6.      *<p>      * Changes introduced with this version:      *<ul>      *<li>bundle nodes into document (OAK-1312)</li>      *<li>journal entries with change set summary for JCR observation (OAK-5101)</li>      *</ul>      */
specifier|static
specifier|final
name|FormatVersion
name|V1_6
init|=
operator|new
name|FormatVersion
argument_list|(
literal|1
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/**      * Format version for Oak 1.8.      *<p>      * Changes introduced with this version:      *<ul>      *<li>SplitDocType.DEFAULT_NO_BRANCH (OAK-5869)</li>      *<li>journal entries with invalidate-only changes (OAK-5964)</li>      *</ul>      */
specifier|static
specifier|final
name|FormatVersion
name|V1_8
init|=
operator|new
name|FormatVersion
argument_list|(
literal|1
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/**      * The ID of the document in the settings collection that contains the      * version information.      */
specifier|private
specifier|static
specifier|final
name|String
name|VERSION_ID
init|=
literal|"version"
decl_stmt|;
comment|/**      * @return well known format versions.      */
specifier|public
specifier|static
name|Iterable
argument_list|<
name|FormatVersion
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|V0
argument_list|,
name|V1_0
argument_list|,
name|V1_2
argument_list|,
name|V1_4
argument_list|,
name|V1_6
argument_list|,
name|V1_8
argument_list|)
return|;
block|}
comment|/**      * Name of the version property.      */
specifier|private
specifier|static
specifier|final
name|String
name|PROP_VERSION
init|=
literal|"_v"
decl_stmt|;
specifier|private
specifier|final
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|,
name|micro
decl_stmt|;
specifier|private
name|FormatVersion
parameter_list|(
name|int
name|major
parameter_list|,
name|int
name|minor
parameter_list|,
name|int
name|micro
parameter_list|)
block|{
name|this
operator|.
name|major
operator|=
name|major
expr_stmt|;
name|this
operator|.
name|minor
operator|=
name|minor
expr_stmt|;
name|this
operator|.
name|micro
operator|=
name|micro
expr_stmt|;
block|}
comment|/**      * Returns {@code true} if {@code this} version can read data written by the      * {@code other} version.      *      * @param other the version the data was written in.      * @return {@code true} if this version can read, {@code false} otherwise.      */
specifier|public
name|boolean
name|canRead
parameter_list|(
name|FormatVersion
name|other
parameter_list|)
block|{
return|return
name|compareTo
argument_list|(
name|checkNotNull
argument_list|(
name|other
argument_list|)
argument_list|)
operator|>=
literal|0
return|;
block|}
comment|/**      * Reads the {@link FormatVersion} from the given store. This method      * returns {@link FormatVersion#V0} if the store currently does not have a      * version set.      *      * @param store the store to read from.      * @return the format version of the store.      * @throws DocumentStoreException if an error occurs while reading from the      *          store.      */
annotation|@
name|NotNull
specifier|public
specifier|static
name|FormatVersion
name|versionOf
parameter_list|(
annotation|@
name|NotNull
name|DocumentStore
name|store
parameter_list|)
throws|throws
name|DocumentStoreException
block|{
name|checkNotNull
argument_list|(
name|store
argument_list|)
expr_stmt|;
name|FormatVersion
name|v
init|=
name|V0
decl_stmt|;
name|Document
name|d
init|=
name|store
operator|.
name|find
argument_list|(
name|SETTINGS
argument_list|,
name|VERSION_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
block|{
name|Object
name|p
init|=
name|d
operator|.
name|get
argument_list|(
name|PROP_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|v
operator|=
name|valueOf
argument_list|(
name|p
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DocumentStoreException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|v
return|;
block|}
comment|/**      * Writes this version to the given document store. The write operation will      * fail with a {@link DocumentStoreException} if the version change is      * considered incompatible or cannot be applied for some other reason. This      * includes:      *<ul>      *<li>An attempt to downgrade the existing version</li>      *<li>There are active cluster nodes using an existing version</li>      *<li>The version was changed concurrently</li>      *</ul>      *      * @param store the document store.      * @return {@code true} if the version in the store was updated,      *      {@code false} otherwise. This method will also return {@code false}      *      if the version in the store equals this version and now update was      *      required.      * @throws DocumentStoreException if the write operation fails. Reasons      *      include: 1) an attempt to downgrade the existing version, 2) there      *      are active cluster nodes using an existing version, 3) the version      *      was changed concurrently.      */
specifier|public
name|boolean
name|writeTo
parameter_list|(
annotation|@
name|NotNull
name|DocumentStore
name|store
parameter_list|)
throws|throws
name|DocumentStoreException
block|{
name|checkNotNull
argument_list|(
name|store
argument_list|)
expr_stmt|;
name|FormatVersion
name|v
init|=
name|versionOf
argument_list|(
name|store
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|this
condition|)
block|{
comment|// already on this version
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|canRead
argument_list|(
name|v
argument_list|)
condition|)
block|{
comment|// never downgrade
throw|throw
name|unableToWrite
argument_list|(
literal|"Version "
operator|+
name|this
operator|+
literal|" cannot read "
operator|+
name|v
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|active
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|ClusterNodeInfoDocument
name|d
range|:
name|ClusterNodeInfoDocument
operator|.
name|all
argument_list|(
name|store
argument_list|)
control|)
block|{
if|if
condition|(
name|d
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|active
operator|.
name|add
argument_list|(
name|d
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|active
operator|.
name|isEmpty
argument_list|()
operator|&&
name|v
operator|!=
name|V0
condition|)
block|{
throw|throw
name|unableToWrite
argument_list|(
literal|"There are active cluster nodes: "
operator|+
name|active
argument_list|)
throw|;
block|}
if|if
condition|(
name|v
operator|==
name|V0
condition|)
block|{
name|UpdateOp
name|op
init|=
operator|new
name|UpdateOp
argument_list|(
name|VERSION_ID
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|op
operator|.
name|set
argument_list|(
name|PROP_VERSION
argument_list|,
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|store
operator|.
name|create
argument_list|(
name|SETTINGS
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
name|concurrentUpdate
argument_list|()
throw|;
block|}
block|}
else|else
block|{
name|UpdateOp
name|op
init|=
operator|new
name|UpdateOp
argument_list|(
name|VERSION_ID
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|op
operator|.
name|equals
argument_list|(
name|PROP_VERSION
argument_list|,
name|v
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|op
operator|.
name|set
argument_list|(
name|PROP_VERSION
argument_list|,
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|.
name|findAndUpdate
argument_list|(
name|SETTINGS
argument_list|,
name|op
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
name|concurrentUpdate
argument_list|()
throw|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns a format version for the given String representation. This method      * either returns one of the well known versions or an entirely new version      * if the version is not well known.      *      * @param s the String representation of a format version.      * @return the parsed format version.      * @throws IllegalArgumentException if the string is malformed.      */
specifier|public
specifier|static
name|FormatVersion
name|valueOf
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|String
index|[]
name|parts
init|=
name|s
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|!=
literal|3
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|s
argument_list|)
throw|;
block|}
name|int
index|[]
name|elements
init|=
operator|new
name|int
index|[
name|parts
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|elements
index|[
name|i
index|]
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|parts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|s
argument_list|)
throw|;
block|}
block|}
name|FormatVersion
name|v
init|=
operator|new
name|FormatVersion
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|,
name|elements
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|FormatVersion
name|known
range|:
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|v
operator|.
name|equals
argument_list|(
name|known
argument_list|)
condition|)
block|{
name|v
operator|=
name|known
expr_stmt|;
break|break;
block|}
block|}
return|return
name|v
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|major
operator|+
literal|"."
operator|+
name|minor
operator|+
literal|"."
operator|+
name|micro
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|instanceof
name|FormatVersion
operator|&&
name|compareTo
argument_list|(
operator|(
name|FormatVersion
operator|)
name|obj
argument_list|)
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
annotation|@
name|NotNull
name|FormatVersion
name|other
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|other
argument_list|)
expr_stmt|;
return|return
name|ComparisonChain
operator|.
name|start
argument_list|()
operator|.
name|compare
argument_list|(
name|major
argument_list|,
name|other
operator|.
name|major
argument_list|)
operator|.
name|compare
argument_list|(
name|minor
argument_list|,
name|other
operator|.
name|minor
argument_list|)
operator|.
name|compare
argument_list|(
name|micro
argument_list|,
name|other
operator|.
name|micro
argument_list|)
operator|.
name|result
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|DocumentStoreException
name|concurrentUpdate
parameter_list|()
block|{
return|return
name|unableToWrite
argument_list|(
literal|"Version was updated concurrently"
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|DocumentStoreException
name|unableToWrite
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
return|return
operator|new
name|DocumentStoreException
argument_list|(
literal|"Unable to write format version. "
operator|+
name|reason
argument_list|)
return|;
block|}
block|}
end_class

end_unit

